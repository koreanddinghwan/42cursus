int _ratio = 10000;
int _allocator_used = 0;
typedef char16_t char16_t;
typedef char32_t char32_t;
namespace std {
    inline namespace __1 {
    }
}
typedef long ptrdiff_t;
typedef unsigned long size_t;
namespace std {
    inline namespace __1 {
        struct __attribute__((type_visibility("default"))) nullptr_t {
            void *__lx;
            struct __nat {
                int __for_bool_;
            };
            nullptr_t() : __lx(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            nullptr_t(int std::__1::nullptr_t::__nat::*) : __lx(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            operator int __nat::*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return 0;
            }
            template <class _Tp> operator _Tp *() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return 0;
            }
            template<> operator const char *<const char>() const __attribute__((internal_linkage))             {
                return 0;
            }
            template<> operator void *<void>() const __attribute__((internal_linkage))             {
                return 0;
            }
            template<> operator const void *<const void>() const __attribute__((internal_linkage))            template<> operator volatile void *<volatile void>() const __attribute__((internal_linkage))            template<> operator const volatile void *<const volatile void>() const __attribute__((internal_linkage))            template<> operator const wchar_t *<const wchar_t>() const __attribute__((internal_linkage))             {
                return 0;
            }
            template<> operator basic_streambuf<char> *<std::__1::basic_streambuf<char>>() const __attribute__((internal_linkage))             {
                return 0;
            }
            template<> operator const basic_streambuf<char> *<const std::__1::basic_streambuf<char>>() const __attribute__((internal_linkage))            template<> operator volatile basic_streambuf<char> *<volatile std::__1::basic_streambuf<char>>() const __attribute__((internal_linkage))            template<> operator const volatile basic_streambuf<char> *<const volatile std::__1::basic_streambuf<char>>() const __attribute__((internal_linkage))            template<> operator basic_string<char> *<std::__1::basic_string<char>>() const __attribute__((internal_linkage))             {
                return 0;
            }
            template<> operator const basic_string<char> *<const std::__1::basic_string<char>>() const __attribute__((internal_linkage))            template<> operator volatile basic_string<char> *<volatile std::__1::basic_string<char>>() const __attribute__((internal_linkage))            template<> operator const volatile basic_string<char> *<const volatile std::__1::basic_string<char>>() const __attribute__((internal_linkage))            template <class _Tp, class _Up> operator _Tp _Up::*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return 0;
            }
            template<> operator int __nat::*<int, std::__1::nullptr_t::__nat>() const __attribute__((internal_linkage))            template<> operator void (__cxx03_bool::*)()<void (), std::__1::__cxx03_bool>() const __attribute__((internal_linkage))            friend bool operator==(std::__1::nullptr_t, std::__1::nullptr_t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return true;
            }
;
            friend bool operator!=(std::__1::nullptr_t, std::__1::nullptr_t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return false;
            }
;
        };
        inline std::__1::nullptr_t __get_nullptr_t() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::nullptr_t(0);
        }
    }
}
namespace std {
    inline namespace __1 {
        using ::ptrdiff_t;
        using ::size_t;
        typedef long double max_align_t;
    }
}
namespace std {
    inline namespace __1 {
        template <class _T1, class _T2> struct __attribute__((type_visibility("default"))) pair
template<> struct pair<unsigned long, unsigned long> {
            typedef unsigned long first_type;
            typedef unsigned long second_type;
            unsigned long first;
            unsigned long second;
            pair() __attribute__((internal_linkage));
            pair(const unsigned long &__t1, const unsigned long &__t2) : first(__t1), second(__t2) __attribute__((internal_linkage))             {
            }
            template <class _U1, class _U2> pair(const pair<_U1, _U2> &__p) __attribute__((internal_linkage));
            template<> pair<unsigned long, unsigned long>(const pair<unsigned long, unsigned long> &__p) __attribute__((internal_linkage));
            std::__1::pair<unsigned long, unsigned long> &operator=(const std::__1::pair<unsigned long, unsigned long> &__p) __attribute__((internal_linkage))             {
                this->first = __p.first;
                this->second = __p.second;
                return *this;
            }
            void swap(std::__1::pair<unsigned long, unsigned long> &__p) __attribute__((internal_linkage));
        private:
        };
        template <class _Tp> class __attribute__((type_visibility("default"))) reference_wrapper;
        template <class _Tp> struct __attribute__((type_visibility("default"))) hash;
        template <class _Tp, _Tp __v> struct __attribute__((type_visibility("default"))) integral_constant {
            static const _Tp value = __v;
            typedef _Tp value_type;
            typedef integral_constant<_Tp, __v> type;
            operator value_type() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return value;
            }
        };
template<> struct integral_constant<bool, true> {
            static const bool value = true;
            typedef bool value_type;
            typedef std::__1::integral_constant<bool, true> type;
            operator value_type() const throw() __attribute__((internal_linkage));
        };
template<> struct integral_constant<bool, false> {
            static const bool value = false;
            typedef bool value_type;
            typedef std::__1::integral_constant<bool, false> type;
            operator value_type() const throw() __attribute__((internal_linkage));
        };
template<> struct integral_constant<unsigned long, 0> {
            static const unsigned long value = 0UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 0> type;
            operator value_type() const throw() __attribute__((internal_linkage));
        };
template<> struct integral_constant<unsigned long, 2> {
            static const unsigned long value = 2UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 2> type;
            operator value_type() const throw() __attribute__((internal_linkage));
        };
template<> struct integral_constant<unsigned long, 9223372036854775808> {
            static const unsigned long value = 9223372036854775808UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 9223372036854775808> type;
            operator value_type() const throw() __attribute__((internal_linkage));
        };
template<> struct integral_constant<unsigned long, 8> {
            static const unsigned long value = 8UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 8> type;
            operator value_type() const throw() __attribute__((internal_linkage));
        };
template<> struct integral_constant<unsigned long, 16> {
            static const unsigned long value = 16UL;
            typedef unsigned long value_type;
            typedef std::__1::integral_constant<unsigned long, 16> type;
            operator value_type() const throw() __attribute__((internal_linkage));
        };
template<> struct integral_constant<int, 0> {
            static const int value = 0;
            typedef int value_type;
            typedef std::__1::integral_constant<int, 0> type;
            operator value_type() const throw() __attribute__((internal_linkage));
        };
        const _Tp value;
        typedef integral_constant<bool, (true)> true_type;
        typedef integral_constant<bool, (false)> false_type;
        template <bool _Val> using _BoolConstant = integral_constant<bool, _Val>;
        template <bool> struct _MetaBase;
        template<> struct _MetaBase<true> {
            template <class _Tp, class _Up> using _SelectImpl = _Tp;
            template <template <class ...> class _FirstFn, template <class ...> class , class ..._Args> using _SelectApplyImpl = _FirstFn<_Args...>;
            template <class _First, class ...> using _FirstImpl = _First;
            template <class, class _Second, class ...> using _SecondImpl = _Second;
            template <class _Tp = void> using _EnableIfImpl = _Tp;
            template <class _Result, class _First, class ..._Rest> using _OrImpl = typename _MetaBase<_First::value != true && sizeof...(_Rest) != 0>::_OrImpl<_First, _Rest...>;
            template <class _Result, class _First, class ..._Rest> using _AndImpl = typename _MetaBase<_First::value == true && sizeof...(_Rest) != 0>::_AndImpl<_First, _Rest...>;
        };
        template<> struct _MetaBase<false> {
            template <class _Tp, class _Up> using _SelectImpl = _Up;
            template <template <class ...> class , template <class ...> class _SecondFn, class ..._Args> using _SelectApplyImpl = _SecondFn<_Args...>;
            template <class _Result, class ...> using _OrImpl = _Result;
            template <class _Result, class ...> using _AndImpl = _Result;
        };
        template <bool _Cond, class _Ret = void> using _EnableIf = typename _MetaBase<_Cond>::_EnableIfImpl<_Ret>;
        template <bool _Cond, class _IfRes, class _ElseRes> using _If = typename _MetaBase<_Cond>::_SelectImpl<_IfRes, _ElseRes>;
        template <class ..._Rest> using _Or = typename _MetaBase<sizeof...(_Rest) != 0>::_OrImpl<std::__1::false_type, _Rest...>;
        template <class ..._Rest> using _And = typename _MetaBase<sizeof...(_Rest) != 0>::_AndImpl<std::__1::true_type, _Rest...>;
        template <class _Pred> struct _Not : _BoolConstant<!_Pred::value> {
        };
        template <class ..._Args> using _FirstType = typename _MetaBase<(sizeof...(_Args) >= 1)>::_FirstImpl<_Args...>;
        template <class ..._Args> using _SecondType = typename _MetaBase<(sizeof...(_Args) >= 2)>::_SecondImpl<_Args...>;
        template <template <class ...> class _Func, class ..._Args> struct _Lazy : _Func<_Args...> {
        };
        template <template <class ...> class _Templ, class ..._Args, class = _Templ<_Args...>> std::__1::true_type __sfinae_test_impl(int);
        template <template <class ...> class , class ...> std::__1::false_type __sfinae_test_impl(...);
        template<> std::__1::false_type __sfinae_test_impl<__return_type, <char *>>(...);
        template<> std::__1::false_type __sfinae_test_impl<__return_type, <const char *>>(...);
        template<> std::__1::false_type __sfinae_test_impl<__return_type, <std::__1::basic_string<char> *>>(...);
        template <template <class ...> class _Templ, class ..._Args> using _IsValidExpansion = decltype(std::__sfinae_test_impl<_Templ, _Args...>(0));
        template <class> struct __void_t {
            typedef void type;
        };
template<> struct __void_t<char *> {
            typedef void type;
        };
template<> struct __void_t<const char *> {
            typedef void type;
        };
template<> struct __void_t<long> {
            typedef void type;
        };
template<> struct __void_t<unsigned long> {
            typedef void type;
        };
template<> struct __void_t<std::__1::integral_constant<bool, true>> {
            typedef void type;
        };
template<> struct __void_t<char> {
            typedef void type;
        };
template<> struct __void_t<wchar_t *> {
            typedef void type;
        };
template<> struct __void_t<const wchar_t *> {
            typedef void type;
        };
template<> struct __void_t<wchar_t> {
            typedef void type;
        };
template<> struct __void_t<long long &&> {
            typedef void type;
        };
template<> struct __void_t<std::__1::basic_string<char> *> {
            typedef void type;
        };
template<> struct __void_t<const std::__1::basic_string<char> *> {
            typedef void type;
        };
template<> struct __void_t<int *> {
            typedef void type;
        };
template<> struct __void_t<const int *> {
            typedef void type;
        };
template<> struct __void_t<std::__1::random_access_iterator_tag> {
            typedef void type;
        };
template<> struct __void_t<int> {
            typedef void type;
        };
template<> struct __void_t<int &> {
            typedef void type;
        };
template<> struct __void_t<long long> {
            typedef void type;
        };
template<> struct __void_t<void> {
            typedef void type;
        };
template<> struct __void_t<std::__1::basic_string<char>> {
            typedef void type;
        };
template<> struct __void_t<const std::__1::basic_string<char> &> {
            typedef void type;
        };
        template <class _Tp> struct __identity {
            typedef _Tp type;
        };
template<> struct __identity<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter type;
        };
        template <class _Tp, bool> struct __attribute__((type_visibility("default"))) __dependent_type : public _Tp {
        };
template<> struct __dependent_type<std::__1::__unique_ptr_deleter_sfinae<std::__1::__builtin_new_allocator::__builtin_new_deleter>, true> : public std::__1::__unique_ptr_deleter_sfinae<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
        };
template<> struct __dependent_type<std::__1::__identity<std::__1::__builtin_new_allocator::__builtin_new_deleter>, true> : public std::__1::__identity<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
        };
template<> struct __dependent_type<std::__1::__unique_ptr_deleter_sfinae<void (*)(void *)>, true> : public std::__1::__unique_ptr_deleter_sfinae<void (*)(void *)> {
        };
        template <bool _Bp, class _If, class _Then> struct __attribute__((type_visibility("default"))) conditional {
            typedef _If type;
        };
template<> struct conditional<false, std::__1::pointer_traits<char *>::__nat, char> {
            typedef char type;
        };
template<> struct conditional<false, std::__1::pointer_traits<wchar_t *>::__nat, wchar_t> {
            typedef wchar_t type;
        };
template<> struct conditional<false, long long *, long long> {
            typedef long long type;
        };
template<> struct conditional<true, std::__1::__common_type2_imp<long long, long long, void>, std::__1::common_type<long long, long long>> {
            typedef std::__1::__common_type2_imp<long long, long long, void> type;
        };
template<> struct conditional<false, std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >, std::__1::__bit_reference<std::__1::__bitset<0, 0>, true>> {
            typedef std::__1::__bit_reference<std::__1::__bitset<0, 0>, true> type;
        };
template<> struct conditional<false, const unsigned long *, unsigned long *> {
            typedef unsigned long *type;
        };
template<> struct conditional<true, std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >, std::__1::__bit_reference<std::__1::__bitset<0, 0>, true>> {
            typedef std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > type;
        };
template<> struct conditional<true, const unsigned long *, unsigned long *> {
            typedef const unsigned long *type;
        };
template<> struct conditional<false, std::__1::pointer_traits<std::__1::basic_string<char> *>::__nat, std::__1::basic_string<char>> {
            typedef std::__1::basic_string<char> type;
        };
template<> struct conditional<false, std::__1::pointer_traits<int *>::__nat, int> {
            typedef int type;
        };
template<> struct conditional<false, void **, void *> {
            typedef void *type;
        };
template<> struct conditional<false, std::__1::__builtin_new_allocator::__builtin_new_deleter *, std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter type;
        };
template<> struct conditional<false, long *, long> {
            typedef long type;
        };
template<> struct conditional<true, std::__1::__common_type2_imp<long long, long, void>, std::__1::common_type<long long, long>> {
            typedef std::__1::__common_type2_imp<long long, long, void> type;
        };
template<> struct conditional<false, std::__1::__default_init_tag *, std::__1::__default_init_tag> {
            typedef std::__1::__default_init_tag type;
        };
template<> struct conditional<false, const std::__1::allocator<char> *, std::__1::allocator<char>> {
            typedef std::__1::allocator<char> type;
        };
template<> struct conditional<false, std::__1::pointer_traits<const char *>::__nat, const char> {
            typedef const char type;
        };
template<> struct conditional<false, std::__1::nullptr_t *, std::__1::nullptr_t> {
            typedef std::__1::nullptr_t type;
        };
template<> struct conditional<false, std::__1::allocator<std::__1::basic_string<char> > *, std::__1::allocator<std::__1::basic_string<char> >> {
            typedef std::__1::allocator<std::__1::basic_string<char> > type;
        };
        template <class _If, class _Then> struct __attribute__((type_visibility("default"))) conditional<false, _If, _Then> {
            typedef _Then type;
        };
        template <bool, class _Tp = void> struct __attribute__((type_visibility("default"))) enable_if {
        };
template<> struct enable_if<false, double> {
        };
template<> struct enable_if<false, int> {
        };
template<> struct enable_if<false, long long> {
        };
template<> struct enable_if<false, long> {
        };
template<> struct enable_if<true, void> {
            typedef void type;
        };
template<> struct enable_if<false, void> {
        };
template<> struct enable_if<true, std::__1::nullptr_t> {
            typedef std::__1::nullptr_t type;
        };
template<> struct enable_if<true, std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >> {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > type;
        };
template<> struct enable_if<true, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > type;
        };
template<> struct enable_if<false, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> {
        };
template<> struct enable_if<false, std::__1::basic_string<char> &> {
        };
template<> struct enable_if<false, unsigned long> {
        };
template<> struct enable_if<true, std::__1::basic_string<char> &> {
            typedef std::__1::basic_string<char> &type;
        };
template<> struct enable_if<true, char *> {
            typedef char *type;
        };
template<> struct enable_if<false, char *> {
        };
template<> struct enable_if<true, wchar_t *> {
            typedef wchar_t *type;
        };
template<> struct enable_if<false, wchar_t *> {
        };
template<> struct enable_if<false, std::__1::error_code &> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) enable_if<true, _Tp> {
            typedef _Tp type;
        };
        template <class _Tp, class _Up> struct __attribute__((type_visibility("default"))) is_same : public std::__1::false_type {
        };
template<> struct is_same<unsigned int, unsigned int> : public std::__1::true_type {
        };
template<> struct is_same<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::__builtin_new_allocator::__builtin_new_deleter, std::__1::default_delete<void>> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::__builtin_new_allocator::__builtin_new_deleter, std::__1::__builtin_new_allocator::__builtin_new_deleter> : public std::__1::true_type {
        };
template<> struct is_same<char, char> : public std::__1::true_type {
        };
template<> struct is_same<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char>> : public std::__1::false_type {
        };
template<> struct is_same<wchar_t, wchar_t> : public std::__1::true_type {
        };
template<> struct is_same<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t>> : public std::__1::false_type {
        };
template<> struct is_same<unsigned char *, void (*)(void *)> : public std::__1::false_type {
        };
template<> struct is_same<void (*)(void *), std::__1::default_delete<unsigned char>> : public std::__1::false_type {
        };
template<> struct is_same<char *, void (*)(void *)> : public std::__1::false_type {
        };
template<> struct is_same<void (*)(void *), std::__1::default_delete<char>> : public std::__1::false_type {
        };
template<> struct is_same<unsigned int *, void (*)(void *)> : public std::__1::false_type {
        };
template<> struct is_same<void (*)(void *), std::__1::default_delete<unsigned int>> : public std::__1::false_type {
        };
template<> struct is_same<__sFILE *, int (*)(__sFILE *)> : public std::__1::false_type {
        };
template<> struct is_same<int (*)(__sFILE *), std::__1::default_delete<__sFILE>> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> >> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::basic_string<char>, std::__1::basic_string<char>> : public std::__1::true_type {
        };
template<> struct is_same<int *, std::__1::allocator<int>> : public std::__1::false_type {
        };
template<> struct is_same<int, int> : public std::__1::true_type {
        };
template<> struct is_same<std::__1::__compressed_pair_elem<void *, 0, false>, void *> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::__compressed_pair_elem<std::__1::__builtin_new_allocator::__builtin_new_deleter, 1, false>, std::__1::__builtin_new_allocator::__builtin_new_deleter> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::__compressed_pair_elem<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, 0, false>, std::__1::__default_init_tag> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::__compressed_pair_elem<std::__1::allocator<char>, 1, true>, std::__1::__default_init_tag> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::__compressed_pair_elem<std::__1::allocator<char>, 1, true>, std::__1::allocator<char>> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::__compressed_pair_elem<std::__1::basic_string<char> *, 0, false>, std::__1::nullptr_t> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::__compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> >, 1, true>, std::__1::__default_init_tag> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > &> : public std::__1::false_type {
        };
template<> struct is_same<std::__1::__compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> > &, 1, false>, std::__1::allocator<std::__1::basic_string<char> >> : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_same<_Tp, _Tp> : public std::__1::true_type {
        };
        template <class _Tp, class _Up> using _IsSame = _BoolConstant<__is_same(_Tp, _Up)>;
        template <class _Tp, class _Up> using _IsNotSame = _BoolConstant<!__is_same(_Tp, _Up)>;
        template <class _Tp> using __test_for_primary_template = _EnableIf<_IsSame<_Tp, typename _Tp::__primary_template>::value>;
        template <class _Tp> using __is_primary_template = _IsValidExpansion<__test_for_primary_template, _Tp>;
        template <class _Tp> inline _Tp *addressof(_Tp &__x) throw() __attribute__((no_sanitize("cfi"))) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_addressof(__x);
        }
        template<> inline char *addressof<char>(char &__x) throw() __attribute__((no_sanitize("cfi"))) __attribute__((internal_linkage))         {
            return __builtin_addressof(__x);
        }
        template<> inline const char *addressof<const char>(const char &__x) throw() __attribute__((no_sanitize("cfi"))) __attribute__((internal_linkage))         {
            return __builtin_addressof(__x);
        }
        struct __two {
            char __lx[2];
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_const : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_const<const _Tp> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_volatile : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_volatile<volatile _Tp> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_const {
            typedef _Tp type;
        };
template<> struct remove_const<double> {
            typedef double type;
        };
template<> struct remove_const<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter type;
        };
template<> struct remove_const<unsigned long long> {
            typedef unsigned long long type;
        };
template<> struct remove_const<unsigned int> {
            typedef unsigned int type;
        };
template<> struct remove_const<unsigned long> {
            typedef unsigned long type;
        };
template<> struct remove_const<long> {
            typedef long type;
        };
template<> struct remove_const<char> {
            typedef char type;
        };
template<> struct remove_const<wchar_t> {
            typedef wchar_t type;
        };
template<> struct remove_const<long long> {
            typedef long long type;
        };
template<> struct remove_const<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >> {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > type;
        };
template<> struct remove_const<int> {
            typedef int type;
        };
template<> struct remove_const<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > type;
        };
template<> struct remove_const<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > type;
        };
template<> struct remove_const<std::__1::basic_string<char>> {
            typedef std::__1::basic_string<char> type;
        };
template<> struct remove_const<void *> {
            typedef void *type;
        };
template<> struct remove_const<const char> {
            typedef char type;
        };
template<> struct remove_const<const wchar_t> {
            typedef wchar_t type;
        };
template<> struct remove_const<std::__1::__default_init_tag> {
            typedef std::__1::__default_init_tag type;
        };
template<> struct remove_const<const std::__1::allocator<char>> {
            typedef std::__1::allocator<char> type;
        };
template<> struct remove_const<std::__1::nullptr_t> {
            typedef std::__1::nullptr_t type;
        };
template<> struct remove_const<std::__1::allocator<std::__1::basic_string<char> >> {
            typedef std::__1::allocator<std::__1::basic_string<char> > type;
        };
template<> struct remove_const<const std::__1::basic_string<char>> {
            typedef std::__1::basic_string<char> type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_const<const _Tp> {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_volatile {
            typedef _Tp type;
        };
template<> struct remove_volatile<double> {
            typedef double type;
        };
template<> struct remove_volatile<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter type;
        };
template<> struct remove_volatile<unsigned long long> {
            typedef unsigned long long type;
        };
template<> struct remove_volatile<unsigned int> {
            typedef unsigned int type;
        };
template<> struct remove_volatile<unsigned long> {
            typedef unsigned long type;
        };
template<> struct remove_volatile<long> {
            typedef long type;
        };
template<> struct remove_volatile<char> {
            typedef char type;
        };
template<> struct remove_volatile<wchar_t> {
            typedef wchar_t type;
        };
template<> struct remove_volatile<long long> {
            typedef long long type;
        };
template<> struct remove_volatile<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >> {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > type;
        };
template<> struct remove_volatile<int> {
            typedef int type;
        };
template<> struct remove_volatile<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > type;
        };
template<> struct remove_volatile<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> {
            typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > type;
        };
template<> struct remove_volatile<std::__1::basic_string<char>> {
            typedef std::__1::basic_string<char> type;
        };
template<> struct remove_volatile<void *> {
            typedef void *type;
        };
template<> struct remove_volatile<std::__1::__default_init_tag> {
            typedef std::__1::__default_init_tag type;
        };
template<> struct remove_volatile<std::__1::allocator<char>> {
            typedef std::__1::allocator<char> type;
        };
template<> struct remove_volatile<std::__1::nullptr_t> {
            typedef std::__1::nullptr_t type;
        };
template<> struct remove_volatile<std::__1::allocator<std::__1::basic_string<char> >> {
            typedef std::__1::allocator<std::__1::basic_string<char> > type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_volatile<volatile _Tp> {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_cv {
            typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;
        };
template<> struct remove_cv<double> {
            typedef typename remove_volatile<typename remove_const<double>::type>::type type;
        };
template<> struct remove_cv<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef typename remove_volatile<typename remove_const<__builtin_new_deleter>::type>::type type;
        };
template<> struct remove_cv<unsigned long long> {
            typedef typename remove_volatile<typename remove_const<unsigned long long>::type>::type type;
        };
template<> struct remove_cv<unsigned int> {
            typedef typename remove_volatile<typename remove_const<unsigned int>::type>::type type;
        };
template<> struct remove_cv<unsigned long> {
            typedef typename remove_volatile<typename remove_const<unsigned long>::type>::type type;
        };
template<> struct remove_cv<long> {
            typedef typename remove_volatile<typename remove_const<long>::type>::type type;
        };
template<> struct remove_cv<char> {
            typedef typename remove_volatile<typename remove_const<char>::type>::type type;
        };
template<> struct remove_cv<wchar_t> {
            typedef typename remove_volatile<typename remove_const<wchar_t>::type>::type type;
        };
template<> struct remove_cv<long long> {
            typedef typename remove_volatile<typename remove_const<long long>::type>::type type;
        };
template<> struct remove_cv<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >> {
            typedef typename remove_volatile<typename remove_const<duration<long long, ratio<1, 1> > >::type>::type type;
        };
template<> struct remove_cv<int> {
            typedef typename remove_volatile<typename remove_const<int>::type>::type type;
        };
template<> struct remove_cv<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> {
            typedef typename remove_volatile<typename remove_const<duration<long long, ratio<1, 1000000000> > >::type>::type type;
        };
template<> struct remove_cv<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> {
            typedef typename remove_volatile<typename remove_const<duration<long long, ratio<1, 1000000> > >::type>::type type;
        };
template<> struct remove_cv<std::__1::basic_string<char>> {
            typedef typename remove_volatile<typename remove_const<basic_string<char> >::type>::type type;
        };
template<> struct remove_cv<void *> {
            typedef typename remove_volatile<typename remove_const<void *>::type>::type type;
        };
template<> struct remove_cv<const char> {
            typedef typename remove_volatile<typename remove_const<const char>::type>::type type;
        };
template<> struct remove_cv<const wchar_t> {
            typedef typename remove_volatile<typename remove_const<const wchar_t>::type>::type type;
        };
template<> struct remove_cv<std::__1::__default_init_tag> {
            typedef typename remove_volatile<typename remove_const<__default_init_tag>::type>::type type;
        };
template<> struct remove_cv<const std::__1::allocator<char>> {
            typedef typename remove_volatile<typename remove_const<const allocator<char> >::type>::type type;
        };
template<> struct remove_cv<std::__1::nullptr_t> {
            typedef typename remove_volatile<typename remove_const<nullptr_t>::type>::type type;
        };
template<> struct remove_cv<std::__1::allocator<std::__1::basic_string<char> >> {
            typedef typename remove_volatile<typename remove_const<allocator<basic_string<char> > >::type>::type type;
        };
template<> struct remove_cv<const std::__1::basic_string<char>> {
            typedef typename remove_volatile<typename remove_const<const basic_string<char> >::type>::type type;
        };
        template <class _Tp> struct __libcpp_is_void : public std::__1::false_type {
        };
template<> struct __libcpp_is_void<char> : public std::__1::false_type {
        };
template<> struct __libcpp_is_void<wchar_t> : public std::__1::false_type {
        };
template<> struct __libcpp_is_void<std::__1::basic_string<char>> : public std::__1::false_type {
        };
template<> struct __libcpp_is_void<int> : public std::__1::false_type {
        };
        template<> struct __libcpp_is_void<void> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_void : public __libcpp_is_void<typename remove_cv<_Tp>::type> {
        };
template<> struct is_void<char> : public __libcpp_is_void<typename remove_cv<char>::type> {
        };
template<> struct is_void<wchar_t> : public __libcpp_is_void<typename remove_cv<wchar_t>::type> {
        };
template<> struct is_void<std::__1::basic_string<char>> : public __libcpp_is_void<typename remove_cv<basic_string<char> >::type> {
        };
template<> struct is_void<int> : public __libcpp_is_void<typename remove_cv<int>::type> {
        };
template<> struct is_void<const char> : public __libcpp_is_void<typename remove_cv<const char>::type> {
        };
        template <class _Tp> struct __is_nullptr_t_impl : public std::__1::false_type {
        };
        template<> struct __is_nullptr_t_impl<std::__1::nullptr_t> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) __is_nullptr_t : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp> struct __libcpp_is_integral : public std::__1::false_type {
        };
template<> struct __libcpp_is_integral<double> : public std::__1::false_type {
        };
        template<> struct __libcpp_is_integral<bool> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<char> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<signed char> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<unsigned char> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<wchar_t> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<char16_t> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<char32_t> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<short> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<unsigned short> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<int> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<unsigned int> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<long> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<unsigned long> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<long long> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<unsigned long long> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<__int128_t> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_integral<__uint128_t> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_integral : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {
        };
template<> struct is_integral<double> : public __libcpp_is_integral<typename remove_cv<double>::type> {
        };
template<> struct is_integral<unsigned long long> : public __libcpp_is_integral<typename remove_cv<unsigned long long>::type> {
        };
template<> struct is_integral<unsigned int> : public __libcpp_is_integral<typename remove_cv<unsigned int>::type> {
        };
template<> struct is_integral<unsigned long> : public __libcpp_is_integral<typename remove_cv<unsigned long>::type> {
        };
template<> struct is_integral<long> : public __libcpp_is_integral<typename remove_cv<long>::type> {
        };
template<> struct is_integral<long long> : public __libcpp_is_integral<typename remove_cv<long long>::type> {
        };
template<> struct is_integral<char> : public __libcpp_is_integral<typename remove_cv<char>::type> {
        };
        template <class _Tp> struct __libcpp_is_floating_point : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<unsigned long long> : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<unsigned int> : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<unsigned long> : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<long> : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<long long> : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >> : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<int> : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> : public std::__1::false_type {
        };
template<> struct __libcpp_is_floating_point<char> : public std::__1::false_type {
        };
        template<> struct __libcpp_is_floating_point<float> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_floating_point<double> : public std::__1::true_type {
        };
        template<> struct __libcpp_is_floating_point<long double> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_floating_point : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {
        };
template<> struct is_floating_point<unsigned long long> : public __libcpp_is_floating_point<typename remove_cv<unsigned long long>::type> {
        };
template<> struct is_floating_point<unsigned int> : public __libcpp_is_floating_point<typename remove_cv<unsigned int>::type> {
        };
template<> struct is_floating_point<unsigned long> : public __libcpp_is_floating_point<typename remove_cv<unsigned long>::type> {
        };
template<> struct is_floating_point<long> : public __libcpp_is_floating_point<typename remove_cv<long>::type> {
        };
template<> struct is_floating_point<long long> : public __libcpp_is_floating_point<typename remove_cv<long long>::type> {
        };
template<> struct is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >> : public __libcpp_is_floating_point<typename remove_cv<duration<long long, ratio<1, 1> > >::type> {
        };
template<> struct is_floating_point<int> : public __libcpp_is_floating_point<typename remove_cv<int>::type> {
        };
template<> struct is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> : public __libcpp_is_floating_point<typename remove_cv<duration<long long, ratio<1, 1000000000> > >::type> {
        };
template<> struct is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> : public __libcpp_is_floating_point<typename remove_cv<duration<long long, ratio<1, 1000000> > >::type> {
        };
template<> struct is_floating_point<char> : public __libcpp_is_floating_point<typename remove_cv<char>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_array : public std::__1::false_type {
        };
template<> struct is_array<void> : public std::__1::false_type {
        };
template<> struct is_array<char> : public std::__1::false_type {
        };
template<> struct is_array<wchar_t> : public std::__1::false_type {
        };
template<> struct is_array<long long> : public std::__1::false_type {
        };
template<> struct is_array<void *> : public std::__1::false_type {
        };
template<> struct is_array<std::__1::__builtin_new_allocator::__builtin_new_deleter> : public std::__1::false_type {
        };
template<> struct is_array<long> : public std::__1::false_type {
        };
template<> struct is_array<std::__1::__default_init_tag> : public std::__1::false_type {
        };
template<> struct is_array<const std::__1::allocator<char>> : public std::__1::false_type {
        };
template<> struct is_array<std::__1::nullptr_t> : public std::__1::false_type {
        };
template<> struct is_array<std::__1::allocator<std::__1::basic_string<char> >> : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_array<_Tp []> : public std::__1::true_type {
        };
        template <class _Tp, size_t _Np> struct __attribute__((type_visibility("default"))) is_array<_Tp [_Np]> : public std::__1::true_type {
        };
        template <class _Tp> struct __libcpp_is_pointer : public std::__1::false_type {
        };
template<> struct __libcpp_is_pointer<std::__1::__builtin_new_allocator::__builtin_new_deleter> : public std::__1::false_type {
        };
        template <class _Tp> struct __libcpp_is_pointer<_Tp *> : public std::__1::true_type {
        };
        template <class _Tp> struct __libcpp_remove_objc_qualifiers {
            typedef _Tp type;
        };
template<> struct __libcpp_remove_objc_qualifiers<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_pointer : public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<_Tp>::type>::type> {
        };
template<> struct is_pointer<std::__1::__builtin_new_allocator::__builtin_new_deleter> : public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<typename remove_cv<__builtin_new_deleter>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_lvalue_reference : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_lvalue_reference<_Tp &> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_rvalue_reference : public std::__1::false_type {
        };
template<> struct is_rvalue_reference<std::__1::__builtin_new_allocator::__builtin_new_deleter> : public std::__1::false_type {
        };
template<> struct is_rvalue_reference<void (*)(void *)> : public std::__1::false_type {
        };
template<> struct is_rvalue_reference<int (*)(__sFILE *)> : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_rvalue_reference<_Tp &&> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_reference : public std::__1::false_type {
        };
template<> struct is_reference<std::__1::__builtin_new_allocator::__builtin_new_deleter> : public std::__1::false_type {
        };
template<> struct is_reference<void (*)(void *)> : public std::__1::false_type {
        };
template<> struct is_reference<int (*)(__sFILE *)> : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_reference<_Tp &> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_reference<_Tp &&> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_union : public integral_constant<bool, __is_union(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_class : public integral_constant<bool, __is_class(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_function : public _BoolConstant<__is_function(_Tp)> {
        };
template<> struct is_function<long long> : public _BoolConstant<__is_function(long long)> {
        };
template<> struct is_function<void *> : public _BoolConstant<__is_function(void *)> {
        };
template<> struct is_function<std::__1::__builtin_new_allocator::__builtin_new_deleter> : public _BoolConstant<__is_function(std::__1::__builtin_new_allocator::__builtin_new_deleter)> {
        };
template<> struct is_function<long> : public _BoolConstant<__is_function(long)> {
        };
template<> struct is_function<std::__1::__default_init_tag> : public _BoolConstant<__is_function(std::__1::__default_init_tag)> {
        };
template<> struct is_function<char> : public _BoolConstant<__is_function(char)> {
        };
template<> struct is_function<const std::__1::allocator<char>> : public _BoolConstant<__is_function(const std::__1::allocator<char>)> {
        };
template<> struct is_function<const char> : public _BoolConstant<__is_function(const char)> {
        };
template<> struct is_function<std::__1::nullptr_t> : public _BoolConstant<__is_function(std::__1::nullptr_t)> {
        };
template<> struct is_function<std::__1::basic_string<char>> : public _BoolConstant<__is_function(std::__1::basic_string<char>)> {
        };
template<> struct is_function<std::__1::allocator<std::__1::basic_string<char> >> : public _BoolConstant<__is_function(std::__1::allocator<std::__1::basic_string<char> >)> {
        };
        template <class _Tp> struct __libcpp_is_member_pointer {
            enum  {
                __is_member = false,
                __is_func = false,
                __is_obj = false
            };
        };
        template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> {
            enum  {
                __is_member = true,
                __is_func = is_function<_Tp>::value,
                __is_obj = !__is_func
            };
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_member_function_pointer : public _BoolConstant<__libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_func> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_member_pointer : public _BoolConstant<__libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_member> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_member_object_pointer : public _BoolConstant<__libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_obj> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_enum : public integral_constant<bool, __is_enum(_Tp)> {
        };
template<> struct is_enum<std::__1::__legacy_memory_order> : public integral_constant<bool, __is_enum(std::__1::__legacy_memory_order)> {
        };
template<> struct is_enum<std::__1::memory_order> : public integral_constant<bool, __is_enum(std::__1::memory_order)> {
        };
template<> struct is_enum<unsigned long> : public integral_constant<bool, __is_enum(unsigned long)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_arithmetic : public integral_constant<bool, is_integral<_Tp>::value || is_floating_point<_Tp>::value> {
        };
template<> struct is_arithmetic<unsigned long long> : public integral_constant<bool, is_integral<unsigned long long>::value || is_floating_point<unsigned long long>::value> {
        };
template<> struct is_arithmetic<unsigned int> : public integral_constant<bool, is_integral<unsigned int>::value || is_floating_point<unsigned int>::value> {
        };
template<> struct is_arithmetic<unsigned long> : public integral_constant<bool, is_integral<unsigned long>::value || is_floating_point<unsigned long>::value> {
        };
template<> struct is_arithmetic<long> : public integral_constant<bool, is_integral<long>::value || is_floating_point<long>::value> {
        };
template<> struct is_arithmetic<long long> : public integral_constant<bool, is_integral<long long>::value || is_floating_point<long long>::value> {
        };
template<> struct is_arithmetic<char> : public integral_constant<bool, is_integral<char>::value || is_floating_point<char>::value> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_fundamental : public integral_constant<bool, is_void<_Tp>::value || __is_nullptr_t<_Tp>::value || is_arithmetic<_Tp>::value> {
        };
        template <class _Tp> struct __is_block : std::__1::false_type {
        };
        template <class _Rp, class ..._Args> struct __is_block<_Rp (^)(_Args...)> : std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_scalar : public integral_constant<bool, is_arithmetic<_Tp>::value || is_member_pointer<_Tp>::value || is_pointer<_Tp>::value || __is_nullptr_t<_Tp>::value || __is_block<_Tp>::value || is_enum<_Tp>::value> {
        };
        template<> struct __attribute__((type_visibility("default"))) is_scalar<std::__1::nullptr_t> : public std::__1::true_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_object : public integral_constant<bool, is_scalar<_Tp>::value || is_array<_Tp>::value || is_union<_Tp>::value || is_class<_Tp>::value> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_compound : public integral_constant<bool, !is_fundamental<_Tp>::value> {
        };
        struct __is_referenceable_impl {
            template <class _Tp> static _Tp &__test(int);
            template<> static long long &__test<long long>(int);
            template<> static unsigned char &__test<unsigned char>(int);
            template<> static char &__test<char>(int);
            template<> static unsigned int &__test<unsigned int>(int);
            template<> static __sFILE &__test<__sFILE>(int);
            template<> static void *&__test<void *>(int);
            template<> static std::__1::__builtin_new_allocator::__builtin_new_deleter &__test<std::__1::__builtin_new_allocator::__builtin_new_deleter>(int);
            template<> static const char &__test<const char>(int);
            template<> static wchar_t &__test<wchar_t>(int);
            template<> static const wchar_t &__test<const wchar_t>(int);
            template<> static long &__test<long>(int);
            template<> static std::__1::__default_init_tag &__test<std::__1::__default_init_tag>(int);
            template<> static const std::__1::allocator<char> &__test<const std::__1::allocator<char>>(int);
            template<> static std::__1::nullptr_t &__test<std::__1::nullptr_t>(int);
            template<> static std::__1::allocator<std::__1::basic_string<char> > &__test<std::__1::allocator<std::__1::basic_string<char> > &>(int);
            template<> static std::__1::allocator<std::__1::basic_string<char> > &__test<std::__1::allocator<std::__1::basic_string<char> >>(int);
            template<> static std::__1::basic_string<char> &__test<std::__1::basic_string<char>>(int);
            template <class _Tp> static std::__1::__two __test(...);
            template<> static std::__1::__two __test<void>(...);
            template<> static std::__1::__two __test<long long>(...);
            template<> static std::__1::__two __test<unsigned char>(...);
            template<> static std::__1::__two __test<char>(...);
            template<> static std::__1::__two __test<unsigned int>(...);
            template<> static std::__1::__two __test<__sFILE>(...);
            template<> static std::__1::__two __test<void *>(...);
            template<> static std::__1::__two __test<std::__1::__builtin_new_allocator::__builtin_new_deleter>(...);
            template<> static std::__1::__two __test<const char>(...);
            template<> static std::__1::__two __test<wchar_t>(...);
            template<> static std::__1::__two __test<const wchar_t>(...);
            template<> static std::__1::__two __test<long>(...);
            template<> static std::__1::__two __test<std::__1::__default_init_tag>(...);
            template<> static std::__1::__two __test<const std::__1::allocator<char>>(...);
            template<> static std::__1::__two __test<std::__1::nullptr_t>(...);
            template<> static std::__1::__two __test<std::__1::allocator<std::__1::basic_string<char> > &>(...);
            template<> static std::__1::__two __test<std::__1::allocator<std::__1::basic_string<char> >>(...);
            template<> static std::__1::__two __test<std::__1::basic_string<char>>(...);
        };
        template <class _Tp> struct __is_referenceable : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {
        };
template<> struct __is_referenceable<void> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<void>(0)), __two>::value> {
        };
template<> struct __is_referenceable<long long> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<long long>(0)), __two>::value> {
        };
template<> struct __is_referenceable<unsigned char> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<unsigned char>(0)), __two>::value> {
        };
template<> struct __is_referenceable<char> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<char>(0)), __two>::value> {
        };
template<> struct __is_referenceable<unsigned int> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<unsigned int>(0)), __two>::value> {
        };
template<> struct __is_referenceable<__sFILE> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<__sFILE>(0)), __two>::value> {
        };
template<> struct __is_referenceable<void *> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<void *>(0)), __two>::value> {
        };
template<> struct __is_referenceable<std::__1::__builtin_new_allocator::__builtin_new_deleter> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<__builtin_new_deleter>(0)), __two>::value> {
        };
template<> struct __is_referenceable<const char> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<const char>(0)), __two>::value> {
        };
template<> struct __is_referenceable<wchar_t> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<wchar_t>(0)), __two>::value> {
        };
template<> struct __is_referenceable<const wchar_t> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<const wchar_t>(0)), __two>::value> {
        };
template<> struct __is_referenceable<long> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<long>(0)), __two>::value> {
        };
template<> struct __is_referenceable<std::__1::__default_init_tag> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<__default_init_tag>(0)), __two>::value> {
        };
template<> struct __is_referenceable<const std::__1::allocator<char>> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<const allocator<char> >(0)), __two>::value> {
        };
template<> struct __is_referenceable<std::__1::nullptr_t> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<nullptr_t>(0)), __two>::value> {
        };
template<> struct __is_referenceable<std::__1::allocator<std::__1::basic_string<char> > &> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<allocator<basic_string<char> > &>(0)), __two>::value> {
        };
template<> struct __is_referenceable<std::__1::allocator<std::__1::basic_string<char> >> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<allocator<basic_string<char> > >(0)), __two>::value> {
        };
template<> struct __is_referenceable<std::__1::basic_string<char>> : integral_constant<bool, _IsNotSame<decltype(__is_referenceable_impl::__test<basic_string<char> >(0)), __two>::value> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) add_const {
            typedef const _Tp type;
        };
template<> struct add_const<char> {
            typedef const char type;
        };
template<> struct add_const<wchar_t> {
            typedef const wchar_t type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) add_volatile {
            typedef volatile _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) add_cv {
            typedef const volatile _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_reference {
            typedef _Tp type;
        };
template<> struct remove_reference<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter type;
        };
template<> struct remove_reference<std::__1::allocator<char>> {
            typedef std::__1::allocator<char> type;
        };
template<> struct remove_reference<std::__1::allocator<wchar_t>> {
            typedef std::__1::allocator<wchar_t> type;
        };
template<> struct remove_reference<long long> {
            typedef long long type;
        };
template<> struct remove_reference<long long &&> {
            typedef long long type;
        };
template<> struct remove_reference<void (*)(void *)> {
            typedef void (*type)(void *);
        };
template<> struct remove_reference<int &> {
            typedef int type;
        };
template<> struct remove_reference<int (*)(__sFILE *)> {
            typedef int (*type)(__sFILE *);
        };
template<> struct remove_reference<std::__1::allocator<std::__1::basic_string<char> >> {
            typedef std::__1::allocator<std::__1::basic_string<char> > type;
        };
template<> struct remove_reference<std::__1::allocator<int>> {
            typedef std::__1::allocator<int> type;
        };
template<> struct remove_reference<unsigned long &> {
            typedef unsigned long type;
        };
template<> struct remove_reference<std::__1::__builtin_new_allocator::__builtin_new_deleter &> {
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter type;
        };
template<> struct remove_reference<void *&> {
            typedef void *type;
        };
template<> struct remove_reference<void *> {
            typedef void *type;
        };
template<> struct remove_reference<long> {
            typedef long type;
        };
template<> struct remove_reference<std::__1::__default_init_tag> {
            typedef std::__1::__default_init_tag type;
        };
template<> struct remove_reference<const std::__1::allocator<char> &> {
            typedef const std::__1::allocator<char> type;
        };
template<> struct remove_reference<const std::__1::allocator<char>> {
            typedef const std::__1::allocator<char> type;
        };
template<> struct remove_reference<std::__1::nullptr_t> {
            typedef std::__1::nullptr_t type;
        };
template<> struct remove_reference<const std::__1::basic_string<char> &> {
            typedef const std::__1::basic_string<char> type;
        };
template<> struct remove_reference<std::__1::allocator<std::__1::basic_string<char> > &> {
            typedef std::__1::allocator<std::__1::basic_string<char> > type;
        };
template<> struct remove_reference<const std::__1::basic_string<char>> {
            typedef const std::__1::basic_string<char> type;
        };
template<> struct remove_reference<std::__1::basic_string<char> &> {
            typedef std::__1::basic_string<char> type;
        };
template<> struct remove_reference<std::__1::basic_string<char> *&> {
            typedef std::__1::basic_string<char> *type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_reference<_Tp &> {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_reference<_Tp &&> {
            typedef _Tp type;
        };
        template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl {
            typedef _Tp type;
        };
template<> struct __add_lvalue_reference_impl<void, false> {
            typedef void type;
        };
template<> struct __add_lvalue_reference_impl<unsigned char, true> {
            typedef unsigned char &type;
        };
template<> struct __add_lvalue_reference_impl<char, true> {
            typedef char &type;
        };
template<> struct __add_lvalue_reference_impl<unsigned int, true> {
            typedef unsigned int &type;
        };
template<> struct __add_lvalue_reference_impl<__sFILE, true> {
            typedef __sFILE &type;
        };
template<> struct __add_lvalue_reference_impl<const char, true> {
            typedef const char &type;
        };
template<> struct __add_lvalue_reference_impl<wchar_t, true> {
            typedef wchar_t &type;
        };
template<> struct __add_lvalue_reference_impl<const wchar_t, true> {
            typedef const wchar_t &type;
        };
template<> struct __add_lvalue_reference_impl<std::__1::allocator<std::__1::basic_string<char> > &, true> {
            typedef std::__1::allocator<std::__1::basic_string<char> > &type;
        };
        template <class _Tp> struct __add_lvalue_reference_impl<_Tp, true> {
            typedef _Tp &type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) add_lvalue_reference {
            typedef typename __add_lvalue_reference_impl<_Tp>::type type;
        };
template<> struct add_lvalue_reference<void> {
            typedef typename __add_lvalue_reference_impl<void>::type type;
        };
template<> struct add_lvalue_reference<unsigned char> {
            typedef typename __add_lvalue_reference_impl<unsigned char>::type type;
        };
template<> struct add_lvalue_reference<char> {
            typedef typename __add_lvalue_reference_impl<char>::type type;
        };
template<> struct add_lvalue_reference<unsigned int> {
            typedef typename __add_lvalue_reference_impl<unsigned int>::type type;
        };
template<> struct add_lvalue_reference<__sFILE> {
            typedef typename __add_lvalue_reference_impl<__sFILE>::type type;
        };
template<> struct add_lvalue_reference<const char> {
            typedef typename __add_lvalue_reference_impl<const char>::type type;
        };
template<> struct add_lvalue_reference<wchar_t> {
            typedef typename __add_lvalue_reference_impl<wchar_t>::type type;
        };
template<> struct add_lvalue_reference<const wchar_t> {
            typedef typename __add_lvalue_reference_impl<const wchar_t>::type type;
        };
template<> struct add_lvalue_reference<std::__1::allocator<std::__1::basic_string<char> > &> {
            typedef typename __add_lvalue_reference_impl<allocator<basic_string<char> > &>::type type;
        };
        template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl {
            typedef _Tp type;
        };
template<> struct __add_rvalue_reference_impl<std::__1::basic_string<char>, true> {
            typedef std::__1::basic_string<char> &&type;
        };
        template <class _Tp> struct __add_rvalue_reference_impl<_Tp, true> {
            typedef _Tp &&type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) add_rvalue_reference {
            typedef typename __add_rvalue_reference_impl<_Tp>::type type;
        };
template<> struct add_rvalue_reference<std::__1::basic_string<char>> {
            typedef typename __add_rvalue_reference_impl<basic_string<char> >::type type;
        };
        template <class _Tp> _Tp &&__declval(int);
        template<> std::__1::allocator<char> &__declval<std::__1::allocator<char> &>(int);
        template<> std::__1::allocator<wchar_t> &__declval<std::__1::allocator<wchar_t> &>(int);
        template<> long long &&__declval<long long>(int);
        template<> long &&__declval<long>(int);
        template<> std::__1::allocator<std::__1::basic_string<char> > &&__declval<std::__1::allocator<std::__1::basic_string<char> >>(int);
        template<> std::__1::basic_string<char> *&&__declval<std::__1::basic_string<char> *>(int);
        template<> const std::__1::basic_string<char> &__declval<const std::__1::basic_string<char> &>(int);
        template<> std::__1::basic_string<char> &&__declval<std::__1::basic_string<char>>(int);
        template<> std::__1::basic_string<char> &&__declval<std::__1::basic_string<char> &&>(int);
        template <class _Tp> _Tp __declval(long);
        template<> std::__1::allocator<char> &__declval<std::__1::allocator<char> &>(long);
        template<> std::__1::allocator<wchar_t> &__declval<std::__1::allocator<wchar_t> &>(long);
        template<> long long __declval<long long>(long);
        template<> long __declval<long>(long);
        template<> std::__1::allocator<std::__1::basic_string<char> > __declval<std::__1::allocator<std::__1::basic_string<char> >>(long);
        template<> std::__1::basic_string<char> *__declval<std::__1::basic_string<char> *>(long);
        template<> const std::__1::basic_string<char> &__declval<const std::__1::basic_string<char> &>(long);
        template<> std::__1::basic_string<char> __declval<std::__1::basic_string<char>>(long);
        template<> std::__1::basic_string<char> &&__declval<std::__1::basic_string<char> &&>(long);
        template <class _Tp> decltype(std::__1::__declval<_Tp>(0)) declval() throw();
        template<> decltype(std::__1::__declval<std::__1::allocator<char> &>(0)) declval<std::__1::allocator<char> &>() throw();
        template<> decltype(std::__1::__declval<std::__1::allocator<wchar_t> &>(0)) declval<std::__1::allocator<wchar_t> &>() throw();
        template<> decltype(std::__1::__declval<long long>(0)) declval<long long>() throw();
        template<> decltype(std::__1::__declval<long>(0)) declval<long>() throw();
        template<> decltype(std::__1::__declval<std::__1::allocator<std::__1::basic_string<char> > >(0)) declval<std::__1::allocator<std::__1::basic_string<char> >>() throw();
        template<> decltype(std::__1::__declval<std::__1::basic_string<char> *>(0)) declval<std::__1::basic_string<char> *>() throw();
        template<> decltype(std::__1::__declval<const std::__1::basic_string<char> &>(0)) declval<const std::__1::basic_string<char> &>() throw();
        template<> decltype(std::__1::__declval<std::__1::basic_string<char> >(0)) declval<std::__1::basic_string<char>>() throw();
        template<> decltype(std::__1::__declval<std::__1::basic_string<char> &&>(0)) declval<std::__1::basic_string<char> &&>() throw();
        template <class _Tp> struct __uncvref {
            typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
        };
        template <class _Tp> struct __unconstref {
            typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
        };
        template <class _Tp, class _Up> struct __is_same_uncvref : _IsSame<typename __uncvref<_Tp>::type, typename __uncvref<_Up>::type> {
        };
        struct __any {
            __any(...);
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_pointer {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_pointer<_Tp *> {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_pointer<_Tp *const> {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_pointer<_Tp *volatile> {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_pointer<_Tp *const volatile> {
            typedef _Tp type;
        };
        template <class _Tp, bool = __is_referenceable<_Tp>::value || _IsSame<typename remove_cv<_Tp>::type, void>::value> struct __add_pointer_impl {
            typedef typename remove_reference<_Tp>::type *type;
        };
template<> struct __add_pointer_impl<long long, true> {
            typedef typename remove_reference<long long>::type *type;
        };
template<> struct __add_pointer_impl<void *, true> {
            typedef typename remove_reference<void *>::type *type;
        };
template<> struct __add_pointer_impl<std::__1::__builtin_new_allocator::__builtin_new_deleter, true> {
            typedef typename remove_reference<__builtin_new_deleter>::type *type;
        };
template<> struct __add_pointer_impl<long, true> {
            typedef typename remove_reference<long>::type *type;
        };
template<> struct __add_pointer_impl<std::__1::__default_init_tag, true> {
            typedef typename remove_reference<__default_init_tag>::type *type;
        };
template<> struct __add_pointer_impl<const std::__1::allocator<char>, true> {
            typedef typename remove_reference<const allocator<char> >::type *type;
        };
template<> struct __add_pointer_impl<std::__1::nullptr_t, true> {
            typedef typename remove_reference<nullptr_t>::type *type;
        };
template<> struct __add_pointer_impl<std::__1::allocator<std::__1::basic_string<char> >, true> {
            typedef typename remove_reference<allocator<basic_string<char> > >::type *type;
        };
        template <class _Tp> struct __add_pointer_impl<_Tp, false> {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) add_pointer {
            typedef typename __add_pointer_impl<_Tp>::type type;
        };
template<> struct add_pointer<long long> {
            typedef typename __add_pointer_impl<long long>::type type;
        };
template<> struct add_pointer<void *> {
            typedef typename __add_pointer_impl<void *>::type type;
        };
template<> struct add_pointer<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef typename __add_pointer_impl<__builtin_new_deleter>::type type;
        };
template<> struct add_pointer<long> {
            typedef typename __add_pointer_impl<long>::type type;
        };
template<> struct add_pointer<std::__1::__default_init_tag> {
            typedef typename __add_pointer_impl<__default_init_tag>::type type;
        };
template<> struct add_pointer<const std::__1::allocator<char>> {
            typedef typename __add_pointer_impl<const allocator<char> >::type type;
        };
template<> struct add_pointer<std::__1::nullptr_t> {
            typedef typename __add_pointer_impl<nullptr_t>::type type;
        };
template<> struct add_pointer<std::__1::allocator<std::__1::basic_string<char> >> {
            typedef typename __add_pointer_impl<allocator<basic_string<char> > >::type type;
        };
        template <class _Tp, bool = is_integral<_Tp>::value> struct __libcpp_is_signed_impl : public integral_constant<bool, (_Tp(-1) < _Tp(0))> {
        };
template<> struct __libcpp_is_signed_impl<unsigned long long, true> : public integral_constant<bool, (unsigned long long(-1) < unsigned long long(0))> {
        };
template<> struct __libcpp_is_signed_impl<unsigned int, true> : public integral_constant<bool, (unsigned int(-1) < unsigned int(0))> {
        };
template<> struct __libcpp_is_signed_impl<unsigned long, true> : public integral_constant<bool, (unsigned long(-1) < unsigned long(0))> {
        };
template<> struct __libcpp_is_signed_impl<long, true> : public integral_constant<bool, (long(-1) < long(0))> {
        };
template<> struct __libcpp_is_signed_impl<long long, true> : public integral_constant<bool, (long long(-1) < long long(0))> {
        };
template<> struct __libcpp_is_signed_impl<char, true> : public integral_constant<bool, (char(-1) < char(0))> {
        };
        template <class _Tp> struct __libcpp_is_signed_impl<_Tp, false> : public std::__1::true_type {
        };
        template <class _Tp, bool = is_arithmetic<_Tp>::value> struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {
        };
template<> struct __libcpp_is_signed<unsigned long long, true> : public __libcpp_is_signed_impl<unsigned long long> {
        };
template<> struct __libcpp_is_signed<unsigned int, true> : public __libcpp_is_signed_impl<unsigned int> {
        };
template<> struct __libcpp_is_signed<unsigned long, true> : public __libcpp_is_signed_impl<unsigned long> {
        };
template<> struct __libcpp_is_signed<long, true> : public __libcpp_is_signed_impl<long> {
        };
template<> struct __libcpp_is_signed<long long, true> : public __libcpp_is_signed_impl<long long> {
        };
template<> struct __libcpp_is_signed<char, true> : public __libcpp_is_signed_impl<char> {
        };
        template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_signed : public __libcpp_is_signed<_Tp> {
        };
template<> struct is_signed<unsigned long long> : public __libcpp_is_signed<unsigned long long> {
        };
template<> struct is_signed<unsigned int> : public __libcpp_is_signed<unsigned int> {
        };
template<> struct is_signed<unsigned long> : public __libcpp_is_signed<unsigned long> {
        };
template<> struct is_signed<long> : public __libcpp_is_signed<long> {
        };
template<> struct is_signed<long long> : public __libcpp_is_signed<long long> {
        };
template<> struct is_signed<char> : public __libcpp_is_signed<char> {
        };
        template <class _Tp, bool = is_integral<_Tp>::value> struct __libcpp_is_unsigned_impl : public integral_constant<bool, (_Tp(0) < _Tp(-1))> {
        };
        template <class _Tp> struct __libcpp_is_unsigned_impl<_Tp, false> : public std::__1::false_type {
        };
        template <class _Tp, bool = is_arithmetic<_Tp>::value> struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {
        };
        template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) rank : public integral_constant<size_t, 0> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) rank<_Tp []> : public integral_constant<size_t, rank<_Tp>::value + 1> {
        };
        template <class _Tp, size_t _Np> struct __attribute__((type_visibility("default"))) rank<_Tp [_Np]> : public integral_constant<size_t, rank<_Tp>::value + 1> {
        };
        template <class _Tp, unsigned int _Ip = 0> struct __attribute__((type_visibility("default"))) extent : public integral_constant<size_t, 0> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) extent<_Tp [], 0> : public integral_constant<size_t, 0> {
        };
        template <class _Tp, unsigned int _Ip> struct __attribute__((type_visibility("default"))) extent<_Tp [], _Ip> : public integral_constant<size_t, extent<_Tp, _Ip - 1>::value> {
        };
        template <class _Tp, size_t _Np> struct __attribute__((type_visibility("default"))) extent<_Tp [_Np], 0> : public integral_constant<size_t, _Np> {
        };
        template <class _Tp, size_t _Np, unsigned int _Ip> struct __attribute__((type_visibility("default"))) extent<_Tp [_Np], _Ip> : public integral_constant<size_t, extent<_Tp, _Ip - 1>::value> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_extent {
            typedef _Tp type;
        };
template<> struct remove_extent<long long> {
            typedef long long type;
        };
template<> struct remove_extent<void *> {
            typedef void *type;
        };
template<> struct remove_extent<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter type;
        };
template<> struct remove_extent<long> {
            typedef long type;
        };
template<> struct remove_extent<std::__1::__default_init_tag> {
            typedef std::__1::__default_init_tag type;
        };
template<> struct remove_extent<const std::__1::allocator<char>> {
            typedef const std::__1::allocator<char> type;
        };
template<> struct remove_extent<std::__1::nullptr_t> {
            typedef std::__1::nullptr_t type;
        };
template<> struct remove_extent<std::__1::allocator<std::__1::basic_string<char> >> {
            typedef std::__1::allocator<std::__1::basic_string<char> > type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_extent<_Tp []> {
            typedef _Tp type;
        };
        template <class _Tp, size_t _Np> struct __attribute__((type_visibility("default"))) remove_extent<_Tp [_Np]> {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_all_extents {
            typedef _Tp type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) remove_all_extents<_Tp []> {
            typedef typename remove_all_extents<_Tp>::type type;
        };
        template <class _Tp, size_t _Np> struct __attribute__((type_visibility("default"))) remove_all_extents<_Tp [_Np]> {
            typedef typename remove_all_extents<_Tp>::type type;
        };
        template <class _Up, bool> struct __decay {
            typedef typename remove_cv<_Up>::type type;
        };
template<> struct __decay<long long, true> {
        public:
            typedef typename conditional<is_array<long long>::value, typename remove_extent<long long>::type *, typename conditional<is_function<long long>::value, typename add_pointer<long long>::type, typename remove_cv<long long>::type>::type>::type type;
        };
template<> struct __decay<void *, true> {
        public:
            typedef typename conditional<is_array<void *>::value, typename remove_extent<void *>::type *, typename conditional<is_function<void *>::value, typename add_pointer<void *>::type, typename remove_cv<void *>::type>::type>::type type;
        };
template<> struct __decay<std::__1::__builtin_new_allocator::__builtin_new_deleter, true> {
        public:
            typedef typename conditional<is_array<__builtin_new_deleter>::value, typename remove_extent<__builtin_new_deleter>::type *, typename conditional<is_function<__builtin_new_deleter>::value, typename add_pointer<__builtin_new_deleter>::type, typename remove_cv<__builtin_new_deleter>::type>::type>::type type;
        };
template<> struct __decay<long, true> {
        public:
            typedef typename conditional<is_array<long>::value, typename remove_extent<long>::type *, typename conditional<is_function<long>::value, typename add_pointer<long>::type, typename remove_cv<long>::type>::type>::type type;
        };
template<> struct __decay<std::__1::__default_init_tag, true> {
        public:
            typedef typename conditional<is_array<__default_init_tag>::value, typename remove_extent<__default_init_tag>::type *, typename conditional<is_function<__default_init_tag>::value, typename add_pointer<__default_init_tag>::type, typename remove_cv<__default_init_tag>::type>::type>::type type;
        };
template<> struct __decay<const std::__1::allocator<char>, true> {
        public:
            typedef typename conditional<is_array<const allocator<char> >::value, typename remove_extent<const allocator<char> >::type *, typename conditional<is_function<const allocator<char> >::value, typename add_pointer<const allocator<char> >::type, typename remove_cv<const allocator<char> >::type>::type>::type type;
        };
template<> struct __decay<std::__1::nullptr_t, true> {
        public:
            typedef typename conditional<is_array<nullptr_t>::value, typename remove_extent<nullptr_t>::type *, typename conditional<is_function<nullptr_t>::value, typename add_pointer<nullptr_t>::type, typename remove_cv<nullptr_t>::type>::type>::type type;
        };
template<> struct __decay<std::__1::allocator<std::__1::basic_string<char> >, true> {
        public:
            typedef typename conditional<is_array<allocator<basic_string<char> > >::value, typename remove_extent<allocator<basic_string<char> > >::type *, typename conditional<is_function<allocator<basic_string<char> > >::value, typename add_pointer<allocator<basic_string<char> > >::type, typename remove_cv<allocator<basic_string<char> > >::type>::type>::type type;
        };
        template <class _Up> struct __decay<_Up, true> {
        public:
            typedef typename conditional<is_array<_Up>::value, typename remove_extent<_Up>::type *, typename conditional<is_function<_Up>::value, typename add_pointer<_Up>::type, typename remove_cv<_Up>::type>::type>::type type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) decay {
        private:
            typedef typename remove_reference<_Tp>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<long long> {
        private:
            typedef typename remove_reference<long long>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<long long &&> {
        private:
            typedef typename remove_reference<long long &&>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<void *&> {
        private:
            typedef typename remove_reference<void *&>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
        private:
            typedef typename remove_reference<__builtin_new_deleter>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<void *> {
        private:
            typedef typename remove_reference<void *>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<long> {
        private:
            typedef typename remove_reference<long>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<std::__1::__default_init_tag> {
        private:
            typedef typename remove_reference<__default_init_tag>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<const std::__1::allocator<char> &> {
        private:
            typedef typename remove_reference<const allocator<char> &>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<std::__1::nullptr_t> {
        private:
            typedef typename remove_reference<nullptr_t>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
template<> struct decay<std::__1::allocator<std::__1::basic_string<char> > &> {
        private:
            typedef typename remove_reference<allocator<basic_string<char> > &>::type _Up;
        public:
            typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) __libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {
        };
template<> struct __libcpp_is_final<void *> : public integral_constant<bool, __is_final(void *)> {
        };
template<> struct __libcpp_is_final<std::__1::__builtin_new_allocator::__builtin_new_deleter> : public integral_constant<bool, __is_final(std::__1::__builtin_new_allocator::__builtin_new_deleter)> {
        };
template<> struct __libcpp_is_final<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep> : public integral_constant<bool, __is_final(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep)> {
        };
template<> struct __libcpp_is_final<std::__1::allocator<char>> : public integral_constant<bool, __is_final(std::__1::allocator<char>)> {
        };
template<> struct __libcpp_is_final<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep> : public integral_constant<bool, __is_final(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep)> {
        };
template<> struct __libcpp_is_final<std::__1::allocator<wchar_t>> : public integral_constant<bool, __is_final(std::__1::allocator<wchar_t>)> {
        };
template<> struct __libcpp_is_final<unsigned char *> : public integral_constant<bool, __is_final(unsigned char *)> {
        };
template<> struct __libcpp_is_final<void (*)(void *)> : public integral_constant<bool, __is_final(void (*)(void *))> {
        };
template<> struct __libcpp_is_final<char *> : public integral_constant<bool, __is_final(char *)> {
        };
template<> struct __libcpp_is_final<unsigned int *> : public integral_constant<bool, __is_final(unsigned int *)> {
        };
template<> struct __libcpp_is_final<__sFILE *> : public integral_constant<bool, __is_final(__sFILE *)> {
        };
template<> struct __libcpp_is_final<int (*)(__sFILE *)> : public integral_constant<bool, __is_final(int (*)(__sFILE *))> {
        };
template<> struct __libcpp_is_final<std::__1::basic_string<char> *> : public integral_constant<bool, __is_final(std::__1::basic_string<char> *)> {
        };
template<> struct __libcpp_is_final<std::__1::allocator<std::__1::basic_string<char> >> : public integral_constant<bool, __is_final(std::__1::allocator<std::__1::basic_string<char> >)> {
        };
template<> struct __libcpp_is_final<int *> : public integral_constant<bool, __is_final(int *)> {
        };
template<> struct __libcpp_is_final<std::__1::allocator<int>> : public integral_constant<bool, __is_final(std::__1::allocator<int>)> {
        };
template<> struct __libcpp_is_final<std::__1::allocator<std::__1::basic_string<char> > &> : public integral_constant<bool, __is_final(std::__1::allocator<std::__1::basic_string<char> > &)> {
        };
        template <class _Bp, class _Dp> struct __attribute__((type_visibility("default"))) is_base_of : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {
        };
        template <class _T1, class _T2> struct __attribute__((type_visibility("default"))) is_convertible : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {
        };
template<> struct is_convertible<void *, void *> : public integral_constant<bool, __is_convertible_to(void *, void *)> {
        };
template<> struct is_convertible<std::__1::__builtin_new_allocator::__builtin_new_deleter, std::__1::__builtin_new_allocator::__builtin_new_deleter> : public integral_constant<bool, __is_convertible_to(std::__1::__builtin_new_allocator::__builtin_new_deleter, std::__1::__builtin_new_allocator::__builtin_new_deleter)> {
        };
template<> struct is_convertible<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >, long long> : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >, long long)> {
        };
template<> struct is_convertible<int, long long> : public integral_constant<bool, __is_convertible_to(int, long long)> {
        };
template<> struct is_convertible<long long, long long> : public integral_constant<bool, __is_convertible_to(long long, long long)> {
        };
template<> struct is_convertible<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >)> {
        };
template<> struct is_convertible<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, long long> : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, long long)> {
        };
template<> struct is_convertible<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >, long long> : public integral_constant<bool, __is_convertible_to(std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >, long long)> {
        };
template<> struct is_convertible<const std::__1::basic_string<char> &, std::__1::basic_string_view<char, std::__1::char_traits<char> >> : public integral_constant<bool, __is_convertible_to(const std::__1::basic_string<char> &, std::__1::basic_string_view<char, std::__1::char_traits<char> >)> {
        };
template<> struct is_convertible<const std::__1::basic_string<char> &, const char *> : public integral_constant<bool, __is_convertible_to(const std::__1::basic_string<char> &, const char *)> {
        };
template<> struct is_convertible<const std::__1::basic_string<wchar_t> &, std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >> : public integral_constant<bool, __is_convertible_to(const std::__1::basic_string<wchar_t> &, std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >)> {
        };
template<> struct is_convertible<const std::__1::basic_string<wchar_t> &, const wchar_t *> : public integral_constant<bool, __is_convertible_to(const std::__1::basic_string<wchar_t> &, const wchar_t *)> {
        };
template<> struct is_convertible<char const (&)[128], std::__1::basic_string_view<char, std::__1::char_traits<char> >> : public integral_constant<bool, __is_convertible_to(char const (&)[128], std::__1::basic_string_view<char, std::__1::char_traits<char> >)> {
        };
template<> struct is_convertible<char const (&)[128], const char *> : public integral_constant<bool, __is_convertible_to(char const (&)[128], const char *)> {
        };
template<> struct is_convertible<char const (&)[19], std::__1::basic_string_view<char, std::__1::char_traits<char> >> : public integral_constant<bool, __is_convertible_to(char const (&)[19], std::__1::basic_string_view<char, std::__1::char_traits<char> >)> {
        };
template<> struct is_convertible<char const (&)[19], const char *> : public integral_constant<bool, __is_convertible_to(char const (&)[19], const char *)> {
        };
template<> struct is_convertible<char const (&)[33], std::__1::basic_string_view<char, std::__1::char_traits<char> >> : public integral_constant<bool, __is_convertible_to(char const (&)[33], std::__1::basic_string_view<char, std::__1::char_traits<char> >)> {
        };
template<> struct is_convertible<char const (&)[33], const char *> : public integral_constant<bool, __is_convertible_to(char const (&)[33], const char *)> {
        };
template<> struct is_convertible<std::__1::random_access_iterator_tag, std::__1::input_iterator_tag> : public integral_constant<bool, __is_convertible_to(std::__1::random_access_iterator_tag, std::__1::input_iterator_tag)> {
        };
template<> struct is_convertible<std::__1::random_access_iterator_tag, std::__1::output_iterator_tag> : public integral_constant<bool, __is_convertible_to(std::__1::random_access_iterator_tag, std::__1::output_iterator_tag)> {
        };
template<> struct is_convertible<int, std::__1::input_iterator_tag> : public integral_constant<bool, __is_convertible_to(int, std::__1::input_iterator_tag)> {
        };
template<> struct is_convertible<int, std::__1::output_iterator_tag> : public integral_constant<bool, __is_convertible_to(int, std::__1::output_iterator_tag)> {
        };
template<> struct is_convertible<std::__1::random_access_iterator_tag, std::__1::random_access_iterator_tag> : public integral_constant<bool, __is_convertible_to(std::__1::random_access_iterator_tag, std::__1::random_access_iterator_tag)> {
        };
template<> struct is_convertible<const char *const &, std::__1::basic_string_view<char, std::__1::char_traits<char> >> : public integral_constant<bool, __is_convertible_to(const char *const &, std::__1::basic_string_view<char, std::__1::char_traits<char> >)> {
        };
template<> struct is_convertible<const char *const &, const char *> : public integral_constant<bool, __is_convertible_to(const char *const &, const char *)> {
        };
template<> struct is_convertible<const std::__1::allocator<char> &, std::__1::basic_string_view<char, std::__1::char_traits<char> >> : public integral_constant<bool, __is_convertible_to(const std::__1::allocator<char> &, std::__1::basic_string_view<char, std::__1::char_traits<char> >)> {
        };
template<> struct is_convertible<const std::__1::allocator<char> &, const char *> : public integral_constant<bool, __is_convertible_to(const std::__1::allocator<char> &, const char *)> {
        };
template<> struct is_convertible<const long &, std::__1::basic_string_view<char, std::__1::char_traits<char> >> : public integral_constant<bool, __is_convertible_to(const long &, std::__1::basic_string_view<char, std::__1::char_traits<char> >)> {
        };
template<> struct is_convertible<const long &, const char *> : public integral_constant<bool, __is_convertible_to(const long &, const char *)> {
        };
template<> struct is_convertible<const std::__1::basic_string<char> *, const std::__1::basic_string<char> *> : public integral_constant<bool, __is_convertible_to(const std::__1::basic_string<char> *, const std::__1::basic_string<char> *)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_empty : public integral_constant<bool, __is_empty(_Tp)> {
        };
template<> struct is_empty<void *> : public integral_constant<bool, __is_empty(void *)> {
        };
template<> struct is_empty<std::__1::__builtin_new_allocator::__builtin_new_deleter> : public integral_constant<bool, __is_empty(std::__1::__builtin_new_allocator::__builtin_new_deleter)> {
        };
template<> struct is_empty<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep> : public integral_constant<bool, __is_empty(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep)> {
        };
template<> struct is_empty<std::__1::allocator<char>> : public integral_constant<bool, __is_empty(std::__1::allocator<char>)> {
        };
template<> struct is_empty<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep> : public integral_constant<bool, __is_empty(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep)> {
        };
template<> struct is_empty<std::__1::allocator<wchar_t>> : public integral_constant<bool, __is_empty(std::__1::allocator<wchar_t>)> {
        };
template<> struct is_empty<unsigned char *> : public integral_constant<bool, __is_empty(unsigned char *)> {
        };
template<> struct is_empty<void (*)(void *)> : public integral_constant<bool, __is_empty(void (*)(void *))> {
        };
template<> struct is_empty<char *> : public integral_constant<bool, __is_empty(char *)> {
        };
template<> struct is_empty<unsigned int *> : public integral_constant<bool, __is_empty(unsigned int *)> {
        };
template<> struct is_empty<__sFILE *> : public integral_constant<bool, __is_empty(__sFILE *)> {
        };
template<> struct is_empty<int (*)(__sFILE *)> : public integral_constant<bool, __is_empty(int (*)(__sFILE *))> {
        };
template<> struct is_empty<std::__1::basic_string<char> *> : public integral_constant<bool, __is_empty(std::__1::basic_string<char> *)> {
        };
template<> struct is_empty<std::__1::allocator<std::__1::basic_string<char> >> : public integral_constant<bool, __is_empty(std::__1::allocator<std::__1::basic_string<char> >)> {
        };
template<> struct is_empty<int *> : public integral_constant<bool, __is_empty(int *)> {
        };
template<> struct is_empty<std::__1::allocator<int>> : public integral_constant<bool, __is_empty(std::__1::allocator<int>)> {
        };
template<> struct is_empty<std::__1::allocator<std::__1::basic_string<char> > &> : public integral_constant<bool, __is_empty(std::__1::allocator<std::__1::basic_string<char> > &)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) alignment_of : public integral_constant<size_t, __alignof(_Tp)> {
        };
        template <class _Hp, class _Tp> struct __type_list {
            typedef _Hp _Head;
            typedef _Tp _Tail;
        };
template<> struct __type_list<signed char, std::__1::__type_list<short, std::__1::__type_list<int, std::__1::__type_list<long, std::__1::__type_list<long long, std::__1::__type_list<__int128, std::__1::__nat> > > > >> {
            typedef signed char _Head;
            typedef std::__1::__type_list<short, std::__1::__type_list<int, std::__1::__type_list<long, std::__1::__type_list<long long, std::__1::__type_list<__int128, std::__1::__nat> > > > > _Tail;
        };
template<> struct __type_list<unsigned char, std::__1::__type_list<unsigned short, std::__1::__type_list<unsigned int, std::__1::__type_list<unsigned long, std::__1::__type_list<unsigned long long, std::__1::__type_list<unsigned __int128, std::__1::__nat> > > > >> {
            typedef unsigned char _Head;
            typedef std::__1::__type_list<unsigned short, std::__1::__type_list<unsigned int, std::__1::__type_list<unsigned long, std::__1::__type_list<unsigned long long, std::__1::__type_list<unsigned __int128, std::__1::__nat> > > > > _Tail;
        };
        struct __nat {
        };
        template <class _Tp> struct __align_type {
            static const size_t value = __alignof(_Tp);
            typedef _Tp type;
        };
template<> struct __align_type<unsigned char> {
            static const size_t value = __alignof(unsigned char);
            typedef unsigned char type;
        };
template<> struct __align_type<unsigned short> {
            static const size_t value = __alignof(unsigned short);
            typedef unsigned short type;
        };
template<> struct __align_type<unsigned int> {
            static const size_t value = __alignof(unsigned int);
            typedef unsigned int type;
        };
template<> struct __align_type<unsigned long> {
            static const size_t value = __alignof(unsigned long);
            typedef unsigned long type;
        };
template<> struct __align_type<unsigned long long> {
            static const size_t value = __alignof(unsigned long long);
            typedef unsigned long long type;
        };
template<> struct __align_type<double> {
            static const size_t value = __alignof(double);
            typedef double type;
        };
template<> struct __align_type<long double> {
            static const size_t value = __alignof(long double);
            typedef long double type;
        };
template<> struct __align_type<std::__1::__struct_double> {
            static const size_t value = __alignof(std::__1::__struct_double);
            typedef std::__1::__struct_double type;
        };
template<> struct __align_type<std::__1::__struct_double4> {
            static const size_t value = __alignof(std::__1::__struct_double4);
            typedef std::__1::__struct_double4 type;
        };
template<> struct __align_type<int *> {
            static const size_t value = __alignof(int *);
            typedef int *type;
        };
        struct __struct_double {
            long double __lx;
        };
        struct __struct_double4 {
            double __lx[4];
        };
        typedef __type_list<__align_type<unsigned char>, __type_list<__align_type<unsigned short>, __type_list<__align_type<unsigned int>, __type_list<__align_type<unsigned long>, __type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<std::__1::__struct_double>, __type_list<__align_type<std::__1::__struct_double4>, __type_list<__align_type<int *>, std::__1::__nat> > > > > > > > > > __all_types;
        template <size_t _Align> struct __attribute__((aligned(_Align))) __fallback_overaligned {
        };
        template <class _TL, size_t _Align> struct __find_pod;
        template <class _Hp, size_t _Align> struct __find_pod<__type_list<_Hp, std::__1::__nat>, _Align> {
            typedef typename conditional<_Align == _Hp::value, typename _Hp::type, __fallback_overaligned<_Align> >::type type;
        };
        template <class _Hp, class _Tp, size_t _Align> struct __find_pod<__type_list<_Hp, _Tp>, _Align> {
            typedef typename conditional<_Align == _Hp::value, typename _Hp::type, typename __find_pod<_Tp, _Align>::type>::type type;
        };
        template <class _TL, size_t _Len> struct __find_max_align
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<unsigned char>, std::__1::__type_list<std::__1::__align_type<unsigned short>, std::__1::__type_list<std::__1::__align_type<unsigned int>, std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > > > > >, 24> : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned char>::value, __find_max_align<__type_list<__align_type<unsigned short>, __type_list<__align_type<unsigned int>, __type_list<__align_type<unsigned long>, __type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > > > > > >, 24UL>::value>::value> {
        }
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<unsigned short>, std::__1::__type_list<std::__1::__align_type<unsigned int>, std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > > > >, 24> : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned short>::value, __find_max_align<__type_list<__align_type<unsigned int>, __type_list<__align_type<unsigned long>, __type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > > > > >, 24UL>::value>::value> {
        }
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<unsigned int>, std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > > >, 24> : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned int>::value, __find_max_align<__type_list<__align_type<unsigned long>, __type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > > > >, 24UL>::value>::value> {
        }
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<unsigned long>, std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > > >, 24> : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned long>::value, __find_max_align<__type_list<__align_type<unsigned long long>, __type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > > >, 24UL>::value>::value> {
        }
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<unsigned long long>, std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > > >, 24> : public integral_constant<size_t, __select_align<24UL, __align_type<unsigned long long>::value, __find_max_align<__type_list<__align_type<double>, __type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > > >, 24UL>::value>::value> {
        }
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<double>, std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > > >, 24> : public integral_constant<size_t, __select_align<24UL, __align_type<double>::value, __find_max_align<__type_list<__align_type<long double>, __type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > > >, 24UL>::value>::value> {
        }
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<long double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > > >, 24> : public integral_constant<size_t, __select_align<24UL, __align_type<long double>::value, __find_max_align<__type_list<__align_type<__struct_double>, __type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> > >, 24UL>::value>::value> {
        }
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double>, std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> > >, 24> : public integral_constant<size_t, __select_align<24UL, __align_type<__struct_double>::value, __find_max_align<__type_list<__align_type<__struct_double4>, __type_list<__align_type<int *>, __nat> >, 24UL>::value>::value> {
        }
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<std::__1::__struct_double4>, std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat> >, 24> : public integral_constant<size_t, __select_align<24UL, __align_type<__struct_double4>::value, __find_max_align<__type_list<__align_type<int *>, __nat>, 24UL>::value>::value> {
        }
template<> struct __find_max_align<std::__1::__type_list<std::__1::__align_type<int *>, std::__1::__nat>, 24> : public integral_constant<size_t, __align_type<int *>::value> {
        };
        template <class _Hp, size_t _Len> struct __find_max_align<__type_list<_Hp, std::__1::__nat>, _Len> : public integral_constant<size_t, _Hp::value> {
        };
        template <size_t _Len, size_t _A1, size_t _A2> struct __select_align {
        private:
            static const size_t __min = _A2 < _A1 ? _A2 : _A1;
            static const size_t __max = _A1 < _A2 ? _A2 : _A1;
        public:
            static const size_t value = _Len < __max ? __min : __max;
        };
template<> struct __select_align<24, 8, 8> {
        private:
            static const size_t __min = 8UL < 8UL ? 8UL : 8UL;
            static const size_t __max = 8UL < 8UL ? 8UL : 8UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        };
template<> struct __select_align<24, 16, 8> {
        private:
            static const size_t __min = 8UL < 16UL ? 8UL : 16UL;
            static const size_t __max = 16UL < 8UL ? 8UL : 16UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        };
template<> struct __select_align<24, 16, 16> {
        private:
            static const size_t __min = 16UL < 16UL ? 16UL : 16UL;
            static const size_t __max = 16UL < 16UL ? 16UL : 16UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        };
template<> struct __select_align<24, 8, 16> {
        private:
            static const size_t __min = 16UL < 8UL ? 16UL : 8UL;
            static const size_t __max = 8UL < 16UL ? 16UL : 8UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        };
template<> struct __select_align<24, 4, 16> {
        private:
            static const size_t __min = 16UL < 4UL ? 16UL : 4UL;
            static const size_t __max = 4UL < 16UL ? 16UL : 4UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        };
template<> struct __select_align<24, 2, 16> {
        private:
            static const size_t __min = 16UL < 2UL ? 16UL : 2UL;
            static const size_t __max = 2UL < 16UL ? 16UL : 2UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        };
template<> struct __select_align<24, 1, 16> {
        private:
            static const size_t __min = 16UL < 1UL ? 16UL : 1UL;
            static const size_t __max = 1UL < 16UL ? 16UL : 1UL;
        public:
            static const size_t value = 24UL < __max ? __min : __max;
        };
        template <class _Hp, class _Tp, size_t _Len> struct __find_max_align<__type_list<_Hp, _Tp>, _Len> : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {
        };
        template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value> struct __attribute__((type_visibility("default"))) aligned_storage {
            typedef typename __find_pod<__all_types, _Align>::type _Aligner;
            union type {
                std::__1::aligned_storage::_Aligner __align;
                unsigned char __data[(_Len + _Align - 1) / _Align * _Align];
            };
        };
template<> struct aligned_storage<24, 16> {
            struct __attribute__((aligned(16))) type {
                unsigned char __lx[32];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 1> {
            struct __attribute__((aligned(1))) type {
                unsigned char __lx[(_Len + 1 - 1) / 1 * 1];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 2> {
            struct __attribute__((aligned(2))) type {
                unsigned char __lx[(_Len + 2 - 1) / 2 * 2];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 4> {
            struct __attribute__((aligned(4))) type {
                unsigned char __lx[(_Len + 4 - 1) / 4 * 4];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 8> {
            struct __attribute__((aligned(8))) type {
                unsigned char __lx[(_Len + 8 - 1) / 8 * 8];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 16> {
            struct __attribute__((aligned(16))) type {
                unsigned char __lx[(_Len + 16 - 1) / 16 * 16];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 32> {
            struct __attribute__((aligned(32))) type {
                unsigned char __lx[(_Len + 32 - 1) / 32 * 32];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 64> {
            struct __attribute__((aligned(64))) type {
                unsigned char __lx[(_Len + 64 - 1) / 64 * 64];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 128> {
            struct __attribute__((aligned(128))) type {
                unsigned char __lx[(_Len + 128 - 1) / 128 * 128];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 256> {
            struct __attribute__((aligned(256))) type {
                unsigned char __lx[(_Len + 256 - 1) / 256 * 256];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 512> {
            struct __attribute__((aligned(512))) type {
                unsigned char __lx[(_Len + 512 - 1) / 512 * 512];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 1024> {
            struct __attribute__((aligned(1024))) type {
                unsigned char __lx[(_Len + 1024 - 1) / 1024 * 1024];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 2048> {
            struct __attribute__((aligned(2048))) type {
                unsigned char __lx[(_Len + 2048 - 1) / 2048 * 2048];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 4096> {
            struct __attribute__((aligned(4096))) type {
                unsigned char __lx[(_Len + 4096 - 1) / 4096 * 4096];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 8192> {
            struct __attribute__((aligned(8192))) type {
                unsigned char __lx[(_Len + 8192 - 1) / 8192 * 8192];
            };
        };
        template <size_t _Len> struct __attribute__((type_visibility("default"))) aligned_storage<_Len, 16384> {
            struct __attribute__((aligned(16384))) type {
                unsigned char __lx[(_Len + 16384 - 1) / 16384 * 16384];
            };
        };
        template <size_t _I0, size_t ..._In> struct __static_max;
        template <size_t _I0> struct __static_max<_I0> {
            static const size_t value = _I0;
        };
        template <size_t _I0, size_t _I1, size_t ..._In> struct __static_max<_I0, _I1, _In...> {
            static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value : __static_max<_I1, _In...>::value;
        };
        template <size_t _Len, class _Type0, class ..._Types> struct aligned_union {
            static const size_t alignment_value = __static_max<__alignof(_Type0), __alignof(_Types)...>::value;
            static const size_t __len = __static_max<_Len, sizeof(_Type0), sizeof(_Types)...>::value;
            typedef typename aligned_storage<__len, alignment_value>::type type;
        };
        template <class _Tp> struct __numeric_type {
            static void __test(...);
            static float __test(float);
            static double __test(char);
            static double __test(int);
            static double __test(unsigned int);
            static double __test(long);
            static double __test(unsigned long);
            static double __test(long long);
            static double __test(unsigned long long);
            static double __test(double);
            static long double __test(long double);
            typedef decltype(__test(declval<_Tp>())) type;
            static const bool value = _IsNotSame<type, void>::value;
        };
        template<> struct __numeric_type<void> {
            static const bool value = true;
        };
        template <class _A1, class _A2 = void, class _A3 = void, bool = __numeric_type<_A1>::value && __numeric_type<_A2>::value && __numeric_type<_A3>::value> class __promote_imp {
        public:
            static const bool value = false;
        };
        template <class _A1, class _A2, class _A3> class __promote_imp<_A1, _A2, _A3, true> {
        private:
            typedef typename __promote_imp<_A1>::type __type1;
            typedef typename __promote_imp<_A2>::type __type2;
            typedef typename __promote_imp<_A3>::type __type3;
        public:
            typedef decltype(std::__1::__promote_imp<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, true>::__type1() + std::__1::__promote_imp<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, true>::__type2() + std::__1::__promote_imp<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, true>::__type3()) type;
            static const bool value = true;
        };
        template <class _A1, class _A2> class __promote_imp<_A1, _A2, void, true> {
        private:
            typedef typename __promote_imp<_A1>::type __type1;
            typedef typename __promote_imp<_A2>::type __type2;
        public:
            typedef decltype(std::__1::__promote_imp<type-parameter-0-0, type-parameter-0-1, void, true>::__type1() + std::__1::__promote_imp<type-parameter-0-0, type-parameter-0-1, void, true>::__type2()) type;
            static const bool value = true;
        };
        template <class _A1> class __promote_imp<_A1, void, void, true> {
        public:
            typedef typename __numeric_type<_A1>::type type;
            static const bool value = true;
        };
        template <class _A1, class _A2 = void, class _A3 = void> class __promote : public __promote_imp<_A1, _A2, _A3> {
        };
        typedef __type_list<signed char, __type_list<short, __type_list<int, __type_list<long, __type_list<long long, __type_list<__int128_t, std::__1::__nat> > > > > > __signed_types;
        typedef __type_list<unsigned char, __type_list<unsigned short, __type_list<unsigned int, __type_list<unsigned long, __type_list<unsigned long long, __type_list<__uint128_t, std::__1::__nat> > > > > > __unsigned_types;
        template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
        template <class _Hp, class _Tp, size_t _Size> struct __find_first<__type_list<_Hp, _Tp>, _Size, true> {
            typedef _Hp type;
        };
        template <class _Hp, class _Tp, size_t _Size> struct __find_first<__type_list<_Hp, _Tp>, _Size, false> {
            typedef typename __find_first<_Tp, _Size>::type type;
        };
        template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value, bool = is_volatile<typename remove_reference<_Tp>::type>::value> struct __apply_cv {
            typedef _Up type;
        };
        template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, true, false> {
            typedef const _Up type;
        };
        template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, false, true> {
            typedef volatile _Up type;
        };
        template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, true, true> {
            typedef const volatile _Up type;
        };
        template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, false, false> {
            typedef _Up &type;
        };
        template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, true, false> {
            typedef const _Up &type;
        };
        template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, false, true> {
            typedef volatile _Up &type;
        };
        template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, true, true> {
            typedef const volatile _Up &type;
        };
        template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value> struct __make_signed {
        };
        template <class _Tp> struct __make_signed<_Tp, true> {
            typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
        };
        template<> struct __make_signed<bool, true> {
        };
        template<> struct __make_signed<short, true> {
            typedef short type;
        };
        template<> struct __make_signed<unsigned short, true> {
            typedef short type;
        };
        template<> struct __make_signed<int, true> {
            typedef int type;
        };
        template<> struct __make_signed<unsigned int, true> {
            typedef int type;
        };
        template<> struct __make_signed<long, true> {
            typedef long type;
        };
        template<> struct __make_signed<unsigned long, true> {
            typedef long type;
        };
        template<> struct __make_signed<long long, true> {
            typedef long long type;
        };
        template<> struct __make_signed<unsigned long long, true> {
            typedef long long type;
        };
        template<> struct __make_signed<__int128_t, true> {
            typedef __int128_t type;
        };
        template<> struct __make_signed<__uint128_t, true> {
            typedef __int128_t type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) make_signed {
            typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
        };
        template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value> struct __make_unsigned {
        };
        template <class _Tp> struct __make_unsigned<_Tp, true> {
            typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
        };
        template<> struct __make_unsigned<bool, true> {
        };
        template<> struct __make_unsigned<short, true> {
            typedef unsigned short type;
        };
        template<> struct __make_unsigned<unsigned short, true> {
            typedef unsigned short type;
        };
        template<> struct __make_unsigned<int, true> {
            typedef unsigned int type;
        };
        template<> struct __make_unsigned<unsigned int, true> {
            typedef unsigned int type;
        };
        template<> struct __make_unsigned<long, true> {
            typedef unsigned long type;
        };
        template<> struct __make_unsigned<unsigned long, true> {
            typedef unsigned long type;
        };
        template<> struct __make_unsigned<long long, true> {
            typedef unsigned long long type;
        };
        template<> struct __make_unsigned<unsigned long long, true> {
            typedef unsigned long long type;
        };
        template<> struct __make_unsigned<__int128_t, true> {
            typedef __uint128_t type;
        };
        template<> struct __make_unsigned<__uint128_t, true> {
            typedef __uint128_t type;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) make_unsigned {
            typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
        };
        template <class _Tp, class _Up, class = void> struct __common_type2_imp {
        };
template<> struct __common_type2_imp<long long, long long, void> {
            typedef typename decay<decltype(true ? std::__1::declval<long long>() : std::__1::declval<long long>())>::type type;
        };
template<> struct __common_type2_imp<long long, long, void> {
            typedef typename decay<decltype(true ? std::__1::declval<long long>() : std::__1::declval<long>())>::type type;
        };
        template <class _Tp, class _Up> struct __common_type2_imp<_Tp, _Up, typename __void_t<decltype(true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>())>::type> {
            typedef typename decay<decltype(true ? std::__1::declval<_Tp>() : std::__1::declval<_Up>())>::type type;
        };
        template <class, class = void> struct __common_type_impl {
        };
template<> struct __common_type_impl<std::__1::__common_types<long long, long long, long>, void> : __common_type_impl<__common_types<typename common_type<long long, long long>::type, long> > {
        };
template<> struct __common_type_impl<std::__1::__common_types<long long, long>, void> {
            typedef typename common_type<long long, long>::type type;
        };
        template <class ...Tp> struct __common_types;
        template <class ..._Tp> struct __attribute__((type_visibility("default"))) common_type
template<> struct common_type<<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >>> : public common_type<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > {
        }
template<> struct common_type<<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >>> {
            typedef chrono::duration<typename common_type<long long, long long>::type, typename __ratio_gcd<ratio<1, 1000000>, ratio<1, 1000000> >::type> type;
        }
template<> struct common_type<<long long, long long>> : conditional<_IsSame<long long, typename decay<long long>::type>::value && _IsSame<long long, typename decay<long long>::type>::value, __common_type2_imp<long long, long long>, common_type<typename decay<long long>::type, typename decay<long long>::type> >::type {
        }
template<> struct common_type<<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >>> : public common_type<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > {
        }
template<> struct common_type<<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >>> {
            typedef chrono::duration<typename common_type<long long, long long>::type, typename __ratio_gcd<ratio<1, 1000000000>, ratio<1, 1000000000> >::type> type;
        }
template<> struct common_type<<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >>> : public common_type<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > > {
        }
template<> struct common_type<<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >>> {
            typedef chrono::duration<typename common_type<long long, long long>::type, typename __ratio_gcd<ratio<1, 1>, ratio<1, 1> >::type> type;
        }
template<> struct common_type<<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >>> {
            typedef chrono::duration<typename common_type<long long, long long>::type, typename __ratio_gcd<ratio<1, 1000000000>, ratio<1, 1> >::type> type;
        }
template<> struct common_type<<long long, long long, long>> : __common_type_impl<__common_types<long long, long long, long> > {
        }
template<> struct common_type<<long long, long>> : conditional<_IsSame<long long, typename decay<long long>::type>::value && _IsSame<long, typename decay<long>::type>::value, __common_type2_imp<long long, long>, common_type<typename decay<long long>::type, typename decay<long>::type> >::type {
        };
        template <class _Tp, class _Up> struct __common_type_impl<__common_types<_Tp, _Up>, typename __void_t<typename common_type<_Tp, _Up>::type>::type> {
            typedef typename common_type<_Tp, _Up>::type type;
        };
        template <class _Tp, class _Up, class _Vp, class ..._Rest> struct __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...>, typename __void_t<typename common_type<_Tp, _Up>::type>::type> : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type, _Vp, _Rest...> > {
        };
        template<> struct __attribute__((type_visibility("default"))) common_type<> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) common_type<_Tp> : public common_type<_Tp, _Tp> {
        };
        template <class _Tp, class _Up> struct __attribute__((type_visibility("default"))) common_type<_Tp, _Up> : conditional<_IsSame<_Tp, typename decay<_Tp>::type>::value && _IsSame<_Up, typename decay<_Up>::type>::value, __common_type2_imp<_Tp, _Up>, common_type<typename decay<_Tp>::type, typename decay<_Up>::type> >::type {
        };
        template <class _Tp, class _Up, class _Vp, class ..._Rest> struct __attribute__((type_visibility("default"))) common_type<_Tp, _Up, _Vp, _Rest...> : __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...> > {
        };
        template <typename, typename _Tp> struct __select_2nd {
            typedef _Tp type;
        };
        template <class _Tp, class _Arg> typename __select_2nd<decltype((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type __is_assignable_test(int);
        template <class, class> std::__1::false_type __is_assignable_test(...);
        template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value> struct __is_assignable_imp : public decltype((std::__1::__is_assignable_test<_Tp, _Arg>(0))) {
        };
        template <class _Tp, class _Arg> struct __is_assignable_imp<_Tp, _Arg, true> : public std::__1::false_type {
        };
        template <class _Tp, class _Arg> struct is_assignable : public __is_assignable_imp<_Tp, _Arg> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_copy_assignable : public is_assignable<typename add_lvalue_reference<_Tp>::type, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_move_assignable : public is_assignable<typename add_lvalue_reference<_Tp>::type, typename add_rvalue_reference<_Tp>::type> {
        };
        template <class> struct __is_destructible_apply {
            typedef int type;
        };
        template <typename _Tp> struct __is_destructor_wellformed {
            template <typename _Tp1> static char __test(typename __is_destructible_apply<decltype(std::__1::declval<_Tp1 &>().~_Tp1())>::type);
            template <typename _Tp1> static std::__1::__two __test(...);
            static const bool value = sizeof (__test<_Tp>(12)) == sizeof(char);
        };
        template <class _Tp, bool> struct __destructible_imp;
        template <class _Tp> struct __destructible_imp<_Tp, false> : public std::__1::integral_constant<bool, __is_destructor_wellformed<typename std::__1::remove_all_extents<_Tp>::type>::value> {
        };
        template <class _Tp> struct __destructible_imp<_Tp, true> : public std::__1::true_type {
        };
        template <class _Tp, bool> struct __destructible_false;
        template <class _Tp> struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {
        };
        template <class _Tp> struct __destructible_false<_Tp, true> : public std::__1::false_type {
        };
        template <class _Tp> struct is_destructible : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {
        };
        template <class _Tp> struct is_destructible<_Tp []> : public std::__1::false_type {
        };
        template<> struct is_destructible<void> : public std::__1::false_type {
        };
        template <class _Tp> inline typename remove_reference<_Tp>::type &&move(_Tp &&__t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename remove_reference<_Tp>::type _Up;
            return static_cast<_Up &&>(__t);
        }
        template<> inline typename remove_reference<unsigned long &>::type &&move<unsigned long &>(unsigned long &__t) throw() __attribute__((internal_linkage))         {
            typedef typename remove_reference<unsigned long &>::type _Up;
            return static_cast<_Up &&>(__t);
        }
        template<> inline typename remove_reference<__builtin_new_deleter &>::type &&move<std::__1::__builtin_new_allocator::__builtin_new_deleter &>(std::__1::__builtin_new_allocator::__builtin_new_deleter &__t) throw() __attribute__((internal_linkage))         {
            typedef typename remove_reference<__builtin_new_deleter &>::type _Up;
            return static_cast<_Up &&>(__t);
        }
        template<> inline typename remove_reference<basic_string<char> &>::type &&move<std::__1::basic_string<char> &>(std::__1::basic_string<char> &__t) throw() __attribute__((internal_linkage))         {
            typedef typename remove_reference<basic_string<char> &>::type _Up;
            return static_cast<_Up &&>(__t);
        }
        template<> inline typename remove_reference<basic_string<char> *&>::type &&move<std::__1::basic_string<char> *&>(std::__1::basic_string<char> *&__t) throw() __attribute__((internal_linkage))         {
            typedef typename remove_reference<basic_string<char> *&>::type _Up;
            return static_cast<_Up &&>(__t);
        }
        template <class _Tp> inline _Tp &&forward(typename remove_reference<_Tp>::type &__t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return static_cast<_Tp &&>(__t);
        }
        template<> inline void *&forward<void *&>(typename remove_reference<void *&>::type &__t) throw() __attribute__((internal_linkage))         {
            return static_cast<void *&>(__t);
        }
        template<> inline std::__1::__builtin_new_allocator::__builtin_new_deleter &&forward<std::__1::__builtin_new_allocator::__builtin_new_deleter>(typename remove_reference<__builtin_new_deleter>::type &__t) throw() __attribute__((internal_linkage))         {
            return static_cast<std::__1::__builtin_new_allocator::__builtin_new_deleter &&>(__t);
        }
        template<> inline void *&&forward<void *>(typename remove_reference<void *>::type &__t) throw() __attribute__((internal_linkage))         {
            return static_cast<void *&&>(__t);
        }
        template<> inline std::__1::__default_init_tag &&forward<std::__1::__default_init_tag>(typename remove_reference<__default_init_tag>::type &__t) throw() __attribute__((internal_linkage))         {
            return static_cast<std::__1::__default_init_tag &&>(__t);
        }
        template<> inline const std::__1::allocator<char> &forward<const std::__1::allocator<char> &>(typename remove_reference<const allocator<char> &>::type &__t) throw() __attribute__((internal_linkage))         {
            return static_cast<const std::__1::allocator<char> &>(__t);
        }
        template<> inline std::__1::nullptr_t &&forward<std::__1::nullptr_t>(typename remove_reference<nullptr_t>::type &__t) throw() __attribute__((internal_linkage))         {
            return static_cast<std::__1::nullptr_t &&>(__t);
        }
        template<> inline const std::__1::basic_string<char> &forward<const std::__1::basic_string<char> &>(typename remove_reference<const basic_string<char> &>::type &__t) throw() __attribute__((internal_linkage))         {
            return static_cast<const std::__1::basic_string<char> &>(__t);
        }
        template<> inline const std::__1::basic_string<char> &&forward<const std::__1::basic_string<char>>(typename remove_reference<const basic_string<char> >::type &__t) throw() __attribute__((internal_linkage))         {
            return static_cast<const std::__1::basic_string<char> &&>(__t);
        }
        template<> inline std::__1::allocator<std::__1::basic_string<char> > &forward<std::__1::allocator<std::__1::basic_string<char> > &>(typename remove_reference<allocator<basic_string<char> > &>::type &__t) throw() __attribute__((internal_linkage))         {
            return static_cast<std::__1::allocator<std::__1::basic_string<char> > &>(__t);
        }
        template <class _Tp> inline _Tp &&forward(typename remove_reference<_Tp>::type &&__t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(!is_lvalue_reference<_Tp>::value, "can not forward an rvalue as an lvalue");
            return static_cast<_Tp &&>(__t);
        }
        template <class _Tp> inline typename decay<_Tp>::type __decay_copy(_Tp &&__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::forward<_Tp>(__t);
        }
        template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr> struct __member_pointer_traits_imp {
        };
        template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false> {
            typedef _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false> {
            typedef _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false> {
            typedef const _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false> {
            typedef const _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false> {
            typedef volatile _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false> {
            typedef volatile _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false> {
            typedef const volatile _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param...);
        };
        template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false> {
            typedef const volatile _Class _ClassType;
            typedef _Rp _ReturnType;
            typedef _Rp (_FnType)(_Param..., ...);
        };
        template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp _Class::*, false, true> {
            typedef _Class _ClassType;
            typedef _Rp _ReturnType;
        };
        template <class _MP> struct __member_pointer_traits : public __member_pointer_traits_imp<typename remove_cv<_MP>::type, is_member_function_pointer<_MP>::value, is_member_object_pointer<_MP>::value> {
        };
        template <class _DecayedFp> struct __member_pointer_class_type {
        };
        template <class _Ret, class _ClassType> struct __member_pointer_class_type<_Ret _ClassType::*> {
            typedef _ClassType type;
        };
        template <class _Callable> class result_of;
        template <class _Fn, bool, bool> class __result_of {
        };
        template <class _Fn> class __result_of<_Fn (), true, false> {
        public:
            typedef decltype(declval<_Fn>()()) type;
        };
        template <class _Fn, class _A0> class __result_of<_Fn (_A0), true, false> {
        public:
            typedef decltype(declval<_Fn>()(declval<_A0>())) type;
        };
        template <class _Fn, class _A0, class _A1> class __result_of<_Fn (_A0, _A1), true, false> {
        public:
            typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
        };
        template <class _Fn, class _A0, class _A1, class _A2> class __result_of<_Fn (_A0, _A1, _A2), true, false> {
        public:
            typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
        };
        template <class _MP, class _Tp, bool _IsMemberFunctionPtr> struct __result_of_mp;
        template <class _MP, class _Tp> struct __result_of_mp<_MP, _Tp, true> : public __identity<typename __member_pointer_traits<_MP>::_ReturnType> {
        };
        template <class _MP, class _Tp, bool> struct __result_of_mdp;
        template <class _Rp, class _Class, class _Tp> struct __result_of_mdp<_Rp _Class::*, _Tp, false> {
            typedef typename __apply_cv<decltype(*std::__1::declval<_Tp>()), _Rp>::type &type;
        };
        template <class _Rp, class _Class, class _Tp> struct __result_of_mdp<_Rp _Class::*, _Tp, true> {
            typedef typename __apply_cv<_Tp, _Rp>::type &type;
        };
        template <class _Rp, class _Class, class _Tp> struct __result_of_mp<_Rp _Class::*, _Tp, false> : public __result_of_mdp<_Rp _Class::*, _Tp, is_base_of<_Class, typename remove_reference<_Tp>::type>::value> {
        };
        template <class _Fn, class _Tp> class __result_of<_Fn (_Tp), false, true> : public __result_of_mp<typename remove_reference<_Fn>::type, _Tp, is_member_function_pointer<typename remove_reference<_Fn>::type>::value> {
        };
        template <class _Fn, class _Tp, class _A0> class __result_of<_Fn (_Tp, _A0), false, true> : public __result_of_mp<typename remove_reference<_Fn>::type, _Tp, is_member_function_pointer<typename remove_reference<_Fn>::type>::value> {
        };
        template <class _Fn, class _Tp, class _A0, class _A1> class __result_of<_Fn (_Tp, _A0, _A1), false, true> : public __result_of_mp<typename remove_reference<_Fn>::type, _Tp, is_member_function_pointer<typename remove_reference<_Fn>::type>::value> {
        };
        template <class _Fn, class _Tp, class _A0, class _A1, class _A2> class __result_of<_Fn (_Tp, _A0, _A1, _A2), false, true> : public __result_of_mp<typename remove_reference<_Fn>::type, _Tp, is_member_function_pointer<typename remove_reference<_Fn>::type>::value> {
        };
        template <class _Fn> class __attribute__((type_visibility("default"))) result_of<_Fn ()> : public __result_of<_Fn (), is_class<typename remove_reference<_Fn>::type>::value || is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value, is_member_pointer<typename remove_reference<_Fn>::type>::value> {
        };
        template <class _Fn, class _A0> class __attribute__((type_visibility("default"))) result_of<_Fn (_A0)> : public __result_of<_Fn (_A0), is_class<typename remove_reference<_Fn>::type>::value || is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value, is_member_pointer<typename remove_reference<_Fn>::type>::value> {
        };
        template <class _Fn, class _A0, class _A1> class __attribute__((type_visibility("default"))) result_of<_Fn (_A0, _A1)> : public __result_of<_Fn (_A0, _A1), is_class<typename remove_reference<_Fn>::type>::value || is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value, is_member_pointer<typename remove_reference<_Fn>::type>::value> {
        };
        template <class _Fn, class _A0, class _A1, class _A2> class __attribute__((type_visibility("default"))) result_of<_Fn (_A0, _A1, _A2)> : public __result_of<_Fn (_A0, _A1, _A2), is_class<typename remove_reference<_Fn>::type>::value || is_function<typename remove_pointer<typename remove_reference<_Fn>::type>::type>::value, is_member_pointer<typename remove_reference<_Fn>::type>::value> {
        };
        namespace __is_construct {
            struct __nat {
            };
        }
        template <class _Tp, class ..._Args> struct __attribute__((type_visibility("default"))) is_constructible : public integral_constant<bool, __is_constructible(_Tp, _Args...)> {
        };
template<> struct is_constructible<std::__1::__builtin_new_allocator::__builtin_new_deleter, <const std::__1::__builtin_new_allocator::__builtin_new_deleter &>> : public integral_constant<bool, __is_constructible(std::__1::__builtin_new_allocator::__builtin_new_deleter, const std::__1::__builtin_new_allocator::__builtin_new_deleter &)> {
        };
template<> struct is_constructible<std::__1::__builtin_new_allocator::__builtin_new_deleter, <std::__1::__builtin_new_allocator::__builtin_new_deleter &&>> : public integral_constant<bool, __is_constructible(std::__1::__builtin_new_allocator::__builtin_new_deleter, std::__1::__builtin_new_allocator::__builtin_new_deleter &&)> {
        };
template<> struct is_constructible<std::__1::__builtin_new_allocator::__builtin_new_deleter, <>> : public integral_constant<bool, __is_constructible(std::__1::__builtin_new_allocator::__builtin_new_deleter)> {
        };
template<> struct is_constructible<void (*)(void *), <void (*const &)(void *)>> : public integral_constant<bool, __is_constructible(void (*)(void *), void (*const &)(void *))> {
        };
template<> struct is_constructible<void (*)(void *), <void (*&&)(void *)>> : public integral_constant<bool, __is_constructible(void (*)(void *), void (*&&)(void *))> {
        };
template<> struct is_constructible<std::__1::basic_string<char>, <std::__1::basic_string<char> &&>> : public integral_constant<bool, __is_constructible(std::__1::basic_string<char>, std::__1::basic_string<char> &&)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_default_constructible : public is_constructible<_Tp> {
        };
template<> struct is_default_constructible<std::__1::__builtin_new_allocator::__builtin_new_deleter> : public is_constructible<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_copy_constructible : public is_constructible<_Tp, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_move_constructible : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type> {
        };
template<> struct is_move_constructible<std::__1::basic_string<char>> : public is_constructible<std::__1::basic_string<char>, typename add_rvalue_reference<basic_string<char> >::type> {
        };
        template <class _Tp, class ..._Args> struct __attribute__((type_visibility("default"))) is_trivially_constructible : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {
        };
template<> struct is_trivially_constructible<std::__1::basic_string<char>, <std::__1::basic_string<char> &&>> : integral_constant<bool, __is_trivially_constructible(std::__1::basic_string<char>, std::__1::basic_string<char> &&)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_default_constructible : public is_trivially_constructible<_Tp> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_copy_constructible : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_move_constructible : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type> {
        };
template<> struct is_trivially_move_constructible<std::__1::basic_string<char>> : public is_trivially_constructible<std::__1::basic_string<char>, typename add_rvalue_reference<basic_string<char> >::type> {
        };
        template <class _Tp, class _Arg> struct is_trivially_assignable : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)> {
        };
template<> struct is_trivially_assignable<char &, const char &> : integral_constant<bool, __is_trivially_assignable(char &, const char &)> {
        };
template<> struct is_trivially_assignable<wchar_t &, const wchar_t &> : integral_constant<bool, __is_trivially_assignable(wchar_t &, const wchar_t &)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_copy_assignable : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
template<> struct is_trivially_copy_assignable<char> : public is_trivially_assignable<typename add_lvalue_reference<char>::type, typename add_lvalue_reference<typename add_const<char>::type>::type> {
        };
template<> struct is_trivially_copy_assignable<wchar_t> : public is_trivially_assignable<typename add_lvalue_reference<wchar_t>::type, typename add_lvalue_reference<typename add_const<wchar_t>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_move_assignable : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type, typename add_rvalue_reference<_Tp>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_destructible : public integral_constant<bool, __is_trivially_destructible(_Tp)> {
        };
        template <class _Tp, class ..._Args> struct __attribute__((type_visibility("default"))) is_nothrow_constructible : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {
        };
template<> struct is_nothrow_constructible<std::__1::mutex, <>> : public integral_constant<bool, __is_nothrow_constructible(std::__1::mutex)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_default_constructible : public is_nothrow_constructible<_Tp> {
        };
template<> struct is_nothrow_default_constructible<std::__1::mutex> : public is_nothrow_constructible<std::__1::mutex> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_copy_constructible : public is_nothrow_constructible<_Tp, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_move_constructible : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type> {
        };
        template <class _Tp, class _Arg> struct __attribute__((type_visibility("default"))) is_nothrow_assignable : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_copy_assignable : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type, typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_move_assignable : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type, typename add_rvalue_reference<_Tp>::type> {
        };
        template <class _Tp> struct __libcpp_nothrow_destructor : public integral_constant<bool, is_scalar<_Tp>::value || is_reference<_Tp>::value> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_destructible : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_nothrow_destructible<_Tp []> : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_pod : public integral_constant<bool, __is_pod(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_literal_type : public integral_constant<bool, __is_literal(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {
        };
template<> struct is_standard_layout<char> : public integral_constant<bool, __is_standard_layout(char)> {
        };
template<> struct is_standard_layout<wchar_t> : public integral_constant<bool, __is_standard_layout(wchar_t)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
        };
template<> struct is_trivial<char> : public integral_constant<bool, __is_trivial(char)> {
        };
template<> struct is_trivial<wchar_t> : public integral_constant<bool, __is_trivial(wchar_t)> {
        };
        template <class _Tp> struct __is_reference_wrapper_impl : public std::__1::false_type {
        };
        template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp>> : public std::__1::true_type {
        };
        template <class _Tp> struct __is_reference_wrapper : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp> struct __is_swappable;
        template <class _Tp> struct __is_nothrow_swappable;
        template <class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Tp> inline void swap(_Tp &__x, _Tp &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            _Tp __t(std::__1::move(__x));
            __x = std::__1::move(__y);
            __y = std::__1::move(__t);
        }
        template<> inline void swap<unsigned long>(unsigned long &__x, unsigned long &__y) __attribute__((internal_linkage))         {
            unsigned long __t(std::__1::move(__x));
            __x = std::__1::move(__y);
            __y = std::__1::move(__t);
        }
        template<> inline void swap<std::__1::basic_string<char> *>(std::__1::basic_string<char> *&__x, std::__1::basic_string<char> *&__y) __attribute__((internal_linkage))         {
            std::__1::basic_string<char> *__t(std::__1::move(__x));
            __x = std::__1::move(__y);
            __y = std::__1::move(__t);
        }
        template <class _Tp, size_t _Np> inline typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::swap_ranges(__a, __a + _Np, __b);
        }
        template <class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                swap(*__first1, *__first2);
            return __first2;
        }
        template <class _ForwardIterator1, class _ForwardIterator2> inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            swap(*__a, *__b);
        }
        namespace __detail {
            template <class _Tp, class _Up = _Tp, bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value> struct __swappable_with {
                template <class _LHS, class _RHS> static decltype(swap(std::__1::declval<_LHS>(), std::__1::declval<_RHS>())) __test_swap(int);
                template <class, class> static std::__1::__nat __test_swap(long);
                typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
                typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;
                static const bool value = _IsNotSame<__swap1, __nat>::value && _IsNotSame<__swap2, __nat>::value;
            };
            template <class _Tp, class _Up> struct __swappable_with<_Tp, _Up, false> : std::__1::false_type {
            };
            template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value> struct __nothrow_swappable_with {
                static const bool value = false;
            };
            template <class _Tp, class _Up> struct __nothrow_swappable_with<_Tp, _Up, false> : std::__1::false_type {
            };
        }
        template <class _Tp> struct __is_swappable : public integral_constant<bool, __detail::__swappable_with<_Tp &>::value> {
        };
        template <class _Tp> struct __is_nothrow_swappable : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp &>::value> {
        };
        template <class _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl
template<> struct __underlying_type_impl<std::__1::__legacy_memory_order, true> {
            typedef __underlying_type(std::__1::__legacy_memory_order) type;
        }
template<> struct __underlying_type_impl<std::__1::memory_order, true> {
            typedef __underlying_type(std::__1::memory_order) type;
        };
        template <class _Tp> struct __underlying_type_impl<_Tp, false> {
        };
        template <class _Tp> struct __underlying_type_impl<_Tp, true> {
            typedef __underlying_type(_Tp) type;
        };
        template <class _Tp> struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {
        };
template<> struct underlying_type<std::__1::__legacy_memory_order> : __underlying_type_impl<std::__1::__legacy_memory_order, is_enum<__legacy_memory_order>::value> {
        };
template<> struct underlying_type<std::__1::memory_order> : __underlying_type_impl<std::__1::memory_order, is_enum<memory_order>::value> {
        };
        template <class _Tp, bool = is_enum<_Tp>::value> struct __sfinae_underlying_type {
            typedef typename underlying_type<_Tp>::type type;
            typedef decltype(((std::__1::__sfinae_underlying_type::type)1) + 0) __promoted_type;
        };
template<> struct __sfinae_underlying_type<unsigned long, false> {
        };
        template <class _Tp> struct __sfinae_underlying_type<_Tp, false> {
        };
        inline int __convert_to_integral(int __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        inline unsigned int __convert_to_integral(unsigned int __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        inline long __convert_to_integral(long __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        inline unsigned long __convert_to_integral(unsigned long __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        inline long long __convert_to_integral(long long __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        inline unsigned long long __convert_to_integral(unsigned long long __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        template <typename _Fp> inline typename enable_if<is_floating_point<_Fp>::value, long long>::type __convert_to_integral(_Fp __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        inline __int128_t __convert_to_integral(__int128_t __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        inline __uint128_t __convert_to_integral(__uint128_t __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        template <class _Tp> inline typename __sfinae_underlying_type<_Tp>::__promoted_type __convert_to_integral(_Tp __val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __val;
        }
        inline bool __libcpp_is_constant_evaluated() throw()         {
            return __builtin_is_constant_evaluated();
        }
        template <class _CharT> using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;
        const bool value;
        const unsigned long value;
        const bool value;
        const unsigned long value;
        const unsigned long value;
    }
}
namespace std {
    inline namespace __1 {
        template <class _Tp> struct __attribute__((type_visibility("default"))) tuple_size;
        template <class _Tp> struct __attribute__((type_visibility("default"))) tuple_size<const _Tp> : public tuple_size<_Tp> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) tuple_size<volatile _Tp> : public tuple_size<_Tp> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) tuple_size<const volatile _Tp> : public tuple_size<_Tp> {
        };
        template <size_t _Ip, class _Tp> struct __attribute__((type_visibility("default"))) tuple_element;
        template <size_t _Ip, class _Tp> struct __attribute__((type_visibility("default"))) tuple_element<_Ip, const _Tp> {
            typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
        };
        template <size_t _Ip, class _Tp> struct __attribute__((type_visibility("default"))) tuple_element<_Ip, volatile _Tp> {
            typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
        };
        template <size_t _Ip, class _Tp> struct __attribute__((type_visibility("default"))) tuple_element<_Ip, const volatile _Tp> {
            typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
        };
        template <class _Tp> struct __tuple_like : std::__1::false_type {
        };
        template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {
        };
        template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {
        };
        template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {
        };
        template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2>> : std::__1::true_type {
        };
        template <size_t _Ip, class _T1, class _T2> typename tuple_element<_Ip, pair<_T1, _T2> >::type &get(pair<_T1, _T2> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <size_t _Ip, class _T1, class _T2> const typename tuple_element<_Ip, pair<_T1, _T2> >::type &get(const pair<_T1, _T2> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Tp, size_t _Size> struct __attribute__((type_visibility("default"))) array;
        template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size>> : std::__1::true_type {
        };
        template <size_t _Ip, class _Tp, size_t _Size> _Tp &get(array<_Tp, _Size> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <size_t _Ip, class _Tp, size_t _Size> const _Tp &get(const array<_Tp, _Size> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
    }
}
namespace std {
}
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;
typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
typedef int __darwin_ct_rune_t;
typedef union {
    char __mbstate8[128];
    long long _mbstateL;
} __mbstate_t;
typedef __mbstate_t __darwin_mbstate_t;
typedef long __darwin_ptrdiff_t;
typedef unsigned long __darwin_size_t;
typedef __builtin_va_list __darwin_va_list;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
typedef int __darwin_wint_t;
typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;
typedef __darwin_ino64_t __darwin_ino_t;
typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
struct __darwin_pthread_handler_rec {
    void (*__routine)(void *);
    void *__arg;
    struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t {
    long __sig;
    char __opaque[56];
};
struct _opaque_pthread_cond_t {
    long __sig;
    char __opaque[40];
};
struct _opaque_pthread_condattr_t {
    long __sig;
    char __opaque[8];
};
struct _opaque_pthread_mutex_t {
    long __sig;
    char __opaque[56];
};
struct _opaque_pthread_mutexattr_t {
    long __sig;
    char __opaque[8];
};
struct _opaque_pthread_once_t {
    long __sig;
    char __opaque[8];
};
struct _opaque_pthread_rwlock_t {
    long __sig;
    char __opaque[192];
};
struct _opaque_pthread_rwlockattr_t {
    long __sig;
    char __opaque[16];
};
struct _opaque_pthread_t {
    long __sig;
    struct __darwin_pthread_handler_rec *__cleanup_stack;
    char __opaque[8176];
};
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;
typedef __uint32_t __darwin_wctype_t;
extern "C" {
    void *memchr(const void *__s, int __c, size_t __n);
    int memcmp(const void *__s1, const void *__s2, size_t __n);
    void *memcpy(void *__dst, const void *__src, size_t __n);
    void *memmove(void *__dst, const void *__src, size_t __len);
    void *memset(void *__b, int __c, size_t __len);
    char *strcat(char *__s1, const char *__s2);
    char *strchr(const char *__s, int __c);
    int strcmp(const char *__s1, const char *__s2);
    int strcoll(const char *__s1, const char *__s2);
    char *strcpy(char *__dst, const char *__src);
    size_t strcspn(const char *__s, const char *__charset);
    char *strerror(int __errnum) asm("_strerror");
    size_t strlen(const char *__s);
    char *strncat(char *__s1, const char *__s2, size_t __n);
    int strncmp(const char *__s1, const char *__s2, size_t __n);
    char *strncpy(char *__dst, const char *__src, size_t __n);
    char *strpbrk(const char *__s, const char *__charset);
    char *strrchr(const char *__s, int __c);
    size_t strspn(const char *__s, const char *__charset);
    char *strstr(const char *__big, const char *__little);
    char *strtok(char *__str, const char *__sep);
    size_t strxfrm(char *__s1, const char *__s2, size_t __n);
}
extern "C" {
    char *strtok_r(char *__str, const char *__sep, char **__lasts);
}
extern "C" {
    int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
    char *strdup(const char *__s1);
    void *memccpy(void *__dst, const void *__src, int __c, size_t __n);
}
extern "C" {
    char *stpcpy(char *__dst, const char *__src);
    char *stpncpy(char *__dst, const char *__src, size_t __n) __attribute__((availability(macos, introduced=10.7)));
    char *strndup(const char *__s1, size_t __n) __attribute__((availability(macos, introduced=10.7)));
    size_t strnlen(const char *__s1, size_t __n) __attribute__((availability(macos, introduced=10.7)));
    char *strsignal(int __sig);
}
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;
typedef int64_t register_t;
typedef __darwin_intptr_t intptr_t;
typedef unsigned long uintptr_t;
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
typedef u_int64_t syscall_arg_t;
typedef __darwin_size_t rsize_t;
typedef int errno_t;
extern "C" {
    errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n) __attribute__((availability(macos, introduced=10.9)));
}
typedef __darwin_ssize_t ssize_t;
extern "C" {
    void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len) __attribute__((availability(macos, introduced=10.7)));
    void memset_pattern4(void *__b, const void *__pattern4, size_t __len) __attribute__((availability(macos, introduced=10.5)));
    void memset_pattern8(void *__b, const void *__pattern8, size_t __len) __attribute__((availability(macos, introduced=10.5)));
    void memset_pattern16(void *__b, const void *__pattern16, size_t __len) __attribute__((availability(macos, introduced=10.5)));
    char *strcasestr(const char *__big, const char *__little);
    char *strnstr(const char *__big, const char *__little, size_t __len);
    size_t strlcat(char *__dst, const char *__source, size_t __size);
    size_t strlcpy(char *__dst, const char *__source, size_t __size);
    void strmode(int __mode, char *__bp);
    char *strsep(char **__stringp, const char *__delim);
    void swab(const void *, void *, ssize_t);
    int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len) __attribute__((availability(macos, introduced=10.12.1))) __attribute__((availability(ios, introduced=10.1))) __attribute__((availability(tvos, introduced=10.0.1))) __attribute__((availability(watchos, introduced=3.1)));
}
extern "C" {
    int bcmp(const void *, const void *, size_t);
    void bcopy(const void *, void *, size_t);
    void bzero(void *, size_t);
    char *index(const char *, int);
    char *rindex(const char *, int);
    int ffs(int);
    int strcasecmp(const char *, const char *);
    int strncasecmp(const char *, const char *, size_t);
}
extern "C" {
    int ffsl(long) __attribute__((availability(macos, introduced=10.5)));
    int ffsll(long long) __attribute__((availability(macos, introduced=10.9)));
    int fls(int) __attribute__((availability(macos, introduced=10.5)));
    int flsl(long) __attribute__((availability(macos, introduced=10.5)));
    int flsll(long long) __attribute__((availability(macos, introduced=10.9)));
}
extern "C++" {
    inline char *__libcpp_strchr(const char *__s, int __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (char *)strchr(__s, __c);
    }
    inline const char *strchr(const char *__s, int __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f50fdda8, "<no message provided>")))     {
        return __libcpp_strchr(__s, __c);
    }
    inline char *strchr(char *__s, int __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f50fe2c8, "<no message provided>")))     {
        return __libcpp_strchr(__s, __c);
    }
    inline char *__libcpp_strpbrk(const char *__s1, const char *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (char *)strpbrk(__s1, __s2);
    }
    inline const char *strpbrk(const char *__s1, const char *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f50ffbb8, "<no message provided>")))     {
        return __libcpp_strpbrk(__s1, __s2);
    }
    inline char *strpbrk(char *__s1, const char *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f5100058, "<no message provided>")))     {
        return __libcpp_strpbrk(__s1, __s2);
    }
    inline char *__libcpp_strrchr(const char *__s, int __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (char *)strrchr(__s, __c);
    }
    inline const char *strrchr(const char *__s, int __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f51008d0, "<no message provided>")))     {
        return __libcpp_strrchr(__s, __c);
    }
    inline char *strrchr(char *__s, int __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f5100d38, "<no message provided>")))     {
        return __libcpp_strrchr(__s, __c);
    }
    inline void *__libcpp_memchr(const void *__s, int __c, size_t __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (void *)memchr(__s, __c, __n);
    }
    inline const void *memchr(const void *__s, int __c, size_t __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f51016d8, "<no message provided>")))     {
        return __libcpp_memchr(__s, __c, __n);
    }
    inline void *memchr(void *__s, int __c, size_t __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f5101c90, "<no message provided>")))     {
        return __libcpp_memchr(__s, __c, __n);
    }
    inline char *__libcpp_strstr(const char *__s1, const char *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (char *)strstr(__s1, __s2);
    }
    inline const char *strstr(const char *__s1, const char *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f51025d0, "<no message provided>")))     {
        return __libcpp_strstr(__s1, __s2);
    }
    inline char *strstr(char *__s1, const char *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5f5102a38, "<no message provided>")))     {
        return __libcpp_strstr(__s1, __s2);
    }
}
namespace std {
    inline namespace __1 {
        using ::size_t;
        using ::memcpy;
        using ::memmove;
        using ::strcpy;
        using ::strncpy;
        using ::strcat;
        using ::strncat;
        using ::memcmp;
        using ::strcmp;
        using ::strncmp;
        using ::strcoll;
        using ::strxfrm;
        using ::memchr;
        using ::strchr;
        using ::strcspn;
        using ::strpbrk;
        using ::strrchr;
        using ::strspn;
        using ::strstr;
        using ::strtok;
        using ::memset;
        using ::strerror;
        using ::strlen;
    }
}
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef long intmax_t;
typedef unsigned long uintmax_t;
namespace std {
    inline namespace __1 {
        using ::int8_t;
        using ::int16_t;
        using ::int32_t;
        using ::int64_t;
        using ::uint8_t;
        using ::uint16_t;
        using ::uint32_t;
        using ::uint64_t;
        using ::int_least8_t;
        using ::int_least16_t;
        using ::int_least32_t;
        using ::int_least64_t;
        using ::uint_least8_t;
        using ::uint_least16_t;
        using ::uint_least32_t;
        using ::uint_least64_t;
        using ::int_fast8_t;
        using ::int_fast16_t;
        using ::int_fast32_t;
        using ::int_fast64_t;
        using ::uint_fast8_t;
        using ::uint_fast16_t;
        using ::uint_fast32_t;
        using ::uint_fast64_t;
        using ::intptr_t;
        using ::uintptr_t;
        using ::intmax_t;
        using ::uintmax_t;
    }
}
typedef __darwin_mbstate_t mbstate_t;
typedef __darwin_ct_rune_t ct_rune_t;
typedef __darwin_rune_t rune_t;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef __darwin_va_list va_list;
extern "C" {
    int renameat(int, const char *, int, const char *) __attribute__((availability(macos, introduced=10.10)));
    int renamex_np(const char *, const char *, unsigned int) __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0)));
    int renameatx_np(int, const char *, int, const char *, unsigned int) __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0)));
}
typedef __darwin_off_t fpos_t;
struct __sbuf {
    unsigned char *_base;
    int _size;
};
struct __sFILEX;
typedef struct __sFILE {
    unsigned char *_p;
    int _r;
    int _w;
    short _flags;
    short _file;
    struct __sbuf _bf;
    int _lbfsize;
    void *_cookie;
    int (* _Nullable _close)(void *);
    int (* _Nullable _read)(void *, char *, int);
    fpos_t (* _Nullable _seek)(void *, fpos_t, int);
    int (* _Nullable _write)(void *, const char *, int);
    struct __sbuf _ub;
    struct __sFILEX *_extra;
    int _ur;
    unsigned char _ubuf[3];
    unsigned char _nbuf[1];
    struct __sbuf _lb;
    int _blksize;
    fpos_t _offset;
} FILE;
extern "C" {
    extern FILE *__stdinp;
    extern FILE *__stdoutp;
    extern FILE *__stderrp;
}
extern "C" {
    void clearerr(FILE *);
    int fclose(FILE *);
    int feof(FILE *);
    int ferror(FILE *);
    int fflush(FILE *);
    int fgetc(FILE *);
    int fgetpos(FILE *, fpos_t *);
    char *fgets(char *, int, FILE *);
    FILE *fopen(const char *__filename, const char *__mode) asm("_fopen");
    int fprintf(FILE *, const char *, ...) __attribute__((format(printf, 2, 3)));
    int fputc(int, FILE *);
    int fputs(const char *, FILE *) asm("_fputs");
    size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream);
    FILE *freopen(const char *, const char *, FILE *) asm("_freopen");
    int fscanf(FILE *, const char *, ...) __attribute__((format(scanf, 2, 3)));
    int fseek(FILE *, long, int);
    int fsetpos(FILE *, const fpos_t *);
    long ftell(FILE *);
    size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream) asm("_fwrite");
    int getc(FILE *);
    int getchar();
    char *gets(char *);
    void perror(const char *) __attribute__((cold));
    int printf(const char *, ...) __attribute__((format(printf, 1, 2)));
    int putc(int, FILE *);
    int putchar(int);
    int puts(const char *);
    int remove(const char *);
    int rename(const char *__old, const char *__new);
    void rewind(FILE *);
    int scanf(const char *, ...) __attribute__((format(scanf, 1, 2)));
    void setbuf(FILE *, char *);
    int setvbuf(FILE *, char *, int, size_t);
    int sprintf(char *, const char *, ...) __attribute__((format(printf, 2, 3))) __attribute__((availability(swift, unavailable)));
    int sscanf(const char *, const char *, ...) __attribute__((format(scanf, 2, 3)));
    FILE *tmpfile();
    char *tmpnam(char *) __attribute__((availability(swift, unavailable))) __attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")));
    int ungetc(int, FILE *);
    int vfprintf(FILE *, const char *, va_list) __attribute__((format(printf, 2, 0)));
    int vprintf(const char *, va_list) __attribute__((format(printf, 1, 0)));
    int vsprintf(char *, const char *, va_list) __attribute__((format(printf, 2, 0))) __attribute__((availability(swift, unavailable)));
}
extern "C" {
    char *ctermid(char *);
    FILE *fdopen(int, const char *) asm("_fdopen");
    int fileno(FILE *);
}
extern "C" {
    int pclose(FILE *) __attribute__((availability(swift, unavailable)));
    FILE *popen(const char *, const char *) asm("_popen") __attribute__((availability(swift, unavailable)));
}
extern "C" {
    int __srget(FILE *);
    int __svfscanf(FILE *, const char *, va_list) __attribute__((format(scanf, 2, 0)));
    int __swbuf(int, FILE *);
}
inline int __sputc(int _c, FILE *_p) __attribute__((always_inline)) {
    if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
        return (*_p->_p++ = _c);
    else
        return (__swbuf(_c, _p));
}
extern "C" {
    void flockfile(FILE *);
    int ftrylockfile(FILE *);
    void funlockfile(FILE *);
    int getc_unlocked(FILE *);
    int getchar_unlocked();
    int putc_unlocked(int, FILE *);
    int putchar_unlocked(int);
    int getw(FILE *);
    int putw(int, FILE *);
    char *tempnam(const char *__dir, const char *__prefix) asm("_tempnam") __attribute__((availability(swift, unavailable))) __attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")));
}
typedef __darwin_off_t off_t;
extern "C" {
    int fseeko(FILE *__stream, off_t __offset, int __whence);
    off_t ftello(FILE *__stream);
}
extern "C" {
    int snprintf(char *__str, size_t __size, const char *__format, ...) __attribute__((format(printf, 3, 4)));
    int vfscanf(FILE *__stream, const char *__format, va_list) __attribute__((format(scanf, 2, 0)));
    int vscanf(const char *__format, va_list) __attribute__((format(scanf, 1, 0)));
    int vsnprintf(char *__str, size_t __size, const char *__format, va_list) __attribute__((format(printf, 3, 0)));
    int vsscanf(const char *__str, const char *__format, va_list) __attribute__((format(scanf, 2, 0)));
}
extern "C" {
    int dprintf(int, const char *, ...) __attribute__((format(printf, 2, 3))) __attribute__((availability(macos, introduced=10.7)));
    int vdprintf(int, const char *, va_list) __attribute__((format(printf, 2, 0))) __attribute__((availability(macos, introduced=10.7)));
    ssize_t getdelim(char **__linep, size_t *__linecapp, int __delimiter, FILE *__stream) __attribute__((availability(macos, introduced=10.7)));
    ssize_t getline(char **__linep, size_t *__linecapp, FILE *__stream) __attribute__((availability(macos, introduced=10.7)));
    FILE *fmemopen(void *__buf, size_t __size, const char *__mode) __attribute__((availability(macos, introduced=10.13))) __attribute__((availability(ios, introduced=11.0))) __attribute__((availability(tvos, introduced=11.0))) __attribute__((availability(watchos, introduced=4.0)));
    FILE *open_memstream(char **__bufp, size_t *__sizep) __attribute__((availability(macos, introduced=10.13))) __attribute__((availability(ios, introduced=11.0))) __attribute__((availability(tvos, introduced=11.0))) __attribute__((availability(watchos, introduced=4.0)));
}
extern "C" {
    extern const int sys_nerr;
    extern const char *const sys_errlist[];
    int asprintf(char **, const char *, ...) __attribute__((format(printf, 2, 3)));
    char *ctermid_r(char *);
    char *fgetln(FILE *, size_t *);
    const char *fmtcheck(const char *, const char *);
    int fpurge(FILE *);
    void setbuffer(FILE *, char *, int);
    int setlinebuf(FILE *);
    int vasprintf(char **, const char *, va_list) __attribute__((format(printf, 2, 0)));
    FILE *zopen(const char *, const char *, int);
    FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *));
}
typedef __darwin_clock_t clock_t;
typedef __darwin_time_t time_t;
struct timespec {
    __darwin_time_t tv_sec;
    long tv_nsec;
};
struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char *tm_zone;
};
extern char *tzname[];
extern int getdate_err;
extern long timezone asm("_timezone");
extern int daylight;
extern "C" {
    char *asctime(const struct tm *);
    clock_t clock() asm("_clock");
    char *ctime(const time_t *);
    double difftime(time_t, time_t);
    struct tm *getdate(const char *);
    struct tm *gmtime(const time_t *);
    struct tm *localtime(const time_t *);
    time_t mktime(struct tm *) asm("_mktime");
    size_t strftime(char *, size_t, const char *, const struct tm *) asm("_strftime");
    char *strptime(const char *, const char *, struct tm *) asm("_strptime");
    time_t time(time_t *);
    void tzset();
    char *asctime_r(const struct tm *, char *);
    char *ctime_r(const time_t *, char *);
    struct tm *gmtime_r(const time_t *, struct tm *);
    struct tm *localtime_r(const time_t *, struct tm *);
    time_t posix2time(time_t);
    void tzsetwall();
    time_t time2posix(time_t);
    time_t timelocal(struct tm *const);
    time_t timegm(struct tm *const);
    int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) asm("_nanosleep");
    typedef enum  {
        _CLOCK_REALTIME __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0))) = 0,
        _CLOCK_MONOTONIC __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0))) = 6,
        _CLOCK_MONOTONIC_RAW __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0))) = 4,
        _CLOCK_MONOTONIC_RAW_APPROX __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0))) = 5,
        _CLOCK_UPTIME_RAW __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0))) = 8,
        _CLOCK_UPTIME_RAW_APPROX __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0))) = 9,
        _CLOCK_PROCESS_CPUTIME_ID __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0))) = 12,
        _CLOCK_THREAD_CPUTIME_ID __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0))) = 16
    } clockid_t;
    int clock_getres(clockid_t __clock_id, struct timespec *__res) __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0)));
    int clock_gettime(clockid_t __clock_id, struct timespec *__tp) __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0)));
    __uint64_t clock_gettime_nsec_np(clockid_t __clock_id) __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0)));
    int clock_settime(clockid_t __clock_id, const struct timespec *__tp) __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, unavailable))) __attribute__((availability(tvos, unavailable))) __attribute__((availability(watchos, unavailable)));
}
typedef __darwin_wint_t wint_t;
typedef __darwin_wctype_t wctype_t;
typedef struct {
    __darwin_rune_t __min;
    __darwin_rune_t __max;
    __darwin_rune_t __map;
    __uint32_t *__types;
} _RuneEntry;
typedef struct {
    int __nranges;
    _RuneEntry *__ranges;
} _RuneRange;
typedef struct {
    char __name[14];
    __uint32_t __mask;
} _RuneCharClass;
typedef struct {
    char __magic[8];
    char __encoding[32];
    __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, const char **);
    int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
    __darwin_rune_t __invalid_rune;
    __uint32_t __runetype[256];
    __darwin_rune_t __maplower[256];
    __darwin_rune_t __mapupper[256];
    _RuneRange __runetype_ext;
    _RuneRange __maplower_ext;
    _RuneRange __mapupper_ext;
    void *__variable;
    int __variable_len;
    int __ncharclasses;
    _RuneCharClass *__charclasses;
} _RuneLocale;
extern "C" {
    extern _RuneLocale _DefaultRuneLocale;
    extern _RuneLocale *_CurrentRuneLocale;
}
extern "C" {
    unsigned long ___runetype(__darwin_ct_rune_t);
    __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
    __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}
inline int isascii(int _c) {
    return ((_c & ~127) == 0);
}
extern "C" {
    int __maskrune(__darwin_ct_rune_t, unsigned long);
}
inline int __istype(__darwin_ct_rune_t _c, unsigned long _f) {
    return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f) : !!__maskrune(_c, _f));
}
inline __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c, unsigned long _f) {
    return (_c < 0 || _c >= (1 << 8)) ? 0 : !!(_DefaultRuneLocale.__runetype[_c] & _f);
}
extern "C" {
    __darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
    __darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}
inline int __wcwidth(__darwin_ct_rune_t _c) {
    unsigned int _x;
    if (_c == 0)
        return (0);
    _x = (unsigned int)__maskrune(_c, 3758096384L | 262144L);
    if ((_x & 3758096384L) != 0)
        return ((_x & 3758096384L) >> 30);
    return ((_x & 262144L) != 0 ? 1 : -1);
}
inline int isalnum(int _c) {
    return (__istype(_c, 256L | 1024L));
}
inline int isalpha(int _c) {
    return (__istype(_c, 256L));
}
inline int isblank(int _c) {
    return (__istype(_c, 131072L));
}
inline int iscntrl(int _c) {
    return (__istype(_c, 512L));
}
inline int isdigit(int _c) {
    return (__isctype(_c, 1024L));
}
inline int isgraph(int _c) {
    return (__istype(_c, 2048L));
}
inline int islower(int _c) {
    return (__istype(_c, 4096L));
}
inline int isprint(int _c) {
    return (__istype(_c, 262144L));
}
inline int ispunct(int _c) {
    return (__istype(_c, 8192L));
}
inline int isspace(int _c) {
    return (__istype(_c, 16384L));
}
inline int isupper(int _c) {
    return (__istype(_c, 32768L));
}
inline int isxdigit(int _c) {
    return (__isctype(_c, 65536L));
}
inline int toascii(int _c) {
    return (_c & 127);
}
inline int tolower(int _c) {
    return (__tolower(_c));
}
inline int toupper(int _c) {
    return (__toupper(_c));
}
inline int digittoint(int _c) {
    return (__maskrune(_c, 15));
}
inline int ishexnumber(int _c) {
    return (__istype(_c, 65536L));
}
inline int isideogram(int _c) {
    return (__istype(_c, 524288L));
}
inline int isnumber(int _c) {
    return (__istype(_c, 1024L));
}
inline int isphonogram(int _c) {
    return (__istype(_c, 2097152L));
}
inline int isrune(int _c) {
    return (__istype(_c, 4294967280L));
}
inline int isspecial(int _c) {
    return (__istype(_c, 1048576L));
}
inline int iswalnum(wint_t _wc) {
    return (__istype(_wc, 256L | 1024L));
}
inline int iswalpha(wint_t _wc) {
    return (__istype(_wc, 256L));
}
inline int iswcntrl(wint_t _wc) {
    return (__istype(_wc, 512L));
}
inline int iswctype(wint_t _wc, wctype_t _charclass) {
    return (__istype(_wc, _charclass));
}
inline int iswdigit(wint_t _wc) {
    return (__isctype(_wc, 1024L));
}
inline int iswgraph(wint_t _wc) {
    return (__istype(_wc, 2048L));
}
inline int iswlower(wint_t _wc) {
    return (__istype(_wc, 4096L));
}
inline int iswprint(wint_t _wc) {
    return (__istype(_wc, 262144L));
}
inline int iswpunct(wint_t _wc) {
    return (__istype(_wc, 8192L));
}
inline int iswspace(wint_t _wc) {
    return (__istype(_wc, 16384L));
}
inline int iswupper(wint_t _wc) {
    return (__istype(_wc, 32768L));
}
inline int iswxdigit(wint_t _wc) {
    return (__isctype(_wc, 65536L));
}
inline wint_t towlower(wint_t _wc) {
    return (__tolower(_wc));
}
inline wint_t towupper(wint_t _wc) {
    return (__toupper(_wc));
}
extern "C" {
    wctype_t wctype(const char *);
}
extern "C" {
    wint_t btowc(int);
    wint_t fgetwc(FILE *);
    wchar_t *fgetws(wchar_t *, int, FILE *);
    wint_t fputwc(wchar_t, FILE *);
    int fputws(const wchar_t *, FILE *);
    int fwide(FILE *, int);
    int fwprintf(FILE *, const wchar_t *, ...);
    int fwscanf(FILE *, const wchar_t *, ...);
    wint_t getwc(FILE *);
    wint_t getwchar();
    size_t mbrlen(const char *, size_t, mbstate_t *);
    size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
    int mbsinit(const mbstate_t *);
    size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
    wint_t putwc(wchar_t, FILE *);
    wint_t putwchar(wchar_t);
    int swprintf(wchar_t *, size_t, const wchar_t *, ...);
    int swscanf(const wchar_t *, const wchar_t *, ...);
    wint_t ungetwc(wint_t, FILE *);
    int vfwprintf(FILE *, const wchar_t *, __darwin_va_list);
    int vswprintf(wchar_t *, size_t, const wchar_t *, __darwin_va_list);
    int vwprintf(const wchar_t *, __darwin_va_list);
    size_t wcrtomb(char *, wchar_t, mbstate_t *);
    wchar_t *wcscat(wchar_t *, const wchar_t *);
    wchar_t *wcschr(const wchar_t *, wchar_t);
    int wcscmp(const wchar_t *, const wchar_t *);
    int wcscoll(const wchar_t *, const wchar_t *);
    wchar_t *wcscpy(wchar_t *, const wchar_t *);
    size_t wcscspn(const wchar_t *, const wchar_t *);
    size_t wcsftime(wchar_t *, size_t, const wchar_t *, const struct tm *) asm("_wcsftime");
    size_t wcslen(const wchar_t *);
    wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t);
    int wcsncmp(const wchar_t *, const wchar_t *, size_t);
    wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
    wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
    wchar_t *wcsrchr(const wchar_t *, wchar_t);
    size_t wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
    size_t wcsspn(const wchar_t *, const wchar_t *);
    wchar_t *wcsstr(const wchar_t *, const wchar_t *);
    size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
    int wctob(wint_t);
    double wcstod(const wchar_t *, wchar_t **);
    wchar_t *wcstok(wchar_t *, const wchar_t *, wchar_t **);
    long wcstol(const wchar_t *, wchar_t **, int);
    unsigned long wcstoul(const wchar_t *, wchar_t **, int);
    wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
    int wmemcmp(const wchar_t *, const wchar_t *, size_t);
    wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t);
    wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
    wchar_t *wmemset(wchar_t *, wchar_t, size_t);
    int wprintf(const wchar_t *, ...);
    int wscanf(const wchar_t *, ...);
    int wcswidth(const wchar_t *, size_t);
    int wcwidth(wchar_t);
}
extern "C" {
    int vfwscanf(FILE *, const wchar_t *, __darwin_va_list);
    int vswscanf(const wchar_t *, const wchar_t *, __darwin_va_list);
    int vwscanf(const wchar_t *, __darwin_va_list);
    float wcstof(const wchar_t *, wchar_t **);
    long double wcstold(const wchar_t *, wchar_t **);
    long long wcstoll(const wchar_t *, wchar_t **, int);
    unsigned long long wcstoull(const wchar_t *, wchar_t **, int);
}
extern "C" {
    size_t mbsnrtowcs(wchar_t *, const char **, size_t, size_t, mbstate_t *);
    wchar_t *wcpcpy(wchar_t *, const wchar_t *) __attribute__((availability(macos, introduced=10.7)));
    wchar_t *wcpncpy(wchar_t *, const wchar_t *, size_t) __attribute__((availability(macos, introduced=10.7)));
    wchar_t *wcsdup(const wchar_t *) __attribute__((availability(macos, introduced=10.7)));
    int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((availability(macos, introduced=10.7)));
    int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((availability(macos, introduced=10.7)));
    size_t wcsnlen(const wchar_t *, size_t) __attribute__((availability(macos, introduced=10.7)));
    size_t wcsnrtombs(char *, const wchar_t **, size_t, size_t, mbstate_t *);
    FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep) __attribute__((availability(macos, introduced=10.13))) __attribute__((availability(ios, introduced=11.0))) __attribute__((availability(tvos, introduced=11.0))) __attribute__((availability(watchos, introduced=4.0)));
}
extern "C" {
    wchar_t *fgetwln(FILE *, size_t *) __attribute__((availability(macos, introduced=10.7)));
    size_t wcslcat(wchar_t *, const wchar_t *, size_t);
    size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
extern "C++" {
    inline wchar_t *__libcpp_wcschr(const wchar_t *__s, wchar_t __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (wchar_t *)wcschr(__s, __c);
    }
    inline const wchar_t *wcschr(const wchar_t *__s, wchar_t __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e4060858, "<no message provided>")))     {
        return __libcpp_wcschr(__s, __c);
    }
    inline wchar_t *wcschr(wchar_t *__s, wchar_t __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e4060cf8, "<no message provided>")))     {
        return __libcpp_wcschr(__s, __c);
    }
    inline wchar_t *__libcpp_wcspbrk(const wchar_t *__s1, const wchar_t *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (wchar_t *)wcspbrk(__s1, __s2);
    }
    inline const wchar_t *wcspbrk(const wchar_t *__s1, const wchar_t *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e40615d8, "<no message provided>")))     {
        return __libcpp_wcspbrk(__s1, __s2);
    }
    inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e4061a78, "<no message provided>")))     {
        return __libcpp_wcspbrk(__s1, __s2);
    }
    inline wchar_t *__libcpp_wcsrchr(const wchar_t *__s, wchar_t __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (wchar_t *)wcsrchr(__s, __c);
    }
    inline const wchar_t *wcsrchr(const wchar_t *__s, wchar_t __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e40622e8, "<no message provided>")))     {
        return __libcpp_wcsrchr(__s, __c);
    }
    inline wchar_t *wcsrchr(wchar_t *__s, wchar_t __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e4062780, "<no message provided>")))     {
        return __libcpp_wcsrchr(__s, __c);
    }
    inline wchar_t *__libcpp_wcsstr(const wchar_t *__s1, const wchar_t *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (wchar_t *)wcsstr(__s1, __s2);
    }
    inline const wchar_t *wcsstr(const wchar_t *__s1, const wchar_t *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e4062ff0, "<no message provided>")))     {
        return __libcpp_wcsstr(__s1, __s2);
    }
    inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e4063458, "<no message provided>")))     {
        return __libcpp_wcsstr(__s1, __s2);
    }
    inline wchar_t *__libcpp_wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (wchar_t *)wmemchr(__s, __c, __n);
    }
    inline const wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e4063de8, "<no message provided>")))     {
        return __libcpp_wmemchr(__s, __c, __n);
    }
    inline wchar_t *wmemchr(wchar_t *__s, wchar_t __c, size_t __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e4064390, "<no message provided>")))     {
        return __libcpp_wmemchr(__s, __c, __n);
    }
}
namespace std {
    inline namespace __1 {
        class __attribute__((visibility("default"))) ios_base;
        template <class _CharT> struct __attribute__((type_visibility("default"))) char_traits;
        template<> struct char_traits<char>;
        template<> struct char_traits<char16_t>;
        template<> struct char_traits<char32_t>;
        template<> struct char_traits<wchar_t>;
        template <class _Tp> class __attribute__((type_visibility("default"))) allocator
template<> class allocator<char> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef char *pointer;
            typedef const char *const_pointer;
            typedef char &reference;
            typedef const char &const_reference;
            typedef char value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage))             {
            }
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            template<> allocator<char>(const allocator<char> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<char>::pointer address(std::__1::allocator<char>::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<char>::const_pointer address(std::__1::allocator<char>::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<char>::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((internal_linkage))             {
                if (__n > this->max_size())
                    __throw_length_error("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
                return static_cast<std::__1::allocator<char>::pointer>(std::__1::__libcpp_allocate(__n * sizeof(char), __alignof(char)));
            }
            void deallocate(std::__1::allocator<char>::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(char), __alignof(char));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage))             {
                return std::__1::allocator::size_type(~0) / sizeof(char);
            }
            void construct(std::__1::allocator<char>::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<char>::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<char>::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<char>::pointer __p) __attribute__((internal_linkage));
        }
template<> class allocator<wchar_t> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef wchar_t *pointer;
            typedef const wchar_t *const_pointer;
            typedef wchar_t &reference;
            typedef const wchar_t &const_reference;
            typedef wchar_t value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage));
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<wchar_t>::pointer address(std::__1::allocator<wchar_t>::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<wchar_t>::const_pointer address(std::__1::allocator<wchar_t>::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<wchar_t>::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((internal_linkage));
            void deallocate(std::__1::allocator<wchar_t>::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(wchar_t), __alignof(wchar_t));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage));
            void construct(std::__1::allocator<wchar_t>::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<wchar_t>::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<wchar_t>::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<wchar_t>::pointer __p) __attribute__((internal_linkage));
        }
template<> class allocator<std::__1::basic_string<char>> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef std::__1::basic_string<char> *pointer;
            typedef const std::__1::basic_string<char> *const_pointer;
            typedef std::__1::basic_string<char> &reference;
            typedef const std::__1::basic_string<char> &const_reference;
            typedef std::__1::basic_string<char> value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage))             {
            }
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<std::__1::basic_string<char> >::pointer address(std::__1::allocator<std::__1::basic_string<char> >::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<std::__1::basic_string<char> >::const_pointer address(std::__1::allocator<std::__1::basic_string<char> >::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<std::__1::basic_string<char> >::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((internal_linkage))             {
                if (__n > this->max_size())
                    __throw_length_error("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
                return static_cast<std::__1::allocator<std::__1::basic_string<char> >::pointer>(std::__1::__libcpp_allocate(__n * sizeof(std::__1::basic_string<char>), __alignof(std::__1::basic_string<char>)));
            }
            void deallocate(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(std::__1::basic_string<char>), __alignof(std::__1::basic_string<char>));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage))             {
                return std::__1::allocator::size_type(~0) / sizeof(std::__1::basic_string<char>);
            }
            void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template<> void construct<const std::__1::basic_string<char>>(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const std::__1::basic_string<char> &__a0) __attribute__((internal_linkage));
            template<> void construct<std::__1::basic_string<char>>(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, std::__1::basic_string<char> &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template<> void construct<std::__1::basic_string<char>>(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const std::__1::basic_string<char> &__a0) __attribute__((internal_linkage))             {
                ::new ((void *)__p) std::__1::basic_string<char>(__a0);
            }
;
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<std::__1::basic_string<char> >::pointer __p) __attribute__((internal_linkage))             {
                __p->~basic_string<char>();
            }
        }
template<> class allocator<int> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef int *pointer;
            typedef const int *const_pointer;
            typedef int &reference;
            typedef const int &const_reference;
            typedef int value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage));
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<int>::pointer address(std::__1::allocator<int>::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<int>::const_pointer address(std::__1::allocator<int>::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<int>::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer) __attribute__((internal_linkage));
            void deallocate(std::__1::allocator<int>::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage));
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage));
            void construct(std::__1::allocator<int>::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<int>::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<int>::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<int>::pointer __p) __attribute__((internal_linkage));
        };
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ios;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_streambuf;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_istream;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ostream;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_iostream;
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_stringbuf;
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_istringstream;
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_ostringstream;
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_stringstream;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_filebuf;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ifstream;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ofstream;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_fstream;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) istreambuf_iterator;
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) ostreambuf_iterator
template<> class ostreambuf_iterator<char, std::__1::char_traits<char>> : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::__1::char_traits<char> > streambuf_type;
            typedef basic_ostream<char, std::__1::char_traits<char> > ostream_type;
        private:
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >::streambuf_type *__sbuf_;
        public:
            ostreambuf_iterator(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >::ostream_type &__s) throw() : iterator<std::__1::output_iterator_tag, void, void, void, void>(), __sbuf_(__s.rdbuf()) __attribute__((internal_linkage))             {
            }
            ostreambuf_iterator(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >::streambuf_type *__s) throw() __attribute__((internal_linkage));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator=(char __c) __attribute__((internal_linkage));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator*() __attribute__((internal_linkage));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator++() __attribute__((internal_linkage));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator++(int) __attribute__((internal_linkage));
            bool failed() const throw() __attribute__((internal_linkage))             {
                return this->__sbuf_ == 0;
            }
            friend template <class _Ch, class _Tr> ostreambuf_iterator<_Ch, _Tr> __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s, const _Ch *__ob, const _Ch *__op, const _Ch *__oe, std::__1::ios_base &__iob, _Ch __fl);
        };
        typedef basic_ios<char> ios;
        typedef basic_ios<wchar_t> wios;
        typedef basic_streambuf<char> streambuf;
        typedef basic_istream<char> istream;
        typedef basic_ostream<char> ostream;
        typedef basic_iostream<char> iostream;
        typedef basic_stringbuf<char> stringbuf;
        typedef basic_istringstream<char> istringstream;
        typedef basic_ostringstream<char> ostringstream;
        typedef basic_stringstream<char> stringstream;
        typedef basic_filebuf<char> filebuf;
        typedef basic_ifstream<char> ifstream;
        typedef basic_ofstream<char> ofstream;
        typedef basic_fstream<char> fstream;
        typedef basic_streambuf<wchar_t> wstreambuf;
        typedef basic_istream<wchar_t> wistream;
        typedef basic_ostream<wchar_t> wostream;
        typedef basic_iostream<wchar_t> wiostream;
        typedef basic_stringbuf<wchar_t> wstringbuf;
        typedef basic_istringstream<wchar_t> wistringstream;
        typedef basic_ostringstream<wchar_t> wostringstream;
        typedef basic_stringstream<wchar_t> wstringstream;
        typedef basic_filebuf<wchar_t> wfilebuf;
        typedef basic_ifstream<wchar_t> wifstream;
        typedef basic_ofstream<wchar_t> wofstream;
        typedef basic_fstream<wchar_t> wfstream;
        template <class _State> class __attribute__((type_visibility("default"))) fpos;
        typedef fpos<mbstate_t> streampos;
        typedef fpos<mbstate_t> wstreampos;
        typedef fpos<mbstate_t> u16streampos;
        typedef fpos<mbstate_t> u32streampos;
        typedef long long streamoff;
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_string;
        typedef basic_string<char, char_traits<char>, allocator<char> > string;
        typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;
        template <class _Tp, class _Alloc = allocator<_Tp>> class __attribute__((type_visibility("default"))) vector
template<> class vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> >> : private __vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > {
        private:
            typedef __vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > __base;
            typedef allocator<std::__1::basic_string<char> > __default_allocator_type;
        public:
            typedef std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > __self;
            typedef std::__1::basic_string<char> value_type;
            typedef std::__1::allocator<std::__1::basic_string<char> > allocator_type;
            typedef typename __base::__alloc_traits __alloc_traits;
            typedef typename __base::reference reference;
            typedef typename __base::const_reference const_reference;
            typedef typename __base::size_type size_type;
            typedef typename __base::difference_type difference_type;
            typedef typename __base::pointer pointer;
            typedef typename __base::const_pointer const_pointer;
            typedef __wrap_iter<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer> iterator;
            typedef __wrap_iter<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            vector() : __vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >() __attribute__((internal_linkage))             {
            }
            explicit vector(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a) __attribute__((internal_linkage));
            explicit vector(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            vector(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type &__x);
            vector(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type &__x, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a);
            template <class _InputIterator> vector(_InputIterator __first, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, _InputIterator>::type __last);
            template <class _InputIterator> vector(_InputIterator __first, _InputIterator __last, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value>::type *);
            template <class _ForwardIterator> vector(_ForwardIterator __first, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, _ForwardIterator>::type __last);
            template <class _ForwardIterator> vector(_ForwardIterator __first, _ForwardIterator __last, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value>::type *);
            ~vector<basic_string<char>, allocator<basic_string<char> > >() __attribute__((internal_linkage))             {
                this->__annotate_delete();
            }
            vector(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__x);
            vector(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__x, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &operator=(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__x) __attribute__((internal_linkage));
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, void>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, void>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            void assign(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __u);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type get_allocator() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator begin() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator vector<basic_string<char>, allocator<basic_string<char> > >::begin() const throw() __attribute__((internal_linkage))             {
                return this->__make_iter(this->__begin_);
            }
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator end() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator vector<basic_string<char>, allocator<basic_string<char> > >::end() const throw() __attribute__((internal_linkage))             {
                return this->__make_iter(this->__end_);
            }
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reverse_iterator rbegin() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reverse_iterator rbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reverse_iterator rend() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reverse_iterator rend() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator cbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator cend() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reverse_iterator crbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reverse_iterator crend() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type size() const throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type>(this->__end_ - this->__begin_);
            }
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type capacity() const throw() __attribute__((internal_linkage))             {
                return this->__base::capacity();
            }
            bool empty() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type vector<basic_string<char>, allocator<basic_string<char> > >::max_size() const throw()             {
                return std::__1::min<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<difference_type>::max());
            }
            void reserve(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void shrink_to_fit() throw();
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reference operator[](std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference operator[](std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reference at(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference at(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) const;
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reference front() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference front() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reference back() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference back() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type *data() throw() __attribute__((internal_linkage));
            const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type *data() const throw() __attribute__((internal_linkage))             {
                return std::__1::__to_address(this->__begin_);
            }
            void __emplace_back(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type &__x) __attribute__((internal_linkage));
            void vector<basic_string<char>, allocator<basic_string<char> > >::push_back(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x) __attribute__((internal_linkage))             {
                if (this->__end_ != this->__end_cap()) {
                    this->__construct_one_at_end(__x);
                } else
                    this->__push_back_slow_path(__x);
            }
            void pop_back();
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator insert(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator insert(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, iterator>::type insert(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, iterator>::type insert(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator erase(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position) __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator erase(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __first, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __last);
            void clear() throw() __attribute__((internal_linkage));
            void resize(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __sz);
            void resize(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __sz, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            void swap(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &);
            bool __invariants() const;
        private:
            void vector<basic_string<char>, allocator<basic_string<char> > >::__invalidate_all_iterators() __attribute__((internal_linkage))             {
            }
            void __invalidate_iterators_past(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __new_last) __attribute__((internal_linkage));
            void __vallocate(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void __vdeallocate() throw();
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type vector<basic_string<char>, allocator<basic_string<char> > >::__recommend(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __new_size) const __attribute__((internal_linkage))             {
                const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __ms = this->max_size();
                if (__new_size > __ms)
                    this->__throw_length_error();
                const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __cap = this->capacity();
                if (__cap >= __ms / 2)
                    return __ms;
                return std::__1::max<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type>(2 * __cap, __new_size);
            }
            void __construct_at_end(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void __construct_at_end(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void __append(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void __append(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator __make_iter(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __p) throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator vector<basic_string<char>, allocator<basic_string<char> > >::__make_iter(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_pointer __p) const throw() __attribute__((internal_linkage))             {
                return std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator(__p);
            }
            void vector<basic_string<char>, allocator<basic_string<char> > >::__swap_out_circular_buffer(__split_buffer<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &> &__v)             {
                this->__annotate_delete();
                __alloc_traits::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
                std::__1::swap(this->__begin_, __v.__begin_);
                std::__1::swap(this->__end_, __v.__end_);
                std::__1::swap(this->__end_cap(), __v.__end_cap());
                __v.__first_ = __v.__begin_;
                this->__annotate_new(this->size());
                this->__invalidate_all_iterators();
            }
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __swap_out_circular_buffer(__split_buffer<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &> &__v, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __p);
            void __move_range(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __from_s, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __from_e, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __to);
            void __move_assign(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__c, std::__1::true_type);
            void __move_assign(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__c, std::__1::false_type);
            void __destruct_at_end(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __new_last) throw() __attribute__((internal_linkage));
            template <class _Up> inline void __push_back_slow_path(_Up &__x);
            template<> inline void vector<basic_string<char>, allocator<basic_string<char> > >::__push_back_slow_path<const std::__1::basic_string<char>>(const std::__1::basic_string<char> &__x)             {
                std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a = this->__alloc();
                __split_buffer<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &> __v(this->__recommend(this->size() + 1), this->size(), __a);
                __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_), std::__1::forward<const std::__1::basic_string<char> >(__x));
                __v.__end_++;
                this->__swap_out_circular_buffer(__v);
            }
;
            void __annotate_contiguous_container(const void *, const void *, const void *, const void *) const throw() __attribute__((internal_linkage))             {
            }
            void __annotate_new(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __current_size) const throw() __attribute__((internal_linkage))             {
                this->__annotate_contiguous_container(this->data(), this->data() + this->capacity(), this->data() + this->capacity(), this->data() + __current_size);
            }
            void __annotate_delete() const throw() __attribute__((internal_linkage))             {
                this->__annotate_contiguous_container(this->data(), this->data() + this->capacity(), this->data() + this->size(), this->data() + this->capacity());
            }
            void __annotate_increase(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) const throw() __attribute__((internal_linkage));
            void __annotate_shrink(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __old_size) const throw() __attribute__((internal_linkage));
            struct _ConstructTransaction {
                std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__v_;
                std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __pos_;
                const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_pointer __new_end_;
            private:
            };
            template <class ..._Args> void __construct_one_at_end(_Args &&...__args) __attribute__((internal_linkage));
            template<> void __construct_one_at_end<<const std::__1::basic_string<char> &>>(const std::__1::basic_string<char> &__args) __attribute__((internal_linkage))             {
                std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::_ConstructTransaction __tx(*this, 1);
                __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_), std::__1::forward<const std::__1::basic_string<char> &>(__args));
                ++__tx.__pos_;
            }
;
        }
template<> class vector<int, std::__1::allocator<int>> : private __vector_base<int, std::__1::allocator<int> > {
        private:
            typedef __vector_base<int, std::__1::allocator<int> > __base;
            typedef allocator<int> __default_allocator_type;
        public:
            typedef std::__1::vector<int, std::__1::allocator<int> > __self;
            typedef int value_type;
            typedef std::__1::allocator<int> allocator_type;
            typedef typename __base::__alloc_traits __alloc_traits;
            typedef typename __base::reference reference;
            typedef typename __base::const_reference const_reference;
            typedef typename __base::size_type size_type;
            typedef typename __base::difference_type difference_type;
            typedef typename __base::pointer pointer;
            typedef typename __base::const_pointer const_pointer;
            typedef __wrap_iter<std::__1::vector<int, std::__1::allocator<int> >::pointer> iterator;
            typedef __wrap_iter<std::__1::vector<int, std::__1::allocator<int> >::const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            vector() __attribute__((internal_linkage));
            explicit vector(const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a) __attribute__((internal_linkage));
            explicit vector(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            vector(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, const std::__1::vector<int, std::__1::allocator<int> >::value_type &__x);
            vector(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, const std::__1::vector<int, std::__1::allocator<int> >::value_type &__x, const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a);
            template <class _InputIterator> vector(_InputIterator __first, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, _InputIterator>::type __last);
            template <class _InputIterator> vector(_InputIterator __first, _InputIterator __last, const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value>::type *);
            template <class _ForwardIterator> vector(_ForwardIterator __first, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, _ForwardIterator>::type __last);
            template <class _ForwardIterator> vector(_ForwardIterator __first, _ForwardIterator __last, const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value>::type *);
            ~vector<int, allocator<int> >() __attribute__((internal_linkage));
            vector(const std::__1::vector<int, std::__1::allocator<int> > &__x);
            vector(const std::__1::vector<int, std::__1::allocator<int> > &__x, const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a);
            std::__1::vector<int, std::__1::allocator<int> > &operator=(const std::__1::vector<int, std::__1::allocator<int> > &__x) __attribute__((internal_linkage));
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, void>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, void>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            void assign(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, std::__1::vector<int, std::__1::allocator<int> >::const_reference __u);
            std::__1::vector<int, std::__1::allocator<int> >::allocator_type get_allocator() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::iterator begin() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator begin() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::iterator end() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator end() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::reverse_iterator rbegin() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reverse_iterator rbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::reverse_iterator rend() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reverse_iterator rend() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator cbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator cend() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reverse_iterator crbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reverse_iterator crend() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::size_type size() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::size_type capacity() const throw() __attribute__((internal_linkage));
            bool empty() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::size_type max_size() const throw();
            void reserve(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void shrink_to_fit() throw();
            std::__1::vector<int, std::__1::allocator<int> >::reference operator[](std::__1::vector<int, std::__1::allocator<int> >::size_type __n) throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reference operator[](std::__1::vector<int, std::__1::allocator<int> >::size_type __n) const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::reference at(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            std::__1::vector<int, std::__1::allocator<int> >::const_reference at(std::__1::vector<int, std::__1::allocator<int> >::size_type __n) const;
            std::__1::vector<int, std::__1::allocator<int> >::reference front() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reference front() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::reference back() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reference back() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::value_type *data() throw() __attribute__((internal_linkage));
            const std::__1::vector<int, std::__1::allocator<int> >::value_type *data() const throw() __attribute__((internal_linkage));
            void __emplace_back(const std::__1::vector<int, std::__1::allocator<int> >::value_type &__x) __attribute__((internal_linkage));
            void push_back(std::__1::vector<int, std::__1::allocator<int> >::const_reference __x) __attribute__((internal_linkage));
            void pop_back();
            std::__1::vector<int, std::__1::allocator<int> >::iterator insert(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            std::__1::vector<int, std::__1::allocator<int> >::iterator insert(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position, std::__1::vector<int, std::__1::allocator<int> >::size_type __n, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, iterator>::type insert(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, iterator>::type insert(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
            std::__1::vector<int, std::__1::allocator<int> >::iterator erase(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position) __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::iterator erase(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __first, std::__1::vector<int, std::__1::allocator<int> >::const_iterator __last);
            void clear() throw() __attribute__((internal_linkage));
            void resize(std::__1::vector<int, std::__1::allocator<int> >::size_type __sz);
            void resize(std::__1::vector<int, std::__1::allocator<int> >::size_type __sz, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            void swap(std::__1::vector<int, std::__1::allocator<int> > &);
            bool __invariants() const;
        private:
            void __invalidate_all_iterators() __attribute__((internal_linkage));
            void __invalidate_iterators_past(std::__1::vector<int, std::__1::allocator<int> >::pointer __new_last) __attribute__((internal_linkage));
            void __vallocate(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void __vdeallocate() throw();
            std::__1::vector<int, std::__1::allocator<int> >::size_type __recommend(std::__1::vector<int, std::__1::allocator<int> >::size_type __new_size) const __attribute__((internal_linkage));
            void __construct_at_end(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void __construct_at_end(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void __append(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void __append(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            std::__1::vector<int, std::__1::allocator<int> >::iterator __make_iter(std::__1::vector<int, std::__1::allocator<int> >::pointer __p) throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator __make_iter(std::__1::vector<int, std::__1::allocator<int> >::const_pointer __p) const throw() __attribute__((internal_linkage));
            void __swap_out_circular_buffer(__split_buffer<std::__1::vector<int, std::__1::allocator<int> >::value_type, std::__1::vector<int, std::__1::allocator<int> >::allocator_type &> &__v);
            std::__1::vector<int, std::__1::allocator<int> >::pointer __swap_out_circular_buffer(__split_buffer<std::__1::vector<int, std::__1::allocator<int> >::value_type, std::__1::vector<int, std::__1::allocator<int> >::allocator_type &> &__v, std::__1::vector<int, std::__1::allocator<int> >::pointer __p);
            void __move_range(std::__1::vector<int, std::__1::allocator<int> >::pointer __from_s, std::__1::vector<int, std::__1::allocator<int> >::pointer __from_e, std::__1::vector<int, std::__1::allocator<int> >::pointer __to);
            void __move_assign(std::__1::vector<int, std::__1::allocator<int> > &__c, std::__1::true_type);
            void __move_assign(std::__1::vector<int, std::__1::allocator<int> > &__c, std::__1::false_type);
            void __destruct_at_end(std::__1::vector<int, std::__1::allocator<int> >::pointer __new_last) throw() __attribute__((internal_linkage));
            template <class _Up> inline void __push_back_slow_path(_Up &__x);
            void __annotate_contiguous_container(const void *, const void *, const void *, const void *) const throw() __attribute__((internal_linkage));
            void __annotate_new(std::__1::vector<int, std::__1::allocator<int> >::size_type __current_size) const throw() __attribute__((internal_linkage));
            void __annotate_delete() const throw() __attribute__((internal_linkage));
            void __annotate_increase(std::__1::vector<int, std::__1::allocator<int> >::size_type __n) const throw() __attribute__((internal_linkage));
            void __annotate_shrink(std::__1::vector<int, std::__1::allocator<int> >::size_type __old_size) const throw() __attribute__((internal_linkage));
            struct _ConstructTransaction;
            template <class ..._Args> void __construct_one_at_end(_Args &&...__args) __attribute__((internal_linkage));
        };
    }
}
namespace std {
    inline namespace __1 {
        struct __attribute__((type_visibility("default"))) __libcpp_debug_info {
            __libcpp_debug_info() : __file_(std::__1::__get_nullptr_t()), __line_(-1), __pred_(std::__1::__get_nullptr_t()), __msg_(std::__1::__get_nullptr_t()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __libcpp_debug_info(const char *__f, int __l, const char *__p, const char *__m) : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::string what() const __attribute__((visibility("default")));
            const char *__file_;
            int __line_;
            const char *__pred_;
            const char *__msg_;
        };
        typedef void (*__libcpp_debug_function_type)(const std::__1::__libcpp_debug_info &);
        extern std::__1::__libcpp_debug_function_type __libcpp_debug_function __attribute__((visibility("default")));
        void __libcpp_abort_debug_function(const std::__1::__libcpp_debug_info &) __attribute__((visibility("default")));
        bool __libcpp_set_debug_function(std::__1::__libcpp_debug_function_type __func) __attribute__((visibility("default")));
    }
}
namespace std {
    inline namespace __1 {
        namespace rel_ops {
            template <class _Tp> inline bool operator!=(const _Tp &__x, const _Tp &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x == __y);
            }
            template <class _Tp> inline bool operator>(const _Tp &__x, const _Tp &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __y < __x;
            }
            template <class _Tp> inline bool operator<=(const _Tp &__x, const _Tp &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__y < __x);
            }
            template <class _Tp> inline bool operator>=(const _Tp &__x, const _Tp &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x < __y);
            }
        }
        template <class _Tp> inline const _Tp &move_if_noexcept(_Tp &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::move(__x);
        }
        template<> inline const std::__1::basic_string<char> &move_if_noexcept<std::__1::basic_string<char>>(std::__1::basic_string<char> &__x) throw() __attribute__((internal_linkage))         {
            return std::__1::move(__x);
        }
        struct __attribute__((type_visibility("default"))) piecewise_construct_t {
            explicit piecewise_construct_t() = default
        };
        extern const std::__1::piecewise_construct_t piecewise_construct __attribute__((visibility("default")));
        template <class _T1, class _T2> struct __attribute__((type_visibility("default"))) pair {
            typedef _T1 first_type;
            typedef _T2 second_type;
            _T1 first;
            _T2 second;
            pair<_T1, _T2>() : first(), second() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            pair<_T1, _T2>(const _T1 &__t1, const _T2 &__t2) : first(__t1), second(__t2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _U1, class _U2> pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            pair<_T1, _T2> &operator=(const pair<_T1, _T2> &__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->first = __p.first;
                this->second = __p.second;
                return *this;
            }
            void swap(pair<_T1, _T2> &__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                using std::__1::swap;
                swap(this->first, __p.first);
                swap(this->second, __p.second);
            }
        private:
        };
template<> struct pair<unsigned long, unsigned long> {
            typedef unsigned long first_type;
            typedef unsigned long second_type;
            unsigned long first;
            unsigned long second;
            pair() __attribute__((internal_linkage));
            pair(const unsigned long &__t1, const unsigned long &__t2) : first(__t1), second(__t2) __attribute__((internal_linkage))             {
            }
            template <class _U1, class _U2> pair(const pair<_U1, _U2> &__p) __attribute__((internal_linkage));
            template<> pair<unsigned long, unsigned long>(const pair<unsigned long, unsigned long> &__p) __attribute__((internal_linkage));
            std::__1::pair<unsigned long, unsigned long> &operator=(const std::__1::pair<unsigned long, unsigned long> &__p) __attribute__((internal_linkage))             {
                this->first = __p.first;
                this->second = __p.second;
                return *this;
            }
            void swap(std::__1::pair<unsigned long, unsigned long> &__p) __attribute__((internal_linkage));
        private:
        };
        template <class _T1, class _T2> inline bool operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.first == __y.first && __x.second == __y.second;
        }
        template <class _T1, class _T2> inline bool operator!=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _T1, class _T2> inline bool operator<(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
        }
        template <class _T1, class _T2> inline bool operator>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _T1, class _T2> inline bool operator>=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _T1, class _T2> inline bool operator<=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _T1, class _T2> inline typename enable_if<__is_swappable<_T1>::value && __is_swappable<_T2>::value, void>::type swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _Tp> struct __unwrap_reference {
            typedef _Tp type;
        };
        template <class _Tp> struct __unwrap_reference<reference_wrapper<_Tp>> {
            typedef _Tp &type;
        };
        template <class _Tp> struct __unwrap_ref_decay : __unwrap_reference<typename decay<_Tp>::type> {
        };
        template <class _T1, class _T2> inline pair<_T1, _T2> make_pair(_T1 __x, _T2 __y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return pair<_T1, _T2>(__x, __y);
        }
        template <class _T1, class _T2> struct __attribute__((type_visibility("default"))) tuple_size<pair<_T1, _T2>> : public integral_constant<size_t, 2> {
        };
        template <size_t _Ip, class _T1, class _T2> struct __attribute__((type_visibility("default"))) tuple_element<_Ip, pair<_T1, _T2>> {
            static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
        };
        template <class _T1, class _T2> struct __attribute__((type_visibility("default"))) tuple_element<0, pair<_T1, _T2>> {
            typedef _T1 type;
        };
        template <class _T1, class _T2> struct __attribute__((type_visibility("default"))) tuple_element<1, pair<_T1, _T2>> {
            typedef _T2 type;
        };
        template <size_t _Ip> struct __get_pair;
        template<> struct __get_pair<0> {
            template <class _T1, class _T2> static _T1 &get(pair<_T1, _T2> &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __p.first;
            }
            template <class _T1, class _T2> static const _T1 &get(const pair<_T1, _T2> &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __p.first;
            }
        };
        template<> struct __get_pair<1> {
            template <class _T1, class _T2> static _T2 &get(pair<_T1, _T2> &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __p.second;
            }
            template <class _T1, class _T2> static const _T2 &get(const pair<_T1, _T2> &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __p.second;
            }
        };
        template <size_t _Ip, class _T1, class _T2> inline typename tuple_element<_Ip, pair<_T1, _T2> >::type &get(pair<_T1, _T2> &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __get_pair<_Ip>::get(__p);
        }
        template <size_t _Ip, class _T1, class _T2> inline const typename tuple_element<_Ip, pair<_T1, _T2> >::type &get(const pair<_T1, _T2> &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __get_pair<_Ip>::get(__p);
        }
        template <class _Arg, class _Result> struct __attribute__((type_visibility("default"))) unary_function {
            typedef _Arg argument_type;
            typedef _Result result_type;
        };
template<> struct unary_function<std::__1::_PairT, unsigned long> {
            typedef std::__1::_PairT argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<bool, unsigned long> {
            typedef bool argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<char, unsigned long> {
            typedef char argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<signed char, unsigned long> {
            typedef signed char argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<unsigned char, unsigned long> {
            typedef unsigned char argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<char16_t, unsigned long> {
            typedef char16_t argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<char32_t, unsigned long> {
            typedef char32_t argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<wchar_t, unsigned long> {
            typedef wchar_t argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<short, unsigned long> {
            typedef short argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<unsigned short, unsigned long> {
            typedef unsigned short argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<int, unsigned long> {
            typedef int argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<unsigned int, unsigned long> {
            typedef unsigned int argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<long, unsigned long> {
            typedef long argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<unsigned long, unsigned long> {
            typedef unsigned long argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<long long, unsigned long> {
            typedef long long argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<unsigned long long, unsigned long> {
            typedef unsigned long long argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<__int128, unsigned long> {
            typedef __int128 argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<unsigned __int128, unsigned long> {
            typedef unsigned __int128 argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<float, unsigned long> {
            typedef float argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<double, unsigned long> {
            typedef double argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<long double, unsigned long> {
            typedef long double argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<std::__1::error_code, unsigned long> {
            typedef std::__1::error_code argument_type;
            typedef unsigned long result_type;
        };
template<> struct unary_function<std::__1::error_condition, unsigned long> {
            typedef std::__1::error_condition argument_type;
            typedef unsigned long result_type;
        };
        template <class _Size> inline _Size __loadword(const void *__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            _Size __r;
            std::memcpy(&__r, __p, sizeof (__r));
            return __r;
        }
        template<> inline unsigned int __loadword<unsigned int>(const void *__p) __attribute__((internal_linkage))         {
            unsigned int __r;
            std::memcpy(&__r, __p, sizeof (__r));
            return __r;
        }
        template<> inline unsigned long __loadword<unsigned long>(const void *__p) __attribute__((internal_linkage))         {
            unsigned long __r;
            std::memcpy(&__r, __p, sizeof (__r));
            return __r;
        }
        template <class _Size, size_t = sizeof(_Size) * 8> struct __murmur2_or_cityhash
template<> struct __murmur2_or_cityhash<unsigned long, 64> {
            inline unsigned long __murmur2_or_cityhash<unsigned long, 64>::operator()(const void *__key, unsigned long __len)             {
                const char *__s = static_cast<const char *>(__key);
                if (__len <= 32) {
                    if (__len <= 16) {
                        return __hash_len_0_to_16(__s, __len);
                    } else {
                        return __hash_len_17_to_32(__s, __len);
                    }
                } else if (__len <= 64) {
                    return __hash_len_33_to_64(__s, __len);
                }
                unsigned long __x = __loadword<unsigned long>(__s + __len - 40);
                unsigned long __y = __loadword<unsigned long>(__s + __len - 16) + __loadword<unsigned long>(__s + __len - 56);
                unsigned long __z = __hash_len_16(__loadword<unsigned long>(__s + __len - 48) + __len, __loadword<unsigned long>(__s + __len - 24));
                pair<unsigned long, unsigned long> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
                pair<unsigned long, unsigned long> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
                __x = __x * __k1 + __loadword<unsigned long>(__s);
                __len = (__len - 1) & ~static_cast<unsigned long>(63);
                do {
                    __x = __rotate(__x + __y + __v.first + __loadword<unsigned long>(__s + 8), 37) * __k1;
                    __y = __rotate(__y + __v.second + __loadword<unsigned long>(__s + 48), 42) * __k1;
                    __x ^= __w.second;
                    __y += __v.first + __loadword<unsigned long>(__s + 40);
                    __z = __rotate(__z + __w.first, 33) * __k1;
                    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
                    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second, __y + __loadword<unsigned long>(__s + 16));
                    std::swap(__z, __x);
                    __s += 64;
                    __len -= 64;
                } while (__len != 0);
                return __hash_len_16(__hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z, __hash_len_16(__v.second, __w.second) + __x);
            }
        private:
            static const unsigned long __k0 = 14097894508562428199ULL;
            static const unsigned long __k1 = 13011662864482103923ULL;
            static const unsigned long __k2 = 11160318154034397263ULL;
            static const unsigned long __k3 = 14504361325974414679ULL;
            static unsigned long __rotate(unsigned long __val, int __shift)             {
                return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
            }
            static unsigned long __rotate_by_at_least_1(unsigned long __val, int __shift)             {
                return (__val >> __shift) | (__val << (64 - __shift));
            }
            static unsigned long __shift_mix(unsigned long __val)             {
                return __val ^ (__val >> 47);
            }
            static unsigned long __hash_len_16(unsigned long __u, unsigned long __v) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                const unsigned long __mul = 11376068507788127593ULL;
                unsigned long __a = (__u ^ __v) * __mul;
                __a ^= (__a >> 47);
                unsigned long __b = (__v ^ __a) * __mul;
                __b ^= (__b >> 47);
                __b *= __mul;
                return __b;
            }
            static unsigned long __hash_len_0_to_16(const char *__s, unsigned long __len) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                if (__len > 8) {
                    const unsigned long __a = __loadword<unsigned long>(__s);
                    const unsigned long __b = __loadword<unsigned long>(__s + __len - 8);
                    return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
                }
                if (__len >= 4) {
                    const uint32_t __a = __loadword<uint32_t>(__s);
                    const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
                    return __hash_len_16(__len + (__a << 3), __b);
                }
                if (__len > 0) {
                    const unsigned char __a = __s[0];
                    const unsigned char __b = __s[__len >> 1];
                    const unsigned char __c = __s[__len - 1];
                    const uint32_t __y = static_cast<uint32_t>(__a) + (static_cast<uint32_t>(__b) << 8);
                    const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
                    return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
                }
                return __k2;
            }
            static unsigned long __hash_len_17_to_32(const char *__s, unsigned long __len) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                const unsigned long __a = __loadword<unsigned long>(__s) * __k1;
                const unsigned long __b = __loadword<unsigned long>(__s + 8);
                const unsigned long __c = __loadword<unsigned long>(__s + __len - 8) * __k2;
                const unsigned long __d = __loadword<unsigned long>(__s + __len - 16) * __k0;
                return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d, __a + __rotate(__b ^ __k3, 20) - __c + __len);
            }
            static pair<unsigned long, unsigned long> __weak_hash_len_32_with_seeds(unsigned long __w, unsigned long __x, unsigned long __y, unsigned long __z, unsigned long __a, unsigned long __b) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                __a += __w;
                __b = __rotate(__b + __a + __z, 21);
                const unsigned long __c = __a;
                __a += __x;
                __a += __y;
                __b += __rotate(__a, 44);
                return pair<unsigned long, unsigned long>(__a + __z, __b + __c);
            }
            static pair<unsigned long, unsigned long> __weak_hash_len_32_with_seeds(const char *__s, unsigned long __a, unsigned long __b) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                return __weak_hash_len_32_with_seeds(__loadword<unsigned long>(__s), __loadword<unsigned long>(__s + 8), __loadword<unsigned long>(__s + 16), __loadword<unsigned long>(__s + 24), __a, __b);
            }
            static unsigned long __hash_len_33_to_64(const char *__s, size_t __len) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                unsigned long __z = __loadword<unsigned long>(__s + 24);
                unsigned long __a = __loadword<unsigned long>(__s) + (__len + __loadword<unsigned long>(__s + __len - 16)) * __k0;
                unsigned long __b = __rotate(__a + __z, 52);
                unsigned long __c = __rotate(__a, 37);
                __a += __loadword<unsigned long>(__s + 8);
                __c += __rotate(__a, 7);
                __a += __loadword<unsigned long>(__s + 16);
                unsigned long __vf = __a + __z;
                unsigned long __vs = __b + __rotate(__a, 31) + __c;
                __a = __loadword<unsigned long>(__s + 16) + __loadword<unsigned long>(__s + __len - 32);
                __z += __loadword<unsigned long>(__s + __len - 8);
                __b = __rotate(__a + __z, 52);
                __c = __rotate(__a, 37);
                __a += __loadword<unsigned long>(__s + __len - 24);
                __c += __rotate(__a, 7);
                __a += __loadword<unsigned long>(__s + __len - 16);
                unsigned long __wf = __a + __z;
                unsigned long __ws = __b + __rotate(__a, 31) + __c;
                unsigned long __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
                return __shift_mix(__r * __k0 + __vs) * __k2;
            }
        };
        template <class _Size> struct __murmur2_or_cityhash<_Size, 32> {
            inline _Size operator()(const void *__key, _Size __len) __attribute__((no_sanitize("unsigned-integer-overflow")));
        };
        template <class _Size> _Size __murmur2_or_cityhash<_Size, 32>::operator()(const void *__key, _Size __len)         {
            const _Size __m = 1540483477;
            const _Size __r = 24;
            _Size __h = __len;
            const unsigned char *__data = static_cast<const unsigned char *>(__key);
            for (; __len >= 4; __data += 4 , __len -= 4) {
                _Size __k = __loadword<_Size>(__data);
                __k *= __m;
                __k ^= __k >> __r;
                __k *= __m;
                __h *= __m;
                __h ^= __k;
            }
            switch (__len) {
              case 3:
                __h ^= __data[2] << 16;
 __attribute__((fallthrough))                ;
              case 2:
                __h ^= __data[1] << 8;
 __attribute__((fallthrough))                ;
              case 1:
                __h ^= __data[0];
                __h *= __m;
            }
            __h ^= __h >> 13;
            __h *= __m;
            __h ^= __h >> 15;
            return __h;
        }
        template <class _Size> struct __murmur2_or_cityhash<_Size, 64> {
            inline _Size operator()(const void *__key, _Size __len) __attribute__((no_sanitize("unsigned-integer-overflow")));
        private:
            static const _Size __k0 = 14097894508562428199ULL;
            static const _Size __k1 = 13011662864482103923ULL;
            static const _Size __k2 = 11160318154034397263ULL;
            static const _Size __k3 = 14504361325974414679ULL;
            static _Size __rotate(_Size __val, int __shift)             {
                return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
            }
            static _Size __rotate_by_at_least_1(_Size __val, int __shift)             {
                return (__val >> __shift) | (__val << (64 - __shift));
            }
            static _Size __shift_mix(_Size __val)             {
                return __val ^ (__val >> 47);
            }
            static _Size __hash_len_16(_Size __u, _Size __v) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                const _Size __mul = 11376068507788127593ULL;
                _Size __a = (__u ^ __v) * __mul;
                __a ^= (__a >> 47);
                _Size __b = (__v ^ __a) * __mul;
                __b ^= (__b >> 47);
                __b *= __mul;
                return __b;
            }
            static _Size __hash_len_0_to_16(const char *__s, _Size __len) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                if (__len > 8) {
                    const _Size __a = __loadword<_Size>(__s);
                    const _Size __b = __loadword<_Size>(__s + __len - 8);
                    return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
                }
                if (__len >= 4) {
                    const uint32_t __a = __loadword<uint32_t>(__s);
                    const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
                    return __hash_len_16(__len + (__a << 3), __b);
                }
                if (__len > 0) {
                    const unsigned char __a = __s[0];
                    const unsigned char __b = __s[__len >> 1];
                    const unsigned char __c = __s[__len - 1];
                    const uint32_t __y = static_cast<uint32_t>(__a) + (static_cast<uint32_t>(__b) << 8);
                    const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
                    return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
                }
                return __k2;
            }
            static _Size __hash_len_17_to_32(const char *__s, _Size __len) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                const _Size __a = __loadword<_Size>(__s) * __k1;
                const _Size __b = __loadword<_Size>(__s + 8);
                const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
                const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
                return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d, __a + __rotate(__b ^ __k3, 20) - __c + __len);
            }
            static pair<_Size, _Size> __weak_hash_len_32_with_seeds(_Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                __a += __w;
                __b = __rotate(__b + __a + __z, 21);
                const _Size __c = __a;
                __a += __x;
                __a += __y;
                __b += __rotate(__a, 44);
                return pair<_Size, _Size>(__a + __z, __b + __c);
            }
            static pair<_Size, _Size> __weak_hash_len_32_with_seeds(const char *__s, _Size __a, _Size __b) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s), __loadword<_Size>(__s + 8), __loadword<_Size>(__s + 16), __loadword<_Size>(__s + 24), __a, __b);
            }
            static _Size __hash_len_33_to_64(const char *__s, size_t __len) __attribute__((no_sanitize("unsigned-integer-overflow")))             {
                _Size __z = __loadword<_Size>(__s + 24);
                _Size __a = __loadword<_Size>(__s) + (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
                _Size __b = __rotate(__a + __z, 52);
                _Size __c = __rotate(__a, 37);
                __a += __loadword<_Size>(__s + 8);
                __c += __rotate(__a, 7);
                __a += __loadword<_Size>(__s + 16);
                _Size __vf = __a + __z;
                _Size __vs = __b + __rotate(__a, 31) + __c;
                __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
                __z += __loadword<_Size>(__s + __len - 8);
                __b = __rotate(__a + __z, 52);
                __c = __rotate(__a, 37);
                __a += __loadword<_Size>(__s + __len - 24);
                __c += __rotate(__a, 7);
                __a += __loadword<_Size>(__s + __len - 16);
                _Size __wf = __a + __z;
                _Size __ws = __b + __rotate(__a, 31) + __c;
                _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
                return __shift_mix(__r * __k0 + __vs) * __k2;
            }
        };
        template <class _Size> _Size __murmur2_or_cityhash<_Size, 64>::operator()(const void *__key, _Size __len)         {
            const char *__s = static_cast<const char *>(__key);
            if (__len <= 32) {
                if (__len <= 16) {
                    return __hash_len_0_to_16(__s, __len);
                } else {
                    return __hash_len_17_to_32(__s, __len);
                }
            } else if (__len <= 64) {
                return __hash_len_33_to_64(__s, __len);
            }
            _Size __x = __loadword<_Size>(__s + __len - 40);
            _Size __y = __loadword<_Size>(__s + __len - 16) + __loadword<_Size>(__s + __len - 56);
            _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len, __loadword<_Size>(__s + __len - 24));
            pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
            pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
            __x = __x * __k1 + __loadword<_Size>(__s);
            __len = (__len - 1) & ~static_cast<_Size>(63);
            do {
                __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
                __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
                __x ^= __w.second;
                __y += __v.first + __loadword<_Size>(__s + 40);
                __z = __rotate(__z + __w.first, 33) * __k1;
                __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
                __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second, __y + __loadword<_Size>(__s + 16));
                std::swap(__z, __x);
                __s += 64;
                __len -= 64;
            } while (__len != 0);
            return __hash_len_16(__hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z, __hash_len_16(__v.second, __w.second) + __x);
        }
        template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)> struct __scalar_hash
template<> struct __scalar_hash<std::__1::_PairT, 2> : public unary_function<std::__1::_PairT, size_t> {
            size_t operator()(std::__1::_PairT __v) const throw() __attribute__((internal_linkage))             {
                union {
                    _PairT __t;
                    struct {
                        size_t __a;
                        size_t __b;
                    };
                    struct (anonymous struct at /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility:1249:13) __s;
                } __u;
                __u.__t = __v;
                return __murmur2_or_cityhash<size_t>()(&__u, sizeof (__u));
            }
        }
template<> struct __scalar_hash<long long, 1> : public unary_function<long long, size_t> {
            size_t operator()(long long __v) const throw() __attribute__((internal_linkage));
        }
template<> struct __scalar_hash<unsigned long long, 1> : public unary_function<unsigned long long, size_t> {
            size_t operator()(unsigned long long __v) const throw() __attribute__((internal_linkage));
        }
template<> struct __scalar_hash<__int128, 2> : public unary_function<__int128, size_t> {
            size_t operator()(__int128 __v) const throw() __attribute__((internal_linkage));
        }
template<> struct __scalar_hash<unsigned __int128, 2> : public unary_function<unsigned __int128, size_t> {
            size_t operator()(unsigned __int128 __v) const throw() __attribute__((internal_linkage));
        }
template<> struct __scalar_hash<float, 0> : public unary_function<float, size_t> {
            size_t operator()(float __v) const throw() __attribute__((internal_linkage))             {
                union {
                    float __t;
                    size_t __a;
                } __u;
                __u.__a = 0;
                __u.__t = __v;
                return __u.__a;
            }
        }
template<> struct __scalar_hash<double, 1> : public unary_function<double, size_t> {
            size_t operator()(double __v) const throw() __attribute__((internal_linkage))             {
                union {
                    double __t;
                    size_t __a;
                } __u;
                __u.__t = __v;
                return __u.__a;
            }
        }
template<> struct __scalar_hash<long double, 2> : public unary_function<long double, size_t> {
            size_t operator()(long double __v) const throw() __attribute__((internal_linkage));
        };
        template <class _Tp> struct __scalar_hash<_Tp, 0> : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                union {
                    _Tp __t;
                    size_t __a;
                } __u;
                __u.__a = 0;
                __u.__t = __v;
                return __u.__a;
            }
        };
        template <class _Tp> struct __scalar_hash<_Tp, 1> : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                union {
                    _Tp __t;
                    size_t __a;
                } __u;
                __u.__t = __v;
                return __u.__a;
            }
        };
        template <class _Tp> struct __scalar_hash<_Tp, 2> : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                union {
                    _Tp __t;
                    struct {
                        size_t __a;
                        size_t __b;
                    } __s;
                } __u;
                __u.__t = __v;
                return __murmur2_or_cityhash<size_t>()(&__u, sizeof (__u));
            }
        };
        template <class _Tp> struct __scalar_hash<_Tp, 3> : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                union {
                    _Tp __t;
                    struct {
                        size_t __a;
                        size_t __b;
                        size_t __c;
                    } __s;
                } __u;
                __u.__t = __v;
                return __murmur2_or_cityhash<size_t>()(&__u, sizeof (__u));
            }
        };
        template <class _Tp> struct __scalar_hash<_Tp, 4> : public unary_function<_Tp, size_t> {
            size_t operator()(_Tp __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                union {
                    _Tp __t;
                    struct {
                        size_t __a;
                        size_t __b;
                        size_t __c;
                        size_t __d;
                    } __s;
                } __u;
                __u.__t = __v;
                return __murmur2_or_cityhash<size_t>()(&__u, sizeof (__u));
            }
        };
        struct _PairT {
            size_t first;
            size_t second;
        };
        inline size_t __hash_combine(size_t __lhs, size_t __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef __scalar_hash<std::__1::_PairT> _HashT;
            const std::__1::_PairT __p = {__lhs, __rhs};
            return _HashT()(__p);
        }
        template <class _Tp> struct __attribute__((type_visibility("default"))) hash<_Tp *> : public unary_function<_Tp *, size_t> {
            size_t operator()(_Tp *__v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                union {
                    _Tp *__t;
                    size_t __a;
                } __u;
                __u.__t = __v;
                return __murmur2_or_cityhash<size_t>()(&__u, sizeof (__u));
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<bool> : public unary_function<bool, size_t> {
            size_t operator()(bool __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<char> : public unary_function<char, size_t> {
            size_t operator()(char __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<signed char> : public unary_function<signed char, size_t> {
            size_t operator()(signed char __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<unsigned char> : public unary_function<unsigned char, size_t> {
            size_t operator()(unsigned char __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<char16_t> : public unary_function<char16_t, size_t> {
            size_t operator()(char16_t __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<char32_t> : public unary_function<char32_t, size_t> {
            size_t operator()(char32_t __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<wchar_t> : public unary_function<wchar_t, size_t> {
            size_t operator()(wchar_t __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<short> : public unary_function<short, size_t> {
            size_t operator()(short __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<unsigned short> : public unary_function<unsigned short, size_t> {
            size_t operator()(unsigned short __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<int> : public unary_function<int, size_t> {
            size_t operator()(int __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<unsigned int> : public unary_function<unsigned int, size_t> {
            size_t operator()(unsigned int __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<long> : public unary_function<long, size_t> {
            size_t operator()(long __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<unsigned long> : public unary_function<unsigned long, size_t> {
            size_t operator()(unsigned long __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<long long> : public __scalar_hash<long long> {
        };
        template<> struct __attribute__((type_visibility("default"))) hash<unsigned long long> : public __scalar_hash<unsigned long long> {
        };
        template<> struct __attribute__((type_visibility("default"))) hash<__int128_t> : public __scalar_hash<__int128_t> {
        };
        template<> struct __attribute__((type_visibility("default"))) hash<__uint128_t> : public __scalar_hash<__uint128_t> {
        };
        template<> struct __attribute__((type_visibility("default"))) hash<float> : public __scalar_hash<float> {
            size_t operator()(float __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__v == 0.F)
                    return 0;
                return this->__scalar_hash<float>::operator()(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<double> : public __scalar_hash<double> {
            size_t operator()(double __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__v == 0.)
                    return 0;
                return this->__scalar_hash<double>::operator()(__v);
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<long double> : public __scalar_hash<long double> {
            size_t operator()(long double __v) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__v == 0.L)
                    return 0;
                union {
                    long double __t;
                    struct {
                        size_t __a;
                        size_t __b;
                    } __s;
                } __u;
                __u.__s.__a = 0;
                __u.__s.__b = 0;
                __u.__t = __v;
                return __u.__s.__a ^ __u.__s.__b;
            }
        };
    }
}
typedef enum  {
    P_ALL,
    P_PID,
    P_PGID
} idtype_t;
typedef __darwin_pid_t pid_t;
typedef __darwin_id_t id_t;
typedef int sig_atomic_t;
struct __darwin_i386_thread_state {
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
struct __darwin_fp_control {
    unsigned short __invalid : 1;
    unsigned short __denorm : 1;
    unsigned short __zdiv : 1;
    unsigned short __ovrfl : 1;
    unsigned short __undfl : 1;
    unsigned short __precis : 1;
    unsigned short : 2;
    unsigned short __pc : 2;
    unsigned short __rc : 2;
    unsigned short : 1;
    unsigned short : 3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
struct __darwin_fp_status {
    unsigned short __invalid : 1;
    unsigned short __denorm : 1;
    unsigned short __zdiv : 1;
    unsigned short __ovrfl : 1;
    unsigned short __undfl : 1;
    unsigned short __precis : 1;
    unsigned short __stkflt : 1;
    unsigned short __errsumm : 1;
    unsigned short __c0 : 1;
    unsigned short __c1 : 1;
    unsigned short __c2 : 1;
    unsigned short __tos : 3;
    unsigned short __c3 : 1;
    unsigned short __busy : 1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
struct __darwin_mmst_reg {
    char __mmst_reg[10];
    char __mmst_rsrv[6];
};
struct __darwin_xmm_reg {
    char __xmm_reg[16];
};
struct __darwin_ymm_reg {
    char __ymm_reg[32];
};
struct __darwin_zmm_reg {
    char __zmm_reg[64];
};
struct __darwin_opmask_reg {
    char __opmask_reg[8];
};
struct __darwin_i386_float_state {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    char __fpu_rsrv4[224];
    int __fpu_reserved1;
};
struct __darwin_i386_avx_state {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    char __fpu_rsrv4[224];
    int __fpu_reserved1;
    char __avx_reserved1[64];
    struct __darwin_xmm_reg __fpu_ymmh0;
    struct __darwin_xmm_reg __fpu_ymmh1;
    struct __darwin_xmm_reg __fpu_ymmh2;
    struct __darwin_xmm_reg __fpu_ymmh3;
    struct __darwin_xmm_reg __fpu_ymmh4;
    struct __darwin_xmm_reg __fpu_ymmh5;
    struct __darwin_xmm_reg __fpu_ymmh6;
    struct __darwin_xmm_reg __fpu_ymmh7;
};
struct __darwin_i386_avx512_state {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    char __fpu_rsrv4[224];
    int __fpu_reserved1;
    char __avx_reserved1[64];
    struct __darwin_xmm_reg __fpu_ymmh0;
    struct __darwin_xmm_reg __fpu_ymmh1;
    struct __darwin_xmm_reg __fpu_ymmh2;
    struct __darwin_xmm_reg __fpu_ymmh3;
    struct __darwin_xmm_reg __fpu_ymmh4;
    struct __darwin_xmm_reg __fpu_ymmh5;
    struct __darwin_xmm_reg __fpu_ymmh6;
    struct __darwin_xmm_reg __fpu_ymmh7;
    struct __darwin_opmask_reg __fpu_k0;
    struct __darwin_opmask_reg __fpu_k1;
    struct __darwin_opmask_reg __fpu_k2;
    struct __darwin_opmask_reg __fpu_k3;
    struct __darwin_opmask_reg __fpu_k4;
    struct __darwin_opmask_reg __fpu_k5;
    struct __darwin_opmask_reg __fpu_k6;
    struct __darwin_opmask_reg __fpu_k7;
    struct __darwin_ymm_reg __fpu_zmmh0;
    struct __darwin_ymm_reg __fpu_zmmh1;
    struct __darwin_ymm_reg __fpu_zmmh2;
    struct __darwin_ymm_reg __fpu_zmmh3;
    struct __darwin_ymm_reg __fpu_zmmh4;
    struct __darwin_ymm_reg __fpu_zmmh5;
    struct __darwin_ymm_reg __fpu_zmmh6;
    struct __darwin_ymm_reg __fpu_zmmh7;
};
struct __darwin_i386_exception_state {
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint32_t __faultvaddr;
};
struct __darwin_x86_debug_state32 {
    unsigned int __dr0;
    unsigned int __dr1;
    unsigned int __dr2;
    unsigned int __dr3;
    unsigned int __dr4;
    unsigned int __dr5;
    unsigned int __dr6;
    unsigned int __dr7;
};
struct __x86_pagein_state {
    int __pagein_error;
};
struct __darwin_x86_thread_state64 {
    __uint64_t __rax;
    __uint64_t __rbx;
    __uint64_t __rcx;
    __uint64_t __rdx;
    __uint64_t __rdi;
    __uint64_t __rsi;
    __uint64_t __rbp;
    __uint64_t __rsp;
    __uint64_t __r8;
    __uint64_t __r9;
    __uint64_t __r10;
    __uint64_t __r11;
    __uint64_t __r12;
    __uint64_t __r13;
    __uint64_t __r14;
    __uint64_t __r15;
    __uint64_t __rip;
    __uint64_t __rflags;
    __uint64_t __cs;
    __uint64_t __fs;
    __uint64_t __gs;
};
struct __darwin_x86_thread_full_state64 {
    struct __darwin_x86_thread_state64 __ss64;
    __uint64_t __ds;
    __uint64_t __es;
    __uint64_t __ss;
    __uint64_t __gsbase;
};
struct __darwin_x86_float_state64 {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    struct __darwin_xmm_reg __fpu_xmm8;
    struct __darwin_xmm_reg __fpu_xmm9;
    struct __darwin_xmm_reg __fpu_xmm10;
    struct __darwin_xmm_reg __fpu_xmm11;
    struct __darwin_xmm_reg __fpu_xmm12;
    struct __darwin_xmm_reg __fpu_xmm13;
    struct __darwin_xmm_reg __fpu_xmm14;
    struct __darwin_xmm_reg __fpu_xmm15;
    char __fpu_rsrv4[96];
    int __fpu_reserved1;
};
struct __darwin_x86_avx_state64 {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    struct __darwin_xmm_reg __fpu_xmm8;
    struct __darwin_xmm_reg __fpu_xmm9;
    struct __darwin_xmm_reg __fpu_xmm10;
    struct __darwin_xmm_reg __fpu_xmm11;
    struct __darwin_xmm_reg __fpu_xmm12;
    struct __darwin_xmm_reg __fpu_xmm13;
    struct __darwin_xmm_reg __fpu_xmm14;
    struct __darwin_xmm_reg __fpu_xmm15;
    char __fpu_rsrv4[96];
    int __fpu_reserved1;
    char __avx_reserved1[64];
    struct __darwin_xmm_reg __fpu_ymmh0;
    struct __darwin_xmm_reg __fpu_ymmh1;
    struct __darwin_xmm_reg __fpu_ymmh2;
    struct __darwin_xmm_reg __fpu_ymmh3;
    struct __darwin_xmm_reg __fpu_ymmh4;
    struct __darwin_xmm_reg __fpu_ymmh5;
    struct __darwin_xmm_reg __fpu_ymmh6;
    struct __darwin_xmm_reg __fpu_ymmh7;
    struct __darwin_xmm_reg __fpu_ymmh8;
    struct __darwin_xmm_reg __fpu_ymmh9;
    struct __darwin_xmm_reg __fpu_ymmh10;
    struct __darwin_xmm_reg __fpu_ymmh11;
    struct __darwin_xmm_reg __fpu_ymmh12;
    struct __darwin_xmm_reg __fpu_ymmh13;
    struct __darwin_xmm_reg __fpu_ymmh14;
    struct __darwin_xmm_reg __fpu_ymmh15;
};
struct __darwin_x86_avx512_state64 {
    int __fpu_reserved[2];
    struct __darwin_fp_control __fpu_fcw;
    struct __darwin_fp_status __fpu_fsw;
    __uint8_t __fpu_ftw;
    __uint8_t __fpu_rsrv1;
    __uint16_t __fpu_fop;
    __uint32_t __fpu_ip;
    __uint16_t __fpu_cs;
    __uint16_t __fpu_rsrv2;
    __uint32_t __fpu_dp;
    __uint16_t __fpu_ds;
    __uint16_t __fpu_rsrv3;
    __uint32_t __fpu_mxcsr;
    __uint32_t __fpu_mxcsrmask;
    struct __darwin_mmst_reg __fpu_stmm0;
    struct __darwin_mmst_reg __fpu_stmm1;
    struct __darwin_mmst_reg __fpu_stmm2;
    struct __darwin_mmst_reg __fpu_stmm3;
    struct __darwin_mmst_reg __fpu_stmm4;
    struct __darwin_mmst_reg __fpu_stmm5;
    struct __darwin_mmst_reg __fpu_stmm6;
    struct __darwin_mmst_reg __fpu_stmm7;
    struct __darwin_xmm_reg __fpu_xmm0;
    struct __darwin_xmm_reg __fpu_xmm1;
    struct __darwin_xmm_reg __fpu_xmm2;
    struct __darwin_xmm_reg __fpu_xmm3;
    struct __darwin_xmm_reg __fpu_xmm4;
    struct __darwin_xmm_reg __fpu_xmm5;
    struct __darwin_xmm_reg __fpu_xmm6;
    struct __darwin_xmm_reg __fpu_xmm7;
    struct __darwin_xmm_reg __fpu_xmm8;
    struct __darwin_xmm_reg __fpu_xmm9;
    struct __darwin_xmm_reg __fpu_xmm10;
    struct __darwin_xmm_reg __fpu_xmm11;
    struct __darwin_xmm_reg __fpu_xmm12;
    struct __darwin_xmm_reg __fpu_xmm13;
    struct __darwin_xmm_reg __fpu_xmm14;
    struct __darwin_xmm_reg __fpu_xmm15;
    char __fpu_rsrv4[96];
    int __fpu_reserved1;
    char __avx_reserved1[64];
    struct __darwin_xmm_reg __fpu_ymmh0;
    struct __darwin_xmm_reg __fpu_ymmh1;
    struct __darwin_xmm_reg __fpu_ymmh2;
    struct __darwin_xmm_reg __fpu_ymmh3;
    struct __darwin_xmm_reg __fpu_ymmh4;
    struct __darwin_xmm_reg __fpu_ymmh5;
    struct __darwin_xmm_reg __fpu_ymmh6;
    struct __darwin_xmm_reg __fpu_ymmh7;
    struct __darwin_xmm_reg __fpu_ymmh8;
    struct __darwin_xmm_reg __fpu_ymmh9;
    struct __darwin_xmm_reg __fpu_ymmh10;
    struct __darwin_xmm_reg __fpu_ymmh11;
    struct __darwin_xmm_reg __fpu_ymmh12;
    struct __darwin_xmm_reg __fpu_ymmh13;
    struct __darwin_xmm_reg __fpu_ymmh14;
    struct __darwin_xmm_reg __fpu_ymmh15;
    struct __darwin_opmask_reg __fpu_k0;
    struct __darwin_opmask_reg __fpu_k1;
    struct __darwin_opmask_reg __fpu_k2;
    struct __darwin_opmask_reg __fpu_k3;
    struct __darwin_opmask_reg __fpu_k4;
    struct __darwin_opmask_reg __fpu_k5;
    struct __darwin_opmask_reg __fpu_k6;
    struct __darwin_opmask_reg __fpu_k7;
    struct __darwin_ymm_reg __fpu_zmmh0;
    struct __darwin_ymm_reg __fpu_zmmh1;
    struct __darwin_ymm_reg __fpu_zmmh2;
    struct __darwin_ymm_reg __fpu_zmmh3;
    struct __darwin_ymm_reg __fpu_zmmh4;
    struct __darwin_ymm_reg __fpu_zmmh5;
    struct __darwin_ymm_reg __fpu_zmmh6;
    struct __darwin_ymm_reg __fpu_zmmh7;
    struct __darwin_ymm_reg __fpu_zmmh8;
    struct __darwin_ymm_reg __fpu_zmmh9;
    struct __darwin_ymm_reg __fpu_zmmh10;
    struct __darwin_ymm_reg __fpu_zmmh11;
    struct __darwin_ymm_reg __fpu_zmmh12;
    struct __darwin_ymm_reg __fpu_zmmh13;
    struct __darwin_ymm_reg __fpu_zmmh14;
    struct __darwin_ymm_reg __fpu_zmmh15;
    struct __darwin_zmm_reg __fpu_zmm16;
    struct __darwin_zmm_reg __fpu_zmm17;
    struct __darwin_zmm_reg __fpu_zmm18;
    struct __darwin_zmm_reg __fpu_zmm19;
    struct __darwin_zmm_reg __fpu_zmm20;
    struct __darwin_zmm_reg __fpu_zmm21;
    struct __darwin_zmm_reg __fpu_zmm22;
    struct __darwin_zmm_reg __fpu_zmm23;
    struct __darwin_zmm_reg __fpu_zmm24;
    struct __darwin_zmm_reg __fpu_zmm25;
    struct __darwin_zmm_reg __fpu_zmm26;
    struct __darwin_zmm_reg __fpu_zmm27;
    struct __darwin_zmm_reg __fpu_zmm28;
    struct __darwin_zmm_reg __fpu_zmm29;
    struct __darwin_zmm_reg __fpu_zmm30;
    struct __darwin_zmm_reg __fpu_zmm31;
};
struct __darwin_x86_exception_state64 {
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
struct __darwin_x86_debug_state64 {
    __uint64_t __dr0;
    __uint64_t __dr1;
    __uint64_t __dr2;
    __uint64_t __dr3;
    __uint64_t __dr4;
    __uint64_t __dr5;
    __uint64_t __dr6;
    __uint64_t __dr7;
};
struct __darwin_x86_cpmu_state64 {
    __uint64_t __ctrs[16];
};
struct __darwin_mcontext32 {
    struct __darwin_i386_exception_state __es;
    struct __darwin_i386_thread_state __ss;
    struct __darwin_i386_float_state __fs;
};
struct __darwin_mcontext_avx32 {
    struct __darwin_i386_exception_state __es;
    struct __darwin_i386_thread_state __ss;
    struct __darwin_i386_avx_state __fs;
};
struct __darwin_mcontext_avx512_32 {
    struct __darwin_i386_exception_state __es;
    struct __darwin_i386_thread_state __ss;
    struct __darwin_i386_avx512_state __fs;
};
struct __darwin_mcontext64 {
    struct __darwin_x86_exception_state64 __es;
    struct __darwin_x86_thread_state64 __ss;
    struct __darwin_x86_float_state64 __fs;
};
struct __darwin_mcontext64_full {
    struct __darwin_x86_exception_state64 __es;
    struct __darwin_x86_thread_full_state64 __ss;
    struct __darwin_x86_float_state64 __fs;
};
struct __darwin_mcontext_avx64 {
    struct __darwin_x86_exception_state64 __es;
    struct __darwin_x86_thread_state64 __ss;
    struct __darwin_x86_avx_state64 __fs;
};
struct __darwin_mcontext_avx64_full {
    struct __darwin_x86_exception_state64 __es;
    struct __darwin_x86_thread_full_state64 __ss;
    struct __darwin_x86_avx_state64 __fs;
};
struct __darwin_mcontext_avx512_64 {
    struct __darwin_x86_exception_state64 __es;
    struct __darwin_x86_thread_state64 __ss;
    struct __darwin_x86_avx512_state64 __fs;
};
struct __darwin_mcontext_avx512_64_full {
    struct __darwin_x86_exception_state64 __es;
    struct __darwin_x86_thread_full_state64 __ss;
    struct __darwin_x86_avx512_state64 __fs;
};
typedef struct __darwin_mcontext64 *mcontext_t;
typedef __darwin_pthread_attr_t pthread_attr_t;
struct __darwin_sigaltstack {
    void *ss_sp;
    __darwin_size_t ss_size;
    int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
struct __darwin_ucontext {
    int uc_onstack;
    __darwin_sigset_t uc_sigmask;
    struct __darwin_sigaltstack uc_stack;
    struct __darwin_ucontext *uc_link;
    __darwin_size_t uc_mcsize;
    struct __darwin_mcontext64 *uc_mcontext;
};
typedef struct __darwin_ucontext ucontext_t;
typedef __darwin_sigset_t sigset_t;
typedef __darwin_uid_t uid_t;
union sigval {
    int sival_int;
    void *sival_ptr;
};
struct sigevent {
    int sigev_notify;
    int sigev_signo;
    union sigval sigev_value;
    void (*sigev_notify_function)(union sigval);
    pthread_attr_t *sigev_notify_attributes;
};
typedef struct __siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    pid_t si_pid;
    uid_t si_uid;
    int si_status;
    void *si_addr;
    union sigval si_value;
    long si_band;
    unsigned long __pad[7];
} siginfo_t;
union __sigaction_u {
    void (*__sa_handler)(int);
    void (*__sa_sigaction)(int, struct __siginfo *, void *);
};
struct __sigaction {
    union __sigaction_u __sigaction_u;
    void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
};
struct sigaction {
    union __sigaction_u __sigaction_u;
    sigset_t sa_mask;
    int sa_flags;
};
typedef void (*sig_t)(int);
struct sigvec {
    void (*sv_handler)(int);
    int sv_mask;
    int sv_flags;
};
struct sigstack {
    char *ss_sp;
    int ss_onstack;
};
extern "C" {
    void (*signal(int, void (*)(int)))(int);
}
struct timeval {
    __darwin_time_t tv_sec;
    __darwin_suseconds_t tv_usec;
};
typedef __uint64_t rlim_t;
struct rusage {
    struct timeval ru_utime;
    struct timeval ru_stime;
    long ru_maxrss;
    long ru_ixrss;
    long ru_idrss;
    long ru_isrss;
    long ru_minflt;
    long ru_majflt;
    long ru_nswap;
    long ru_inblock;
    long ru_oublock;
    long ru_msgsnd;
    long ru_msgrcv;
    long ru_nsignals;
    long ru_nvcsw;
    long ru_nivcsw;
};
typedef void *rusage_info_t;
struct rusage_info_v0 {
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
};
struct rusage_info_v1 {
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
};
struct rusage_info_v2 {
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
};
struct rusage_info_v3 {
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
    uint64_t ri_cpu_time_qos_default;
    uint64_t ri_cpu_time_qos_maintenance;
    uint64_t ri_cpu_time_qos_background;
    uint64_t ri_cpu_time_qos_utility;
    uint64_t ri_cpu_time_qos_legacy;
    uint64_t ri_cpu_time_qos_user_initiated;
    uint64_t ri_cpu_time_qos_user_interactive;
    uint64_t ri_billed_system_time;
    uint64_t ri_serviced_system_time;
};
struct rusage_info_v4 {
    uint8_t ri_uuid[16];
    uint64_t ri_user_time;
    uint64_t ri_system_time;
    uint64_t ri_pkg_idle_wkups;
    uint64_t ri_interrupt_wkups;
    uint64_t ri_pageins;
    uint64_t ri_wired_size;
    uint64_t ri_resident_size;
    uint64_t ri_phys_footprint;
    uint64_t ri_proc_start_abstime;
    uint64_t ri_proc_exit_abstime;
    uint64_t ri_child_user_time;
    uint64_t ri_child_system_time;
    uint64_t ri_child_pkg_idle_wkups;
    uint64_t ri_child_interrupt_wkups;
    uint64_t ri_child_pageins;
    uint64_t ri_child_elapsed_abstime;
    uint64_t ri_diskio_bytesread;
    uint64_t ri_diskio_byteswritten;
    uint64_t ri_cpu_time_qos_default;
    uint64_t ri_cpu_time_qos_maintenance;
    uint64_t ri_cpu_time_qos_background;
    uint64_t ri_cpu_time_qos_utility;
    uint64_t ri_cpu_time_qos_legacy;
    uint64_t ri_cpu_time_qos_user_initiated;
    uint64_t ri_cpu_time_qos_user_interactive;
    uint64_t ri_billed_system_time;
    uint64_t ri_serviced_system_time;
    uint64_t ri_logical_writes;
    uint64_t ri_lifetime_max_phys_footprint;
    uint64_t ri_instructions;
    uint64_t ri_cycles;
    uint64_t ri_billed_energy;
    uint64_t ri_serviced_energy;
    uint64_t ri_interval_max_phys_footprint;
    uint64_t ri_runnable_time;
};
typedef struct rusage_info_v4 rusage_info_current;
struct rlimit {
    rlim_t rlim_cur;
    rlim_t rlim_max;
};
struct proc_rlimit_control_wakeupmon {
    uint32_t wm_flags;
    int32_t wm_rate;
};
extern "C" {
    int getpriority(int, id_t);
    int getiopolicy_np(int, int) __attribute__((availability(macos, introduced=10.5)));
    int getrlimit(int, struct rlimit *) asm("_getrlimit");
    int getrusage(int, struct rusage *);
    int setpriority(int, id_t, int);
    int setiopolicy_np(int, int, int) __attribute__((availability(macos, introduced=10.5)));
    int setrlimit(int, const struct rlimit *) asm("_setrlimit");
}
static inline __uint16_t _OSSwapInt16(__uint16_t _data) {
    return (__uint16_t)((_data << 8) | (_data >> 8));
}
static inline __uint32_t _OSSwapInt32(__uint32_t _data) {
    return __builtin_bswap32(_data);
}
static inline __uint64_t _OSSwapInt64(__uint64_t _data) {
    return __builtin_bswap64(_data);
}
union wait {
    int w_status;
    struct {
        unsigned int w_Termsig : 7;
        unsigned int w_Coredump : 1;
        unsigned int w_Retcode : 8;
        unsigned int w_Filler : 16;
    } w_T;
    struct {
        unsigned int w_Stopval : 8;
        unsigned int w_Stopsig : 8;
        unsigned int w_Filler : 16;
    } w_S;
};
extern "C" {
    pid_t wait(int *) asm("_wait");
    pid_t waitpid(pid_t, int *, int) asm("_waitpid");
    int waitid(idtype_t, id_t, siginfo_t *, int) asm("_waitid");
    pid_t wait3(int *, int, struct rusage *);
    pid_t wait4(pid_t, int *, int, struct rusage *);
}
extern "C" {
    void *alloca(size_t);
}
typedef struct {
    int quot;
    int rem;
} div_t;
typedef struct {
    long quot;
    long rem;
} ldiv_t;
typedef struct {
    long long quot;
    long long rem;
} lldiv_t;
extern int __mb_cur_max;
extern "C" {
    void *malloc(size_t __size) __attribute__((warn_unused_result(""))) __attribute__((alloc_size(1)));
    void *calloc(size_t __count, size_t __size) __attribute__((warn_unused_result(""))) __attribute__((alloc_size(1, 2)));
    void free(void *);
    void *realloc(void *__ptr, size_t __size) __attribute__((warn_unused_result(""))) __attribute__((alloc_size(2)));
    void *valloc(size_t) __attribute__((alloc_size(1)));
    int posix_memalign(void **__memptr, size_t __alignment, size_t __size) __attribute__((availability(macos, introduced=10.6)));
}
extern "C" {
    void abort() __attribute__((cold));
    int abs(int) __attribute__((const));
    int atexit(void (* _Nonnull)());
    double atof(const char *);
    int atoi(const char *);
    long atol(const char *);
    long long atoll(const char *);
    void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *));
    div_t div(int, int) __attribute__((const));
    void exit(int);
    char *getenv(const char *);
    long labs(long) __attribute__((const));
    ldiv_t ldiv(long, long) __attribute__((const));
    long long llabs(long long);
    lldiv_t lldiv(long long, long long);
    int mblen(const char *__s, size_t __n);
    size_t mbstowcs(wchar_t *, const char *, size_t);
    int mbtowc(wchar_t *, const char *, size_t);
    void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *));
    int rand() __attribute__((availability(swift, unavailable)));
    void srand(unsigned int) __attribute__((availability(swift, unavailable)));
    double strtod(const char *, char **) asm("_strtod");
    float strtof(const char *, char **) asm("_strtof");
    long strtol(const char *__str, char **__endptr, int __base);
    long double strtold(const char *, char **);
    long long strtoll(const char *__str, char **__endptr, int __base);
    unsigned long strtoul(const char *__str, char **__endptr, int __base);
    unsigned long long strtoull(const char *__str, char **__endptr, int __base);
    int system(const char *) asm("_system") __attribute__((availability(swift, unavailable))) __attribute__((availability(macos, introduced=10.0))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    size_t wcstombs(char *, const wchar_t *, size_t);
    int wctomb(char *, wchar_t);
    void _Exit(int);
    long a64l(const char *);
    double drand48();
    char *ecvt(double, int, int *, int *);
    double erand48(unsigned short [3]);
    char *fcvt(double, int, int *, int *);
    char *gcvt(double, int, char *);
    int getsubopt(char **, char *const *, char **);
    int grantpt(int);
    char *initstate(unsigned int, char *, size_t);
    long jrand48(unsigned short [3]) __attribute__((availability(swift, unavailable)));
    char *l64a(long);
    void lcong48(unsigned short [7]);
    long lrand48() __attribute__((availability(swift, unavailable)));
    char *mktemp(char *);
    int mkstemp(char *);
    long mrand48() __attribute__((availability(swift, unavailable)));
    long nrand48(unsigned short [3]) __attribute__((availability(swift, unavailable)));
    int posix_openpt(int);
    char *ptsname(int);
    int ptsname_r(int fildes, char *buffer, size_t buflen) __attribute__((availability(macos, introduced=10.13.4))) __attribute__((availability(ios, introduced=11.3))) __attribute__((availability(tvos, introduced=11.3))) __attribute__((availability(watchos, introduced=4.3)));
    int putenv(char *) asm("_putenv");
    long random() __attribute__((availability(swift, unavailable)));
    int rand_r(unsigned int *) __attribute__((availability(swift, unavailable)));
    char *realpath(const char *, char *) asm("_realpath$DARWIN_EXTSN");
    unsigned short *seed48(unsigned short [3]);
    int setenv(const char *__name, const char *__value, int __overwrite) asm("_setenv");
    void setkey(const char *) asm("_setkey");
    char *setstate(const char *);
    void srand48(long);
    void srandom(unsigned int);
    int unlockpt(int);
    int unsetenv(const char *) asm("_unsetenv");
    typedef __darwin_dev_t dev_t;
    typedef __darwin_mode_t mode_t;
    uint32_t arc4random();
    void arc4random_addrandom(unsigned char *, int) __attribute__((availability(macos, introduced=10.0))) __attribute__((availability(macos, deprecated=10.12))) __attribute__((availability(ios, introduced=2.0))) __attribute__((availability(ios, deprecated=10.0))) __attribute__((availability(tvos, introduced=2.0))) __attribute__((availability(tvos, deprecated=10.0))) __attribute__((availability(watchos, introduced=1.0))) __attribute__((availability(watchos, deprecated=3.0)));
    void arc4random_buf(void *__buf, size_t __nbytes) __attribute__((availability(macos, introduced=10.7)));
    void arc4random_stir();
    uint32_t arc4random_uniform(uint32_t __upper_bound) __attribute__((availability(macos, introduced=10.7)));
    int atexit_b(void (^ _Nonnull)()) __attribute__((availability(macos, introduced=10.6)));
    void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, int (^ _Nonnull __compar)(const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    char *cgetcap(char *, const char *, int);
    int cgetclose();
    int cgetent(char **, char **, const char *);
    int cgetfirst(char **, char **);
    int cgetmatch(const char *, const char *);
    int cgetnext(char **, char **);
    int cgetnum(char *, const char *, long *);
    int cgetset(const char *);
    int cgetstr(char *, const char *, char **);
    int cgetustr(char *, const char *, char **);
    int daemon(int, int) asm("_daemon$1050") __attribute__((availability(macos, introduced=10.0, deprecated=10.5))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    char *devname(dev_t, mode_t);
    char *devname_r(dev_t, mode_t, char *buf, int len);
    char *getbsize(int *, long *);
    int getloadavg(double [], int);
    const char *getprogname();
    void setprogname(const char *);
    int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *));
    int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *) __attribute__((noescape))) __attribute__((availability(macos, introduced=10.6)));
    int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *));
    int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *) __attribute__((noescape))) __attribute__((availability(macos, introduced=10.6)));
    void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *) __attribute__((noescape))) __attribute__((availability(macos, introduced=10.6)));
    void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *)) __attribute__((availability(macos, introduced=10.6)));
    void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *) __attribute__((noescape))) __attribute__((availability(macos, introduced=10.6)));
    void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *));
    int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte);
    int rpmatch(const char *) __attribute__((availability(macos, introduced=10.15))) __attribute__((availability(ios, introduced=13.0))) __attribute__((availability(tvos, introduced=13.0))) __attribute__((availability(watchos, introduced=6.0)));
    int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte);
    void sranddev();
    void srandomdev();
    void *reallocf(void *__ptr, size_t __size) __attribute__((alloc_size(2)));
    long long strtoq(const char *__str, char **__endptr, int __base);
    unsigned long long strtouq(const char *__str, char **__endptr, int __base);
    extern char *suboptarg;
}
extern "C" {
    typedef float float_t;
    typedef double double_t;
    extern int __math_errhandling();
    extern int __fpclassifyf(float);
    extern int __fpclassifyd(double);
    extern int __fpclassifyl(long double);
    inline int __inline_isfinitef(float) __attribute__((always_inline));
    inline int __inline_isfinited(double) __attribute__((always_inline));
    inline int __inline_isfinitel(long double) __attribute__((always_inline));
    inline int __inline_isinff(float) __attribute__((always_inline));
    inline int __inline_isinfd(double) __attribute__((always_inline));
    inline int __inline_isinfl(long double) __attribute__((always_inline));
    inline int __inline_isnanf(float) __attribute__((always_inline));
    inline int __inline_isnand(double) __attribute__((always_inline));
    inline int __inline_isnanl(long double) __attribute__((always_inline));
    inline int __inline_isnormalf(float) __attribute__((always_inline));
    inline int __inline_isnormald(double) __attribute__((always_inline));
    inline int __inline_isnormall(long double) __attribute__((always_inline));
    inline int __inline_signbitf(float) __attribute__((always_inline));
    inline int __inline_signbitd(double) __attribute__((always_inline));
    inline int __inline_signbitl(long double) __attribute__((always_inline));
    inline int __inline_isfinitef(float __x) __attribute__((always_inline))     {
        return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
    }
    inline int __inline_isfinited(double __x) __attribute__((always_inline))     {
        return __x == __x && __builtin_fabs(__x) != __builtin_inf();
    }
    inline int __inline_isfinitel(long double __x) __attribute__((always_inline))     {
        return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
    }
    inline int __inline_isinff(float __x) __attribute__((always_inline))     {
        return __builtin_fabsf(__x) == __builtin_inff();
    }
    inline int __inline_isinfd(double __x) __attribute__((always_inline))     {
        return __builtin_fabs(__x) == __builtin_inf();
    }
    inline int __inline_isinfl(long double __x) __attribute__((always_inline))     {
        return __builtin_fabsl(__x) == __builtin_infl();
    }
    inline int __inline_isnanf(float __x) __attribute__((always_inline))     {
        return __x != __x;
    }
    inline int __inline_isnand(double __x) __attribute__((always_inline))     {
        return __x != __x;
    }
    inline int __inline_isnanl(long double __x) __attribute__((always_inline))     {
        return __x != __x;
    }
    inline int __inline_signbitf(float __x) __attribute__((always_inline))     {
        union {
            float __f;
            unsigned int __u;
        } __u;
        __u.__f = __x;
        return (int)(__u.__u >> 31);
    }
    inline int __inline_signbitd(double __x) __attribute__((always_inline))     {
        union {
            double __f;
            unsigned long long __u;
        } __u;
        __u.__f = __x;
        return (int)(__u.__u >> 63);
    }
    inline int __inline_signbitl(long double __x) __attribute__((always_inline))     {
        union {
            long double __ld;
            struct {
                unsigned long long __m;
                unsigned short __sexp;
            } __p;
        } __u;
        __u.__ld = __x;
        return (int)(__u.__p.__sexp >> 15);
    }
    inline int __inline_isnormalf(float __x) __attribute__((always_inline))     {
        return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435E-38F;
    }
    inline int __inline_isnormald(double __x) __attribute__((always_inline))     {
        return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014E-308;
    }
    inline int __inline_isnormall(long double __x) __attribute__((always_inline))     {
        return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 3.36210314311209350626E-4932L;
    }
    extern float acosf(float);
    extern double acos(double);
    extern long double acosl(long double);
    extern float asinf(float);
    extern double asin(double);
    extern long double asinl(long double);
    extern float atanf(float);
    extern double atan(double);
    extern long double atanl(long double);
    extern float atan2f(float, float);
    extern double atan2(double, double);
    extern long double atan2l(long double, long double);
    extern float cosf(float);
    extern double cos(double);
    extern long double cosl(long double);
    extern float sinf(float);
    extern double sin(double);
    extern long double sinl(long double);
    extern float tanf(float);
    extern double tan(double);
    extern long double tanl(long double);
    extern float acoshf(float);
    extern double acosh(double);
    extern long double acoshl(long double);
    extern float asinhf(float);
    extern double asinh(double);
    extern long double asinhl(long double);
    extern float atanhf(float);
    extern double atanh(double);
    extern long double atanhl(long double);
    extern float coshf(float);
    extern double cosh(double);
    extern long double coshl(long double);
    extern float sinhf(float);
    extern double sinh(double);
    extern long double sinhl(long double);
    extern float tanhf(float);
    extern double tanh(double);
    extern long double tanhl(long double);
    extern float expf(float);
    extern double exp(double);
    extern long double expl(long double);
    extern float exp2f(float);
    extern double exp2(double);
    extern long double exp2l(long double);
    extern float expm1f(float);
    extern double expm1(double);
    extern long double expm1l(long double);
    extern float logf(float);
    extern double log(double);
    extern long double logl(long double);
    extern float log10f(float);
    extern double log10(double);
    extern long double log10l(long double);
    extern float log2f(float);
    extern double log2(double);
    extern long double log2l(long double);
    extern float log1pf(float);
    extern double log1p(double);
    extern long double log1pl(long double);
    extern float logbf(float);
    extern double logb(double);
    extern long double logbl(long double);
    extern float modff(float, float *);
    extern double modf(double, double *);
    extern long double modfl(long double, long double *);
    extern float ldexpf(float, int);
    extern double ldexp(double, int);
    extern long double ldexpl(long double, int);
    extern float frexpf(float, int *);
    extern double frexp(double, int *);
    extern long double frexpl(long double, int *);
    extern int ilogbf(float);
    extern int ilogb(double);
    extern int ilogbl(long double);
    extern float scalbnf(float, int);
    extern double scalbn(double, int);
    extern long double scalbnl(long double, int);
    extern float scalblnf(float, long);
    extern double scalbln(double, long);
    extern long double scalblnl(long double, long);
    extern float fabsf(float);
    extern double fabs(double);
    extern long double fabsl(long double);
    extern float cbrtf(float);
    extern double cbrt(double);
    extern long double cbrtl(long double);
    extern float hypotf(float, float);
    extern double hypot(double, double);
    extern long double hypotl(long double, long double);
    extern float powf(float, float);
    extern double pow(double, double);
    extern long double powl(long double, long double);
    extern float sqrtf(float);
    extern double sqrt(double);
    extern long double sqrtl(long double);
    extern float erff(float);
    extern double erf(double);
    extern long double erfl(long double);
    extern float erfcf(float);
    extern double erfc(double);
    extern long double erfcl(long double);
    extern float lgammaf(float);
    extern double lgamma(double);
    extern long double lgammal(long double);
    extern float tgammaf(float);
    extern double tgamma(double);
    extern long double tgammal(long double);
    extern float ceilf(float);
    extern double ceil(double);
    extern long double ceill(long double);
    extern float floorf(float);
    extern double floor(double);
    extern long double floorl(long double);
    extern float nearbyintf(float);
    extern double nearbyint(double);
    extern long double nearbyintl(long double);
    extern float rintf(float);
    extern double rint(double);
    extern long double rintl(long double);
    extern long lrintf(float);
    extern long lrint(double);
    extern long lrintl(long double);
    extern float roundf(float);
    extern double round(double);
    extern long double roundl(long double);
    extern long lroundf(float);
    extern long lround(double);
    extern long lroundl(long double);
    extern long long llrintf(float);
    extern long long llrint(double);
    extern long long llrintl(long double);
    extern long long llroundf(float);
    extern long long llround(double);
    extern long long llroundl(long double);
    extern float truncf(float);
    extern double trunc(double);
    extern long double truncl(long double);
    extern float fmodf(float, float);
    extern double fmod(double, double);
    extern long double fmodl(long double, long double);
    extern float remainderf(float, float);
    extern double remainder(double, double);
    extern long double remainderl(long double, long double);
    extern float remquof(float, float, int *);
    extern double remquo(double, double, int *);
    extern long double remquol(long double, long double, int *);
    extern float copysignf(float, float);
    extern double copysign(double, double);
    extern long double copysignl(long double, long double);
    extern float nanf(const char *);
    extern double nan(const char *);
    extern long double nanl(const char *);
    extern float nextafterf(float, float);
    extern double nextafter(double, double);
    extern long double nextafterl(long double, long double);
    extern double nexttoward(double, long double);
    extern float nexttowardf(float, long double);
    extern long double nexttowardl(long double, long double);
    extern float fdimf(float, float);
    extern double fdim(double, double);
    extern long double fdiml(long double, long double);
    extern float fmaxf(float, float);
    extern double fmax(double, double);
    extern long double fmaxl(long double, long double);
    extern float fminf(float, float);
    extern double fmin(double, double);
    extern long double fminl(long double, long double);
    extern float fmaf(float, float, float);
    extern double fma(double, double, double);
    extern long double fmal(long double, long double, long double);
    extern float __inff() __attribute__((availability(macos, introduced=10.0, deprecated=10.9))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    extern double __inf() __attribute__((availability(macos, introduced=10.0, deprecated=10.9))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    extern long double __infl() __attribute__((availability(macos, introduced=10.0, deprecated=10.9))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    extern float __nan() __attribute__((availability(macos, introduced=10.0, deprecated=10.14))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    extern float __exp10f(float) __attribute__((availability(macos, introduced=10.9))) __attribute__((availability(ios, introduced=7.0)));
    extern double __exp10(double) __attribute__((availability(macos, introduced=10.9))) __attribute__((availability(ios, introduced=7.0)));
    inline void __sincosf(float __x, float *__sinp, float *__cosp) __attribute__((always_inline));
    inline void __sincos(double __x, double *__sinp, double *__cosp) __attribute__((always_inline));
    extern float __cospif(float) __attribute__((availability(macos, introduced=10.9))) __attribute__((availability(ios, introduced=7.0)));
    extern double __cospi(double) __attribute__((availability(macos, introduced=10.9))) __attribute__((availability(ios, introduced=7.0)));
    extern float __sinpif(float) __attribute__((availability(macos, introduced=10.9))) __attribute__((availability(ios, introduced=7.0)));
    extern double __sinpi(double) __attribute__((availability(macos, introduced=10.9))) __attribute__((availability(ios, introduced=7.0)));
    extern float __tanpif(float) __attribute__((availability(macos, introduced=10.9))) __attribute__((availability(ios, introduced=7.0)));
    extern double __tanpi(double) __attribute__((availability(macos, introduced=10.9))) __attribute__((availability(ios, introduced=7.0)));
    inline void __sincospif(float __x, float *__sinp, float *__cosp) __attribute__((always_inline));
    inline void __sincospi(double __x, double *__sinp, double *__cosp) __attribute__((always_inline));
    struct __float2 {
        float __sinval;
        float __cosval;
    };
    struct __double2 {
        double __sinval;
        double __cosval;
    };
    extern struct __float2 __sincosf_stret(float);
    extern struct __double2 __sincos_stret(double);
    extern struct __float2 __sincospif_stret(float);
    extern struct __double2 __sincospi_stret(double);
    inline void __sincosf(float __x, float *__sinp, float *__cosp) __attribute__((always_inline))     {
        const struct __float2 __stret = __sincosf_stret(__x);
        *__sinp = __stret.__sinval;
        *__cosp = __stret.__cosval;
    }
    inline void __sincos(double __x, double *__sinp, double *__cosp) __attribute__((always_inline))     {
        const struct __double2 __stret = __sincos_stret(__x);
        *__sinp = __stret.__sinval;
        *__cosp = __stret.__cosval;
    }
    inline void __sincospif(float __x, float *__sinp, float *__cosp) __attribute__((always_inline))     {
        const struct __float2 __stret = __sincospif_stret(__x);
        *__sinp = __stret.__sinval;
        *__cosp = __stret.__cosval;
    }
    inline void __sincospi(double __x, double *__sinp, double *__cosp) __attribute__((always_inline))     {
        const struct __double2 __stret = __sincospi_stret(__x);
        *__sinp = __stret.__sinval;
        *__cosp = __stret.__cosval;
    }
    extern double j0(double) __attribute__((availability(macos, introduced=10.0))) __attribute__((availability(ios, introduced=3.2)));
    extern double j1(double) __attribute__((availability(macos, introduced=10.0))) __attribute__((availability(ios, introduced=3.2)));
    extern double jn(int, double) __attribute__((availability(macos, introduced=10.0))) __attribute__((availability(ios, introduced=3.2)));
    extern double y0(double) __attribute__((availability(macos, introduced=10.0))) __attribute__((availability(ios, introduced=3.2)));
    extern double y1(double) __attribute__((availability(macos, introduced=10.0))) __attribute__((availability(ios, introduced=3.2)));
    extern double yn(int, double) __attribute__((availability(macos, introduced=10.0))) __attribute__((availability(ios, introduced=3.2)));
    extern double scalb(double, double);
    extern int signgam;
    extern long rinttol(double) __attribute__((availability(macos, introduced=10.0, deprecated=10.9))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    extern long roundtol(double) __attribute__((availability(macos, introduced=10.0, deprecated=10.9))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    extern double drem(double, double) __attribute__((availability(macos, introduced=10.0, deprecated=10.9))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    extern int finite(double) __attribute__((availability(macos, introduced=10.0, deprecated=10.9))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    extern double gamma(double) __attribute__((availability(macos, introduced=10.0, deprecated=10.9))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    extern double significand(double) __attribute__((availability(macos, introduced=10.0, deprecated=10.9))) __attribute__((availability(ios, unavailable))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
}
extern "C++" {
    namespace std {
        inline namespace __1 {
            enum float_round_style {
                round_indeterminate = -1,
                round_toward_zero = 0,
                round_to_nearest = 1,
                round_toward_infinity = 2,
                round_toward_neg_infinity = 3
            };
            enum float_denorm_style {
                denorm_indeterminate = -1,
                denorm_absent = 0,
                denorm_present = 1
            };
            template <class _Tp, bool = is_arithmetic<_Tp>::value> class __libcpp_numeric_limits {
            protected:
                typedef _Tp type;
                static const bool is_specialized = false;
                static std::__1::__libcpp_numeric_limits::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits::type();
                }
                static std::__1::__libcpp_numeric_limits::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits::type();
                }
                static std::__1::__libcpp_numeric_limits::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits::type();
                }
                static const int digits = 0;
                static const int digits10 = 0;
                static const int max_digits10 = 0;
                static const bool is_signed = false;
                static const bool is_integer = false;
                static const bool is_exact = false;
                static const int radix = 0;
                static std::__1::__libcpp_numeric_limits::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits::type();
                }
                static std::__1::__libcpp_numeric_limits::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits::type();
                }
                static const int min_exponent = 0;
                static const int min_exponent10 = 0;
                static const int max_exponent = 0;
                static const int max_exponent10 = 0;
                static const bool has_infinity = false;
                static const bool has_quiet_NaN = false;
                static const bool has_signaling_NaN = false;
                static const std::__1::float_denorm_style has_denorm = denorm_absent;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits::type();
                }
                static std::__1::__libcpp_numeric_limits::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits::type();
                }
                static std::__1::__libcpp_numeric_limits::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits::type();
                }
                static std::__1::__libcpp_numeric_limits::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits::type();
                }
                static const bool is_iec559 = false;
                static const bool is_bounded = false;
                static const bool is_modulo = false;
                static const bool traps = false;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_toward_zero;
            };
template<> class __libcpp_numeric_limits<unsigned long long, true> {
            protected:
                typedef unsigned long long type;
                static const bool is_specialized = true;
                static const bool is_signed = std::__1::__libcpp_numeric_limits<unsigned long long, true>::type(-1) < std::__1::__libcpp_numeric_limits<unsigned long long, true>::type(0);
                static const int digits = static_cast<int>(sizeof(std::__1::__libcpp_numeric_limits<unsigned long long, true>::type) * 8 - is_signed);
                static const int digits10 = digits * 3 / 10;
                static const int max_digits10 = 0;
                static const std::__1::__libcpp_numeric_limits<unsigned long long, true>::type __min = __libcpp_compute_min<type, digits, is_signed>::value;
                static const std::__1::__libcpp_numeric_limits<unsigned long long, true>::type __max = is_signed ? std::__1::__libcpp_numeric_limits<unsigned long long, true>::type(std::__1::__libcpp_numeric_limits<unsigned long long, true>::type(~0) ^ __min) : std::__1::__libcpp_numeric_limits<unsigned long long, true>::type(~0);
                static std::__1::__libcpp_numeric_limits<unsigned long long, true>::type min() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long long, true>::type max() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long long, true>::type lowest() throw() __attribute__((internal_linkage));
                static const bool is_integer = true;
                static const bool is_exact = true;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<unsigned long long, true>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long long, true>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = 0;
                static const int min_exponent10 = 0;
                static const int max_exponent = 0;
                static const int max_exponent10 = 0;
                static const bool has_infinity = false;
                static const bool has_quiet_NaN = false;
                static const bool has_signaling_NaN = false;
                static const std::__1::float_denorm_style has_denorm = denorm_absent;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<unsigned long long, true>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long long, true>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long long, true>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long long, true>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = false;
                static const bool is_bounded = true;
                static const bool is_modulo = !std::__1::is_signed<unsigned long long>::value;
                static const bool traps = true;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_toward_zero;
            };
template<> class __libcpp_numeric_limits<unsigned int, true> {
            protected:
                typedef unsigned int type;
                static const bool is_specialized = true;
                static const bool is_signed = std::__1::__libcpp_numeric_limits<unsigned int, true>::type(-1) < std::__1::__libcpp_numeric_limits<unsigned int, true>::type(0);
                static const int digits = static_cast<int>(sizeof(std::__1::__libcpp_numeric_limits<unsigned int, true>::type) * 8 - is_signed);
                static const int digits10 = digits * 3 / 10;
                static const int max_digits10 = 0;
                static const std::__1::__libcpp_numeric_limits<unsigned int, true>::type __min = __libcpp_compute_min<type, digits, is_signed>::value;
                static const std::__1::__libcpp_numeric_limits<unsigned int, true>::type __max = is_signed ? std::__1::__libcpp_numeric_limits<unsigned int, true>::type(std::__1::__libcpp_numeric_limits<unsigned int, true>::type(~0) ^ __min) : std::__1::__libcpp_numeric_limits<unsigned int, true>::type(~0);
                static std::__1::__libcpp_numeric_limits<unsigned int, true>::type min() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned int, true>::type max() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned int, true>::type lowest() throw() __attribute__((internal_linkage));
                static const bool is_integer = true;
                static const bool is_exact = true;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<unsigned int, true>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned int, true>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = 0;
                static const int min_exponent10 = 0;
                static const int max_exponent = 0;
                static const int max_exponent10 = 0;
                static const bool has_infinity = false;
                static const bool has_quiet_NaN = false;
                static const bool has_signaling_NaN = false;
                static const std::__1::float_denorm_style has_denorm = denorm_absent;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<unsigned int, true>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned int, true>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned int, true>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned int, true>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = false;
                static const bool is_bounded = true;
                static const bool is_modulo = !std::__1::is_signed<unsigned int>::value;
                static const bool traps = true;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_toward_zero;
            };
template<> class __libcpp_numeric_limits<unsigned long, true> {
            protected:
                typedef unsigned long type;
                static const bool is_specialized = true;
                static const bool is_signed = std::__1::__libcpp_numeric_limits<unsigned long, true>::type(-1) < std::__1::__libcpp_numeric_limits<unsigned long, true>::type(0);
                static const int digits = static_cast<int>(sizeof(std::__1::__libcpp_numeric_limits<unsigned long, true>::type) * 8 - is_signed);
                static const int digits10 = digits * 3 / 10;
                static const int max_digits10 = 0;
                static const std::__1::__libcpp_numeric_limits<unsigned long, true>::type __min = __libcpp_compute_min<type, digits, is_signed>::value;
                static const std::__1::__libcpp_numeric_limits<unsigned long, true>::type __max = is_signed ? std::__1::__libcpp_numeric_limits<unsigned long, true>::type(std::__1::__libcpp_numeric_limits<unsigned long, true>::type(~0) ^ __min) : std::__1::__libcpp_numeric_limits<unsigned long, true>::type(~0);
                static std::__1::__libcpp_numeric_limits<unsigned long, true>::type min() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long, true>::type max() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long, true>::type lowest() throw() __attribute__((internal_linkage));
                static const bool is_integer = true;
                static const bool is_exact = true;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<unsigned long, true>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long, true>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = 0;
                static const int min_exponent10 = 0;
                static const int max_exponent = 0;
                static const int max_exponent10 = 0;
                static const bool has_infinity = false;
                static const bool has_quiet_NaN = false;
                static const bool has_signaling_NaN = false;
                static const std::__1::float_denorm_style has_denorm = denorm_absent;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<unsigned long, true>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long, true>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long, true>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<unsigned long, true>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = false;
                static const bool is_bounded = true;
                static const bool is_modulo = !std::__1::is_signed<unsigned long>::value;
                static const bool traps = true;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_toward_zero;
            };
template<> class __libcpp_numeric_limits<long, true> {
            protected:
                typedef long type;
                static const bool is_specialized = true;
                static const bool is_signed = std::__1::__libcpp_numeric_limits<long, true>::type(-1) < std::__1::__libcpp_numeric_limits<long, true>::type(0);
                static const int digits = static_cast<int>(sizeof(std::__1::__libcpp_numeric_limits<long, true>::type) * 8 - is_signed);
                static const int digits10 = digits * 3 / 10;
                static const int max_digits10 = 0;
                static const std::__1::__libcpp_numeric_limits<long, true>::type __min = __libcpp_compute_min<type, digits, is_signed>::value;
                static const std::__1::__libcpp_numeric_limits<long, true>::type __max = is_signed ? std::__1::__libcpp_numeric_limits<long, true>::type(std::__1::__libcpp_numeric_limits<long, true>::type(~0) ^ __min) : std::__1::__libcpp_numeric_limits<long, true>::type(~0);
                static std::__1::__libcpp_numeric_limits<long, true>::type min() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long, true>::type max() throw() __attribute__((internal_linkage))                 {
                    return __max;
                }
                static std::__1::__libcpp_numeric_limits<long, true>::type lowest() throw() __attribute__((internal_linkage));
                static const bool is_integer = true;
                static const bool is_exact = true;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<long, true>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long, true>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = 0;
                static const int min_exponent10 = 0;
                static const int max_exponent = 0;
                static const int max_exponent10 = 0;
                static const bool has_infinity = false;
                static const bool has_quiet_NaN = false;
                static const bool has_signaling_NaN = false;
                static const std::__1::float_denorm_style has_denorm = denorm_absent;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<long, true>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long, true>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long, true>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long, true>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = false;
                static const bool is_bounded = true;
                static const bool is_modulo = !std::__1::is_signed<long>::value;
                static const bool traps = true;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_toward_zero;
            };
template<> class __libcpp_numeric_limits<long long, true> {
            protected:
                typedef long long type;
                static const bool is_specialized = true;
                static const bool is_signed = std::__1::__libcpp_numeric_limits<long long, true>::type(-1) < std::__1::__libcpp_numeric_limits<long long, true>::type(0);
                static const int digits = static_cast<int>(sizeof(std::__1::__libcpp_numeric_limits<long long, true>::type) * 8 - is_signed);
                static const int digits10 = digits * 3 / 10;
                static const int max_digits10 = 0;
                static const std::__1::__libcpp_numeric_limits<long long, true>::type __min = __libcpp_compute_min<type, digits, is_signed>::value;
                static const std::__1::__libcpp_numeric_limits<long long, true>::type __max = is_signed ? std::__1::__libcpp_numeric_limits<long long, true>::type(std::__1::__libcpp_numeric_limits<long long, true>::type(~0) ^ __min) : std::__1::__libcpp_numeric_limits<long long, true>::type(~0);
                static std::__1::__libcpp_numeric_limits<long long, true>::type min() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long long, true>::type max() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long long, true>::type lowest() throw() __attribute__((internal_linkage));
                static const bool is_integer = true;
                static const bool is_exact = true;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<long long, true>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long long, true>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = 0;
                static const int min_exponent10 = 0;
                static const int max_exponent = 0;
                static const int max_exponent10 = 0;
                static const bool has_infinity = false;
                static const bool has_quiet_NaN = false;
                static const bool has_signaling_NaN = false;
                static const std::__1::float_denorm_style has_denorm = denorm_absent;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<long long, true>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long long, true>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long long, true>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<long long, true>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = false;
                static const bool is_bounded = true;
                static const bool is_modulo = !std::__1::is_signed<long long>::value;
                static const bool traps = true;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_toward_zero;
            };
template<> class __libcpp_numeric_limits<char, true> {
            protected:
                typedef char type;
                static const bool is_specialized = true;
                static const bool is_signed = std::__1::__libcpp_numeric_limits<char, true>::type(-1) < std::__1::__libcpp_numeric_limits<char, true>::type(0);
                static const int digits = static_cast<int>(sizeof(std::__1::__libcpp_numeric_limits<char, true>::type) * 8 - is_signed);
                static const int digits10 = digits * 3 / 10;
                static const int max_digits10 = 0;
                static const std::__1::__libcpp_numeric_limits<char, true>::type __min = __libcpp_compute_min<type, digits, is_signed>::value;
                static const std::__1::__libcpp_numeric_limits<char, true>::type __max = is_signed ? std::__1::__libcpp_numeric_limits<char, true>::type(std::__1::__libcpp_numeric_limits<char, true>::type(~0) ^ __min) : std::__1::__libcpp_numeric_limits<char, true>::type(~0);
                static std::__1::__libcpp_numeric_limits<char, true>::type min() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<char, true>::type max() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<char, true>::type lowest() throw() __attribute__((internal_linkage));
                static const bool is_integer = true;
                static const bool is_exact = true;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<char, true>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<char, true>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = 0;
                static const int min_exponent10 = 0;
                static const int max_exponent = 0;
                static const int max_exponent10 = 0;
                static const bool has_infinity = false;
                static const bool has_quiet_NaN = false;
                static const bool has_signaling_NaN = false;
                static const std::__1::float_denorm_style has_denorm = denorm_absent;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<char, true>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<char, true>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<char, true>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::__libcpp_numeric_limits<char, true>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = false;
                static const bool is_bounded = true;
                static const bool is_modulo = !std::__1::is_signed<char>::value;
                static const bool traps = true;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_toward_zero;
            };
            template <class _Tp, int __digits, bool _IsSigned> struct __libcpp_compute_min {
                static const _Tp value = _Tp(_Tp(1) << __digits);
            };
template<> struct __libcpp_compute_min<unsigned long long, 64, false> {
                static const unsigned long long value = unsigned long long(0);
            };
template<> struct __libcpp_compute_min<unsigned int, 32, false> {
                static const unsigned int value = unsigned int(0);
            };
template<> struct __libcpp_compute_min<unsigned long, 64, false> {
                static const unsigned long value = unsigned long(0);
            };
template<> struct __libcpp_compute_min<long, 63, true> {
                static const long value = long(long(1) << 63);
            };
template<> struct __libcpp_compute_min<long long, 63, true> {
                static const long long value = long long(long long(1) << 63);
            };
template<> struct __libcpp_compute_min<char, 7, true> {
                static const char value = char(char(1) << 7);
            };
            template <class _Tp, int __digits> struct __libcpp_compute_min<_Tp, __digits, false> {
                static const _Tp value = _Tp(0);
            };
            template <class _Tp> class __libcpp_numeric_limits<_Tp, true> {
            protected:
                typedef _Tp type;
                static const bool is_specialized = true;
                static const bool is_signed = std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(-1) < std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(0);
                static const int digits = static_cast<int>(sizeof(std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type) * 8 - is_signed);
                static const int digits10 = digits * 3 / 10;
                static const int max_digits10 = 0;
                static const std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type __min = __libcpp_compute_min<type, digits, is_signed>::value;
                static const std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type __max = is_signed ? std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(~0) ^ __min) : std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(~0);
                static std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __min;
                }
                static std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __max;
                }
                static std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return min();
                }
                static const bool is_integer = true;
                static const bool is_exact = true;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(0);
                }
                static std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(0);
                }
                static const int min_exponent = 0;
                static const int min_exponent10 = 0;
                static const int max_exponent = 0;
                static const int max_exponent10 = 0;
                static const bool has_infinity = false;
                static const bool has_quiet_NaN = false;
                static const bool has_signaling_NaN = false;
                static const std::__1::float_denorm_style has_denorm = denorm_absent;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(0);
                }
                static std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(0);
                }
                static std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(0);
                }
                static std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<type-parameter-0-0, true>::type(0);
                }
                static const bool is_iec559 = false;
                static const bool is_bounded = true;
                static const bool is_modulo = !std::__1::is_signed<_Tp>::value;
                static const bool traps = true;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_toward_zero;
            };
            template<> class __libcpp_numeric_limits<bool, true> {
            protected:
                typedef bool type;
                static const bool is_specialized = true;
                static const bool is_signed = false;
                static const int digits = 1;
                static const int digits10 = 0;
                static const int max_digits10 = 0;
                static const std::__1::__libcpp_numeric_limits<bool, true>::type __min = false;
                static const std::__1::__libcpp_numeric_limits<bool, true>::type __max = true;
                static std::__1::__libcpp_numeric_limits<bool, true>::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __min;
                }
                static std::__1::__libcpp_numeric_limits<bool, true>::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __max;
                }
                static std::__1::__libcpp_numeric_limits<bool, true>::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return min();
                }
                static const bool is_integer = true;
                static const bool is_exact = true;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<bool, true>::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<bool, true>::type(0);
                }
                static std::__1::__libcpp_numeric_limits<bool, true>::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<bool, true>::type(0);
                }
                static const int min_exponent = 0;
                static const int min_exponent10 = 0;
                static const int max_exponent = 0;
                static const int max_exponent10 = 0;
                static const bool has_infinity = false;
                static const bool has_quiet_NaN = false;
                static const bool has_signaling_NaN = false;
                static const std::__1::float_denorm_style has_denorm = denorm_absent;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<bool, true>::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<bool, true>::type(0);
                }
                static std::__1::__libcpp_numeric_limits<bool, true>::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<bool, true>::type(0);
                }
                static std::__1::__libcpp_numeric_limits<bool, true>::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<bool, true>::type(0);
                }
                static std::__1::__libcpp_numeric_limits<bool, true>::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return std::__1::__libcpp_numeric_limits<bool, true>::type(0);
                }
                static const bool is_iec559 = false;
                static const bool is_bounded = true;
                static const bool is_modulo = false;
                static const bool traps = false;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_toward_zero;
            };
            template<> class __libcpp_numeric_limits<float, true> {
            protected:
                typedef float type;
                static const bool is_specialized = true;
                static const bool is_signed = true;
                static const int digits = 24;
                static const int digits10 = 6;
                static const int max_digits10 = 2 + (digits * 30103L) / 100000L;
                static std::__1::__libcpp_numeric_limits<float, true>::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 1.17549435E-38F;
                }
                static std::__1::__libcpp_numeric_limits<float, true>::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 3.40282347E+38F;
                }
                static std::__1::__libcpp_numeric_limits<float, true>::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return -max();
                }
                static const bool is_integer = false;
                static const bool is_exact = false;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<float, true>::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 1.1920929E-7F;
                }
                static std::__1::__libcpp_numeric_limits<float, true>::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 0.5F;
                }
                static const int min_exponent = (-125);
                static const int min_exponent10 = (-37);
                static const int max_exponent = 128;
                static const int max_exponent10 = 38;
                static const bool has_infinity = true;
                static const bool has_quiet_NaN = true;
                static const bool has_signaling_NaN = true;
                static const std::__1::float_denorm_style has_denorm = denorm_present;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<float, true>::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __builtin_huge_valf();
                }
                static std::__1::__libcpp_numeric_limits<float, true>::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __builtin_nanf("");
                }
                static std::__1::__libcpp_numeric_limits<float, true>::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __builtin_nansf("");
                }
                static std::__1::__libcpp_numeric_limits<float, true>::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 1.40129846E-45F;
                }
                static const bool is_iec559 = true;
                static const bool is_bounded = true;
                static const bool is_modulo = false;
                static const bool traps = false;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_to_nearest;
            };
            template<> class __libcpp_numeric_limits<double, true> {
            protected:
                typedef double type;
                static const bool is_specialized = true;
                static const bool is_signed = true;
                static const int digits = 53;
                static const int digits10 = 15;
                static const int max_digits10 = 2 + (digits * 30103L) / 100000L;
                static std::__1::__libcpp_numeric_limits<double, true>::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 2.2250738585072014E-308;
                }
                static std::__1::__libcpp_numeric_limits<double, true>::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 1.7976931348623157E+308;
                }
                static std::__1::__libcpp_numeric_limits<double, true>::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return -max();
                }
                static const bool is_integer = false;
                static const bool is_exact = false;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<double, true>::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 2.2204460492503131E-16;
                }
                static std::__1::__libcpp_numeric_limits<double, true>::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 0.5;
                }
                static const int min_exponent = (-1021);
                static const int min_exponent10 = (-307);
                static const int max_exponent = 1024;
                static const int max_exponent10 = 308;
                static const bool has_infinity = true;
                static const bool has_quiet_NaN = true;
                static const bool has_signaling_NaN = true;
                static const std::__1::float_denorm_style has_denorm = denorm_present;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<double, true>::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __builtin_huge_val();
                }
                static std::__1::__libcpp_numeric_limits<double, true>::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __builtin_nan("");
                }
                static std::__1::__libcpp_numeric_limits<double, true>::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __builtin_nans("");
                }
                static std::__1::__libcpp_numeric_limits<double, true>::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 4.9406564584124654E-324;
                }
                static const bool is_iec559 = true;
                static const bool is_bounded = true;
                static const bool is_modulo = false;
                static const bool traps = false;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_to_nearest;
            };
            template<> class __libcpp_numeric_limits<long double, true> {
            protected:
                typedef long double type;
                static const bool is_specialized = true;
                static const bool is_signed = true;
                static const int digits = 64;
                static const int digits10 = 18;
                static const int max_digits10 = 2 + (digits * 30103L) / 100000L;
                static std::__1::__libcpp_numeric_limits<long double, true>::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 3.36210314311209350626E-4932L;
                }
                static std::__1::__libcpp_numeric_limits<long double, true>::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 1.18973149535723176502E+4932L;
                }
                static std::__1::__libcpp_numeric_limits<long double, true>::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return -max();
                }
                static const bool is_integer = false;
                static const bool is_exact = false;
                static const int radix = 2;
                static std::__1::__libcpp_numeric_limits<long double, true>::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 1.08420217248550443401E-19L;
                }
                static std::__1::__libcpp_numeric_limits<long double, true>::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 0.5L;
                }
                static const int min_exponent = (-16381);
                static const int min_exponent10 = (-4931);
                static const int max_exponent = 16384;
                static const int max_exponent10 = 4932;
                static const bool has_infinity = true;
                static const bool has_quiet_NaN = true;
                static const bool has_signaling_NaN = true;
                static const std::__1::float_denorm_style has_denorm = denorm_present;
                static const bool has_denorm_loss = false;
                static std::__1::__libcpp_numeric_limits<long double, true>::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __builtin_huge_vall();
                }
                static std::__1::__libcpp_numeric_limits<long double, true>::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __builtin_nanl("");
                }
                static std::__1::__libcpp_numeric_limits<long double, true>::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __builtin_nansl("");
                }
                static std::__1::__libcpp_numeric_limits<long double, true>::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return 3.64519953188247460253E-4951L;
                }
                static const bool is_iec559 = true;
                static const bool is_bounded = true;
                static const bool is_modulo = false;
                static const bool traps = false;
                static const bool tinyness_before = false;
                static const std::__1::float_round_style round_style = round_to_nearest;
            };
            template <class _Tp> class __attribute__((type_visibility("default"))) numeric_limits : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type> {
                typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
                typedef typename __base::type type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::min();
                }
                static std::__1::numeric_limits::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::max();
                }
                static std::__1::numeric_limits::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::lowest();
                }
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::epsilon();
                }
                static std::__1::numeric_limits::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::round_error();
                }
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::infinity();
                }
                static std::__1::numeric_limits::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::quiet_NaN();
                }
                static std::__1::numeric_limits::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::signaling_NaN();
                }
                static std::__1::numeric_limits::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::denorm_min();
                }
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
template<> class numeric_limits<unsigned long long> : private __libcpp_numeric_limits<typename remove_cv<unsigned long long>::type> {
                typedef __libcpp_numeric_limits<typename remove_cv<unsigned long long>::type> __base;
                typedef typename __base::type type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits<unsigned long long>::type min() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long long>::type max() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long long>::type lowest() throw() __attribute__((internal_linkage));
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits<unsigned long long>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long long>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits<unsigned long long>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long long>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long long>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long long>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
template<> class numeric_limits<unsigned int> : private __libcpp_numeric_limits<typename remove_cv<unsigned int>::type> {
                typedef __libcpp_numeric_limits<typename remove_cv<unsigned int>::type> __base;
                typedef typename __base::type type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits<unsigned int>::type min() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned int>::type max() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned int>::type lowest() throw() __attribute__((internal_linkage));
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits<unsigned int>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned int>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits<unsigned int>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned int>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned int>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned int>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
template<> class numeric_limits<unsigned long> : private __libcpp_numeric_limits<typename remove_cv<unsigned long>::type> {
                typedef __libcpp_numeric_limits<typename remove_cv<unsigned long>::type> __base;
                typedef typename __base::type type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits<unsigned long>::type min() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long>::type max() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long>::type lowest() throw() __attribute__((internal_linkage));
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits<unsigned long>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits<unsigned long>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<unsigned long>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
template<> class numeric_limits<long> : private __libcpp_numeric_limits<typename remove_cv<long>::type> {
                typedef __libcpp_numeric_limits<typename remove_cv<long>::type> __base;
                typedef typename __base::type type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits<long>::type min() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long>::type max() throw() __attribute__((internal_linkage))                 {
                    return __base::max();
                }
                static std::__1::numeric_limits<long>::type lowest() throw() __attribute__((internal_linkage));
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits<long>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits<long>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
template<> class numeric_limits<long long> : private __libcpp_numeric_limits<typename remove_cv<long long>::type> {
                typedef __libcpp_numeric_limits<typename remove_cv<long long>::type> __base;
                typedef typename __base::type type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits<long long>::type min() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long long>::type max() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long long>::type lowest() throw() __attribute__((internal_linkage));
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits<long long>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long long>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits<long long>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long long>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long long>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<long long>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
template<> class numeric_limits<char> : private __libcpp_numeric_limits<typename remove_cv<char>::type> {
                typedef __libcpp_numeric_limits<typename remove_cv<char>::type> __base;
                typedef typename __base::type type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits<char>::type min() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<char>::type max() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<char>::type lowest() throw() __attribute__((internal_linkage));
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits<char>::type epsilon() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<char>::type round_error() throw() __attribute__((internal_linkage));
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits<char>::type infinity() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<char>::type quiet_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<char>::type signaling_NaN() throw() __attribute__((internal_linkage));
                static std::__1::numeric_limits<char>::type denorm_min() throw() __attribute__((internal_linkage));
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
            const bool is_specialized;
            const int digits;
            const int digits10;
            const int max_digits10;
            const bool is_signed;
            const bool is_integer;
            const bool is_exact;
            const int radix;
            const int min_exponent;
            const int min_exponent10;
            const int max_exponent;
            const int max_exponent10;
            const bool has_infinity;
            const bool has_quiet_NaN;
            const bool has_signaling_NaN;
            const std::__1::float_denorm_style has_denorm;
            const bool has_denorm_loss;
            const bool is_iec559;
            const bool is_bounded;
            const bool is_modulo;
            const bool traps;
            const bool tinyness_before;
            const std::__1::float_round_style round_style;
            template <class _Tp> class __attribute__((type_visibility("default"))) numeric_limits<const _Tp> : private numeric_limits<_Tp> {
                typedef numeric_limits<_Tp> __base;
                typedef _Tp type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits<const type-parameter-0-0>::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::min();
                }
                static std::__1::numeric_limits<const type-parameter-0-0>::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::max();
                }
                static std::__1::numeric_limits<const type-parameter-0-0>::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::lowest();
                }
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits<const type-parameter-0-0>::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::epsilon();
                }
                static std::__1::numeric_limits<const type-parameter-0-0>::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::round_error();
                }
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits<const type-parameter-0-0>::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::infinity();
                }
                static std::__1::numeric_limits<const type-parameter-0-0>::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::quiet_NaN();
                }
                static std::__1::numeric_limits<const type-parameter-0-0>::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::signaling_NaN();
                }
                static std::__1::numeric_limits<const type-parameter-0-0>::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::denorm_min();
                }
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
            const bool is_specialized;
            const int digits;
            const int digits10;
            const int max_digits10;
            const bool is_signed;
            const bool is_integer;
            const bool is_exact;
            const int radix;
            const int min_exponent;
            const int min_exponent10;
            const int max_exponent;
            const int max_exponent10;
            const bool has_infinity;
            const bool has_quiet_NaN;
            const bool has_signaling_NaN;
            const std::__1::float_denorm_style has_denorm;
            const bool has_denorm_loss;
            const bool is_iec559;
            const bool is_bounded;
            const bool is_modulo;
            const bool traps;
            const bool tinyness_before;
            const std::__1::float_round_style round_style;
            template <class _Tp> class __attribute__((type_visibility("default"))) numeric_limits<volatile _Tp> : private numeric_limits<_Tp> {
                typedef numeric_limits<_Tp> __base;
                typedef _Tp type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits<volatile type-parameter-0-0>::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::min();
                }
                static std::__1::numeric_limits<volatile type-parameter-0-0>::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::max();
                }
                static std::__1::numeric_limits<volatile type-parameter-0-0>::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::lowest();
                }
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits<volatile type-parameter-0-0>::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::epsilon();
                }
                static std::__1::numeric_limits<volatile type-parameter-0-0>::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::round_error();
                }
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits<volatile type-parameter-0-0>::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::infinity();
                }
                static std::__1::numeric_limits<volatile type-parameter-0-0>::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::quiet_NaN();
                }
                static std::__1::numeric_limits<volatile type-parameter-0-0>::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::signaling_NaN();
                }
                static std::__1::numeric_limits<volatile type-parameter-0-0>::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::denorm_min();
                }
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
            const bool is_specialized;
            const int digits;
            const int digits10;
            const int max_digits10;
            const bool is_signed;
            const bool is_integer;
            const bool is_exact;
            const int radix;
            const int min_exponent;
            const int min_exponent10;
            const int max_exponent;
            const int max_exponent10;
            const bool has_infinity;
            const bool has_quiet_NaN;
            const bool has_signaling_NaN;
            const std::__1::float_denorm_style has_denorm;
            const bool has_denorm_loss;
            const bool is_iec559;
            const bool is_bounded;
            const bool is_modulo;
            const bool traps;
            const bool tinyness_before;
            const std::__1::float_round_style round_style;
            template <class _Tp> class __attribute__((type_visibility("default"))) numeric_limits<const volatile _Tp> : private numeric_limits<_Tp> {
                typedef numeric_limits<_Tp> __base;
                typedef _Tp type;
            public:
                static const bool is_specialized = __base::is_specialized;
                static std::__1::numeric_limits<const volatile type-parameter-0-0>::type min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::min();
                }
                static std::__1::numeric_limits<const volatile type-parameter-0-0>::type max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::max();
                }
                static std::__1::numeric_limits<const volatile type-parameter-0-0>::type lowest() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::lowest();
                }
                static const int digits = __base::digits;
                static const int digits10 = __base::digits10;
                static const int max_digits10 = __base::max_digits10;
                static const bool is_signed = __base::is_signed;
                static const bool is_integer = __base::is_integer;
                static const bool is_exact = __base::is_exact;
                static const int radix = __base::radix;
                static std::__1::numeric_limits<const volatile type-parameter-0-0>::type epsilon() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::epsilon();
                }
                static std::__1::numeric_limits<const volatile type-parameter-0-0>::type round_error() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::round_error();
                }
                static const int min_exponent = __base::min_exponent;
                static const int min_exponent10 = __base::min_exponent10;
                static const int max_exponent = __base::max_exponent;
                static const int max_exponent10 = __base::max_exponent10;
                static const bool has_infinity = __base::has_infinity;
                static const bool has_quiet_NaN = __base::has_quiet_NaN;
                static const bool has_signaling_NaN = __base::has_signaling_NaN;
                static const std::__1::float_denorm_style has_denorm = __base::has_denorm;
                static const bool has_denorm_loss = __base::has_denorm_loss;
                static std::__1::numeric_limits<const volatile type-parameter-0-0>::type infinity() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::infinity();
                }
                static std::__1::numeric_limits<const volatile type-parameter-0-0>::type quiet_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::quiet_NaN();
                }
                static std::__1::numeric_limits<const volatile type-parameter-0-0>::type signaling_NaN() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::signaling_NaN();
                }
                static std::__1::numeric_limits<const volatile type-parameter-0-0>::type denorm_min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __base::denorm_min();
                }
                static const bool is_iec559 = __base::is_iec559;
                static const bool is_bounded = __base::is_bounded;
                static const bool is_modulo = __base::is_modulo;
                static const bool traps = __base::traps;
                static const bool tinyness_before = __base::tinyness_before;
                static const std::__1::float_round_style round_style = __base::round_style;
            };
            const bool is_specialized;
            const int digits;
            const int digits10;
            const int max_digits10;
            const bool is_signed;
            const bool is_integer;
            const bool is_exact;
            const int radix;
            const int min_exponent;
            const int min_exponent10;
            const int max_exponent;
            const int max_exponent10;
            const bool has_infinity;
            const bool has_quiet_NaN;
            const bool has_signaling_NaN;
            const std::__1::float_denorm_style has_denorm;
            const bool has_denorm_loss;
            const bool is_iec559;
            const bool is_bounded;
            const bool is_modulo;
            const bool traps;
            const bool tinyness_before;
            const std::__1::float_round_style round_style;
            const int digits;
            const int digits;
            const int digits;
            const int digits;
            const int digits;
        }
    }
    template <class _A1> bool __libcpp_signbit(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_signbitf((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_signbitd((double)(__lcpp_x)) : __inline_signbitl((long double)(__lcpp_x)));
    }
    template <class _A1> inline typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type signbit(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type signbit(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __lcpp_x < 0;
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type signbit(_A1) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return false;
    }
    template <class _A1> int __libcpp_fpclassify(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __fpclassifyf((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __fpclassifyd((double)(__lcpp_x)) : __fpclassifyl((long double)(__lcpp_x)));
    }
    template <class _A1> inline typename std::enable_if<std::is_floating_point<_A1>::value, int>::type fpclassify(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, int>::type fpclassify(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __lcpp_x == 0 ? 3 : 4;
    }
    template <class _A1> bool __libcpp_isfinite(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isfinitef((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isfinited((double)(__lcpp_x)) : __inline_isfinitel((long double)(__lcpp_x)));
    }
    template <class _A1> inline typename std::enable_if<std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity, bool>::type isfinite(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity, bool>::type isfinite(_A1) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return true;
    }
    template <class _A1> bool __libcpp_isinf(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isinff((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isinfd((double)(__lcpp_x)) : __inline_isinfl((long double)(__lcpp_x)));
    }
    template<> bool __libcpp_isinf<float>(float __lcpp_x) throw() __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isinff((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isinfd((double)(__lcpp_x)) : __inline_isinfl((long double)(__lcpp_x)));
    }
    template<> bool __libcpp_isinf<double>(double __lcpp_x) throw() __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isinff((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isinfd((double)(__lcpp_x)) : __inline_isinfl((long double)(__lcpp_x)));
    }
    template<> bool __libcpp_isinf<long double>(long double __lcpp_x) throw() __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isinff((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isinfd((double)(__lcpp_x)) : __inline_isinfl((long double)(__lcpp_x)));
    }
    template <class _A1> inline typename std::enable_if<std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity, bool>::type isinf(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity, bool>::type isinf(_A1) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return false;
    }
    inline bool isinf(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_isinf(__lcpp_x);
    }
    inline bool isinf(double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e41e28f8, "<no message provided>")))     {
        return __libcpp_isinf(__lcpp_x);
    }
    inline bool isinf(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_isinf(__lcpp_x);
    }
    template <class _A1> bool __libcpp_isnan(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isnanf((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isnand((double)(__lcpp_x)) : __inline_isnanl((long double)(__lcpp_x)));
    }
    template<> bool __libcpp_isnan<float>(float __lcpp_x) throw() __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isnanf((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isnand((double)(__lcpp_x)) : __inline_isnanl((long double)(__lcpp_x)));
    }
    template<> bool __libcpp_isnan<double>(double __lcpp_x) throw() __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isnanf((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isnand((double)(__lcpp_x)) : __inline_isnanl((long double)(__lcpp_x)));
    }
    template<> bool __libcpp_isnan<long double>(long double __lcpp_x) throw() __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isnanf((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isnand((double)(__lcpp_x)) : __inline_isnanl((long double)(__lcpp_x)));
    }
    template <class _A1> inline typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type isnan(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, bool>::type isnan(_A1) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return false;
    }
    inline bool isnan(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_isnan(__lcpp_x);
    }
    inline bool isnan(double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((enable_if(0x7ff5e41e63b8, "<no message provided>")))     {
        return __libcpp_isnan(__lcpp_x);
    }
    inline bool isnan(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_isnan(__lcpp_x);
    }
    template <class _A1> bool __libcpp_isnormal(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return (sizeof (__lcpp_x) == sizeof(float) ? __inline_isnormalf((float)(__lcpp_x)) : sizeof (__lcpp_x) == sizeof(double) ? __inline_isnormald((double)(__lcpp_x)) : __inline_isnormall((long double)(__lcpp_x)));
    }
    template <class _A1> inline typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type isnormal(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, bool>::type isnormal(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __lcpp_x != 0;
    }
    template <class _A1, class _A2> bool __libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __builtin_isgreater((__lcpp_x), (__lcpp_y));
    }
    template <class _A1, class _A2> inline typename std::enable_if<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, bool>::type isgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type type;
        return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
    }
    template <class _A1, class _A2> bool __libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __builtin_isgreaterequal((__lcpp_x), (__lcpp_y));
    }
    template <class _A1, class _A2> inline typename std::enable_if<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, bool>::type isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type type;
        return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
    }
    template <class _A1, class _A2> bool __libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __builtin_isless((__lcpp_x), (__lcpp_y));
    }
    template <class _A1, class _A2> inline typename std::enable_if<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, bool>::type isless(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type type;
        return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
    }
    template <class _A1, class _A2> bool __libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __builtin_islessequal((__lcpp_x), (__lcpp_y));
    }
    template <class _A1, class _A2> inline typename std::enable_if<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, bool>::type islessequal(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type type;
        return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
    }
    template <class _A1, class _A2> bool __libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __builtin_islessgreater((__lcpp_x), (__lcpp_y));
    }
    template <class _A1, class _A2> inline typename std::enable_if<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, bool>::type islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type type;
        return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
    }
    template <class _A1, class _A2> bool __libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return __builtin_isunordered((__lcpp_x), (__lcpp_y));
    }
    template <class _A1, class _A2> inline typename std::enable_if<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, bool>::type isunordered(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type type;
        return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
    }
    inline long abs(long __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::labs(__x);
    }
    inline long long abs(long long __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::llabs(__x);
    }
    inline float abs(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fabsf(__lcpp_x);
    }
    inline double abs(double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fabs(__lcpp_x);
    }
    inline long double abs(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fabsl(__lcpp_x);
    }
    inline ldiv_t div(long __x, long __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ldiv(__x, __y);
    }
    inline lldiv_t div(long long __x, long long __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lldiv(__x, __y);
    }
    inline float acos(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::acosf(__lcpp_x);
    }
    inline long double acos(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::acosl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type acos(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::acos((double)__lcpp_x);
    }
    inline float asin(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::asinf(__lcpp_x);
    }
    inline long double asin(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::asinl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type asin(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::asin((double)__lcpp_x);
    }
    inline float atan(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::atanf(__lcpp_x);
    }
    inline long double atan(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::atanl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type atan(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::atan((double)__lcpp_x);
    }
    inline float atan2(float __lcpp_y, float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::atan2f(__lcpp_y, __lcpp_x);
    }
    inline long double atan2(long double __lcpp_y, long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::atan2l(__lcpp_y, __lcpp_x);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type atan2(_A1 __lcpp_y, _A2 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
    }
    inline float ceil(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ceilf(__lcpp_x);
    }
    inline long double ceil(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ceill(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type ceil(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ceil((double)__lcpp_x);
    }
    inline float cos(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::cosf(__lcpp_x);
    }
    inline long double cos(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::cosl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type cos(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::cos((double)__lcpp_x);
    }
    inline float cosh(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::coshf(__lcpp_x);
    }
    inline long double cosh(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::coshl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type cosh(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::cosh((double)__lcpp_x);
    }
    inline float exp(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::expf(__lcpp_x);
    }
    inline long double exp(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::expl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type exp(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::exp((double)__lcpp_x);
    }
    inline float fabs(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fabsf(__lcpp_x);
    }
    inline long double fabs(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fabsl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type fabs(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fabs((double)__lcpp_x);
    }
    inline float floor(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::floorf(__lcpp_x);
    }
    inline long double floor(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::floorl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type floor(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::floor((double)__lcpp_x);
    }
    inline float fmod(float __lcpp_x, float __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fmodf(__lcpp_x, __lcpp_y);
    }
    inline long double fmod(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fmodl(__lcpp_x, __lcpp_y);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type fmod(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
    }
    inline float frexp(float __lcpp_x, int *__lcpp_e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::frexpf(__lcpp_x, __lcpp_e);
    }
    inline long double frexp(long double __lcpp_x, int *__lcpp_e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::frexpl(__lcpp_x, __lcpp_e);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type frexp(_A1 __lcpp_x, int *__lcpp_e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::frexp((double)__lcpp_x, __lcpp_e);
    }
    inline float ldexp(float __lcpp_x, int __lcpp_e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ldexpf(__lcpp_x, __lcpp_e);
    }
    inline long double ldexp(long double __lcpp_x, int __lcpp_e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ldexpl(__lcpp_x, __lcpp_e);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type ldexp(_A1 __lcpp_x, int __lcpp_e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ldexp((double)__lcpp_x, __lcpp_e);
    }
    inline float log(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::logf(__lcpp_x);
    }
    inline long double log(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::logl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type log(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log((double)__lcpp_x);
    }
    inline float log10(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log10f(__lcpp_x);
    }
    inline long double log10(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log10l(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type log10(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log10((double)__lcpp_x);
    }
    inline float modf(float __lcpp_x, float *__lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::modff(__lcpp_x, __lcpp_y);
    }
    inline long double modf(long double __lcpp_x, long double *__lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::modfl(__lcpp_x, __lcpp_y);
    }
    inline float pow(float __lcpp_x, float __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::powf(__lcpp_x, __lcpp_y);
    }
    inline long double pow(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::powl(__lcpp_x, __lcpp_y);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type pow(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
    }
    inline float sin(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::sinf(__lcpp_x);
    }
    inline long double sin(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::sinl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type sin(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::sin((double)__lcpp_x);
    }
    inline float sinh(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::sinhf(__lcpp_x);
    }
    inline long double sinh(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::sinhl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type sinh(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::sinh((double)__lcpp_x);
    }
    inline float sqrt(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::sqrtf(__lcpp_x);
    }
    inline long double sqrt(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::sqrtl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type sqrt(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::sqrt((double)__lcpp_x);
    }
    inline float tan(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::tanf(__lcpp_x);
    }
    inline long double tan(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::tanl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type tan(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::tan((double)__lcpp_x);
    }
    inline float tanh(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::tanhf(__lcpp_x);
    }
    inline long double tanh(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::tanhl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type tanh(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::tanh((double)__lcpp_x);
    }
    inline float acosh(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::acoshf(__lcpp_x);
    }
    inline long double acosh(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::acoshl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type acosh(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::acosh((double)__lcpp_x);
    }
    inline float asinh(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::asinhf(__lcpp_x);
    }
    inline long double asinh(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::asinhl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type asinh(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::asinh((double)__lcpp_x);
    }
    inline float atanh(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::atanhf(__lcpp_x);
    }
    inline long double atanh(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::atanhl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type atanh(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::atanh((double)__lcpp_x);
    }
    inline float cbrt(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::cbrtf(__lcpp_x);
    }
    inline long double cbrt(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::cbrtl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type cbrt(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::cbrt((double)__lcpp_x);
    }
    inline float copysign(float __lcpp_x, float __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::copysignf(__lcpp_x, __lcpp_y);
    }
    inline long double copysign(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::copysignl(__lcpp_x, __lcpp_y);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type copysign(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
    }
    inline float erf(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::erff(__lcpp_x);
    }
    inline long double erf(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::erfl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type erf(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::erf((double)__lcpp_x);
    }
    inline float erfc(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::erfcf(__lcpp_x);
    }
    inline long double erfc(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::erfcl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type erfc(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::erfc((double)__lcpp_x);
    }
    inline float exp2(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::exp2f(__lcpp_x);
    }
    inline long double exp2(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::exp2l(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type exp2(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::exp2((double)__lcpp_x);
    }
    inline float expm1(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::expm1f(__lcpp_x);
    }
    inline long double expm1(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::expm1l(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type expm1(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::expm1((double)__lcpp_x);
    }
    inline float fdim(float __lcpp_x, float __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fdimf(__lcpp_x, __lcpp_y);
    }
    inline long double fdim(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fdiml(__lcpp_x, __lcpp_y);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type fdim(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
    }
    inline float fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);
    }
    inline long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);
    }
    template <class _A1, class _A2, class _A3> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value && std::is_arithmetic<_A3>::value, std::__promote<_A1, _A2, _A3> >::type fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value && std::_IsSame<_A3, __result_type>::value)), "");
        return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
    }
    inline float fmax(float __lcpp_x, float __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fmaxf(__lcpp_x, __lcpp_y);
    }
    inline long double fmax(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fmaxl(__lcpp_x, __lcpp_y);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type fmax(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
    }
    inline float fmin(float __lcpp_x, float __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fminf(__lcpp_x, __lcpp_y);
    }
    inline long double fmin(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::fminl(__lcpp_x, __lcpp_y);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type fmin(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
    }
    inline float hypot(float __lcpp_x, float __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::hypotf(__lcpp_x, __lcpp_y);
    }
    inline long double hypot(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::hypotl(__lcpp_x, __lcpp_y);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type hypot(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
    }
    inline int ilogb(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ilogbf(__lcpp_x);
    }
    inline int ilogb(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ilogbl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, int>::type ilogb(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::ilogb((double)__lcpp_x);
    }
    inline float lgamma(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lgammaf(__lcpp_x);
    }
    inline long double lgamma(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lgammal(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type lgamma(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lgamma((double)__lcpp_x);
    }
    inline long long llrint(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::llrintf(__lcpp_x);
    }
    inline long long llrint(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::llrintl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, long long>::type llrint(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::llrint((double)__lcpp_x);
    }
    inline long long llround(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::llroundf(__lcpp_x);
    }
    inline long long llround(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::llroundl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, long long>::type llround(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::llround((double)__lcpp_x);
    }
    inline float log1p(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log1pf(__lcpp_x);
    }
    inline long double log1p(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log1pl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type log1p(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log1p((double)__lcpp_x);
    }
    inline float log2(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log2f(__lcpp_x);
    }
    inline long double log2(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log2l(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type log2(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::log2((double)__lcpp_x);
    }
    inline float logb(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::logbf(__lcpp_x);
    }
    inline long double logb(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::logbl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type logb(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::logb((double)__lcpp_x);
    }
    inline long lrint(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lrintf(__lcpp_x);
    }
    inline long lrint(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lrintl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, long>::type lrint(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lrint((double)__lcpp_x);
    }
    inline long lround(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lroundf(__lcpp_x);
    }
    inline long lround(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lroundl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, long>::type lround(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::lround((double)__lcpp_x);
    }
    inline float nearbyint(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::nearbyintf(__lcpp_x);
    }
    inline long double nearbyint(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::nearbyintl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type nearbyint(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::nearbyint((double)__lcpp_x);
    }
    inline float nextafter(float __lcpp_x, float __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::nextafterf(__lcpp_x, __lcpp_y);
    }
    inline long double nextafter(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::nextafterl(__lcpp_x, __lcpp_y);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type nextafter(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
    }
    inline float nexttoward(float __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::nexttowardf(__lcpp_x, __lcpp_y);
    }
    inline long double nexttoward(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::nexttowardl(__lcpp_x, __lcpp_y);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type nexttoward(_A1 __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::nexttoward((double)__lcpp_x, __lcpp_y);
    }
    inline float remainder(float __lcpp_x, float __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::remainderf(__lcpp_x, __lcpp_y);
    }
    inline long double remainder(long double __lcpp_x, long double __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::remainderl(__lcpp_x, __lcpp_y);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type remainder(_A1 __lcpp_x, _A2 __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
    }
    inline float remquo(float __lcpp_x, float __lcpp_y, int *__lcpp_z) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);
    }
    inline long double remquo(long double __lcpp_x, long double __lcpp_y, int *__lcpp_z) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);
    }
    template <class _A1, class _A2> inline typename std::_EnableIf<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, std::__promote<_A1, _A2> >::type remquo(_A1 __lcpp_x, _A2 __lcpp_y, int *__lcpp_z) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        typedef typename std::__promote<_A1, _A2>::type __result_type;
        static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
        return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
    }
    inline float rint(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::rintf(__lcpp_x);
    }
    inline long double rint(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::rintl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type rint(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::rint((double)__lcpp_x);
    }
    inline float round(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::roundf(__lcpp_x);
    }
    inline long double round(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::roundl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type round(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::round((double)__lcpp_x);
    }
    inline float scalbln(float __lcpp_x, long __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::scalblnf(__lcpp_x, __lcpp_y);
    }
    inline long double scalbln(long double __lcpp_x, long __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::scalblnl(__lcpp_x, __lcpp_y);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type scalbln(_A1 __lcpp_x, long __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::scalbln((double)__lcpp_x, __lcpp_y);
    }
    inline float scalbn(float __lcpp_x, int __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::scalbnf(__lcpp_x, __lcpp_y);
    }
    inline long double scalbn(long double __lcpp_x, int __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::scalbnl(__lcpp_x, __lcpp_y);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type scalbn(_A1 __lcpp_x, int __lcpp_y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::scalbn((double)__lcpp_x, __lcpp_y);
    }
    inline float tgamma(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::tgammaf(__lcpp_x);
    }
    inline long double tgamma(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::tgammal(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type tgamma(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::tgamma((double)__lcpp_x);
    }
    inline float trunc(float __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::truncf(__lcpp_x);
    }
    inline long double trunc(long double __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::truncl(__lcpp_x);
    }
    template <class _A1> inline typename std::enable_if<std::is_integral<_A1>::value, double>::type trunc(_A1 __lcpp_x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        return ::trunc((double)__lcpp_x);
    }
}
namespace std {
    inline namespace __1 {
        using ::size_t;
        using ::div_t;
        using ::ldiv_t;
        using ::lldiv_t;
        using ::atof;
        using ::atoi;
        using ::atol;
        using ::atoll;
        using ::strtod;
        using ::strtof;
        using ::strtold;
        using ::strtol;
        using ::strtoll;
        using ::strtoul;
        using ::strtoull;
        using ::rand;
        using ::srand;
        using ::calloc;
        using ::free;
        using ::malloc;
        using ::realloc;
        using ::abort;
        using ::atexit;
        using ::exit;
        using ::_Exit;
        using ::getenv;
        using ::system;
        using ::bsearch;
        using ::qsort;
        using ::abs;
        using ::labs;
        using ::llabs;
        using ::div;
        using ::ldiv;
        using ::lldiv;
        using ::mblen;
        using ::mbtowc;
        using ::wctomb;
        using ::mbstowcs;
        using ::wcstombs;
    }
}
namespace std {
    class __attribute__((visibility("default"))) exception {
    public:
        exception() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        virtual ~exception() throw();
        virtual const char *what() const throw();
    };
    class __attribute__((visibility("default"))) bad_exception : public std::exception {
    public:
        bad_exception() throw() : std::exception() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        virtual ~bad_exception() throw();
        virtual const char *what() const throw();
    };
    typedef void (*unexpected_handler)();
    std::unexpected_handler set_unexpected(std::unexpected_handler) throw() __attribute__((visibility("default")));
    std::unexpected_handler get_unexpected() throw() __attribute__((visibility("default")));
    void unexpected() __attribute__((visibility("default")));
    typedef void (*terminate_handler)();
    std::terminate_handler set_terminate(std::terminate_handler) throw() __attribute__((visibility("default")));
    std::terminate_handler get_terminate() throw() __attribute__((visibility("default")));
    void terminate() throw() __attribute__((visibility("default")));
    bool uncaught_exception() throw() __attribute__((visibility("default")));
    int uncaught_exceptions() throw() __attribute__((visibility("default"))) __attribute__((availability(macos, strict, introduced=10.12))) __attribute__((availability(ios, strict, introduced=10.0))) __attribute__((availability(tvos, strict, introduced=10.0))) __attribute__((availability(watchos, strict, introduced=3.0)));
    class __attribute__((visibility("default"))) exception_ptr;
    std::exception_ptr current_exception() throw() __attribute__((visibility("default")));
    void rethrow_exception(std::exception_ptr) __attribute__((visibility("default")));
    class __attribute__((visibility("default"))) exception_ptr {
        void *__ptr_;
    public:
        exception_ptr() throw() : __ptr_(/*implicit*/(void *)0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        exception_ptr(std::__1::nullptr_t) throw() : __ptr_(/*implicit*/(void *)0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        exception_ptr(const std::exception_ptr &) throw();
        std::exception_ptr &operator=(const std::exception_ptr &) throw();
        ~exception_ptr() throw();
        operator bool() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return this->__ptr_ != std::__1::__get_nullptr_t();
        }
        friend bool operator==(const std::exception_ptr &__x, const std::exception_ptr &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.__ptr_ == __y.__ptr_;
        }
;
        friend bool operator!=(const std::exception_ptr &__x, const std::exception_ptr &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
;
        friend std::exception_ptr current_exception() throw() __attribute__((visibility("default")));
        friend void rethrow_exception(std::exception_ptr) __attribute__((visibility("default")));
    };
    template <class _Ep> std::exception_ptr make_exception_ptr(_Ep __e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        try {
            throw __e;
        } catch (...) {
            return current_exception();
        }
    }
    class __attribute__((visibility("default"))) nested_exception {
        std::exception_ptr __ptr_;
    public:
        nested_exception() throw();
        virtual ~nested_exception() throw();
        void rethrow_nested() const;
        std::exception_ptr nested_ptr() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return this->__ptr_;
        }
    };
    template <class _Tp> struct __nested : public _Tp, public std::nested_exception {
        explicit __nested<_Tp>(const _Tp &__t) : _Tp(__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
    };
    template <class _Tp, class _Up, bool> struct __throw_with_nested;
    template <class _Tp, class _Up> struct __throw_with_nested<_Tp, _Up, true> {
        static inline void __do_throw(_Tp &&__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw __nested<_Up>(std::__1::forward<_Tp>(__t));
        }
    };
    template <class _Tp, class _Up> struct __throw_with_nested<_Tp, _Up, false> {
        static inline void __do_throw(_Tp &__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::__1::forward<_Tp>(__t);
        }
    };
    template <class _Tp> void throw_with_nested(_Tp &&__t)     {
        typedef typename decay<_Tp>::type _Up;
        static_assert(is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
        __throw_with_nested<_Tp, _Up, is_class<_Up>::value && !is_base_of<nested_exception, _Up>::value && !__libcpp_is_final<_Up>::value>::__do_throw(std::__1::forward<_Tp>(__t));
    }
    template <class _From, class _To> struct __can_dynamic_cast : public integral_constant<bool, (is_polymorphic<_From>::value && (!is_base_of<_To, _From>::value || is_convertible<const _From *, const _To *>::value))> {
    };
    template <class _Ep> inline void rethrow_if_nested(const _Ep &__e, typename enable_if<__can_dynamic_cast<_Ep, nested_exception>::value>::type * = 0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
        const std::nested_exception *__nep = dynamic_cast<const std::nested_exception *>(std::__1::addressof(__e));
        if (__nep)
            __nep->rethrow_nested();
    }
    template <class _Ep> inline void rethrow_if_nested(const _Ep &, typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type * = 0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))     {
    }
}
namespace std {
    struct __type_info_implementations {
        struct __string_impl_base {
            typedef const char *__type_name_t;
            static const char *__type_name_to_string(std::__type_info_implementations::__string_impl_base::__type_name_t __v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return __v;
            }
            static std::__type_info_implementations::__string_impl_base::__type_name_t __string_to_type_name(const char *__v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return __v;
            }
        };
        struct __unique_impl : std::__type_info_implementations::__string_impl_base {
            static size_t __hash(std::__type_info_implementations::__string_impl_base::__type_name_t __v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return reinterpret_cast<size_t>(__v);
            }
            static bool __eq(std::__type_info_implementations::__string_impl_base::__type_name_t __lhs, std::__type_info_implementations::__string_impl_base::__type_name_t __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return __lhs == __rhs;
            }
            static bool __lt(std::__type_info_implementations::__string_impl_base::__type_name_t __lhs, std::__type_info_implementations::__string_impl_base::__type_name_t __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return __lhs < __rhs;
            }
        };
        struct __non_unique_impl : std::__type_info_implementations::__string_impl_base {
            static size_t __hash(std::__type_info_implementations::__string_impl_base::__type_name_t __ptr) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                size_t __hash = 5381;
                while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
                    __hash = (__hash * 33) ^ __c;
                return __hash;
            }
            static bool __eq(std::__type_info_implementations::__string_impl_base::__type_name_t __lhs, std::__type_info_implementations::__string_impl_base::__type_name_t __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
            }
            static bool __lt(std::__type_info_implementations::__string_impl_base::__type_name_t __lhs, std::__type_info_implementations::__string_impl_base::__type_name_t __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return __builtin_strcmp(__lhs, __rhs) < 0;
            }
        };
        struct __non_unique_arm_rtti_bit_impl {
            typedef uintptr_t __type_name_t;
            static const char *__type_name_to_string(std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return reinterpret_cast<const char *>(__v & ~__non_unique_rtti_bit::value);
            }
            static std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __string_to_type_name(const char *__v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return reinterpret_cast<std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t>(__v);
            }
            static size_t __hash(std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                if (__is_type_name_unique(__v))
                    return reinterpret_cast<size_t>(__v);
                return __non_unique_impl::__hash(__type_name_to_string(__v));
            }
            static bool __eq(std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __lhs, std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                if (__lhs == __rhs)
                    return true;
                if (__is_type_name_unique(__lhs, __rhs))
                    return false;
                return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
            }
            static bool __lt(std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __lhs, std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                if (__is_type_name_unique(__lhs, __rhs))
                    return __lhs < __rhs;
                return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
            }
        private:
            typedef std::integral_constant<__type_name_t, (1ULL << ((8 * sizeof(__type_name_t)) - 1))> __non_unique_rtti_bit;
            static bool __is_type_name_unique(std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __lhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__lhs & __non_unique_rtti_bit::value);
            }
            static bool __is_type_name_unique(std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __lhs, std::__type_info_implementations::__non_unique_arm_rtti_bit_impl::__type_name_t __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !((__lhs & __rhs) & __non_unique_rtti_bit::value);
            }
        };
        typedef std::__type_info_implementations::__unique_impl __impl;
    };
    class __attribute__((visibility("default"))) type_info {
        std::type_info &operator=(const std::type_info &);
        type_info(const std::type_info &);
    protected:
        typedef __type_info_implementations::__impl __impl;
        __impl::__type_name_t __type_name;
        explicit type_info(const char *__n) : __type_name(__impl::__string_to_type_name(__n)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
    public:
        virtual ~type_info() __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
        const char *name() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __impl::__type_name_to_string(this->__type_name);
        }
        bool before(const std::type_info &__arg) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __impl::__lt(this->__type_name, __arg.__type_name);
        }
        size_t hash_code() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __impl::__hash(this->__type_name);
        }
        bool operator==(const std::type_info &__arg) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __impl::__eq(this->__type_name, __arg.__type_name);
        }
        bool operator!=(const std::type_info &__arg) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !this->operator==(__arg);
        }
    };
    class __attribute__((visibility("default"))) bad_cast : public std::exception {
    public:
        bad_cast() throw();
        virtual ~bad_cast() throw();
        virtual const char *what() const throw();
    };
    class __attribute__((visibility("default"))) bad_typeid : public std::exception {
    public:
        bad_typeid() throw();
        virtual ~bad_typeid() throw();
        virtual const char *what() const throw();
    };
}
namespace std {
    inline namespace __1 {
        inline void __throw_bad_cast() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::bad_cast();
        }
    }
}
namespace std {
    struct __attribute__((visibility("default"))) nothrow_t {
        explicit nothrow_t() = default
    };
    extern const std::nothrow_t nothrow __attribute__((visibility("default")));
    class __attribute__((visibility("default"))) bad_alloc : public std::exception {
    public:
        bad_alloc() throw();
        virtual ~bad_alloc() throw();
        virtual const char *what() const throw();
    };
    class __attribute__((visibility("default"))) bad_array_new_length : public std::bad_alloc {
    public:
        bad_array_new_length() throw();
        virtual ~bad_array_new_length() throw();
        virtual const char *what() const throw();
    };
    typedef void (*new_handler)();
    std::new_handler set_new_handler(std::new_handler) throw() __attribute__((visibility("default")));
    std::new_handler get_new_handler() throw() __attribute__((visibility("default")));
    void __throw_bad_alloc() __attribute__((visibility("default")));
    enum align_val_t {
        __zero = 0,
        __max = (size_t)-1
    };
}
void *operator new(std::size_t __sz) throw(std::bad_alloc) __attribute__((visibility("default")));
void *operator new(std::size_t __sz, const std::nothrow_t &) throw() __attribute__((visibility("default"))) __attribute__((malloc));
void operator delete(void *__p) throw() __attribute__((visibility("default")));
void operator delete(void *__p, const std::nothrow_t &) throw() __attribute__((visibility("default")));
void *operator new[](std::size_t __sz) throw(std::bad_alloc) __attribute__((visibility("default")));
void *operator new[](std::size_t __sz, const std::nothrow_t &) throw() __attribute__((visibility("default"))) __attribute__((malloc));
void operator delete[](void *__p) throw() __attribute__((visibility("default")));
void operator delete[](void *__p, const std::nothrow_t &) throw() __attribute__((visibility("default")));
void *operator new(std::size_t __sz, std::align_val_t) throw(std::bad_alloc) __attribute__((visibility("default")));
void *operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t &) throw() __attribute__((visibility("default"))) __attribute__((malloc));
void operator delete(void *__p, std::align_val_t) throw() __attribute__((visibility("default")));
void operator delete(void *__p, std::align_val_t, const std::nothrow_t &) throw() __attribute__((visibility("default")));
void *operator new[](std::size_t __sz, std::align_val_t) throw(std::bad_alloc) __attribute__((visibility("default")));
void *operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t &) throw() __attribute__((visibility("default"))) __attribute__((malloc));
void operator delete[](void *__p, std::align_val_t) throw() __attribute__((visibility("default")));
void operator delete[](void *__p, std::align_val_t, const std::nothrow_t &) throw() __attribute__((visibility("default")));
inline void *operator new(std::size_t, void *__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) {
    return __p;
}
inline void *operator new[](std::size_t, void *__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) {
    return __p;
}
inline void operator delete(void *, void *) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) {
}
inline void operator delete[](void *, void *) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) {
}
namespace std {
    inline namespace __1 {
        inline bool __is_overaligned_for_new(size_t __align) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __align > 16UL;
        }
        inline void *__libcpp_allocate(size_t __size, size_t __align) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ((void)__align);
            return __builtin_operator_new(__size);
        }
        struct _DeallocateCaller {
            static inline void __do_deallocate_handle_size_align(void *__ptr, size_t __size, size_t __align) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)__align);
                return __do_deallocate_handle_size(__ptr, __size);
            }
            static inline void __do_deallocate_handle_align(void *__ptr, size_t __align) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)__align);
                return __do_call(__ptr);
            }
        private:
            static inline void __do_deallocate_handle_size(void *__ptr, size_t __size)             {
                ((void)__size);
                return __do_call(__ptr);
            }
        private:
            template <class _A1, class _A2> static inline void __do_call(void *__ptr, _A1 __a1, _A2 __a2)             {
                return __builtin_operator_delete(__ptr, __a1, __a2);
            }
            template <class _A1> static inline void __do_call(void *__ptr, _A1 __a1)             {
                return __builtin_operator_delete(__ptr, __a1);
            }
            static inline void __do_call(void *__ptr)             {
                return __builtin_operator_delete(__ptr);
            }
        };
        inline void __libcpp_deallocate(void *__ptr, size_t __size, size_t __align) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            _DeallocateCaller::__do_deallocate_handle_size_align(__ptr, __size, __align);
        }
        inline void __libcpp_deallocate_unsized(void *__ptr, size_t __align) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            _DeallocateCaller::__do_deallocate_handle_align(__ptr, __align);
        }
        template <class _Tp> inline _Tp *__launder(_Tp *__p) throw()         {
            static_assert(!(is_function<_Tp>::value), "can't launder functions");
            static_assert(!(is_same<void, typename remove_cv<_Tp>::type>::value), "can't launder cv-void");
            return __builtin_launder(__p);
        }
    }
}
namespace std {
    inline namespace __1 {
        template <class _Arg1, class _Arg2, class _Result> struct __attribute__((type_visibility("default"))) binary_function {
            typedef _Arg1 first_argument_type;
            typedef _Arg2 second_argument_type;
            typedef _Result result_type;
        };
        template <class _Tp> struct __has_result_type {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_result_type::__two __test(...);
            template <class _Up> static char __test(typename _Up::result_type * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) less : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x < __y;
            }
        };
        template <class _Tp> struct __derives_from_unary_function {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            static std::__1::__derives_from_unary_function::__two __test(...);
            template <class _Ap, class _Rp> static unary_function<_Ap, _Rp> __test(const volatile unary_function<_Ap, _Rp> *);
        public:
            static const bool value = !is_same<decltype(__test((_Tp *)0)), __two>::value;
            typedef decltype(__test((_Tp *)0)) type;
        };
        template <class _Tp> struct __derives_from_binary_function {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            static std::__1::__derives_from_binary_function::__two __test(...);
            template <class _A1, class _A2, class _Rp> static binary_function<_A1, _A2, _Rp> __test(const volatile binary_function<_A1, _A2, _Rp> *);
        public:
            static const bool value = !is_same<decltype(__test((_Tp *)0)), __two>::value;
            typedef decltype(__test((_Tp *)0)) type;
        };
        template <class _Tp, bool = __derives_from_unary_function<_Tp>::value> struct __maybe_derive_from_unary_function : public __derives_from_unary_function<_Tp>::type {
        };
        template <class _Tp> struct __maybe_derive_from_unary_function<_Tp, false> {
        };
        template <class _Tp, bool = __derives_from_binary_function<_Tp>::value> struct __maybe_derive_from_binary_function : public __derives_from_binary_function<_Tp>::type {
        };
        template <class _Tp> struct __maybe_derive_from_binary_function<_Tp, false> {
        };
        template <class _Tp, bool = __has_result_type<_Tp>::value> struct __weak_result_type_imp : public __maybe_derive_from_unary_function<_Tp>, public __maybe_derive_from_binary_function<_Tp> {
            typedef typename _Tp::result_type result_type;
        };
        template <class _Tp> struct __weak_result_type_imp<_Tp, false> : public __maybe_derive_from_unary_function<_Tp>, public __maybe_derive_from_binary_function<_Tp> {
        };
        template <class _Tp> struct __weak_result_type : public __weak_result_type_imp<_Tp> {
        };
        template <class _Rp> struct __weak_result_type<_Rp ()> {
            typedef _Rp result_type;
        };
        template <class _Rp> struct __weak_result_type<_Rp (&)()> {
            typedef _Rp result_type;
        };
        template <class _Rp> struct __weak_result_type<_Rp (*)()> {
            typedef _Rp result_type;
        };
        template <class _Rp, class _A1> struct __weak_result_type<_Rp (_A1)> : public unary_function<_A1, _Rp> {
        };
        template <class _Rp, class _A1> struct __weak_result_type<_Rp (&)(_A1)> : public unary_function<_A1, _Rp> {
        };
        template <class _Rp, class _A1> struct __weak_result_type<_Rp (*)(_A1)> : public unary_function<_A1, _Rp> {
        };
        template <class _Rp, class _Cp> struct __weak_result_type<_Rp (_Cp::*)()> : public unary_function<_Cp *, _Rp> {
        };
        template <class _Rp, class _Cp> struct __weak_result_type<_Rp (_Cp::*)() const> : public unary_function<const _Cp *, _Rp> {
        };
        template <class _Rp, class _Cp> struct __weak_result_type<_Rp (_Cp::*)() volatile> : public unary_function<volatile _Cp *, _Rp> {
        };
        template <class _Rp, class _Cp> struct __weak_result_type<_Rp (_Cp::*)() const volatile> : public unary_function<const volatile _Cp *, _Rp> {
        };
        template <class _Rp, class _A1, class _A2> struct __weak_result_type<_Rp (_A1, _A2)> : public binary_function<_A1, _A2, _Rp> {
        };
        template <class _Rp, class _A1, class _A2> struct __weak_result_type<_Rp (*)(_A1, _A2)> : public binary_function<_A1, _A2, _Rp> {
        };
        template <class _Rp, class _A1, class _A2> struct __weak_result_type<_Rp (&)(_A1, _A2)> : public binary_function<_A1, _A2, _Rp> {
        };
        template <class _Rp, class _Cp, class _A1> struct __weak_result_type<_Rp (_Cp::*)(_A1)> : public binary_function<_Cp *, _A1, _Rp> {
        };
        template <class _Rp, class _Cp, class _A1> struct __weak_result_type<_Rp (_Cp::*)(_A1) const> : public binary_function<const _Cp *, _A1, _Rp> {
        };
        template <class _Rp, class _Cp, class _A1> struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile> : public binary_function<volatile _Cp *, _A1, _Rp> {
        };
        template <class _Rp, class _Cp, class _A1> struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile> : public binary_function<const volatile _Cp *, _A1, _Rp> {
        };
        template <class _Ret, class _T1, bool _IsFunc, bool _IsBase> struct __enable_invoke_imp;
        template <class _Ret, class _T1> struct __enable_invoke_imp<_Ret, _T1, true, true> {
            typedef _Ret _Bullet1;
            typedef std::__1::__enable_invoke_imp<type-parameter-0-0, type-parameter-0-1, true, true>::_Bullet1 type;
        };
        template <class _Ret, class _T1> struct __enable_invoke_imp<_Ret, _T1, true, false> {
            typedef _Ret _Bullet2;
            typedef std::__1::__enable_invoke_imp<type-parameter-0-0, type-parameter-0-1, true, false>::_Bullet2 type;
        };
        template <class _Ret, class _T1> struct __enable_invoke_imp<_Ret, _T1, false, true> {
            typedef typename add_lvalue_reference<typename __apply_cv<_T1, _Ret>::type>::type _Bullet3;
            typedef std::__1::__enable_invoke_imp<type-parameter-0-0, type-parameter-0-1, false, true>::_Bullet3 type;
        };
        template <class _Ret, class _T1> struct __enable_invoke_imp<_Ret, _T1, false, false> {
            typedef typename add_lvalue_reference<typename __apply_cv<decltype(*std::__1::declval<_T1>()), _Ret>::type>::type _Bullet4;
            typedef std::__1::__enable_invoke_imp<type-parameter-0-0, type-parameter-0-1, false, false>::_Bullet4 type;
        };
        template <class _Ret, class _T1> struct __enable_invoke_imp<_Ret, _T1 *, false, false> {
            typedef typename add_lvalue_reference<typename __apply_cv<_T1, _Ret>::type>::type _Bullet4;
            typedef std::__1::__enable_invoke_imp<type-parameter-0-0, type-parameter-0-1 *, false, false>::_Bullet4 type;
        };
        template <class _Fn, class _T1, class _Traits = __member_pointer_traits<_Fn>, class _Ret = typename _Traits::_ReturnType, class _Class = typename _Traits::_ClassType> struct __enable_invoke : __enable_invoke_imp<_Ret, _T1, is_member_function_pointer<_Fn>::value, is_base_of<_Class, typename remove_reference<_T1>::type>::value> {
        };
        std::__1::__nat __invoke(std::__1::__any, ...);
        template <class _Fn, class _T1> inline typename __enable_invoke<_Fn, _T1>::_Bullet1 __invoke(_Fn __f, _T1 &__t1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (__t1 .* __f)();
        }
        template <class _Fn, class _T1, class _A0> inline typename __enable_invoke<_Fn, _T1>::_Bullet1 __invoke(_Fn __f, _T1 &__t1, _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (__t1 .* __f)(__a0);
        }
        template <class _Fn, class _T1, class _A0, class _A1> inline typename __enable_invoke<_Fn, _T1>::_Bullet1 __invoke(_Fn __f, _T1 &__t1, _A0 &__a0, _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (__t1 .* __f)(__a0, __a1);
        }
        template <class _Fn, class _T1, class _A0, class _A1, class _A2> inline typename __enable_invoke<_Fn, _T1>::_Bullet1 __invoke(_Fn __f, _T1 &__t1, _A0 &__a0, _A1 &__a1, _A2 &__a2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (__t1 .* __f)(__a0, __a1, __a2);
        }
        template <class _Fn, class _T1> inline typename __enable_invoke<_Fn, _T1>::_Bullet2 __invoke(_Fn __f, _T1 &__t1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return ((*__t1) .* __f)();
        }
        template <class _Fn, class _T1, class _A0> inline typename __enable_invoke<_Fn, _T1>::_Bullet2 __invoke(_Fn __f, _T1 &__t1, _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return ((*__t1) .* __f)(__a0);
        }
        template <class _Fn, class _T1, class _A0, class _A1> inline typename __enable_invoke<_Fn, _T1>::_Bullet2 __invoke(_Fn __f, _T1 &__t1, _A0 &__a0, _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return ((*__t1) .* __f)(__a0, __a1);
        }
        template <class _Fn, class _T1, class _A0, class _A1, class _A2> inline typename __enable_invoke<_Fn, _T1>::_Bullet2 __invoke(_Fn __f, _T1 &__t1, _A0 &__a0, _A1 &__a1, _A2 &__a2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return ((*__t1) .* __f)(__a0, __a1, __a2);
        }
        template <class _Fn, class _T1> inline typename __enable_invoke<_Fn, _T1>::_Bullet3 __invoke(_Fn __f, _T1 &__t1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __t1 .* __f;
        }
        template <class _Fn, class _T1> inline typename __enable_invoke<_Fn, _T1>::_Bullet4 __invoke(_Fn __f, _T1 &__t1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (*__t1) .* __f;
        }
        template <class _Fp> inline decltype(std::__1::declval<_Fp &>()()) __invoke(_Fp &__f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __f();
        }
        template <class _Fp, class _A0> inline decltype(std::__1::declval<_Fp &>()(std::__1::declval<_A0 &>())) __invoke(_Fp &__f, _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __f(__a0);
        }
        template <class _Fp, class _A0, class _A1> inline decltype(std::__1::declval<_Fp &>()(std::__1::declval<_A0 &>(), std::__1::declval<_A1 &>())) __invoke(_Fp &__f, _A0 &__a0, _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __f(__a0, __a1);
        }
        template <class _Fp, class _A0, class _A1, class _A2> inline decltype(std::__1::declval<_Fp &>()(std::__1::declval<_A0 &>(), std::__1::declval<_A1 &>(), std::__1::declval<_A2 &>())) __invoke(_Fp &__f, _A0 &__a0, _A1 &__a1, _A2 &__a2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __f(__a0, __a1, __a2);
        }
        template <class _Fp, bool = __has_result_type<__weak_result_type<_Fp> >::value> struct __invoke_return {
            typedef typename __weak_result_type<_Fp>::result_type type;
        };
        template <class _Fp> struct __invoke_return<_Fp, false> {
            typedef decltype(__invoke(std::__1::declval<_Fp &>())) type;
        };
        template <class _Tp, class _A0> struct __invoke_return0 {
            typedef decltype(__invoke(std::__1::declval<_Tp &>(), std::__1::declval<_A0 &>())) type;
        };
        template <class _Rp, class _Tp, class _A0> struct __invoke_return0<_Rp _Tp::*, _A0> {
            typedef typename __enable_invoke<_Rp _Tp::*, _A0>::type type;
        };
        template <class _Tp, class _A0, class _A1> struct __invoke_return1 {
            typedef decltype(__invoke(std::__1::declval<_Tp &>(), std::__1::declval<_A0 &>(), std::__1::declval<_A1 &>())) type;
        };
        template <class _Rp, class _Class, class _A0, class _A1> struct __invoke_return1<_Rp _Class::*, _A0, _A1> {
            typedef typename __enable_invoke<_Rp _Class::*, _A0>::type type;
        };
        template <class _Tp, class _A0, class _A1, class _A2> struct __invoke_return2 {
            typedef decltype(__invoke(std::__1::declval<_Tp &>(), std::__1::declval<_A0 &>(), std::__1::declval<_A1 &>(), std::__1::declval<_A2 &>())) type;
        };
        template <class _Ret, class _Class, class _A0, class _A1, class _A2> struct __invoke_return2<_Ret _Class::*, _A0, _A1, _A2> {
            typedef typename __enable_invoke<_Ret _Class::*, _A0>::type type;
        };
        template <class _Ret> struct __invoke_void_return_wrapper {
            template <class _Fn> static _Ret __call(_Fn __f)             {
                return __invoke(__f);
            }
            template <class _Fn, class _A0> static _Ret __call(_Fn __f, _A0 &__a0)             {
                return __invoke(__f, __a0);
            }
            template <class _Fn, class _A0, class _A1> static _Ret __call(_Fn __f, _A0 &__a0, _A1 &__a1)             {
                return __invoke(__f, __a0, __a1);
            }
            template <class _Fn, class _A0, class _A1, class _A2> static _Ret __call(_Fn __f, _A0 &__a0, _A1 &__a1, _A2 &__a2)             {
                return __invoke(__f, __a0, __a1, __a2);
            }
        };
        template<> struct __invoke_void_return_wrapper<void> {
            template <class _Fn> static void __call(_Fn __f)             {
                __invoke(__f);
            }
            template <class _Fn, class _A0> static void __call(_Fn __f, _A0 &__a0)             {
                __invoke(__f, __a0);
            }
            template <class _Fn, class _A0, class _A1> static void __call(_Fn __f, _A0 &__a0, _A1 &__a1)             {
                __invoke(__f, __a0, __a1);
            }
            template <class _Fn, class _A0, class _A1, class _A2> static void __call(_Fn __f, _A0 &__a0, _A1 &__a1, _A2 &__a2)             {
                __invoke(__f, __a0, __a1, __a2);
            }
        };
        template <class _Tp> class __attribute__((type_visibility("default"))) reference_wrapper : public __weak_result_type<_Tp> {
        public:
            typedef _Tp type;
        private:
            std::__1::reference_wrapper::type *__f_;
        public:
            reference_wrapper<_Tp>(std::__1::reference_wrapper::type &__f) throw() : __f_(std::__1::addressof(__f)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            operator type &() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__f_;
            }
            std::__1::reference_wrapper::type &get() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__f_;
            }
            typename __invoke_return<type>::type operator()() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get());
            }
            template <class _A0> typename __invoke_return0<type, _A0>::type operator()(_A0 &__a0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0);
            }
            template <class _A0> typename __invoke_return0<type, const _A0>::type operator()(const _A0 &__a0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0);
            }
            template <class _A0, class _A1> typename __invoke_return1<type, _A0, _A1>::type operator()(_A0 &__a0, _A1 &__a1) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1);
            }
            template <class _A0, class _A1> typename __invoke_return1<type, const _A0, _A1>::type operator()(const _A0 &__a0, _A1 &__a1) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1);
            }
            template <class _A0, class _A1> typename __invoke_return1<type, _A0, const _A1>::type operator()(_A0 &__a0, const _A1 &__a1) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1);
            }
            template <class _A0, class _A1> typename __invoke_return1<type, const _A0, const _A1>::type operator()(const _A0 &__a0, const _A1 &__a1) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, _A0, _A1, _A2>::type operator()(_A0 &__a0, _A1 &__a1, _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, const _A0, _A1, _A2>::type operator()(const _A0 &__a0, _A1 &__a1, _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, _A0, const _A1, _A2>::type operator()(_A0 &__a0, const _A1 &__a1, _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, _A0, _A1, const _A2>::type operator()(_A0 &__a0, _A1 &__a1, const _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, const _A0, const _A1, _A2>::type operator()(const _A0 &__a0, const _A1 &__a1, _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, const _A0, _A1, const _A2>::type operator()(const _A0 &__a0, _A1 &__a1, const _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, _A0, const _A1, const _A2>::type operator()(_A0 &__a0, const _A1 &__a1, const _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, const _A0, const _A1, const _A2>::type operator()(const _A0 &__a0, const _A1 &__a1, const _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->get(), __a0, __a1, __a2);
            }
        };
        template <class _Tp> inline reference_wrapper<_Tp> ref(_Tp &__t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return reference_wrapper<_Tp>(__t);
        }
        template <class _Tp> inline reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return ref(__t.get());
        }
        template <class _Tp> inline reference_wrapper<const _Tp> cref(const _Tp &__t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return reference_wrapper<const _Tp>(__t);
        }
        template <class _Tp> inline reference_wrapper<const _Tp> cref(reference_wrapper<_Tp> __t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return cref(__t.get());
        }
        struct __attribute__((type_visibility("default"))) allocator_arg_t {
            explicit allocator_arg_t() = default
        };
        extern const std::__1::allocator_arg_t allocator_arg __attribute__((visibility("default")));
        template <class _Tp> struct __has_allocator_type {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_allocator_type::__two __test(...);
            template <class _Up> static char __test(typename _Up::allocator_type * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value> struct __uses_allocator : public integral_constant<bool, is_convertible<_Alloc, typename _Tp::allocator_type>::value> {
        };
        template <class _Tp, class _Alloc> struct __uses_allocator<_Tp, _Alloc, false> : public std::__1::false_type {
        };
        template <class _Tp, class _Alloc> struct __attribute__((type_visibility("default"))) uses_allocator : public __uses_allocator<_Tp, _Alloc> {
        };
    }
}
namespace std {
    inline namespace __1 {
        template <class _Iter> struct __attribute__((type_visibility("default"))) iterator_traits
template<> struct iterator_traits<int *> {
            typedef ptrdiff_t difference_type;
            typedef typename remove_cv<int>::type value_type;
            typedef int *pointer;
            typedef int &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        }
template<> struct iterator_traits<std::__1::__wrap_iter<int *>> : __iterator_traits<std::__1::__wrap_iter<int *>, __has_iterator_typedefs<__wrap_iter<int *> >::value> {
            using __primary_template = std::__1::iterator_traits<std::__1::__wrap_iter<int *> >;
        }
template<> struct iterator_traits<int> : __iterator_traits<int, __has_iterator_typedefs<int>::value> {
            using __primary_template = std::__1::iterator_traits<int>;
        }
template<> struct iterator_traits<std::__1::__wrap_iter<int>> : __iterator_traits<std::__1::__wrap_iter<int>, __has_iterator_typedefs<__wrap_iter<int> >::value> {
            using __primary_template = std::__1::iterator_traits<std::__1::__wrap_iter<int> >;
        }
template<> struct iterator_traits<const char *> {
            typedef ptrdiff_t difference_type;
            typedef typename remove_cv<const char>::type value_type;
            typedef const char *pointer;
            typedef const char &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        }
template<> struct iterator_traits<const wchar_t *> {
            typedef ptrdiff_t difference_type;
            typedef typename remove_cv<const wchar_t>::type value_type;
            typedef const wchar_t *pointer;
            typedef const wchar_t &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        }
template<> struct iterator_traits<const std::__1::basic_string<char> *> {
            typedef ptrdiff_t difference_type;
            typedef typename remove_cv<const basic_string<char> >::type value_type;
            typedef const std::__1::basic_string<char> *pointer;
            typedef const std::__1::basic_string<char> &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        }
template<> struct iterator_traits<std::__1::__wrap_iter<const std::__1::basic_string<char> *>> : __iterator_traits<std::__1::__wrap_iter<const std::__1::basic_string<char> *>, __has_iterator_typedefs<__wrap_iter<const basic_string<char> *> >::value> {
            using __primary_template = std::__1::iterator_traits<std::__1::__wrap_iter<const std::__1::basic_string<char> *> >;
        };
        struct __attribute__((type_visibility("default"))) input_iterator_tag {
        };
        struct __attribute__((type_visibility("default"))) output_iterator_tag {
        };
        struct __attribute__((type_visibility("default"))) forward_iterator_tag : public std::__1::input_iterator_tag {
        };
        struct __attribute__((type_visibility("default"))) bidirectional_iterator_tag : public std::__1::forward_iterator_tag {
        };
        struct __attribute__((type_visibility("default"))) random_access_iterator_tag : public std::__1::bidirectional_iterator_tag {
        };
        template <class _Iter> struct __iter_traits_cache {
            using type = _If<__is_primary_template<iterator_traits<_Iter> >::value, _Iter, iterator_traits<_Iter> >;
        };
        template <class _Iter> using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;
        struct __iter_concept_concept_test {
            template <class _Iter> using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
        };
        struct __iter_concept_category_test {
            template <class _Iter> using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
        };
        struct __iter_concept_random_fallback {
            template <class _Iter> using _Apply = _EnableIf<__is_primary_template<iterator_traits<_Iter> >::value, std::__1::random_access_iterator_tag>;
        };
        template <class _Iter, class _Tester> struct __test_iter_concept : _IsValidExpansion<_Tester::template _Apply, _Iter>, _Tester {
        };
        template <class _Iter> struct __iter_concept_cache {
            using type = _Or<__test_iter_concept<_Iter, std::__1::__iter_concept_concept_test>, __test_iter_concept<_Iter, std::__1::__iter_concept_category_test>, __test_iter_concept<_Iter, std::__1::__iter_concept_random_fallback> >;
        };
        template <class _Iter> using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::_Apply<_Iter>;
        template <class _Tp> struct __has_iterator_typedefs {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_iterator_typedefs::__two __test(...);
            template <class _Up> static char __test(typename std::__void_t<typename _Up::iterator_category>::type * = 0, typename std::__void_t<typename _Up::difference_type>::type * = 0, typename std::__void_t<typename _Up::value_type>::type * = 0, typename std::__void_t<typename _Up::reference>::type * = 0, typename std::__void_t<typename _Up::pointer>::type * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0, 0, 0, 0, 0)) == 1;
        };
template<> struct __has_iterator_typedefs<std::__1::__wrap_iter<int *>> {
        private:
            struct __two;
            template <class _Up> static std::__1::__has_iterator_typedefs<std::__1::__wrap_iter<int *> >::__two __test(...);
            template<> static std::__1::__has_iterator_typedefs<std::__1::__wrap_iter<int *> >::__two __test<std::__1::__wrap_iter<int *>>(...);
            template <class _Up> static char __test(typename std::__void_t<typename _Up::iterator_category>::type *, typename std::__void_t<typename _Up::difference_type>::type *, typename std::__void_t<typename _Up::value_type>::type *, typename std::__void_t<typename _Up::reference>::type *, typename std::__void_t<typename _Up::pointer>::type *);
            template<> static char __test<std::__1::__wrap_iter<int *>>(typename std::__void_t<typename __wrap_iter<int *>::iterator_category>::type *, typename std::__void_t<typename __wrap_iter<int *>::difference_type>::type *, typename std::__void_t<typename __wrap_iter<int *>::value_type>::type *, typename std::__void_t<typename __wrap_iter<int *>::reference>::type *, typename std::__void_t<typename __wrap_iter<int *>::pointer>::type *);
        public:
            static const bool value = sizeof (__test<std::__1::__wrap_iter<int *> >(0, 0, 0, 0, 0)) == 1;
        };
template<> struct __has_iterator_typedefs<int> {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_iterator_typedefs<int>::__two __test(...);
            template<> static std::__1::__has_iterator_typedefs<int>::__two __test<int>(...);
            template <class _Up> static char __test(typename std::__void_t<typename _Up::iterator_category>::type *, typename std::__void_t<typename _Up::difference_type>::type *, typename std::__void_t<typename _Up::value_type>::type *, typename std::__void_t<typename _Up::reference>::type *, typename std::__void_t<typename _Up::pointer>::type *);
        public:
            static const bool value = sizeof (__test<int>(0, 0, 0, 0, 0)) == 1;
        };
template<> struct __has_iterator_typedefs<std::__1::__wrap_iter<int>> {
        private:
            struct __two;
            template <class _Up> static std::__1::__has_iterator_typedefs<std::__1::__wrap_iter<int> >::__two __test(...);
            template<> static std::__1::__has_iterator_typedefs<std::__1::__wrap_iter<int> >::__two __test<std::__1::__wrap_iter<int>>(...);
            template <class _Up> static char __test(typename std::__void_t<typename _Up::iterator_category>::type *, typename std::__void_t<typename _Up::difference_type>::type *, typename std::__void_t<typename _Up::value_type>::type *, typename std::__void_t<typename _Up::reference>::type *, typename std::__void_t<typename _Up::pointer>::type *);
            template<> static char __test<std::__1::__wrap_iter<int>>(typename std::__void_t<typename __wrap_iter<int>::iterator_category>::type *, typename std::__void_t<typename __wrap_iter<int>::difference_type>::type *, typename std::__void_t<typename __wrap_iter<int>::value_type>::type *, typename std::__void_t<typename __wrap_iter<int>::reference>::type *, typename std::__void_t<typename __wrap_iter<int>::pointer>::type *);
        public:
            static const bool value = sizeof (__test<std::__1::__wrap_iter<int> >(0, 0, 0, 0, 0)) == 1;
        };
template<> struct __has_iterator_typedefs<std::__1::__wrap_iter<const std::__1::basic_string<char> *>> {
        private:
            struct __two;
            template <class _Up> static std::__1::__has_iterator_typedefs<std::__1::__wrap_iter<const std::__1::basic_string<char> *> >::__two __test(...);
            template<> static std::__1::__has_iterator_typedefs<std::__1::__wrap_iter<const std::__1::basic_string<char> *> >::__two __test<std::__1::__wrap_iter<const std::__1::basic_string<char> *>>(...);
            template <class _Up> static char __test(typename std::__void_t<typename _Up::iterator_category>::type *, typename std::__void_t<typename _Up::difference_type>::type *, typename std::__void_t<typename _Up::value_type>::type *, typename std::__void_t<typename _Up::reference>::type *, typename std::__void_t<typename _Up::pointer>::type *);
            template<> static char __test<std::__1::__wrap_iter<const std::__1::basic_string<char> *>>(typename std::__void_t<typename __wrap_iter<const basic_string<char> *>::iterator_category>::type *, typename std::__void_t<typename __wrap_iter<const basic_string<char> *>::difference_type>::type *, typename std::__void_t<typename __wrap_iter<const basic_string<char> *>::value_type>::type *, typename std::__void_t<typename __wrap_iter<const basic_string<char> *>::reference>::type *, typename std::__void_t<typename __wrap_iter<const basic_string<char> *>::pointer>::type *);
        public:
            static const bool value = sizeof (__test<std::__1::__wrap_iter<const std::__1::basic_string<char> *> >(0, 0, 0, 0, 0)) == 1;
        };
        template <class _Tp> struct __has_iterator_category {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Up> static std::__1::__has_iterator_category::__two __test(...);
            template <class _Up> static char __test(typename _Up::iterator_category * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
template<> struct __has_iterator_category<std::__1::iterator_traits<const char *>> {
        private:
            struct __two;
            template <class _Up> static std::__1::__has_iterator_category<std::__1::iterator_traits<const char *> >::__two __test(...);
            template<> static std::__1::__has_iterator_category<std::__1::iterator_traits<const char *> >::__two __test<std::__1::iterator_traits<const char *>>(...);
            template <class _Up> static char __test(typename _Up::iterator_category *);
            template<> static char __test<std::__1::iterator_traits<const char *>>(typename iterator_traits<const char *>::iterator_category *);
        public:
            static const bool value = sizeof (__test<std::__1::iterator_traits<const char *> >(0)) == 1;
        };
template<> struct __has_iterator_category<std::__1::iterator_traits<const wchar_t *>> {
        private:
            struct __two;
            template <class _Up> static std::__1::__has_iterator_category<std::__1::iterator_traits<const wchar_t *> >::__two __test(...);
            template<> static std::__1::__has_iterator_category<std::__1::iterator_traits<const wchar_t *> >::__two __test<std::__1::iterator_traits<const wchar_t *>>(...);
            template <class _Up> static char __test(typename _Up::iterator_category *);
            template<> static char __test<std::__1::iterator_traits<const wchar_t *>>(typename iterator_traits<const wchar_t *>::iterator_category *);
        public:
            static const bool value = sizeof (__test<std::__1::iterator_traits<const wchar_t *> >(0)) == 1;
        };
        template <class _Iter, bool> struct __iterator_traits_impl {
        };
template<> struct __iterator_traits_impl<std::__1::__wrap_iter<int *>, true> {
            typedef typename __wrap_iter<int *>::difference_type difference_type;
            typedef typename __wrap_iter<int *>::value_type value_type;
            typedef typename __wrap_iter<int *>::pointer pointer;
            typedef typename __wrap_iter<int *>::reference reference;
            typedef typename __wrap_iter<int *>::iterator_category iterator_category;
        };
template<> struct __iterator_traits_impl<std::__1::__wrap_iter<int>, false> {
        };
template<> struct __iterator_traits_impl<std::__1::__wrap_iter<const std::__1::basic_string<char> *>, true> {
            typedef typename __wrap_iter<const basic_string<char> *>::difference_type difference_type;
            typedef typename __wrap_iter<const basic_string<char> *>::value_type value_type;
            typedef typename __wrap_iter<const basic_string<char> *>::pointer pointer;
            typedef typename __wrap_iter<const basic_string<char> *>::reference reference;
            typedef typename __wrap_iter<const basic_string<char> *>::iterator_category iterator_category;
        };
        template <class _Iter> struct __iterator_traits_impl<_Iter, true> {
            typedef typename _Iter::difference_type difference_type;
            typedef typename _Iter::value_type value_type;
            typedef typename _Iter::pointer pointer;
            typedef typename _Iter::reference reference;
            typedef typename _Iter::iterator_category iterator_category;
        };
        template <class _Iter, bool> struct __iterator_traits {
        };
template<> struct __iterator_traits<std::__1::__wrap_iter<int *>, true> : __iterator_traits_impl<std::__1::__wrap_iter<int *>, is_convertible<typename __wrap_iter<int *>::iterator_category, input_iterator_tag>::value || is_convertible<typename __wrap_iter<int *>::iterator_category, output_iterator_tag>::value> {
        };
template<> struct __iterator_traits<int, false> {
        };
template<> struct __iterator_traits<std::__1::__wrap_iter<int>, true> : __iterator_traits_impl<std::__1::__wrap_iter<int>, is_convertible<typename __wrap_iter<int>::iterator_category, input_iterator_tag>::value || is_convertible<typename __wrap_iter<int>::iterator_category, output_iterator_tag>::value> {
        };
template<> struct __iterator_traits<std::__1::__wrap_iter<const std::__1::basic_string<char> *>, true> : __iterator_traits_impl<std::__1::__wrap_iter<const std::__1::basic_string<char> *>, is_convertible<typename __wrap_iter<const basic_string<char> *>::iterator_category, input_iterator_tag>::value || is_convertible<typename __wrap_iter<const basic_string<char> *>::iterator_category, output_iterator_tag>::value> {
        };
        template <class _Iter> struct __iterator_traits<_Iter, true> : __iterator_traits_impl<_Iter, is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value || is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value> {
        };
        template <class _Iter> struct __attribute__((type_visibility("default"))) iterator_traits : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {
            using __primary_template = iterator_traits<_Iter>;
        };
template<> struct iterator_traits<int *> {
            typedef ptrdiff_t difference_type;
            typedef typename remove_cv<int>::type value_type;
            typedef int *pointer;
            typedef int &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        };
template<> struct iterator_traits<std::__1::__wrap_iter<int *>> : __iterator_traits<std::__1::__wrap_iter<int *>, __has_iterator_typedefs<__wrap_iter<int *> >::value> {
            using __primary_template = std::__1::iterator_traits<std::__1::__wrap_iter<int *> >;
        };
template<> struct iterator_traits<int> : __iterator_traits<int, __has_iterator_typedefs<int>::value> {
            using __primary_template = std::__1::iterator_traits<int>;
        };
template<> struct iterator_traits<std::__1::__wrap_iter<int>> : __iterator_traits<std::__1::__wrap_iter<int>, __has_iterator_typedefs<__wrap_iter<int> >::value> {
            using __primary_template = std::__1::iterator_traits<std::__1::__wrap_iter<int> >;
        };
template<> struct iterator_traits<const char *> {
            typedef ptrdiff_t difference_type;
            typedef typename remove_cv<const char>::type value_type;
            typedef const char *pointer;
            typedef const char &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        };
template<> struct iterator_traits<const wchar_t *> {
            typedef ptrdiff_t difference_type;
            typedef typename remove_cv<const wchar_t>::type value_type;
            typedef const wchar_t *pointer;
            typedef const wchar_t &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        };
template<> struct iterator_traits<const std::__1::basic_string<char> *> {
            typedef ptrdiff_t difference_type;
            typedef typename remove_cv<const basic_string<char> >::type value_type;
            typedef const std::__1::basic_string<char> *pointer;
            typedef const std::__1::basic_string<char> &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        };
template<> struct iterator_traits<std::__1::__wrap_iter<const std::__1::basic_string<char> *>> : __iterator_traits<std::__1::__wrap_iter<const std::__1::basic_string<char> *>, __has_iterator_typedefs<__wrap_iter<const basic_string<char> *> >::value> {
            using __primary_template = std::__1::iterator_traits<std::__1::__wrap_iter<const std::__1::basic_string<char> *> >;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) iterator_traits<_Tp *> {
            typedef ptrdiff_t difference_type;
            typedef typename remove_cv<_Tp>::type value_type;
            typedef _Tp *pointer;
            typedef _Tp &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        };
        template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value> struct __has_iterator_category_convertible_to : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value> {
        };
template<> struct __has_iterator_category_convertible_to<const char *, std::__1::input_iterator_tag, true> : public integral_constant<bool, is_convertible<typename iterator_traits<const char *>::iterator_category, input_iterator_tag>::value> {
        };
template<> struct __has_iterator_category_convertible_to<const char *, std::__1::random_access_iterator_tag, true> : public integral_constant<bool, is_convertible<typename iterator_traits<const char *>::iterator_category, random_access_iterator_tag>::value> {
        };
template<> struct __has_iterator_category_convertible_to<const wchar_t *, std::__1::input_iterator_tag, true> : public integral_constant<bool, is_convertible<typename iterator_traits<const wchar_t *>::iterator_category, input_iterator_tag>::value> {
        };
template<> struct __has_iterator_category_convertible_to<const wchar_t *, std::__1::random_access_iterator_tag, true> : public integral_constant<bool, is_convertible<typename iterator_traits<const wchar_t *>::iterator_category, random_access_iterator_tag>::value> {
        };
        template <class _Tp, class _Up> struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public std::__1::false_type {
        };
        template <class _Tp> struct __is_cpp17_input_iterator : public __has_iterator_category_convertible_to<_Tp, std::__1::input_iterator_tag> {
        };
template<> struct __is_cpp17_input_iterator<const char *> : public __has_iterator_category_convertible_to<const char *, std::__1::input_iterator_tag> {
        };
template<> struct __is_cpp17_input_iterator<const wchar_t *> : public __has_iterator_category_convertible_to<const wchar_t *, std::__1::input_iterator_tag> {
        };
        template <class _Tp> struct __is_cpp17_forward_iterator : public __has_iterator_category_convertible_to<_Tp, std::__1::forward_iterator_tag> {
        };
        template <class _Tp> struct __is_cpp17_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, std::__1::bidirectional_iterator_tag> {
        };
        template <class _Tp> struct __is_cpp17_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, std::__1::random_access_iterator_tag> {
        };
template<> struct __is_cpp17_random_access_iterator<const char *> : public __has_iterator_category_convertible_to<const char *, std::__1::random_access_iterator_tag> {
        };
template<> struct __is_cpp17_random_access_iterator<const wchar_t *> : public __has_iterator_category_convertible_to<const wchar_t *, std::__1::random_access_iterator_tag> {
        };
        template <class _Tp> struct __is_cpp17_contiguous_iterator : public std::__1::false_type {
        };
        template <class _Tp> struct __is_exactly_cpp17_input_iterator : public integral_constant<bool, __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value && !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {
        };
        template <class _Category, class _Tp, class _Distance = ptrdiff_t, class _Pointer = _Tp *, class _Reference = _Tp &> struct __attribute__((type_visibility("default"))) iterator {
            typedef _Tp value_type;
            typedef _Distance difference_type;
            typedef _Pointer pointer;
            typedef _Reference reference;
            typedef _Category iterator_category;
        };
template<> struct iterator<std::__1::output_iterator_tag, void, void, void, void> {
            typedef void value_type;
            typedef void difference_type;
            typedef void pointer;
            typedef void reference;
            typedef std::__1::output_iterator_tag iterator_category;
        };
template<> struct iterator<std::__1::random_access_iterator_tag, int, long, int *, int &> {
            typedef int value_type;
            typedef long difference_type;
            typedef int *pointer;
            typedef int &reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        };
        template <class _InputIter> inline void __advance(_InputIter &__i, typename iterator_traits<_InputIter>::difference_type __n, std::__1::input_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __n > 0; --__n)
                ++__i;
        }
        template <class _BiDirIter> inline void __advance(_BiDirIter &__i, typename iterator_traits<_BiDirIter>::difference_type __n, std::__1::bidirectional_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__n >= 0)
                for (; __n > 0; --__n)
                    ++__i;
            else
                for (; __n < 0; ++__n)
                    --__i;
        }
        template <class _RandIter> inline void __advance(_RandIter &__i, typename iterator_traits<_RandIter>::difference_type __n, std::__1::random_access_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __i += __n;
        }
        template <class _InputIter> inline void advance(_InputIter &__i, typename iterator_traits<_InputIter>::difference_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ((void)0);
            __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
        }
        template <class _InputIter> inline typename iterator_traits<_InputIter>::difference_type __distance(_InputIter __first, _InputIter __last, std::__1::input_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typename iterator_traits<_InputIter>::difference_type __r(0);
            for (; __first != __last; ++__first)
                ++__r;
            return __r;
        }
        template <class _RandIter> inline typename iterator_traits<_RandIter>::difference_type __distance(_RandIter __first, _RandIter __last, std::__1::random_access_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __last - __first;
        }
        template <class _InputIter> inline typename iterator_traits<_InputIter>::difference_type distance(_InputIter __first, _InputIter __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
        }
        template <class _InputIter> inline typename enable_if<__is_cpp17_input_iterator<_InputIter>::value, _InputIter>::type next(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ((void)0);
            std::__1::advance(__x, __n);
            return __x;
        }
        template <class _InputIter> inline typename enable_if<__is_cpp17_input_iterator<_InputIter>::value, _InputIter>::type prev(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ((void)0);
            std::__1::advance(__x, -__n);
            return __x;
        }
        template <class _Tp, class = void> struct __is_stashing_iterator : std::__1::false_type {
        };
template<> struct __is_stashing_iterator<std::__1::__wrap_iter<int *>, void> : std::__1::false_type {
        };
        template <class _Tp> struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type> : std::__1::true_type {
        };
        template <class _Iter> class __attribute__((type_visibility("default"))) reverse_iterator : public iterator<typename iterator_traits<_Iter>::iterator_category, typename iterator_traits<_Iter>::value_type, typename iterator_traits<_Iter>::difference_type, typename iterator_traits<_Iter>::pointer, typename iterator_traits<_Iter>::reference> {
        private:
            _Iter __t;
            static_assert(!__is_stashing_iterator<_Iter>::value, "The specified iterator type cannot be used with reverse_iterator; Using stashing iterators with reverse_iterator causes undefined behavior");
        protected:
            _Iter current;
        public:
            typedef _Iter iterator_type;
            typedef typename iterator_traits<_Iter>::difference_type difference_type;
            typedef typename iterator_traits<_Iter>::reference reference;
            typedef typename iterator_traits<_Iter>::pointer pointer;
            reverse_iterator<_Iter>() : __t(), current() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit reverse_iterator<_Iter>(_Iter __x) : __t(__x), current(__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> reverse_iterator<_Iter>(const reverse_iterator<_Up> &__u) : __t(__u.base()), current(__u.base()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> reverse_iterator<_Iter> &operator=(const reverse_iterator<_Up> &__u) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__t = this->current = __u.base();
                return *this;
            }
            _Iter base() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->current;
            }
            std::__1::reverse_iterator::reference operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                _Iter __tmp = this->current;
                return *--__tmp;
            }
            std::__1::reverse_iterator::pointer operator->() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::addressof(this->operator*());
            }
            reverse_iterator<_Iter> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                --this->current;
                return *this;
            }
            reverse_iterator<_Iter> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                reverse_iterator<_Iter> __tmp(*this);
                --this->current;
                return __tmp;
            }
            reverse_iterator<_Iter> &operator--() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ++this->current;
                return *this;
            }
            reverse_iterator<_Iter> operator--(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                reverse_iterator<_Iter> __tmp(*this);
                ++this->current;
                return __tmp;
            }
            reverse_iterator<_Iter> operator+(std::__1::reverse_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return reverse_iterator<_Iter>(this->current - __n);
            }
            reverse_iterator<_Iter> &operator+=(std::__1::reverse_iterator::difference_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->current -= __n;
                return *this;
            }
            reverse_iterator<_Iter> operator-(std::__1::reverse_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return reverse_iterator<_Iter>(this->current + __n);
            }
            reverse_iterator<_Iter> &operator-=(std::__1::reverse_iterator::difference_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->current += __n;
                return *this;
            }
            std::__1::reverse_iterator::reference operator[](std::__1::reverse_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *(*this + __n);
            }
        };
template<> class reverse_iterator<std::__1::__wrap_iter<int *>> : public iterator<typename iterator_traits<__wrap_iter<int *> >::iterator_category, typename iterator_traits<__wrap_iter<int *> >::value_type, typename iterator_traits<__wrap_iter<int *> >::difference_type, typename iterator_traits<__wrap_iter<int *> >::pointer, typename iterator_traits<__wrap_iter<int *> >::reference> {
        private:
            std::__1::__wrap_iter<int *> __t;
            static_assert(!__is_stashing_iterator<__wrap_iter<int *> >::value, "The specified iterator type cannot be used with reverse_iterator; Using stashing iterators with reverse_iterator causes undefined behavior");
        protected:
            std::__1::__wrap_iter<int *> current;
        public:
            typedef std::__1::__wrap_iter<int *> iterator_type;
            typedef typename iterator_traits<__wrap_iter<int *> >::difference_type difference_type;
            typedef typename iterator_traits<__wrap_iter<int *> >::reference reference;
            typedef typename iterator_traits<__wrap_iter<int *> >::pointer pointer;
            reverse_iterator() __attribute__((internal_linkage));
            explicit reverse_iterator(std::__1::__wrap_iter<int *> __x) __attribute__((internal_linkage));
            template <class _Up> reverse_iterator(const reverse_iterator<_Up> &__u) __attribute__((internal_linkage));
            template <class _Up> std::__1::reverse_iterator<std::__1::__wrap_iter<int *> > &operator=(const reverse_iterator<_Up> &__u) __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> base() const __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> >::reference operator*() const __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> >::pointer operator->() const __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> > &operator++() __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> > operator++(int) __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> > &operator--() __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> > operator--(int) __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> > operator+(std::__1::reverse_iterator<std::__1::__wrap_iter<int *> >::difference_type __n) const __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> > &operator+=(std::__1::reverse_iterator<std::__1::__wrap_iter<int *> >::difference_type __n) __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> > operator-(std::__1::reverse_iterator<std::__1::__wrap_iter<int *> >::difference_type __n) const __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> > &operator-=(std::__1::reverse_iterator<std::__1::__wrap_iter<int *> >::difference_type __n) __attribute__((internal_linkage));
            std::__1::reverse_iterator<std::__1::__wrap_iter<int *> >::reference operator[](std::__1::reverse_iterator<std::__1::__wrap_iter<int *> >::difference_type __n) const __attribute__((internal_linkage));
        };
        template <class _Iter1, class _Iter2> inline bool operator==(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() == __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator<(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() > __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator!=(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() != __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator>(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() < __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator>=(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() <= __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator<=(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() >= __y.base();
        }
        template <class _Iter1, class _Iter2> inline typename reverse_iterator<_Iter1>::difference_type operator-(const reverse_iterator<_Iter1> &__x, const reverse_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y.base() - __x.base();
        }
        template <class _Iter> inline reverse_iterator<_Iter> operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return reverse_iterator<_Iter>(__x.base() - __n);
        }
        template <class _Container> class __attribute__((type_visibility("default"))) back_insert_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        protected:
            _Container *container;
        public:
            typedef _Container container_type;
            explicit back_insert_iterator<_Container>(_Container &__x) : container(std::__1::addressof(__x)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            back_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->container->push_back(__value_);
                return *this;
            }
            back_insert_iterator<_Container> &operator*() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            back_insert_iterator<_Container> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            back_insert_iterator<_Container> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
        };
template<> class back_insert_iterator<std::__1::basic_string<char>> : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        protected:
            std::__1::basic_string<char> *container;
        public:
            typedef std::__1::basic_string<char> container_type;
            explicit back_insert_iterator(std::__1::basic_string<char> &__x) __attribute__((internal_linkage));
            std::__1::back_insert_iterator<std::__1::basic_string<char> > &operator=(const typename basic_string<char>::value_type &__value_) __attribute__((internal_linkage));
            std::__1::back_insert_iterator<std::__1::basic_string<char> > &operator*() __attribute__((internal_linkage));
            std::__1::back_insert_iterator<std::__1::basic_string<char> > &operator++() __attribute__((internal_linkage));
            std::__1::back_insert_iterator<std::__1::basic_string<char> > operator++(int) __attribute__((internal_linkage));
        };
        template <class _Container> inline back_insert_iterator<_Container> back_inserter(_Container &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return back_insert_iterator<_Container>(__x);
        }
        template<> inline back_insert_iterator<std::__1::basic_string<char> > back_inserter<std::__1::basic_string<char>>(std::__1::basic_string<char> &__x) __attribute__((internal_linkage))        template <class _Container> class __attribute__((type_visibility("default"))) front_insert_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        protected:
            _Container *container;
        public:
            typedef _Container container_type;
            explicit front_insert_iterator<_Container>(_Container &__x) : container(std::__1::addressof(__x)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            front_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->container->push_front(__value_);
                return *this;
            }
            front_insert_iterator<_Container> &operator*() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            front_insert_iterator<_Container> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            front_insert_iterator<_Container> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
        };
        template <class _Container> inline front_insert_iterator<_Container> front_inserter(_Container &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return front_insert_iterator<_Container>(__x);
        }
        template <class _Container> class __attribute__((type_visibility("default"))) insert_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        protected:
            _Container *container;
            typename _Container::iterator iter;
        public:
            typedef _Container container_type;
            insert_iterator<_Container>(_Container &__x, typename _Container::iterator __i) : container(std::__1::addressof(__x)), iter(__i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            insert_iterator<_Container> &operator=(const typename _Container::value_type &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->iter = this->container->insert(this->iter, __value_);
                ++this->iter;
                return *this;
            }
            insert_iterator<_Container> &operator*() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            insert_iterator<_Container> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            insert_iterator<_Container> &operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
        };
        template <class _Container> inline insert_iterator<_Container> inserter(_Container &__x, typename _Container::iterator __i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return insert_iterator<_Container>(__x, __i);
        }
        template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t> class __attribute__((type_visibility("default"))) istream_iterator : public iterator<std::__1::input_iterator_tag, _Tp, _Distance, const _Tp *, const _Tp &> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_istream<_CharT, _Traits> istream_type;
        private:
            std::__1::istream_iterator::istream_type *__in_stream_;
            _Tp __value_;
        public:
            istream_iterator<_Tp, _CharT, _Traits, _Distance>() : __in_stream_(0), __value_() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            istream_iterator<_Tp, _CharT, _Traits, _Distance>(std::__1::istream_iterator::istream_type &__s) : __in_stream_(std::__1::addressof(__s)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (!(*this->__in_stream_ >> this->__value_))
                    this->__in_stream_ = 0;
            }
            const _Tp &operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__value_;
            }
            const _Tp *operator->() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::addressof((this->operator*()));
            }
            istream_iterator<_Tp, _CharT, _Traits, _Distance> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (!(*this->__in_stream_ >> this->__value_))
                    this->__in_stream_ = 0;
                return *this;
            }
            istream_iterator<_Tp, _CharT, _Traits, _Distance> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                istream_iterator<_Tp, _CharT, _Traits, _Distance> __t(*this);
                ++(*this);
                return __t;
            }
            friend template <class _Up, class _CharU, class _TraitsU, class _DistanceU> bool operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__x, const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            friend template <class _Up, class _CharU, class _TraitsU, class _DistanceU> bool operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__x, const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        };
        template <class _Tp, class _CharT, class _Traits, class _Distance> inline bool operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__x, const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.__in_stream_ == __y.__in_stream_;
        }
        template <class _Tp, class _CharT, class _Traits, class _Distance> inline bool operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__x, const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) ostream_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_ostream<_CharT, _Traits> ostream_type;
        private:
            std::__1::ostream_iterator::ostream_type *__out_stream_;
            const std::__1::ostream_iterator::char_type *__delim_;
        public:
            ostream_iterator<_Tp, _CharT, _Traits>(std::__1::ostream_iterator::ostream_type &__s) throw() : __out_stream_(std::__1::addressof(__s)), __delim_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ostream_iterator<_Tp, _CharT, _Traits>(std::__1::ostream_iterator::ostream_type &__s, const _CharT *__delimiter) throw() : __out_stream_(std::__1::addressof(__s)), __delim_(__delimiter) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ostream_iterator<_Tp, _CharT, _Traits> &operator=(const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                *this->__out_stream_ << __value_;
                if (this->__delim_)
                    *this->__out_stream_ << this->__delim_;
                return *this;
            }
            ostream_iterator<_Tp, _CharT, _Traits> &operator*() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            ostream_iterator<_Tp, _CharT, _Traits> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            ostream_iterator<_Tp, _CharT, _Traits> &operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
        };
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) istreambuf_iterator : public iterator<std::__1::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename _Traits::int_type int_type;
            typedef basic_streambuf<_CharT, _Traits> streambuf_type;
            typedef basic_istream<_CharT, _Traits> istream_type;
        private:
            mutable std::__1::istreambuf_iterator::streambuf_type *__sbuf_;
            class __proxy {
                std::__1::istreambuf_iterator::char_type __keep_;
                std::__1::istreambuf_iterator::streambuf_type *__sbuf_;
                __proxy(std::__1::istreambuf_iterator::char_type __c, std::__1::istreambuf_iterator::streambuf_type *__s) : __keep_(__c), __sbuf_(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                friend  class istreambuf_iterator<_CharT, _Traits>;
            public:
                std::__1::istreambuf_iterator::char_type operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return this->__keep_;
                }
            };
            bool __test_for_eof() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__sbuf_ && traits_type::eq_int_type(this->__sbuf_->sgetc(), traits_type::eof()))
                    this->__sbuf_ = 0;
                return this->__sbuf_ == 0;
            }
        public:
            istreambuf_iterator<_CharT, _Traits>() throw() : __sbuf_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            istreambuf_iterator<_CharT, _Traits>(std::__1::istreambuf_iterator::istream_type &__s) throw() : __sbuf_(__s.rdbuf()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            istreambuf_iterator<_CharT, _Traits>(std::__1::istreambuf_iterator::streambuf_type *__s) throw() : __sbuf_(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            istreambuf_iterator<_CharT, _Traits>(const std::__1::istreambuf_iterator::__proxy &__p) throw() : __sbuf_(__p.__sbuf_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::istreambuf_iterator::char_type operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::istreambuf_iterator::char_type>(this->__sbuf_->sgetc());
            }
            istreambuf_iterator<_CharT, _Traits> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__sbuf_->sbumpc();
                return *this;
            }
            std::__1::istreambuf_iterator::__proxy operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::istreambuf_iterator::__proxy(this->__sbuf_->sbumpc(), this->__sbuf_);
            }
            bool equal(const istreambuf_iterator<_CharT, _Traits> &__b) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__test_for_eof() == __b.__test_for_eof();
            }
        };
        template <class _CharT, class _Traits> inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __a.equal(__b);
        }
        template <class _CharT, class _Traits> inline bool operator!=(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !__a.equal(__b);
        }
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) ostreambuf_iterator : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef basic_streambuf<_CharT, _Traits> streambuf_type;
            typedef basic_ostream<_CharT, _Traits> ostream_type;
        private:
            std::__1::ostreambuf_iterator::streambuf_type *__sbuf_;
        public:
            ostreambuf_iterator<_CharT, _Traits>(std::__1::ostreambuf_iterator::ostream_type &__s) throw() : __sbuf_(__s.rdbuf()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ostreambuf_iterator<_CharT, _Traits>(std::__1::ostreambuf_iterator::streambuf_type *__s) throw() : __sbuf_(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ostreambuf_iterator<_CharT, _Traits> &operator=(_CharT __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__sbuf_ && traits_type::eq_int_type(this->__sbuf_->sputc(__c), traits_type::eof()))
                    this->__sbuf_ = 0;
                return *this;
            }
            ostreambuf_iterator<_CharT, _Traits> &operator*() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            ostreambuf_iterator<_CharT, _Traits> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            ostreambuf_iterator<_CharT, _Traits> &operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            bool failed() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__sbuf_ == 0;
            }
            friend template <class _Ch, class _Tr> ostreambuf_iterator<_Ch, _Tr> __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s, const _Ch *__ob, const _Ch *__op, const _Ch *__oe, std::__1::ios_base &__iob, _Ch __fl) __attribute__((visibility("hidden")));
        };
template<> class ostreambuf_iterator<char, std::__1::char_traits<char>> : public iterator<std::__1::output_iterator_tag, void, void, void, void> {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::__1::char_traits<char> > streambuf_type;
            typedef basic_ostream<char, std::__1::char_traits<char> > ostream_type;
        private:
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >::streambuf_type *__sbuf_;
        public:
            ostreambuf_iterator(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >::ostream_type &__s) throw() : iterator<std::__1::output_iterator_tag, void, void, void, void>(), __sbuf_(__s.rdbuf()) __attribute__((internal_linkage))             {
            }
            ostreambuf_iterator(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >::streambuf_type *__s) throw() __attribute__((internal_linkage));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator=(char __c) __attribute__((internal_linkage));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator*() __attribute__((internal_linkage));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator++() __attribute__((internal_linkage));
            std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > &operator++(int) __attribute__((internal_linkage));
            bool failed() const throw() __attribute__((internal_linkage))             {
                return this->__sbuf_ == 0;
            }
            friend template <class _Ch, class _Tr> ostreambuf_iterator<_Ch, _Tr> __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s, const _Ch *__ob, const _Ch *__op, const _Ch *__oe, std::__1::ios_base &__iob, _Ch __fl);
        };
        template <class _Iter> class __attribute__((type_visibility("default"))) move_iterator {
        private:
            _Iter __i;
        public:
            typedef _Iter iterator_type;
            typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
            typedef typename iterator_traits<iterator_type>::value_type value_type;
            typedef typename iterator_traits<iterator_type>::difference_type difference_type;
            typedef std::__1::move_iterator::iterator_type pointer;
            typedef typename iterator_traits<iterator_type>::reference reference;
            move_iterator<_Iter>() : __i() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit move_iterator<_Iter>(_Iter __x) : __i(__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> move_iterator<_Iter>(const move_iterator<_Up> &__u) : __i(__u.base()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Iter base() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__i;
            }
            std::__1::move_iterator::reference operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::move_iterator::reference>(*this->__i);
            }
            std::__1::move_iterator::pointer operator->() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__i;
            }
            move_iterator<_Iter> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ++this->__i;
                return *this;
            }
            move_iterator<_Iter> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                move_iterator<_Iter> __tmp(*this);
                ++this->__i;
                return __tmp;
            }
            move_iterator<_Iter> &operator--() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                --this->__i;
                return *this;
            }
            move_iterator<_Iter> operator--(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                move_iterator<_Iter> __tmp(*this);
                --this->__i;
                return __tmp;
            }
            move_iterator<_Iter> operator+(std::__1::move_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return move_iterator<_Iter>(this->__i + __n);
            }
            move_iterator<_Iter> &operator+=(std::__1::move_iterator::difference_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__i += __n;
                return *this;
            }
            move_iterator<_Iter> operator-(std::__1::move_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return move_iterator<_Iter>(this->__i - __n);
            }
            move_iterator<_Iter> &operator-=(std::__1::move_iterator::difference_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__i -= __n;
                return *this;
            }
            std::__1::move_iterator::reference operator[](std::__1::move_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::move_iterator::reference>(this->__i[__n]);
            }
        };
        template <class _Iter1, class _Iter2> inline bool operator==(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() == __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator<(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() < __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator!=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() != __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator>(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() > __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator>=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() >= __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator<=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() <= __y.base();
        }
        template <class _Iter1, class _Iter2> inline typename move_iterator<_Iter1>::difference_type operator-(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() - __y.base();
        }
        template <class _Iter> inline move_iterator<_Iter> operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return move_iterator<_Iter>(__x.base() + __n);
        }
        template <class _Iter> inline move_iterator<_Iter> make_move_iterator(_Iter __i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return move_iterator<_Iter>(__i);
        }
        template <class _Iter> class __wrap_iter
template<> class __wrap_iter<const std::__1::basic_string<char> *> {
        public:
            typedef const std::__1::basic_string<char> *iterator_type;
            typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
            typedef typename iterator_traits<iterator_type>::value_type value_type;
            typedef typename iterator_traits<iterator_type>::difference_type difference_type;
            typedef typename iterator_traits<iterator_type>::pointer pointer;
            typedef typename iterator_traits<iterator_type>::reference reference;
        private:
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::iterator_type __i;
        public:
            __wrap_iter() throw() __attribute__((internal_linkage));
            template <class _Up> __wrap_iter(const __wrap_iter<_Up> &__u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type *) throw() __attribute__((internal_linkage));
            template<> __wrap_iter<const std::__1::basic_string<char> *>(const __wrap_iter<const std::__1::basic_string<char> *> &__u, typename enable_if<is_convertible<const basic_string<char> *, iterator_type>::value>::type *) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::reference operator*() const throw() __attribute__((internal_linkage))             {
                return *this->__i;
            }
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> &operator++() throw() __attribute__((internal_linkage))             {
                ++this->__i;
                return *this;
            }
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> operator++(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> &operator--() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> operator--(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> operator+(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> &operator+=(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> operator-(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> &operator-=(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::reference operator[](std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::iterator_type base() const throw() __attribute__((internal_linkage))             {
                return this->__i;
            }
        private:
            __wrap_iter(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::iterator_type __x) throw() : __i(__x) __attribute__((internal_linkage))             {
            }
            friend template <class _Up> class __wrap_iter;
            friend template <class _CharT, class _Traits = char_traits<_CharT>, class _Alloc = allocator<_CharT>> class basic_string;
            friend template <class _Tp, class _Alloc = allocator<_Tp>> class vector;
            friend template <class _Tp, size_t> class span;
            friend template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1> __wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();
            friend template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2);
            friend template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2);
            friend template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>);
        }
template<> class __wrap_iter<int *> {
        public:
            typedef int *iterator_type;
            typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
            typedef typename iterator_traits<iterator_type>::value_type value_type;
            typedef typename iterator_traits<iterator_type>::difference_type difference_type;
            typedef typename iterator_traits<iterator_type>::pointer pointer;
            typedef typename iterator_traits<iterator_type>::reference reference;
        private:
            std::__1::__wrap_iter<int *>::iterator_type __i;
        public:
            __wrap_iter() throw() __attribute__((internal_linkage));
            template <class _Up> __wrap_iter(const __wrap_iter<_Up> &__u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type *) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *>::reference operator*() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> &operator++() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> operator++(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> &operator--() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> operator--(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> operator+(std::__1::__wrap_iter<int *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> &operator+=(std::__1::__wrap_iter<int *>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> operator-(std::__1::__wrap_iter<int *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> &operator-=(std::__1::__wrap_iter<int *>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *>::reference operator[](std::__1::__wrap_iter<int *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *>::iterator_type base() const throw() __attribute__((internal_linkage));
        private:
            __wrap_iter(std::__1::__wrap_iter<int *>::iterator_type __x) throw() __attribute__((internal_linkage));
            friend template <class _Up> class __wrap_iter;
            friend template <class _CharT, class _Traits = char_traits<_CharT>, class _Alloc = allocator<_CharT>> class basic_string;
            friend template <class _Tp, class _Alloc = allocator<_Tp>> class vector;
            friend template <class _Tp, size_t> class span;
            friend template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1> __wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();
            friend template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2);
            friend template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2);
            friend template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>);
        }
template<> class __wrap_iter<int> {
        public:
            typedef int iterator_type;
            typedef int iterator_category;
            typedef int value_type;
            typedef int difference_type;
            typedef int pointer;
            typedef int reference;
        private:
            std::__1::__wrap_iter<int>::iterator_type __i;
        public:
            __wrap_iter() throw() __attribute__((internal_linkage));
            template <class _Up> __wrap_iter(const __wrap_iter<_Up> &__u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type *) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int>::reference operator*() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> &operator++() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> operator++(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> &operator--() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> operator--(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> operator+(std::__1::__wrap_iter<int>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> &operator+=(std::__1::__wrap_iter<int>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> operator-(std::__1::__wrap_iter<int>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> &operator-=(std::__1::__wrap_iter<int>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int>::reference operator[](std::__1::__wrap_iter<int>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int>::iterator_type base() const throw() __attribute__((internal_linkage));
        private:
            __wrap_iter(std::__1::__wrap_iter<int>::iterator_type __x) throw() __attribute__((internal_linkage));
            friend template <class _Up> class __wrap_iter;
            friend template <class _CharT, class _Traits = char_traits<_CharT>, class _Alloc = allocator<_CharT>> class basic_string;
            friend template <class _Tp, class _Alloc = allocator<_Tp>> class vector;
            friend template <class _Tp, size_t> class span;
            friend template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1> __wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();
            friend template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2);
            friend template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2);
            friend template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>);
        };
        template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Iter> __wrap_iter<_Iter> operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Iter> class __wrap_iter {
        public:
            typedef _Iter iterator_type;
            typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
            typedef typename iterator_traits<iterator_type>::value_type value_type;
            typedef typename iterator_traits<iterator_type>::difference_type difference_type;
            typedef typename iterator_traits<iterator_type>::pointer pointer;
            typedef typename iterator_traits<iterator_type>::reference reference;
        private:
            std::__1::__wrap_iter::iterator_type __i;
        public:
            __wrap_iter<_Iter>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> __wrap_iter<_Iter>(const __wrap_iter<_Up> &__u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type * = 0) throw() : __i(__u.base()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__wrap_iter::reference operator*() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__i;
            }
            std::__1::__wrap_iter::pointer operator->() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (std::__1::__wrap_iter::pointer)std::__1::addressof(*this->__i);
            }
            __wrap_iter<_Iter> &operator++() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ++this->__i;
                return *this;
            }
            __wrap_iter<_Iter> operator++(int) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __wrap_iter<_Iter> __tmp(*this);
                ++(*this);
                return __tmp;
            }
            __wrap_iter<_Iter> &operator--() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                --this->__i;
                return *this;
            }
            __wrap_iter<_Iter> operator--(int) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __wrap_iter<_Iter> __tmp(*this);
                --(*this);
                return __tmp;
            }
            __wrap_iter<_Iter> operator+(std::__1::__wrap_iter::difference_type __n) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __wrap_iter<_Iter> __w(*this);
                __w += __n;
                return __w;
            }
            __wrap_iter<_Iter> &operator+=(std::__1::__wrap_iter::difference_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__i += __n;
                return *this;
            }
            __wrap_iter<_Iter> operator-(std::__1::__wrap_iter::difference_type __n) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this + (- __n);
            }
            __wrap_iter<_Iter> &operator-=(std::__1::__wrap_iter::difference_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                *this += - __n;
                return *this;
            }
            std::__1::__wrap_iter::reference operator[](std::__1::__wrap_iter::difference_type __n) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__i[__n];
            }
            std::__1::__wrap_iter::iterator_type base() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__i;
            }
        private:
            __wrap_iter<_Iter>(std::__1::__wrap_iter::iterator_type __x) throw() : __i(__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _Up> class __wrap_iter;
            friend template <class _CharT, class _Traits, class _Alloc> class basic_string;
            friend template <class _Tp, class _Alloc> class __attribute__((type_visibility("default"))) vector;
            friend template <class _Tp, size_t> class __attribute__((type_visibility("default"))) span;
            friend template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1> __wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();
            friend template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2);
            friend template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2);
            friend template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>);
        };
template<> class __wrap_iter<const std::__1::basic_string<char> *> {
        public:
            typedef const std::__1::basic_string<char> *iterator_type;
            typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
            typedef typename iterator_traits<iterator_type>::value_type value_type;
            typedef typename iterator_traits<iterator_type>::difference_type difference_type;
            typedef typename iterator_traits<iterator_type>::pointer pointer;
            typedef typename iterator_traits<iterator_type>::reference reference;
        private:
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::iterator_type __i;
        public:
            __wrap_iter() throw() __attribute__((internal_linkage));
            template <class _Up> __wrap_iter(const __wrap_iter<_Up> &__u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type *) throw() __attribute__((internal_linkage));
            template<> __wrap_iter<const std::__1::basic_string<char> *>(const __wrap_iter<const std::__1::basic_string<char> *> &__u, typename enable_if<is_convertible<const basic_string<char> *, iterator_type>::value>::type *) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::reference operator*() const throw() __attribute__((internal_linkage))             {
                return *this->__i;
            }
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> &operator++() throw() __attribute__((internal_linkage))             {
                ++this->__i;
                return *this;
            }
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> operator++(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> &operator--() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> operator--(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> operator+(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> &operator+=(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> operator-(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *> &operator-=(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::reference operator[](std::__1::__wrap_iter<const std::__1::basic_string<char> *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<const std::__1::basic_string<char> *>::iterator_type base() const throw() __attribute__((internal_linkage))             {
                return this->__i;
            }
        private:
            __wrap_iter(std::__1::__wrap_iter<const std::__1::basic_string<char> *>::iterator_type __x) throw() : __i(__x) __attribute__((internal_linkage))             {
            }
            friend template <class _Up> class __wrap_iter;
            friend template <class _CharT, class _Traits = char_traits<_CharT>, class _Alloc = allocator<_CharT>> class basic_string;
            friend template <class _Tp, class _Alloc = allocator<_Tp>> class vector;
            friend template <class _Tp, size_t> class span;
            friend template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1> __wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();
            friend template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2);
            friend template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2);
            friend template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>);
        };
template<> class __wrap_iter<int *> {
        public:
            typedef int *iterator_type;
            typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
            typedef typename iterator_traits<iterator_type>::value_type value_type;
            typedef typename iterator_traits<iterator_type>::difference_type difference_type;
            typedef typename iterator_traits<iterator_type>::pointer pointer;
            typedef typename iterator_traits<iterator_type>::reference reference;
        private:
            std::__1::__wrap_iter<int *>::iterator_type __i;
        public:
            __wrap_iter() throw() __attribute__((internal_linkage));
            template <class _Up> __wrap_iter(const __wrap_iter<_Up> &__u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type *) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *>::reference operator*() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> &operator++() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> operator++(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> &operator--() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> operator--(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> operator+(std::__1::__wrap_iter<int *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> &operator+=(std::__1::__wrap_iter<int *>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> operator-(std::__1::__wrap_iter<int *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *> &operator-=(std::__1::__wrap_iter<int *>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *>::reference operator[](std::__1::__wrap_iter<int *>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int *>::iterator_type base() const throw() __attribute__((internal_linkage));
        private:
            __wrap_iter(std::__1::__wrap_iter<int *>::iterator_type __x) throw() __attribute__((internal_linkage));
            friend template <class _Up> class __wrap_iter;
            friend template <class _CharT, class _Traits = char_traits<_CharT>, class _Alloc = allocator<_CharT>> class basic_string;
            friend template <class _Tp, class _Alloc = allocator<_Tp>> class vector;
            friend template <class _Tp, size_t> class span;
            friend template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1> __wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();
            friend template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2);
            friend template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2);
            friend template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>);
        };
template<> class __wrap_iter<int> {
        public:
            typedef int iterator_type;
            typedef int iterator_category;
            typedef int value_type;
            typedef int difference_type;
            typedef int pointer;
            typedef int reference;
        private:
            std::__1::__wrap_iter<int>::iterator_type __i;
        public:
            __wrap_iter() throw() __attribute__((internal_linkage));
            template <class _Up> __wrap_iter(const __wrap_iter<_Up> &__u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type *) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int>::reference operator*() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> &operator++() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> operator++(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> &operator--() throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> operator--(int) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> operator+(std::__1::__wrap_iter<int>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> &operator+=(std::__1::__wrap_iter<int>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> operator-(std::__1::__wrap_iter<int>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int> &operator-=(std::__1::__wrap_iter<int>::difference_type __n) throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int>::reference operator[](std::__1::__wrap_iter<int>::difference_type __n) const throw() __attribute__((internal_linkage));
            std::__1::__wrap_iter<int>::iterator_type base() const throw() __attribute__((internal_linkage));
        private:
            __wrap_iter(std::__1::__wrap_iter<int>::iterator_type __x) throw() __attribute__((internal_linkage));
            friend template <class _Up> class __wrap_iter;
            friend template <class _CharT, class _Traits = char_traits<_CharT>, class _Alloc = allocator<_CharT>> class basic_string;
            friend template <class _Tp, class _Alloc = allocator<_Tp>> class vector;
            friend template <class _Tp, size_t> class span;
            friend template <class _Iter1, class _Iter2> bool operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> bool operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1, class _Iter2> typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) throw();
            friend template <class _Iter1> __wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();
            friend template <class _Ip, class _Op> _Op copy(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 copy_backward(_B1, _B1, _B2);
            friend template <class _Ip, class _Op> _Op move(_Ip, _Ip, _Op);
            friend template <class _B1, class _B2> _B2 move_backward(_B1, _B1, _B2);
            friend template <class _Tp> typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *>);
        };
        template <class _Iter1, class _Iter2> inline bool operator==(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() == __y.base();
        }
        template<> inline bool operator==<const std::__1::basic_string<char> *, const std::__1::basic_string<char> *>(const __wrap_iter<const std::__1::basic_string<char> *> &__x, const __wrap_iter<const std::__1::basic_string<char> *> &__y) throw() __attribute__((internal_linkage))         {
            return __x.base() == __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator<(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() < __y.base();
        }
        template <class _Iter1, class _Iter2> inline bool operator!=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template<> inline bool operator!=<const std::__1::basic_string<char> *, const std::__1::basic_string<char> *>(const __wrap_iter<const std::__1::basic_string<char> *> &__x, const __wrap_iter<const std::__1::basic_string<char> *> &__y) throw() __attribute__((internal_linkage))        template <class _Iter1, class _Iter2> inline bool operator>(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Iter1, class _Iter2> inline bool operator>=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Iter1, class _Iter2> inline bool operator<=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Iter1> inline bool operator!=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template<> inline bool operator!=<const std::__1::basic_string<char> *>(const __wrap_iter<const std::__1::basic_string<char> *> &__x, const __wrap_iter<const std::__1::basic_string<char> *> &__y) throw() __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Iter1> inline bool operator>(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Iter1> inline bool operator>=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Iter1> inline bool operator<=(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter1> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Iter1, class _Iter2> inline typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1> &__x, const __wrap_iter<_Iter2> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.base() - __y.base();
        }
        template <class _Iter> inline __wrap_iter<_Iter> operator+(typename __wrap_iter<_Iter>::difference_type __n, __wrap_iter<_Iter> __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x += __n;
            return __x;
        }
        template <class _Iter> struct __libcpp_is_trivial_iterator : public integral_constant<bool, (is_pointer<_Iter>::value)> {
        };
        template <class _Iter> struct __libcpp_is_trivial_iterator<move_iterator<_Iter>> : public integral_constant<bool, (__libcpp_is_trivial_iterator<_Iter>::value)> {
        };
        template <class _Iter> struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter>> : public integral_constant<bool, (__libcpp_is_trivial_iterator<_Iter>::value)> {
        };
        template <class _Iter> struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter>> : public integral_constant<bool, (__libcpp_is_trivial_iterator<_Iter>::value)> {
        };
        template <class _Tp, size_t _Np> _Tp *begin(_Tp (&__array)[_Np]) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __array;
        }
        template <class _Tp, size_t _Np> _Tp *end(_Tp (&__array)[_Np]) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __array + _Np;
        }
        template <class _Cp> typename _Cp::iterator begin(_Cp &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c.begin();
        }
        template <class _Cp> typename _Cp::const_iterator begin(const _Cp &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c.begin();
        }
        template <class _Cp> typename _Cp::iterator end(_Cp &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c.end();
        }
        template <class _Cp> typename _Cp::const_iterator end(const _Cp &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c.end();
        }
    }
}
namespace std {
    inline namespace __1 {
    }
}
namespace std {
    inline namespace __1 {
        class __attribute__((visibility("hidden"))) __libcpp_refstring {
            const char *__imp_;
            bool __uses_refcount() const;
        public:
            explicit __libcpp_refstring(const char *__msg);
            __libcpp_refstring(const std::__1::__libcpp_refstring &__s) throw();
            std::__1::__libcpp_refstring &operator=(const std::__1::__libcpp_refstring &__s) throw();
            ~__libcpp_refstring();
            const char *c_str() const throw()             {
                return this->__imp_;
            }
        };
    }
}
namespace std {
    class __attribute__((visibility("default"))) logic_error : public std::exception {
    private:
        std::__1::__libcpp_refstring __imp_;
    public:
        explicit logic_error(const std::__1::string &);
        explicit logic_error(const char *);
        logic_error(const std::logic_error &) throw();
        std::logic_error &operator=(const std::logic_error &) throw();
        virtual ~logic_error() throw();
        virtual const char *what() const throw();
    };
    class __attribute__((visibility("default"))) runtime_error : public std::exception {
    private:
        std::__1::__libcpp_refstring __imp_;
    public:
        explicit runtime_error(const std::__1::string &);
        explicit runtime_error(const char *);
        runtime_error(const std::runtime_error &) throw();
        std::runtime_error &operator=(const std::runtime_error &) throw();
        virtual ~runtime_error() throw();
        virtual const char *what() const throw();
    };
    class __attribute__((visibility("default"))) domain_error : public std::logic_error {
    public:
        explicit domain_error(const std::__1::string &__s) : std::logic_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        explicit domain_error(const char *__s) : std::logic_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        virtual ~domain_error() throw();
    };
    class __attribute__((visibility("default"))) invalid_argument : public std::logic_error {
    public:
        explicit invalid_argument(const std::__1::string &__s) : std::logic_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        explicit invalid_argument(const char *__s) : std::logic_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        virtual ~invalid_argument() throw();
    };
    class __attribute__((visibility("default"))) length_error : public std::logic_error {
    public:
        explicit length_error(const std::__1::string &__s) : std::logic_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        explicit length_error(const char *__s) : std::logic_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        virtual ~length_error() throw();
    };
    class __attribute__((visibility("default"))) out_of_range : public std::logic_error {
    public:
        explicit out_of_range(const std::__1::string &__s) : std::logic_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        explicit out_of_range(const char *__s) : std::logic_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        virtual ~out_of_range() throw();
    };
    class __attribute__((visibility("default"))) range_error : public std::runtime_error {
    public:
        explicit range_error(const std::__1::string &__s) : std::runtime_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        explicit range_error(const char *__s) : std::runtime_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        virtual ~range_error() throw();
    };
    class __attribute__((visibility("default"))) overflow_error : public std::runtime_error {
    public:
        explicit overflow_error(const std::__1::string &__s) : std::runtime_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        explicit overflow_error(const char *__s) : std::runtime_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        virtual ~overflow_error() throw();
    };
    class __attribute__((visibility("default"))) underflow_error : public std::runtime_error {
    public:
        explicit underflow_error(const std::__1::string &__s) : std::runtime_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        explicit underflow_error(const char *__s) : std::runtime_error(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        virtual ~underflow_error() throw();
    };
}
namespace std {
    inline namespace __1 {
        void __throw_runtime_error(const char *) __attribute__((visibility("default")));
        inline void __throw_logic_error(const char *__msg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::logic_error(__msg);
        }
        inline void __throw_domain_error(const char *__msg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::domain_error(__msg);
        }
        inline void __throw_invalid_argument(const char *__msg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::invalid_argument(__msg);
        }
        inline void __throw_length_error(const char *__msg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::length_error(__msg);
        }
        inline void __throw_out_of_range(const char *__msg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::out_of_range(__msg);
        }
        inline void __throw_range_error(const char *__msg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::range_error(__msg);
        }
        inline void __throw_overflow_error(const char *__msg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::overflow_error(__msg);
        }
        inline void __throw_underflow_error(const char *__msg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::underflow_error(__msg);
        }
    }
}
namespace std {
    inline namespace __1 {
        enum __legacy_memory_order {
            __mo_relaxed,
            __mo_consume,
            __mo_acquire,
            __mo_release,
            __mo_acq_rel,
            __mo_seq_cst
        };
        typedef underlying_type<__legacy_memory_order>::type __memory_order_underlying_t;
        typedef enum memory_order {
            memory_order_relaxed = __mo_relaxed,
            memory_order_consume = __mo_consume,
            memory_order_acquire = __mo_acquire,
            memory_order_release = __mo_release,
            memory_order_acq_rel = __mo_acq_rel,
            memory_order_seq_cst = __mo_seq_cst
        } memory_order;
        static_assert((is_same<underlying_type<memory_order>::type, __memory_order_underlying_t>::value), "unexpected underlying type for std::memory_order");
        template <typename _Tp> struct __cxx_atomic_base_impl {
            __cxx_atomic_base_impl<_Tp>() throw() : __a_value() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit __cxx_atomic_base_impl<_Tp>(_Tp value) throw() : __a_value(value)             {
            }
            _Atomic(_Tp) __a_value;
        };
template<> struct __cxx_atomic_base_impl<bool> {
            __cxx_atomic_base_impl() throw() : __a_value(/*implicit*/(_Atomic(bool))0) __attribute__((internal_linkage))             {
            }
            explicit __cxx_atomic_base_impl(bool value) throw() : __a_value(value)             {
            }
            _Atomic(bool) __a_value;
        };
        inline void __cxx_atomic_thread_fence(std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __c11_atomic_thread_fence(static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        inline void __cxx_atomic_signal_fence(std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __c11_atomic_signal_fence(static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> void __cxx_atomic_init(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp __val) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __c11_atomic_init(&__a->__a_value, __val);
        }
        template <class _Tp> void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> *__a, _Tp __val) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __c11_atomic_init(&__a->__a_value, __val);
        }
        template <class _Tp> void __cxx_atomic_store(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp __val, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __c11_atomic_store(&__a->__a_value, __val, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template<> void __cxx_atomic_store<bool>(volatile __cxx_atomic_base_impl<bool> *__a, bool __val, std::__1::memory_order __order) throw() __attribute__((internal_linkage))         {
            __c11_atomic_store(&__a->__a_value, __val, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> *__a, _Tp __val, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __c11_atomic_store(&__a->__a_value, __val, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template<> void __cxx_atomic_store<bool>(__cxx_atomic_base_impl<bool> *__a, bool __val, std::__1::memory_order __order) throw() __attribute__((internal_linkage))         {
            __c11_atomic_store(&__a->__a_value, __val, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_load(const volatile __cxx_atomic_base_impl<_Tp> *__a, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type *;
            return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_load(const __cxx_atomic_base_impl<_Tp> *__a, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type *;
            return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_exchange(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp __value, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template<> bool __cxx_atomic_exchange<bool>(volatile __cxx_atomic_base_impl<bool> *__a, bool __value, std::__1::memory_order __order) throw() __attribute__((internal_linkage))         {
            return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> *__a, _Tp __value, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template<> bool __cxx_atomic_exchange<bool>(__cxx_atomic_base_impl<bool> *__a, bool __value, std::__1::memory_order __order) throw() __attribute__((internal_linkage))         {
            return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> bool __cxx_atomic_compare_exchange_strong(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp *__expected, _Tp __value, std::__1::memory_order __success, std::__1::memory_order __failure) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<std::__1::__memory_order_underlying_t>(__success), static_cast<std::__1::__memory_order_underlying_t>(__failure));
        }
        template <class _Tp> bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> *__a, _Tp *__expected, _Tp __value, std::__1::memory_order __success, std::__1::memory_order __failure) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<std::__1::__memory_order_underlying_t>(__success), static_cast<std::__1::__memory_order_underlying_t>(__failure));
        }
        template <class _Tp> bool __cxx_atomic_compare_exchange_weak(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp *__expected, _Tp __value, std::__1::memory_order __success, std::__1::memory_order __failure) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<std::__1::__memory_order_underlying_t>(__success), static_cast<std::__1::__memory_order_underlying_t>(__failure));
        }
        template <class _Tp> bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> *__a, _Tp *__expected, _Tp __value, std::__1::memory_order __success, std::__1::memory_order __failure) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<std::__1::__memory_order_underlying_t>(__success), static_cast<std::__1::__memory_order_underlying_t>(__failure));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_add(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp __delta, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> *__a, _Tp __delta, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp *__cxx_atomic_fetch_add(volatile __cxx_atomic_base_impl<_Tp *> *__a, ptrdiff_t __delta, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp *__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp *> *__a, ptrdiff_t __delta, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_sub(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp __delta, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> *__a, _Tp __delta, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp *__cxx_atomic_fetch_sub(volatile __cxx_atomic_base_impl<_Tp *> *__a, ptrdiff_t __delta, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp *__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp *> *__a, ptrdiff_t __delta, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_and(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_or(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_xor(volatile __cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern, std::__1::memory_order __order) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<std::__1::__memory_order_underlying_t>(__order));
        }
        template <class _Tp> _Tp kill_dependency(_Tp __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y;
        }
        template <typename _Tp, typename _Base = __cxx_atomic_base_impl<_Tp>> struct __cxx_atomic_impl : public _Base {
            __cxx_atomic_impl<_Tp, _Base>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit __cxx_atomic_impl<_Tp, _Base>(_Tp value) throw() : _Base(value) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
template<> struct __cxx_atomic_impl<bool, std::__1::__cxx_atomic_base_impl<bool>> : public std::__1::__cxx_atomic_base_impl<bool> {
            __cxx_atomic_impl() throw() : std::__1::__cxx_atomic_base_impl<bool>() __attribute__((internal_linkage))             {
            }
            explicit __cxx_atomic_impl(bool value) throw() : std::__1::__cxx_atomic_base_impl<bool>(value) __attribute__((internal_linkage))             {
            }
        };
        template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value> struct __atomic_base {
            mutable __cxx_atomic_impl<_Tp> __a_;
            bool is_lock_free() const volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __c11_atomic_is_lock_free(sizeof(_Tp));
            }
            bool is_lock_free() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<const volatile __atomic_base<_Tp, > *>(this)->is_lock_free();
            }
            void store(_Tp __d, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e4350710, "memory order argument to atomic operation is invalid", "warning")))             {
                __cxx_atomic_store(&this->__a_, __d, __m);
            }
            void store(_Tp __d, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e4350e18, "memory order argument to atomic operation is invalid", "warning")))             {
                __cxx_atomic_store(&this->__a_, __d, __m);
            }
            _Tp load(std::__1::memory_order __m = memory_order_seq_cst) const volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e43512c0, "memory order argument to atomic operation is invalid", "warning")))             {
                return __cxx_atomic_load(&this->__a_, __m);
            }
            _Tp load(std::__1::memory_order __m = memory_order_seq_cst) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e4351768, "memory order argument to atomic operation is invalid", "warning")))             {
                return __cxx_atomic_load(&this->__a_, __m);
            }
            operator _Tp() const volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return load();
            }
            operator _Tp() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return load();
            }
            _Tp exchange(_Tp __d, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_exchange(&this->__a_, __d, __m);
            }
            _Tp exchange(_Tp __d, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_exchange(&this->__a_, __d, __m);
            }
            bool compare_exchange_weak(_Tp &__e, _Tp __d, std::__1::memory_order __s, std::__1::memory_order __f) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e4351c10, "memory order argument to atomic operation is invalid", "warning")))             {
                return __cxx_atomic_compare_exchange_weak(&this->__a_, &__e, __d, __s, __f);
            }
            bool compare_exchange_weak(_Tp &__e, _Tp __d, std::__1::memory_order __s, std::__1::memory_order __f) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e43520b8, "memory order argument to atomic operation is invalid", "warning")))             {
                return __cxx_atomic_compare_exchange_weak(&this->__a_, &__e, __d, __s, __f);
            }
            bool compare_exchange_strong(_Tp &__e, _Tp __d, std::__1::memory_order __s, std::__1::memory_order __f) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e4352588, "memory order argument to atomic operation is invalid", "warning")))             {
                return __cxx_atomic_compare_exchange_strong(&this->__a_, &__e, __d, __s, __f);
            }
            bool compare_exchange_strong(_Tp &__e, _Tp __d, std::__1::memory_order __s, std::__1::memory_order __f) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e4352a30, "memory order argument to atomic operation is invalid", "warning")))             {
                return __cxx_atomic_compare_exchange_strong(&this->__a_, &__e, __d, __s, __f);
            }
            bool compare_exchange_weak(_Tp &__e, _Tp __d, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_compare_exchange_weak(&this->__a_, &__e, __d, __m, __m);
            }
            bool compare_exchange_weak(_Tp &__e, _Tp __d, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_compare_exchange_weak(&this->__a_, &__e, __d, __m, __m);
            }
            bool compare_exchange_strong(_Tp &__e, _Tp __d, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_compare_exchange_strong(&this->__a_, &__e, __d, __m, __m);
            }
            bool compare_exchange_strong(_Tp &__e, _Tp __d, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_compare_exchange_strong(&this->__a_, &__e, __d, __m, __m);
            }
            __atomic_base<_Tp, >() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __atomic_base<_Tp, >(_Tp __d) throw() : __a_(__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        private:
            __atomic_base<_Tp, >(const __atomic_base<_Tp, > &);
            __atomic_base<_Tp, > &operator=(const __atomic_base<_Tp, > &);
            __atomic_base<_Tp, > &operator=(const __atomic_base<_Tp, > &) volatile;
        };
        template <class _Tp> struct __atomic_base<_Tp, true> : public __atomic_base<_Tp, false> {
            typedef __atomic_base<_Tp, false> __base;
            __atomic_base<type-parameter-0-0, true>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __atomic_base<type-parameter-0-0, true>(_Tp __d) throw() : std::__1::__atomic_base<type-parameter-0-0, true>::__base(__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Tp fetch_add(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
            }
            _Tp fetch_add(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
            }
            _Tp fetch_sub(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
            }
            _Tp fetch_sub(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
            }
            _Tp fetch_and(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_and(&this->__a_, __op, __m);
            }
            _Tp fetch_and(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_and(&this->__a_, __op, __m);
            }
            _Tp fetch_or(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_or(&this->__a_, __op, __m);
            }
            _Tp fetch_or(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_or(&this->__a_, __op, __m);
            }
            _Tp fetch_xor(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);
            }
            _Tp fetch_xor(_Tp __op, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);
            }
            _Tp operator++(int) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(_Tp(1));
            }
            _Tp operator++(int) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(_Tp(1));
            }
            _Tp operator--(int) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(_Tp(1));
            }
            _Tp operator--(int) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(_Tp(1));
            }
            _Tp operator++() volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(_Tp(1)) + _Tp(1);
            }
            _Tp operator++() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(_Tp(1)) + _Tp(1);
            }
            _Tp operator--() volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(_Tp(1)) - _Tp(1);
            }
            _Tp operator--() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(_Tp(1)) - _Tp(1);
            }
            _Tp operator+=(_Tp __op) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(__op) + __op;
            }
            _Tp operator+=(_Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(__op) + __op;
            }
            _Tp operator-=(_Tp __op) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(__op) - __op;
            }
            _Tp operator-=(_Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(__op) - __op;
            }
            _Tp operator&=(_Tp __op) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_and(__op) & __op;
            }
            _Tp operator&=(_Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_and(__op) & __op;
            }
            _Tp operator|=(_Tp __op) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_or(__op) | __op;
            }
            _Tp operator|=(_Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_or(__op) | __op;
            }
            _Tp operator^=(_Tp __op) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_xor(__op) ^ __op;
            }
            _Tp operator^=(_Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_xor(__op) ^ __op;
            }
        };
        template <class _Tp> struct atomic : public __atomic_base<_Tp> {
            typedef __atomic_base<_Tp> __base;
            atomic<_Tp>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            atomic<_Tp>(_Tp __d) throw() : std::__1::atomic::__base(__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Tp operator=(_Tp __d) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __base::store(__d);
                return __d;
            }
            _Tp operator=(_Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __base::store(__d);
                return __d;
            }
        };
        template <class _Tp> struct atomic<_Tp *> : public __atomic_base<_Tp *> {
            typedef __atomic_base<_Tp *> __base;
            atomic<type-parameter-0-0 *>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            atomic<type-parameter-0-0 *>(_Tp *__d) throw() : std::__1::atomic<type-parameter-0-0 *>::__base(__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Tp *operator=(_Tp *__d) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __base::store(__d);
                return __d;
            }
            _Tp *operator=(_Tp *__d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __base::store(__d);
                return __d;
            }
            _Tp *fetch_add(ptrdiff_t __op, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
            }
            _Tp *fetch_add(ptrdiff_t __op, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
            }
            _Tp *fetch_sub(ptrdiff_t __op, std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
            }
            _Tp *fetch_sub(ptrdiff_t __op, std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
            }
            _Tp *operator++(int) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(1);
            }
            _Tp *operator++(int) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(1);
            }
            _Tp *operator--(int) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(1);
            }
            _Tp *operator--(int) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(1);
            }
            _Tp *operator++() volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(1) + 1;
            }
            _Tp *operator++() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(1) + 1;
            }
            _Tp *operator--() volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(1) - 1;
            }
            _Tp *operator--() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(1) - 1;
            }
            _Tp *operator+=(ptrdiff_t __op) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(__op) + __op;
            }
            _Tp *operator+=(ptrdiff_t __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_add(__op) + __op;
            }
            _Tp *operator-=(ptrdiff_t __op) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(__op) - __op;
            }
            _Tp *operator-=(ptrdiff_t __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return fetch_sub(__op) - __op;
            }
        };
        template <class _Tp> bool atomic_is_lock_free(const volatile atomic<_Tp> *__o) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->is_lock_free();
        }
        template <class _Tp> bool atomic_is_lock_free(const atomic<_Tp> *__o) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->is_lock_free();
        }
        template <class _Tp> void atomic_init(volatile atomic<_Tp> *__o, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __cxx_atomic_init(&__o->__a_, __d);
        }
        template <class _Tp> void atomic_init(atomic<_Tp> *__o, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __cxx_atomic_init(&__o->__a_, __d);
        }
        template <class _Tp> void atomic_store(volatile atomic<_Tp> *__o, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __o->store(__d);
        }
        template <class _Tp> void atomic_store(atomic<_Tp> *__o, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __o->store(__d);
        }
        template <class _Tp> void atomic_store_explicit(volatile atomic<_Tp> *__o, _Tp __d, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e41b01b8, "memory order argument to atomic operation is invalid", "warning")))         {
            __o->store(__d, __m);
        }
        template <class _Tp> void atomic_store_explicit(atomic<_Tp> *__o, _Tp __d, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e41b0e78, "memory order argument to atomic operation is invalid", "warning")))         {
            __o->store(__d, __m);
        }
        template <class _Tp> _Tp atomic_load(const volatile atomic<_Tp> *__o) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->load();
        }
        template <class _Tp> _Tp atomic_load(const atomic<_Tp> *__o) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->load();
        }
        template <class _Tp> _Tp atomic_load_explicit(const volatile atomic<_Tp> *__o, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e41b2258, "memory order argument to atomic operation is invalid", "warning")))         {
            return __o->load(__m);
        }
        template <class _Tp> _Tp atomic_load_explicit(const atomic<_Tp> *__o, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e41b2c78, "memory order argument to atomic operation is invalid", "warning")))         {
            return __o->load(__m);
        }
        template <class _Tp> _Tp atomic_exchange(volatile atomic<_Tp> *__o, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->exchange(__d);
        }
        template <class _Tp> _Tp atomic_exchange(atomic<_Tp> *__o, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->exchange(__d);
        }
        template <class _Tp> _Tp atomic_exchange_explicit(volatile atomic<_Tp> *__o, _Tp __d, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->exchange(__d, __m);
        }
        template <class _Tp> _Tp atomic_exchange_explicit(atomic<_Tp> *__o, _Tp __d, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->exchange(__d, __m);
        }
        template <class _Tp> bool atomic_compare_exchange_weak(volatile atomic<_Tp> *__o, _Tp *__e, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->compare_exchange_weak(*__e, __d);
        }
        template <class _Tp> bool atomic_compare_exchange_weak(atomic<_Tp> *__o, _Tp *__e, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->compare_exchange_weak(*__e, __d);
        }
        template <class _Tp> bool atomic_compare_exchange_strong(volatile atomic<_Tp> *__o, _Tp *__e, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->compare_exchange_strong(*__e, __d);
        }
        template <class _Tp> bool atomic_compare_exchange_strong(atomic<_Tp> *__o, _Tp *__e, _Tp __d) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->compare_exchange_strong(*__e, __d);
        }
        template <class _Tp> bool atomic_compare_exchange_weak_explicit(volatile atomic<_Tp> *__o, _Tp *__e, _Tp __d, std::__1::memory_order __s, std::__1::memory_order __f) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e4372ba0, "memory order argument to atomic operation is invalid", "warning")))         {
            return __o->compare_exchange_weak(*__e, __d, __s, __f);
        }
        template <class _Tp> bool atomic_compare_exchange_weak_explicit(atomic<_Tp> *__o, _Tp *__e, _Tp __d, std::__1::memory_order __s, std::__1::memory_order __f) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e4373850, "memory order argument to atomic operation is invalid", "warning")))         {
            return __o->compare_exchange_weak(*__e, __d, __s, __f);
        }
        template <class _Tp> bool atomic_compare_exchange_strong_explicit(volatile atomic<_Tp> *__o, _Tp *__e, _Tp __d, std::__1::memory_order __s, std::__1::memory_order __f) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e43744b0, "memory order argument to atomic operation is invalid", "warning")))         {
            return __o->compare_exchange_strong(*__e, __d, __s, __f);
        }
        template <class _Tp> bool atomic_compare_exchange_strong_explicit(atomic<_Tp> *__o, _Tp *__e, _Tp __d, std::__1::memory_order __s, std::__1::memory_order __f) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((diagnose_if(0x7ff5e4375110, "memory order argument to atomic operation is invalid", "warning")))         {
            return __o->compare_exchange_strong(*__e, __d, __s, __f);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_add(volatile atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_add(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_add(atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_add(__op);
        }
        template <class _Tp> _Tp *atomic_fetch_add(volatile atomic<_Tp *> *__o, ptrdiff_t __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_add(__op);
        }
        template <class _Tp> _Tp *atomic_fetch_add(atomic<_Tp *> *__o, ptrdiff_t __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_add(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_add_explicit(volatile atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_add(__op, __m);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_add_explicit(atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_add(__op, __m);
        }
        template <class _Tp> _Tp *atomic_fetch_add_explicit(volatile atomic<_Tp *> *__o, ptrdiff_t __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_add(__op, __m);
        }
        template <class _Tp> _Tp *atomic_fetch_add_explicit(atomic<_Tp *> *__o, ptrdiff_t __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_add(__op, __m);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_sub(volatile atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_sub(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_sub(atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_sub(__op);
        }
        template <class _Tp> _Tp *atomic_fetch_sub(volatile atomic<_Tp *> *__o, ptrdiff_t __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_sub(__op);
        }
        template <class _Tp> _Tp *atomic_fetch_sub(atomic<_Tp *> *__o, ptrdiff_t __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_sub(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_sub_explicit(volatile atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_sub(__op, __m);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_sub_explicit(atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_sub(__op, __m);
        }
        template <class _Tp> _Tp *atomic_fetch_sub_explicit(volatile atomic<_Tp *> *__o, ptrdiff_t __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_sub(__op, __m);
        }
        template <class _Tp> _Tp *atomic_fetch_sub_explicit(atomic<_Tp *> *__o, ptrdiff_t __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_sub(__op, __m);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_and(volatile atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_and(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_and(atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_and(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_and_explicit(volatile atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_and(__op, __m);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_and_explicit(atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_and(__op, __m);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_or(volatile atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_or(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_or(atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_or(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_or_explicit(volatile atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_or(__op, __m);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_or_explicit(atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_or(__op, __m);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_xor(volatile atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_xor(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_xor(atomic<_Tp> *__o, _Tp __op) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_xor(__op);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_xor_explicit(volatile atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_xor(__op, __m);
        }
        template <class _Tp> typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, _Tp>::type atomic_fetch_xor_explicit(atomic<_Tp> *__o, _Tp __op, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->fetch_xor(__op, __m);
        }
        typedef struct atomic_flag {
            __cxx_atomic_impl<bool> __a_;
            bool test_and_set(std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_exchange(&this->__a_, bool(true), __m);
            }
            bool test_and_set(std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __cxx_atomic_exchange(&this->__a_, bool(true), __m);
            }
            void clear(std::__1::memory_order __m = memory_order_seq_cst) volatile throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __cxx_atomic_store(&this->__a_, bool(false), __m);
            }
            void clear(std::__1::memory_order __m = memory_order_seq_cst) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __cxx_atomic_store(&this->__a_, bool(false), __m);
            }
            atomic_flag() throw() : __a_() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            atomic_flag(bool __b) throw() : __a_(__b) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        private:
            atomic_flag(const std::__1::atomic_flag &);
            std::__1::atomic_flag &operator=(const std::__1::atomic_flag &);
            std::__1::atomic_flag &operator=(const std::__1::atomic_flag &) volatile;
        } atomic_flag;
        inline bool atomic_flag_test_and_set(volatile std::__1::atomic_flag *__o) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->test_and_set();
        }
        inline bool atomic_flag_test_and_set(std::__1::atomic_flag *__o) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->test_and_set();
        }
        inline bool atomic_flag_test_and_set_explicit(volatile std::__1::atomic_flag *__o, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->test_and_set(__m);
        }
        inline bool atomic_flag_test_and_set_explicit(std::__1::atomic_flag *__o, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __o->test_and_set(__m);
        }
        inline void atomic_flag_clear(volatile std::__1::atomic_flag *__o) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __o->clear();
        }
        inline void atomic_flag_clear(std::__1::atomic_flag *__o) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __o->clear();
        }
        inline void atomic_flag_clear_explicit(volatile std::__1::atomic_flag *__o, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __o->clear(__m);
        }
        inline void atomic_flag_clear_explicit(std::__1::atomic_flag *__o, std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __o->clear(__m);
        }
        inline void atomic_thread_fence(std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __cxx_atomic_thread_fence(__m);
        }
        inline void atomic_signal_fence(std::__1::memory_order __m) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __cxx_atomic_signal_fence(__m);
        }
        typedef atomic<bool> atomic_bool;
        typedef atomic<char> atomic_char;
        typedef atomic<signed char> atomic_schar;
        typedef atomic<unsigned char> atomic_uchar;
        typedef atomic<short> atomic_short;
        typedef atomic<unsigned short> atomic_ushort;
        typedef atomic<int> atomic_int;
        typedef atomic<unsigned int> atomic_uint;
        typedef atomic<long> atomic_long;
        typedef atomic<unsigned long> atomic_ulong;
        typedef atomic<long long> atomic_llong;
        typedef atomic<unsigned long long> atomic_ullong;
        typedef atomic<char16_t> atomic_char16_t;
        typedef atomic<char32_t> atomic_char32_t;
        typedef atomic<wchar_t> atomic_wchar_t;
        typedef atomic<int_least8_t> atomic_int_least8_t;
        typedef atomic<uint_least8_t> atomic_uint_least8_t;
        typedef atomic<int_least16_t> atomic_int_least16_t;
        typedef atomic<uint_least16_t> atomic_uint_least16_t;
        typedef atomic<int_least32_t> atomic_int_least32_t;
        typedef atomic<uint_least32_t> atomic_uint_least32_t;
        typedef atomic<int_least64_t> atomic_int_least64_t;
        typedef atomic<uint_least64_t> atomic_uint_least64_t;
        typedef atomic<int_fast8_t> atomic_int_fast8_t;
        typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
        typedef atomic<int_fast16_t> atomic_int_fast16_t;
        typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
        typedef atomic<int_fast32_t> atomic_int_fast32_t;
        typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
        typedef atomic<int_fast64_t> atomic_int_fast64_t;
        typedef atomic<uint_fast64_t> atomic_uint_fast64_t;
        typedef atomic<int8_t> atomic_int8_t;
        typedef atomic<uint8_t> atomic_uint8_t;
        typedef atomic<int16_t> atomic_int16_t;
        typedef atomic<uint16_t> atomic_uint16_t;
        typedef atomic<int32_t> atomic_int32_t;
        typedef atomic<uint32_t> atomic_uint32_t;
        typedef atomic<int64_t> atomic_int64_t;
        typedef atomic<uint64_t> atomic_uint64_t;
        typedef atomic<intptr_t> atomic_intptr_t;
        typedef atomic<uintptr_t> atomic_uintptr_t;
        typedef atomic<size_t> atomic_size_t;
        typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
        typedef atomic<intmax_t> atomic_intmax_t;
        typedef atomic<uintmax_t> atomic_uintmax_t;
    }
}
extern "C" {
    void __assert_rtn(const char *, const char *, int, const char *) __attribute__((cold)) __attribute__((disable_tail_calls));
}
namespace std {
    inline namespace __1 {
        template <class _ValueType> inline _ValueType __libcpp_relaxed_load(const _ValueType *__value) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __atomic_load_n(__value, 0);
        }
        template<> inline long __libcpp_relaxed_load<long>(const long *__value) __attribute__((internal_linkage))         {
            return __atomic_load_n(__value, 0);
        }
        template <class _ValueType> inline _ValueType __libcpp_acquire_load(const _ValueType *__value) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __atomic_load_n(__value, 2);
        }
        template<> inline unsigned long __libcpp_acquire_load<unsigned long>(const unsigned long *__value) __attribute__((internal_linkage))        template <class _Tp> class allocator
template<> class allocator<char> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef char *pointer;
            typedef const char *const_pointer;
            typedef char &reference;
            typedef const char &const_reference;
            typedef char value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage))             {
            }
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            template<> allocator<char>(const allocator<char> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<char>::pointer address(std::__1::allocator<char>::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<char>::const_pointer address(std::__1::allocator<char>::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<char>::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((internal_linkage))             {
                if (__n > this->max_size())
                    __throw_length_error("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
                return static_cast<std::__1::allocator<char>::pointer>(std::__1::__libcpp_allocate(__n * sizeof(char), __alignof(char)));
            }
            void deallocate(std::__1::allocator<char>::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(char), __alignof(char));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage))             {
                return std::__1::allocator::size_type(~0) / sizeof(char);
            }
            void construct(std::__1::allocator<char>::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<char>::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<char>::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<char>::pointer __p) __attribute__((internal_linkage));
        }
template<> class allocator<wchar_t> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef wchar_t *pointer;
            typedef const wchar_t *const_pointer;
            typedef wchar_t &reference;
            typedef const wchar_t &const_reference;
            typedef wchar_t value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage));
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<wchar_t>::pointer address(std::__1::allocator<wchar_t>::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<wchar_t>::const_pointer address(std::__1::allocator<wchar_t>::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<wchar_t>::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((internal_linkage));
            void deallocate(std::__1::allocator<wchar_t>::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(wchar_t), __alignof(wchar_t));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage));
            void construct(std::__1::allocator<wchar_t>::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<wchar_t>::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<wchar_t>::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<wchar_t>::pointer __p) __attribute__((internal_linkage));
        }
template<> class allocator<std::__1::basic_string<char>> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef std::__1::basic_string<char> *pointer;
            typedef const std::__1::basic_string<char> *const_pointer;
            typedef std::__1::basic_string<char> &reference;
            typedef const std::__1::basic_string<char> &const_reference;
            typedef std::__1::basic_string<char> value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage))             {
            }
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<std::__1::basic_string<char> >::pointer address(std::__1::allocator<std::__1::basic_string<char> >::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<std::__1::basic_string<char> >::const_pointer address(std::__1::allocator<std::__1::basic_string<char> >::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<std::__1::basic_string<char> >::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((internal_linkage))             {
                if (__n > this->max_size())
                    __throw_length_error("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
                return static_cast<std::__1::allocator<std::__1::basic_string<char> >::pointer>(std::__1::__libcpp_allocate(__n * sizeof(std::__1::basic_string<char>), __alignof(std::__1::basic_string<char>)));
            }
            void deallocate(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(std::__1::basic_string<char>), __alignof(std::__1::basic_string<char>));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage))             {
                return std::__1::allocator::size_type(~0) / sizeof(std::__1::basic_string<char>);
            }
            void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template<> void construct<const std::__1::basic_string<char>>(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const std::__1::basic_string<char> &__a0) __attribute__((internal_linkage));
            template<> void construct<std::__1::basic_string<char>>(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, std::__1::basic_string<char> &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template<> void construct<std::__1::basic_string<char>>(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const std::__1::basic_string<char> &__a0) __attribute__((internal_linkage))             {
                ::new ((void *)__p) std::__1::basic_string<char>(__a0);
            }
;
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<std::__1::basic_string<char> >::pointer __p) __attribute__((internal_linkage))             {
                __p->~basic_string<char>();
            }
        }
template<> class allocator<int> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef int *pointer;
            typedef const int *const_pointer;
            typedef int &reference;
            typedef const int &const_reference;
            typedef int value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage));
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<int>::pointer address(std::__1::allocator<int>::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<int>::const_pointer address(std::__1::allocator<int>::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<int>::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer) __attribute__((internal_linkage));
            void deallocate(std::__1::allocator<int>::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage));
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage));
            void construct(std::__1::allocator<int>::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<int>::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<int>::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<int>::pointer __p) __attribute__((internal_linkage));
        };
        template<> class __attribute__((type_visibility("default"))) allocator<void> {
        public:
            typedef void *pointer;
            typedef const void *const_pointer;
            typedef void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        };
        template<> class __attribute__((type_visibility("default"))) allocator<const void> {
        public:
            typedef const void *pointer;
            typedef const void *const_pointer;
            typedef const void value_type;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
        };
        template <class _Tp, class = void> struct __has_element_type : std::__1::false_type {
        };
        template <class _Tp> struct __has_element_type<_Tp, typename __void_t<typename _Tp::element_type>::type> : std::__1::true_type {
        };
        template <class _Ptr, bool = __has_element_type<_Ptr>::value> struct __pointer_traits_element_type;
        template <class _Ptr> struct __pointer_traits_element_type<_Ptr, true> {
            typedef typename _Ptr::element_type type;
        };
        template <template <class> class _Sp, class _Tp> struct __pointer_traits_element_type<_Sp<_Tp>, true> {
            typedef typename _Sp<_Tp>::element_type type;
        };
        template <template <class> class _Sp, class _Tp> struct __pointer_traits_element_type<_Sp<_Tp>, false> {
            typedef _Tp type;
        };
        template <template <class, class> class _Sp, class _Tp, class _A0> struct __pointer_traits_element_type<_Sp<_Tp, _A0>, true> {
            typedef typename _Sp<_Tp, _A0>::element_type type;
        };
        template <template <class, class> class _Sp, class _Tp, class _A0> struct __pointer_traits_element_type<_Sp<_Tp, _A0>, false> {
            typedef _Tp type;
        };
        template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1> struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true> {
            typedef typename _Sp<_Tp, _A0, _A1>::element_type type;
        };
        template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1> struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false> {
            typedef _Tp type;
        };
        template <template <class, class, class, class> class _Sp, class _Tp, class _A0, class _A1, class _A2> struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true> {
            typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;
        };
        template <template <class, class, class, class> class _Sp, class _Tp, class _A0, class _A1, class _A2> struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false> {
            typedef _Tp type;
        };
        template <class _Tp, class = void> struct __has_difference_type : std::__1::false_type {
        };
template<> struct __has_difference_type<std::__1::allocator<char>, void> : std::__1::true_type {
        };
template<> struct __has_difference_type<std::__1::allocator<wchar_t>, void> : std::__1::true_type {
        };
template<> struct __has_difference_type<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::true_type {
        };
template<> struct __has_difference_type<std::__1::allocator<int>, void> : std::__1::true_type {
        };
        template <class _Tp> struct __has_difference_type<_Tp, typename __void_t<typename _Tp::difference_type>::type> : std::__1::true_type {
        };
        template <class _Ptr, bool = __has_difference_type<_Ptr>::value> struct __pointer_traits_difference_type {
            typedef ptrdiff_t type;
        };
        template <class _Ptr> struct __pointer_traits_difference_type<_Ptr, true> {
            typedef typename _Ptr::difference_type type;
        };
        template <class _Tp, class _Up> struct __has_rebind {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Xp> static std::__1::__has_rebind::__two __test(...);
            template <class _Xp> static char __test(typename _Xp::rebind<_Up> * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value> struct __pointer_traits_rebind {
            typedef typename _Tp::template _Tp::rebind<_Up>::other type;
        };
        template <template <class> class _Sp, class _Tp, class _Up> struct __pointer_traits_rebind<_Sp<_Tp>, _Up, true> {
            typedef typename _Sp<_Tp>::template _Sp<_Tp>::rebind<_Up>::other type;
        };
        template <template <class> class _Sp, class _Tp, class _Up> struct __pointer_traits_rebind<_Sp<_Tp>, _Up, false> {
            typedef _Sp<_Up> type;
        };
        template <template <class, class> class _Sp, class _Tp, class _A0, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true> {
            typedef typename _Sp<_Tp, _A0>::template _Sp<_Tp, _A0>::rebind<_Up>::other type;
        };
        template <template <class, class> class _Sp, class _Tp, class _A0, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false> {
            typedef _Sp<_Up, _A0> type;
        };
        template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true> {
            typedef typename _Sp<_Tp, _A0, _A1>::template _Sp<_Tp, _A0, _A1>::rebind<_Up>::other type;
        };
        template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false> {
            typedef _Sp<_Up, _A0, _A1> type;
        };
        template <template <class, class, class, class> class _Sp, class _Tp, class _A0, class _A1, class _A2, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true> {
            typedef typename _Sp<_Tp, _A0, _A1, _A2>::template _Sp<_Tp, _A0, _A1, _A2>::rebind<_Up>::other type;
        };
        template <template <class, class, class, class> class _Sp, class _Tp, class _A0, class _A1, class _A2, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false> {
            typedef _Sp<_Up, _A0, _A1, _A2> type;
        };
        template <class _Ptr> struct __attribute__((type_visibility("default"))) pointer_traits {
            typedef _Ptr pointer;
            typedef typename __pointer_traits_element_type<pointer>::type element_type;
            typedef typename __pointer_traits_difference_type<pointer>::type difference_type;
            template <class _Up> struct rebind {
                typedef typename __pointer_traits_rebind<pointer, _Up>::type other;
            };
        private:
            struct __nat {
            };
        public:
            static std::__1::pointer_traits::pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return pointer::pointer_to(__r);
            }
        };
template<> struct pointer_traits<char *> {
            typedef char *pointer;
            typedef char element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> struct rebind
template<> struct rebind<void> {
                typedef void *other;
            }
template<> struct rebind<const void> {
                typedef const void *other;
            };
        private:
            struct __nat;
        public:
            static std::__1::pointer_traits<char *>::pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) throw() __attribute__((internal_linkage))             {
                return std::__1::addressof(__r);
            }
        };
template<> struct pointer_traits<wchar_t *> {
            typedef wchar_t *pointer;
            typedef wchar_t element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> struct rebind
template<> struct rebind<void> {
                typedef void *other;
            }
template<> struct rebind<const void> {
                typedef const void *other;
            };
        private:
            struct __nat;
        public:
            static std::__1::pointer_traits<wchar_t *>::pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) throw() __attribute__((internal_linkage));
        };
template<> struct pointer_traits<std::__1::basic_string<char> *> {
            typedef std::__1::basic_string<char> *pointer;
            typedef std::__1::basic_string<char> element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> struct rebind
template<> struct rebind<void> {
                typedef void *other;
            }
template<> struct rebind<const void> {
                typedef const void *other;
            };
        private:
            struct __nat;
        public:
            static std::__1::pointer_traits<std::__1::basic_string<char> *>::pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) throw() __attribute__((internal_linkage));
        };
template<> struct pointer_traits<int *> {
            typedef int *pointer;
            typedef int element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> struct rebind
template<> struct rebind<void> {
                typedef void *other;
            }
template<> struct rebind<const void> {
                typedef const void *other;
            };
        private:
            struct __nat;
        public:
            static std::__1::pointer_traits<int *>::pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) throw() __attribute__((internal_linkage));
        };
template<> struct pointer_traits<const char *> {
            typedef const char *pointer;
            typedef const char element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> struct rebind;
        private:
            struct __nat;
        public:
            static std::__1::pointer_traits<const char *>::pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) throw() __attribute__((internal_linkage))             {
                return std::__1::addressof(__r);
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) pointer_traits<_Tp *> {
            typedef _Tp *pointer;
            typedef _Tp element_type;
            typedef ptrdiff_t difference_type;
            template <class _Up> struct rebind {
                typedef _Up *other;
            };
        private:
            struct __nat {
            };
        public:
            static std::__1::pointer_traits<type-parameter-0-0 *>::pointer pointer_to(typename conditional<is_void<element_type>::value, __nat, element_type>::type &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::addressof(__r);
            }
        };
        template <class _From, class _To> struct __rebind_pointer {
            typedef typename pointer_traits<_From>::template pointer_traits<_From>::rebind<_To>::other type;
        };
        template <class _Tp, class = void> struct __has_pointer_type : std::__1::false_type {
        };
template<> struct __has_pointer_type<std::__1::__builtin_new_allocator::__builtin_new_deleter, void> : std::__1::false_type {
        };
template<> struct __has_pointer_type<std::__1::allocator<char>, void> : std::__1::true_type {
        };
template<> struct __has_pointer_type<std::__1::allocator<wchar_t>, void> : std::__1::true_type {
        };
template<> struct __has_pointer_type<void (*)(void *), void> : std::__1::false_type {
        };
template<> struct __has_pointer_type<int (*)(__sFILE *), void> : std::__1::false_type {
        };
template<> struct __has_pointer_type<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::true_type {
        };
template<> struct __has_pointer_type<std::__1::allocator<int>, void> : std::__1::true_type {
        };
        template <class _Tp> struct __has_pointer_type<_Tp, typename __void_t<typename _Tp::pointer>::type> : std::__1::true_type {
        };
        namespace __pointer_type_imp {
            template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value> struct __pointer_type {
                typedef typename _Dp::pointer type;
            };
template<> struct __pointer_type<void, std::__1::__builtin_new_allocator::__builtin_new_deleter, false> {
                typedef void *type;
            };
template<> struct __pointer_type<char, std::__1::allocator<char>, true> {
                typedef typename allocator<char>::pointer type;
            };
template<> struct __pointer_type<wchar_t, std::__1::allocator<wchar_t>, true> {
                typedef typename allocator<wchar_t>::pointer type;
            };
template<> struct __pointer_type<unsigned char, void (*)(void *), false> {
                typedef unsigned char *type;
            };
template<> struct __pointer_type<char, void (*)(void *), false> {
                typedef char *type;
            };
template<> struct __pointer_type<unsigned int, void (*)(void *), false> {
                typedef unsigned int *type;
            };
template<> struct __pointer_type<__sFILE, int (*)(__sFILE *), false> {
                typedef __sFILE *type;
            };
template<> struct __pointer_type<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> >, true> {
                typedef typename allocator<basic_string<char> >::pointer type;
            };
template<> struct __pointer_type<int, std::__1::allocator<int>, true> {
                typedef typename allocator<int>::pointer type;
            };
            template <class _Tp, class _Dp> struct __pointer_type<_Tp, _Dp, false> {
                typedef _Tp *type;
            };
        }
        template <class _Tp, class _Dp> struct __pointer_type {
            typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
        };
template<> struct __pointer_type<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            typedef typename __pointer_type_imp::__pointer_type<void, typename remove_reference<__builtin_new_deleter>::type>::type type;
        };
template<> struct __pointer_type<char, std::__1::allocator<char>> {
            typedef typename __pointer_type_imp::__pointer_type<char, typename remove_reference<allocator<char> >::type>::type type;
        };
template<> struct __pointer_type<wchar_t, std::__1::allocator<wchar_t>> {
            typedef typename __pointer_type_imp::__pointer_type<wchar_t, typename remove_reference<allocator<wchar_t> >::type>::type type;
        };
template<> struct __pointer_type<unsigned char, void (*)(void *)> {
            typedef typename __pointer_type_imp::__pointer_type<unsigned char, typename remove_reference<void (*)(void *)>::type>::type type;
        };
template<> struct __pointer_type<char, void (*)(void *)> {
            typedef typename __pointer_type_imp::__pointer_type<char, typename remove_reference<void (*)(void *)>::type>::type type;
        };
template<> struct __pointer_type<unsigned int, void (*)(void *)> {
            typedef typename __pointer_type_imp::__pointer_type<unsigned int, typename remove_reference<void (*)(void *)>::type>::type type;
        };
template<> struct __pointer_type<__sFILE, int (*)(__sFILE *)> {
            typedef typename __pointer_type_imp::__pointer_type<__sFILE, typename remove_reference<int (*)(__sFILE *)>::type>::type type;
        };
template<> struct __pointer_type<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> >> {
            typedef typename __pointer_type_imp::__pointer_type<basic_string<char>, typename remove_reference<allocator<basic_string<char> > >::type>::type type;
        };
template<> struct __pointer_type<int, std::__1::allocator<int>> {
            typedef typename __pointer_type_imp::__pointer_type<int, typename remove_reference<allocator<int> >::type>::type type;
        };
        template <class _Tp, class = void> struct __has_const_pointer : std::__1::false_type {
        };
template<> struct __has_const_pointer<std::__1::allocator<char>, void> : std::__1::true_type {
        };
template<> struct __has_const_pointer<std::__1::allocator<wchar_t>, void> : std::__1::true_type {
        };
template<> struct __has_const_pointer<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::true_type {
        };
template<> struct __has_const_pointer<std::__1::allocator<int>, void> : std::__1::true_type {
        };
        template <class _Tp> struct __has_const_pointer<_Tp, typename __void_t<typename _Tp::const_pointer>::type> : std::__1::true_type {
        };
        template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value> struct __const_pointer {
            typedef typename _Alloc::const_pointer type;
        };
template<> struct __const_pointer<char, char *, std::__1::allocator<char>, true> {
            typedef typename allocator<char>::const_pointer type;
        };
template<> struct __const_pointer<wchar_t, wchar_t *, std::__1::allocator<wchar_t>, true> {
            typedef typename allocator<wchar_t>::const_pointer type;
        };
template<> struct __const_pointer<std::__1::basic_string<char>, std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> >, true> {
            typedef typename allocator<basic_string<char> >::const_pointer type;
        };
template<> struct __const_pointer<int, int *, std::__1::allocator<int>, true> {
            typedef typename allocator<int>::const_pointer type;
        };
        template <class _Tp, class _Ptr, class _Alloc> struct __const_pointer<_Tp, _Ptr, _Alloc, false> {
            typedef typename pointer_traits<_Ptr>::template pointer_traits<_Ptr>::rebind<const _Tp>::other type;
        };
        template <class _Tp, class = void> struct __has_void_pointer : std::__1::false_type {
        };
template<> struct __has_void_pointer<std::__1::allocator<char>, void> : std::__1::false_type {
        };
template<> struct __has_void_pointer<std::__1::allocator<wchar_t>, void> : std::__1::false_type {
        };
template<> struct __has_void_pointer<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::false_type {
        };
template<> struct __has_void_pointer<std::__1::allocator<int>, void> : std::__1::false_type {
        };
        template <class _Tp> struct __has_void_pointer<_Tp, typename __void_t<typename _Tp::void_pointer>::type> : std::__1::true_type {
        };
        template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value> struct __void_pointer {
            typedef typename _Alloc::void_pointer type;
        };
template<> struct __void_pointer<char *, std::__1::allocator<char>, false> {
            typedef typename pointer_traits<char *>::rebind<void>::other type;
        };
template<> struct __void_pointer<wchar_t *, std::__1::allocator<wchar_t>, false> {
            typedef typename pointer_traits<wchar_t *>::rebind<void>::other type;
        };
template<> struct __void_pointer<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> >, false> {
            typedef typename pointer_traits<basic_string<char> *>::rebind<void>::other type;
        };
template<> struct __void_pointer<int *, std::__1::allocator<int>, false> {
            typedef typename pointer_traits<int *>::rebind<void>::other type;
        };
        template <class _Ptr, class _Alloc> struct __void_pointer<_Ptr, _Alloc, false> {
            typedef typename pointer_traits<_Ptr>::template pointer_traits<_Ptr>::rebind<void>::other type;
        };
        template <class _Tp, class = void> struct __has_const_void_pointer : std::__1::false_type {
        };
template<> struct __has_const_void_pointer<std::__1::allocator<char>, void> : std::__1::false_type {
        };
template<> struct __has_const_void_pointer<std::__1::allocator<wchar_t>, void> : std::__1::false_type {
        };
template<> struct __has_const_void_pointer<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::false_type {
        };
template<> struct __has_const_void_pointer<std::__1::allocator<int>, void> : std::__1::false_type {
        };
        template <class _Tp> struct __has_const_void_pointer<_Tp, typename __void_t<typename _Tp::const_void_pointer>::type> : std::__1::true_type {
        };
        template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value> struct __const_void_pointer {
            typedef typename _Alloc::const_void_pointer type;
        };
template<> struct __const_void_pointer<char *, std::__1::allocator<char>, false> {
            typedef typename pointer_traits<char *>::rebind<const void>::other type;
        };
template<> struct __const_void_pointer<wchar_t *, std::__1::allocator<wchar_t>, false> {
            typedef typename pointer_traits<wchar_t *>::rebind<const void>::other type;
        };
template<> struct __const_void_pointer<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> >, false> {
            typedef typename pointer_traits<basic_string<char> *>::rebind<const void>::other type;
        };
template<> struct __const_void_pointer<int *, std::__1::allocator<int>, false> {
            typedef typename pointer_traits<int *>::rebind<const void>::other type;
        };
        template <class _Ptr, class _Alloc> struct __const_void_pointer<_Ptr, _Alloc, false> {
            typedef typename pointer_traits<_Ptr>::template pointer_traits<_Ptr>::rebind<const void>::other type;
        };
        template <bool _UsePointerTraits> struct __to_address_helper;
        template<> struct __to_address_helper<true> {
            template <class _Pointer> using __return_type = decltype(pointer_traits<_Pointer>::to_address(std::declval<const _Pointer &>()));
            template <class _Pointer> static __return_type<_Pointer> __do_it(const _Pointer &__p) throw()             {
                return pointer_traits<_Pointer>::to_address(__p);
            }
        };
        template <class _Pointer, bool _Dummy = true> using __choose_to_address = __to_address_helper<_IsValidExpansion<__to_address_helper<_Dummy>::template __return_type, _Pointer>::value>;
        template <class _Tp> inline _Tp *__to_address(_Tp *__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(!is_function<_Tp>::value, "_Tp is a function type");
            return __p;
        }
        template<> inline char *__to_address<char>(char *__p) throw() __attribute__((internal_linkage))         {
            static_assert(!is_function<char>::value, "_Tp is a function type");
            return __p;
        }
        template<> inline const char *__to_address<const char>(const char *__p) throw() __attribute__((internal_linkage))         {
            static_assert(!is_function<const char>::value, "_Tp is a function type");
            return __p;
        }
        template<> inline std::__1::basic_string<char> *__to_address<std::__1::basic_string<char>>(std::__1::basic_string<char> *__p) throw() __attribute__((internal_linkage))         {
            static_assert(!is_function<basic_string<char> >::value, "_Tp is a function type");
            return __p;
        }
        template <class _Pointer> inline typename __choose_to_address<_Pointer>::__return_type<_Pointer> __to_address(const _Pointer &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __choose_to_address<_Pointer>::__do_it(__p);
        }
        template<> inline typename __choose_to_address<char *>::__return_type<char *> __to_address<char *>(char *const &__p) throw() __attribute__((internal_linkage))        template<> inline typename __choose_to_address<const char *>::__return_type<const char *> __to_address<const char *>(const char *const &__p) throw() __attribute__((internal_linkage))        template<> inline typename __choose_to_address<basic_string<char> *>::__return_type<basic_string<char> *> __to_address<std::__1::basic_string<char> *>(std::__1::basic_string<char> *const &__p) throw() __attribute__((internal_linkage))        template<> struct __to_address_helper<false> {
            template <class _Pointer> using __return_type = typename pointer_traits<_Pointer>::element_type *;
            template <class _Pointer> static __return_type<_Pointer> __do_it(const _Pointer &__p) throw()             {
                return std::__to_address(__p.operator->());
            }
        };
        template <class _Tp, class = void> struct __has_size_type : std::__1::false_type {
        };
template<> struct __has_size_type<std::__1::allocator<char>, void> : std::__1::true_type {
        };
template<> struct __has_size_type<std::__1::allocator<wchar_t>, void> : std::__1::true_type {
        };
template<> struct __has_size_type<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::true_type {
        };
template<> struct __has_size_type<std::__1::allocator<int>, void> : std::__1::true_type {
        };
        template <class _Tp> struct __has_size_type<_Tp, typename __void_t<typename _Tp::size_type>::type> : std::__1::true_type {
        };
        template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value> struct __size_type {
            typedef typename make_unsigned<_DiffType>::type type;
        };
template<> struct __size_type<std::__1::allocator<char>, long, true> {
            typedef typename allocator<char>::size_type type;
        };
template<> struct __size_type<std::__1::allocator<wchar_t>, long, true> {
            typedef typename allocator<wchar_t>::size_type type;
        };
template<> struct __size_type<std::__1::allocator<std::__1::basic_string<char> >, long, true> {
            typedef typename allocator<basic_string<char> >::size_type type;
        };
template<> struct __size_type<std::__1::allocator<int>, long, true> {
            typedef typename allocator<int>::size_type type;
        };
        template <class _Alloc, class _DiffType> struct __size_type<_Alloc, _DiffType, true> {
            typedef typename _Alloc::size_type type;
        };
        template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : std::__1::false_type {
        };
template<> struct __has_propagate_on_container_copy_assignment<std::__1::allocator<char>, void> : std::__1::false_type {
        };
template<> struct __has_propagate_on_container_copy_assignment<std::__1::allocator<wchar_t>, void> : std::__1::false_type {
        };
template<> struct __has_propagate_on_container_copy_assignment<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::false_type {
        };
template<> struct __has_propagate_on_container_copy_assignment<std::__1::allocator<int>, void> : std::__1::false_type {
        };
        template <class _Tp> struct __has_propagate_on_container_copy_assignment<_Tp, typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type> : std::__1::true_type {
        };
        template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value> struct __propagate_on_container_copy_assignment {
            typedef std::__1::false_type type;
        };
template<> struct __propagate_on_container_copy_assignment<std::__1::allocator<char>, false> {
            typedef std::__1::false_type type;
        };
template<> struct __propagate_on_container_copy_assignment<std::__1::allocator<wchar_t>, false> {
            typedef std::__1::false_type type;
        };
template<> struct __propagate_on_container_copy_assignment<std::__1::allocator<std::__1::basic_string<char> >, false> {
            typedef std::__1::false_type type;
        };
template<> struct __propagate_on_container_copy_assignment<std::__1::allocator<int>, false> {
            typedef std::__1::false_type type;
        };
        template <class _Alloc> struct __propagate_on_container_copy_assignment<_Alloc, true> {
            typedef typename _Alloc::propagate_on_container_copy_assignment type;
        };
        template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : std::__1::false_type {
        };
template<> struct __has_propagate_on_container_move_assignment<std::__1::allocator<char>, void> : std::__1::true_type {
        };
template<> struct __has_propagate_on_container_move_assignment<std::__1::allocator<wchar_t>, void> : std::__1::true_type {
        };
template<> struct __has_propagate_on_container_move_assignment<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::true_type {
        };
template<> struct __has_propagate_on_container_move_assignment<std::__1::allocator<int>, void> : std::__1::true_type {
        };
        template <class _Tp> struct __has_propagate_on_container_move_assignment<_Tp, typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type> : std::__1::true_type {
        };
        template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value> struct __propagate_on_container_move_assignment {
            typedef std::__1::false_type type;
        };
template<> struct __propagate_on_container_move_assignment<std::__1::allocator<char>, true> {
            typedef typename allocator<char>::propagate_on_container_move_assignment type;
        };
template<> struct __propagate_on_container_move_assignment<std::__1::allocator<wchar_t>, true> {
            typedef typename allocator<wchar_t>::propagate_on_container_move_assignment type;
        };
template<> struct __propagate_on_container_move_assignment<std::__1::allocator<std::__1::basic_string<char> >, true> {
            typedef typename allocator<basic_string<char> >::propagate_on_container_move_assignment type;
        };
template<> struct __propagate_on_container_move_assignment<std::__1::allocator<int>, true> {
            typedef typename allocator<int>::propagate_on_container_move_assignment type;
        };
        template <class _Alloc> struct __propagate_on_container_move_assignment<_Alloc, true> {
            typedef typename _Alloc::propagate_on_container_move_assignment type;
        };
        template <class _Tp, class = void> struct __has_propagate_on_container_swap : std::__1::false_type {
        };
template<> struct __has_propagate_on_container_swap<std::__1::allocator<char>, void> : std::__1::false_type {
        };
template<> struct __has_propagate_on_container_swap<std::__1::allocator<wchar_t>, void> : std::__1::false_type {
        };
template<> struct __has_propagate_on_container_swap<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::false_type {
        };
template<> struct __has_propagate_on_container_swap<std::__1::allocator<int>, void> : std::__1::false_type {
        };
        template <class _Tp> struct __has_propagate_on_container_swap<_Tp, typename __void_t<typename _Tp::propagate_on_container_swap>::type> : std::__1::true_type {
        };
        template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value> struct __propagate_on_container_swap {
            typedef std::__1::false_type type;
        };
template<> struct __propagate_on_container_swap<std::__1::allocator<char>, false> {
            typedef std::__1::false_type type;
        };
template<> struct __propagate_on_container_swap<std::__1::allocator<wchar_t>, false> {
            typedef std::__1::false_type type;
        };
template<> struct __propagate_on_container_swap<std::__1::allocator<std::__1::basic_string<char> >, false> {
            typedef std::__1::false_type type;
        };
template<> struct __propagate_on_container_swap<std::__1::allocator<int>, false> {
            typedef std::__1::false_type type;
        };
        template <class _Alloc> struct __propagate_on_container_swap<_Alloc, true> {
            typedef typename _Alloc::propagate_on_container_swap type;
        };
        template <class _Tp, class = void> struct __has_is_always_equal : std::__1::false_type {
        };
template<> struct __has_is_always_equal<std::__1::allocator<char>, void> : std::__1::true_type {
        };
template<> struct __has_is_always_equal<std::__1::allocator<wchar_t>, void> : std::__1::true_type {
        };
template<> struct __has_is_always_equal<std::__1::allocator<std::__1::basic_string<char> >, void> : std::__1::true_type {
        };
template<> struct __has_is_always_equal<std::__1::allocator<int>, void> : std::__1::true_type {
        };
        template <class _Tp> struct __has_is_always_equal<_Tp, typename __void_t<typename _Tp::is_always_equal>::type> : std::__1::true_type {
        };
        template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value> struct __is_always_equal {
            typedef typename std::__1::is_empty<_Alloc>::type type;
        };
template<> struct __is_always_equal<std::__1::allocator<char>, true> {
            typedef typename allocator<char>::is_always_equal type;
        };
template<> struct __is_always_equal<std::__1::allocator<wchar_t>, true> {
            typedef typename allocator<wchar_t>::is_always_equal type;
        };
template<> struct __is_always_equal<std::__1::allocator<std::__1::basic_string<char> >, true> {
            typedef typename allocator<basic_string<char> >::is_always_equal type;
        };
template<> struct __is_always_equal<std::__1::allocator<int>, true> {
            typedef typename allocator<int>::is_always_equal type;
        };
        template <class _Alloc> struct __is_always_equal<_Alloc, true> {
            typedef typename _Alloc::is_always_equal type;
        };
        template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value> struct __has_rebind_other {
        private:
            struct __two {
                char __lx;
                char __lxx;
            };
            template <class _Xp> static std::__1::__has_rebind_other::__two __test(...);
            template <class _Xp> static char __test(typename _Xp::template _Xp::rebind<_Up>::other * = 0);
        public:
            static const bool value = sizeof (__test<_Tp>(0)) == 1;
        };
        template <class _Tp, class _Up> struct __has_rebind_other<_Tp, _Up, false> {
            static const bool value = false;
        };
        template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value> struct __allocator_traits_rebind {
            typedef typename _Tp::template _Tp::rebind<_Up>::other type;
        };
        template <template <class> class _Alloc, class _Tp, class _Up> struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true> {
            typedef typename _Alloc<_Tp>::template _Alloc<_Tp>::rebind<_Up>::other type;
        };
        template <template <class> class _Alloc, class _Tp, class _Up> struct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false> {
            typedef _Alloc<_Up> type;
        };
        template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up> struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true> {
            typedef typename _Alloc<_Tp, _A0>::template _Alloc<_Tp, _A0>::rebind<_Up>::other type;
        };
        template <template <class, class> class _Alloc, class _Tp, class _A0, class _Up> struct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false> {
            typedef _Alloc<_Up, _A0> type;
        };
        template <template <class, class, class> class _Alloc, class _Tp, class _A0, class _A1, class _Up> struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true> {
            typedef typename _Alloc<_Tp, _A0, _A1>::template _Alloc<_Tp, _A0, _A1>::rebind<_Up>::other type;
        };
        template <template <class, class, class> class _Alloc, class _Tp, class _A0, class _A1, class _Up> struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false> {
            typedef _Alloc<_Up, _A0, _A1> type;
        };
        template <template <class, class, class, class> class _Alloc, class _Tp, class _A0, class _A1, class _A2, class _Up> struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true> {
            typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template _Alloc<_Tp, _A0, _A1, _A2>::rebind<_Up>::other type;
        };
        template <template <class, class, class, class> class _Alloc, class _Tp, class _A0, class _A1, class _A2, class _Up> struct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false> {
            typedef _Alloc<_Up, _A0, _A1, _A2> type;
        };
        template <class _Alloc, class _SizeType, class _ConstVoidPtr> struct __has_allocate_hint : std::__1::true_type {
        };
        template <class _Alloc, class _Pointer, class _Tp, class = void> struct __has_construct : std::false_type {
        };
template<> struct __has_construct<std::__1::allocator<std::__1::basic_string<char> >, std::__1::basic_string<char> *, const std::__1::basic_string<char> &, void> : std::true_type {
        };
template<> struct __has_construct<std::__1::allocator<std::__1::basic_string<char> >, std::__1::basic_string<char> *, std::__1::basic_string<char>, void> : std::true_type {
        };
template<> struct __has_construct<std::__1::allocator<std::__1::basic_string<char> >, std::__1::basic_string<char> *, std::__1::basic_string<char> &&, void> : std::true_type {
        };
        template <class _Alloc, class _Pointer, class _Tp> struct __has_construct<_Alloc, _Pointer, _Tp, typename __void_t<decltype(std::__1::declval<_Alloc>().construct(std::__1::declval<_Pointer>(), std::__1::declval<_Tp>()))>::type> : std::true_type {
        };
        template <class _Alloc, class _Pointer, class = void> struct __has_destroy : std::__1::false_type {
        };
template<> struct __has_destroy<std::__1::allocator<std::__1::basic_string<char> >, std::__1::basic_string<char> *, void> : std::true_type {
        };
        template <class _Alloc, class _Pointer> struct __has_destroy<_Alloc, _Pointer, typename __void_t<decltype(std::__1::declval<_Alloc>().destroy(std::__1::declval<_Pointer>()))>::type> : std::true_type {
        };
        template <class _Alloc> struct __has_max_size : std::__1::true_type {
        };
template<> struct __has_max_size<const std::__1::allocator<char>> : std::__1::true_type {
        };
template<> struct __has_max_size<const std::__1::allocator<std::__1::basic_string<char> >> : std::__1::true_type {
        };
        template <class _Alloc> struct __has_select_on_container_copy_construction : std::__1::false_type {
        };
        template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value> struct __alloc_traits_difference_type {
            typedef typename pointer_traits<_Ptr>::difference_type type;
        };
template<> struct __alloc_traits_difference_type<std::__1::allocator<char>, char *, true> {
            typedef typename allocator<char>::difference_type type;
        };
template<> struct __alloc_traits_difference_type<std::__1::allocator<wchar_t>, wchar_t *, true> {
            typedef typename allocator<wchar_t>::difference_type type;
        };
template<> struct __alloc_traits_difference_type<std::__1::allocator<std::__1::basic_string<char> >, std::__1::basic_string<char> *, true> {
            typedef typename allocator<basic_string<char> >::difference_type type;
        };
template<> struct __alloc_traits_difference_type<std::__1::allocator<int>, int *, true> {
            typedef typename allocator<int>::difference_type type;
        };
        template <class _Alloc, class _Ptr> struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
            typedef typename _Alloc::difference_type type;
        };
        template <class _Tp> struct __is_default_allocator : std::__1::false_type {
        };
template<> struct __is_default_allocator<std::__1::allocator<char>> : std::__1::true_type {
        };
template<> struct __is_default_allocator<std::__1::allocator<wchar_t>> : std::__1::true_type {
        };
template<> struct __is_default_allocator<std::__1::allocator<std::__1::basic_string<char> >> : std::__1::true_type {
        };
template<> struct __is_default_allocator<std::__1::allocator<int>> : std::__1::true_type {
        };
        template <class _Tp> struct __is_default_allocator<std::__1::allocator<_Tp>> : std::__1::true_type {
        };
        template <class _Alloc, bool = __has_construct<_Alloc, typename _Alloc::value_type *, typename _Alloc::value_type &&>::value && !__is_default_allocator<_Alloc>::value> struct __is_cpp17_move_insertable
template<> struct __is_cpp17_move_insertable<std::__1::allocator<std::__1::basic_string<char> >, false> : std::is_move_constructible<typename allocator<basic_string<char> >::value_type> {
        };
        template <class _Alloc> struct __is_cpp17_move_insertable<_Alloc, true> : std::true_type {
        };
        template <class _Alloc> struct __is_cpp17_move_insertable<_Alloc, false> : std::is_move_constructible<typename _Alloc::value_type> {
        };
        template <class _Alloc, bool = __has_construct<_Alloc, typename _Alloc::value_type *, const typename _Alloc::value_type &>::value && !__is_default_allocator<_Alloc>::value> struct __is_cpp17_copy_insertable;
        template <class _Alloc> struct __is_cpp17_copy_insertable<_Alloc, true> : __is_cpp17_move_insertable<_Alloc> {
        };
        template <class _Alloc> struct __is_cpp17_copy_insertable<_Alloc, false> : integral_constant<bool, std::is_copy_constructible<typename _Alloc::value_type>::value && __is_cpp17_move_insertable<_Alloc>::value> {
        };
        template <class _Alloc> struct __attribute__((type_visibility("default"))) allocator_traits {
            typedef _Alloc allocator_type;
            typedef typename allocator_type::value_type value_type;
            typedef typename __pointer_type<value_type, allocator_type>::type pointer;
            typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
            typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
            typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
            typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
            typedef typename __size_type<allocator_type, difference_type>::type size_type;
            typedef typename __propagate_on_container_copy_assignment<allocator_type>::type propagate_on_container_copy_assignment;
            typedef typename __propagate_on_container_move_assignment<allocator_type>::type propagate_on_container_move_assignment;
            typedef typename __propagate_on_container_swap<allocator_type>::type propagate_on_container_swap;
            typedef typename __is_always_equal<allocator_type>::type is_always_equal;
            template <class _Tp> struct rebind_alloc {
                typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;
            };
            template <class _Tp> struct rebind_traits {
                typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;
            };
            static std::__1::allocator_traits::pointer allocate(std::__1::allocator_traits::allocator_type &__a, std::__1::allocator_traits::size_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __a.allocate(__n);
            }
            static std::__1::allocator_traits::pointer allocate(std::__1::allocator_traits::allocator_type &__a, std::__1::allocator_traits::size_type __n, std::__1::allocator_traits::const_void_pointer __hint) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __allocate(__a, __n, __hint, __has_allocate_hint<std::__1::allocator_traits::allocator_type, std::__1::allocator_traits::size_type, std::__1::allocator_traits::const_void_pointer>());
            }
            static void deallocate(std::__1::allocator_traits::allocator_type &__a, std::__1::allocator_traits::pointer __p, std::__1::allocator_traits::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __a.deallocate(__p, __n);
            }
            template <class _Tp> static void construct(std::__1::allocator_traits::allocator_type &, _Tp *__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp(());
            }
            template <class _Tp, class _A0> static void construct(std::__1::allocator_traits::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __construct(__has_construct<std::__1::allocator_traits::allocator_type, _Tp *, const _A0 &>(), __a, __p, __a0);
            }
            template <class _Tp, class _A0, class _A1> static void construct(std::__1::allocator_traits::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp((__a0, __a1));
            }
            template <class _Tp, class _A0, class _A1, class _A2> static void construct(std::__1::allocator_traits::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1, const _A2 &__a2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp((__a0, __a1, __a2));
            }
            template <class _Tp> static void destroy(std::__1::allocator_traits::allocator_type &__a, _Tp *__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __destroy(__has_destroy<std::__1::allocator_traits::allocator_type, _Tp *>(), __a, __p);
            }
            static std::__1::allocator_traits::size_type max_size(const std::__1::allocator_traits::allocator_type &__a) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __max_size(__has_max_size<const std::__1::allocator_traits::allocator_type>(), __a);
            }
            static std::__1::allocator_traits::allocator_type select_on_container_copy_construction(const std::__1::allocator_traits::allocator_type &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __select_on_container_copy_construction(__has_select_on_container_copy_construction<const std::__1::allocator_traits::allocator_type>(), __a);
            }
            template <class _Ptr> static void __construct_forward_with_exception_guarantees(std::__1::allocator_traits::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__begin2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(__is_cpp17_move_insertable<allocator_type>::value, "The specified type does not meet the requirements of Cpp17MoveInsertible");
                for (; __begin1 != __end1; ++__begin1 , (void)++__begin2)
                    construct(__a, std::__1::__to_address(__begin2), std::__1::move_if_noexcept(*__begin1));
            }
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_forward_with_exception_guarantees(std::__1::allocator_traits::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ptrdiff_t _Np = __end1 - __begin1;
                if (_Np > 0) {
                    std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
                    __begin2 += _Np;
                }
            }
            template <class _Iter, class _Ptr> static void __construct_range_forward(std::__1::allocator_traits::allocator_type &__a, _Iter __begin1, _Iter __end1, _Ptr &__begin2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (; __begin1 != __end1; ++__begin1 , (void)++__begin2)
                    construct(__a, std::__1::__to_address(__begin2), *__begin1);
            }
            template <class _SourceTp, class _DestTp, class _RawSourceTp = typename remove_const<_SourceTp>::type, class _RawDestTp = typename remove_const<_DestTp>::type> static typename enable_if<is_trivially_copy_constructible<_DestTp>::value && is_same<_RawSourceTp, _RawDestTp>::value && (__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _DestTp *, _SourceTp &>::value), void>::type __construct_range_forward(std::__1::allocator_traits::allocator_type &, _SourceTp *__begin1, _SourceTp *__end1, _DestTp *&__begin2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ptrdiff_t _Np = __end1 - __begin1;
                if (_Np > 0) {
                    std::__1::memcpy(const_cast<_RawDestTp *>(__begin2), __begin1, _Np * sizeof(_DestTp));
                    __begin2 += _Np;
                }
            }
            template <class _Ptr> static void __construct_backward_with_exception_guarantees(std::__1::allocator_traits::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__end2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(__is_cpp17_move_insertable<allocator_type>::value, "The specified type does not meet the requirements of Cpp17MoveInsertable");
                while (__end1 != __begin1)
                    {
                        construct(__a, std::__1::__to_address(__end2 - 1), std::__1::move_if_noexcept(*--__end1));
                        --__end2;
                    }
            }
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_backward_with_exception_guarantees(std::__1::allocator_traits::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__end2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ptrdiff_t _Np = __end1 - __begin1;
                __end2 -= _Np;
                if (_Np > 0)
                    std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
            }
        private:
            static std::__1::allocator_traits::pointer __allocate(std::__1::allocator_traits::allocator_type &__a, std::__1::allocator_traits::size_type __n, std::__1::allocator_traits::const_void_pointer __hint, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __a.allocate(__n, __hint);
            }
            static std::__1::allocator_traits::pointer __allocate(std::__1::allocator_traits::allocator_type &__a, std::__1::allocator_traits::size_type __n, std::__1::allocator_traits::const_void_pointer, std::__1::false_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __a.allocate(__n);
            }
            template <class _Tp, class _A0> static void __construct(std::__1::true_type, std::__1::allocator_traits::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __a.construct(__p, __a0);
            }
            template <class _Tp, class _A0> static void __construct(std::__1::false_type, std::__1::allocator_traits::allocator_type &, _Tp *__p, const _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp((__a0));
            }
            template <class _Tp> static void __destroy(std::__1::true_type, std::__1::allocator_traits::allocator_type &__a, _Tp *__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __a.destroy(__p);
            }
            template <class _Tp> static void __destroy(std::__1::false_type, std::__1::allocator_traits::allocator_type &, _Tp *__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __p->~_Tp();
            }
            static std::__1::allocator_traits::size_type __max_size(std::__1::true_type, const std::__1::allocator_traits::allocator_type &__a) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __a.max_size();
            }
            static std::__1::allocator_traits::size_type __max_size(std::__1::false_type, const std::__1::allocator_traits::allocator_type &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return numeric_limits<size_type>::max() / sizeof(std::__1::allocator_traits::value_type);
            }
            static std::__1::allocator_traits::allocator_type __select_on_container_copy_construction(std::__1::true_type, const std::__1::allocator_traits::allocator_type &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __a.select_on_container_copy_construction();
            }
            static std::__1::allocator_traits::allocator_type __select_on_container_copy_construction(std::__1::false_type, const std::__1::allocator_traits::allocator_type &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __a;
            }
        };
template<> struct allocator_traits<std::__1::allocator<char>> {
            typedef std::__1::allocator<char> allocator_type;
            typedef typename allocator_type::value_type value_type;
            typedef typename __pointer_type<value_type, allocator_type>::type pointer;
            typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
            typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
            typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
            typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
            typedef typename __size_type<allocator_type, difference_type>::type size_type;
            typedef typename __propagate_on_container_copy_assignment<allocator_type>::type propagate_on_container_copy_assignment;
            typedef typename __propagate_on_container_move_assignment<allocator_type>::type propagate_on_container_move_assignment;
            typedef typename __propagate_on_container_swap<allocator_type>::type propagate_on_container_swap;
            typedef typename __is_always_equal<allocator_type>::type is_always_equal;
            template <class _Tp> struct rebind_alloc;
            template <class _Tp> struct rebind_traits;
            static std::__1::allocator_traits<std::__1::allocator<char> >::pointer allocate(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<char> >::size_type __n) __attribute__((internal_linkage))             {
                return __a.allocate(__n);
            }
            static std::__1::allocator_traits<std::__1::allocator<char> >::pointer allocate(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<char> >::size_type __n, std::__1::allocator_traits<std::__1::allocator<char> >::const_void_pointer __hint) __attribute__((internal_linkage));
            static void deallocate(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<char> >::pointer __p, std::__1::allocator_traits<std::__1::allocator<char> >::size_type __n) throw() __attribute__((internal_linkage))             {
                __a.deallocate(__p, __n);
            }
            template <class _Tp> static void construct(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &, _Tp *__p) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void construct(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp, class _A0, class _A1> static void construct(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _Tp, class _A0, class _A1, class _A2> static void construct(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1, const _A2 &__a2) __attribute__((internal_linkage));
            template <class _Tp> static void destroy(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, _Tp *__p) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<char> >::size_type max_size(const std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a) throw() __attribute__((internal_linkage))             {
                return __max_size(__has_max_size<const std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type>(), __a);
            }
            static std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type select_on_container_copy_construction(const std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a) __attribute__((internal_linkage));
            template <class _Ptr> static void __construct_forward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__begin2) __attribute__((internal_linkage));
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_forward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((internal_linkage));
            template <class _Iter, class _Ptr> static void __construct_range_forward(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, _Iter __begin1, _Iter __end1, _Ptr &__begin2) __attribute__((internal_linkage));
            template <class _SourceTp, class _DestTp, class _RawSourceTp = typename remove_const<_SourceTp>::type, class _RawDestTp = typename remove_const<_DestTp>::type> static typename enable_if<is_trivially_copy_constructible<_DestTp>::value && is_same<_RawSourceTp, _RawDestTp>::value && (__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _DestTp *, _SourceTp &>::value), void>::type __construct_range_forward(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &, _SourceTp *__begin1, _SourceTp *__end1, _DestTp *&__begin2) __attribute__((internal_linkage));
            template <class _Ptr> static void __construct_backward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__end2) __attribute__((internal_linkage));
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_backward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__end2) __attribute__((internal_linkage));
        private:
            static std::__1::allocator_traits<std::__1::allocator<char> >::pointer __allocate(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<char> >::size_type __n, std::__1::allocator_traits<std::__1::allocator<char> >::const_void_pointer __hint, std::__1::true_type) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<char> >::pointer __allocate(std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<char> >::size_type __n, std::__1::allocator_traits<std::__1::allocator<char> >::const_void_pointer, std::__1::false_type) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void __construct(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void __construct(std::__1::false_type, std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp> static void __destroy(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a, _Tp *__p) __attribute__((internal_linkage));
            template <class _Tp> static void __destroy(std::__1::false_type, std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &, _Tp *__p) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<char> >::size_type __max_size(std::__1::true_type, const std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a) throw() __attribute__((internal_linkage))             {
                return __a.max_size();
            }
            static std::__1::allocator_traits<std::__1::allocator<char> >::size_type __max_size(std::__1::false_type, const std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &) throw() __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type __select_on_container_copy_construction(std::__1::true_type, const std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type __select_on_container_copy_construction(std::__1::false_type, const std::__1::allocator_traits<std::__1::allocator<char> >::allocator_type &__a) __attribute__((internal_linkage));
        };
template<> struct allocator_traits<std::__1::allocator<wchar_t>> {
            typedef std::__1::allocator<wchar_t> allocator_type;
            typedef typename allocator_type::value_type value_type;
            typedef typename __pointer_type<value_type, allocator_type>::type pointer;
            typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
            typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
            typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
            typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
            typedef typename __size_type<allocator_type, difference_type>::type size_type;
            typedef typename __propagate_on_container_copy_assignment<allocator_type>::type propagate_on_container_copy_assignment;
            typedef typename __propagate_on_container_move_assignment<allocator_type>::type propagate_on_container_move_assignment;
            typedef typename __propagate_on_container_swap<allocator_type>::type propagate_on_container_swap;
            typedef typename __is_always_equal<allocator_type>::type is_always_equal;
            template <class _Tp> struct rebind_alloc;
            template <class _Tp> struct rebind_traits;
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::pointer allocate(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::size_type __n) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::pointer allocate(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::size_type __n, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::const_void_pointer __hint) __attribute__((internal_linkage));
            static void deallocate(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::pointer __p, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::size_type __n) throw() __attribute__((internal_linkage))             {
                __a.deallocate(__p, __n);
            }
            template <class _Tp> static void construct(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &, _Tp *__p) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void construct(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp, class _A0, class _A1> static void construct(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _Tp, class _A0, class _A1, class _A2> static void construct(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1, const _A2 &__a2) __attribute__((internal_linkage));
            template <class _Tp> static void destroy(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, _Tp *__p) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::size_type max_size(const std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a) throw() __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type select_on_container_copy_construction(const std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a) __attribute__((internal_linkage));
            template <class _Ptr> static void __construct_forward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__begin2) __attribute__((internal_linkage));
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_forward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((internal_linkage));
            template <class _Iter, class _Ptr> static void __construct_range_forward(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, _Iter __begin1, _Iter __end1, _Ptr &__begin2) __attribute__((internal_linkage));
            template <class _SourceTp, class _DestTp, class _RawSourceTp = typename remove_const<_SourceTp>::type, class _RawDestTp = typename remove_const<_DestTp>::type> static typename enable_if<is_trivially_copy_constructible<_DestTp>::value && is_same<_RawSourceTp, _RawDestTp>::value && (__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _DestTp *, _SourceTp &>::value), void>::type __construct_range_forward(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &, _SourceTp *__begin1, _SourceTp *__end1, _DestTp *&__begin2) __attribute__((internal_linkage));
            template <class _Ptr> static void __construct_backward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__end2) __attribute__((internal_linkage));
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_backward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__end2) __attribute__((internal_linkage));
        private:
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::pointer __allocate(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::size_type __n, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::const_void_pointer __hint, std::__1::true_type) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::pointer __allocate(std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::size_type __n, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::const_void_pointer, std::__1::false_type) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void __construct(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void __construct(std::__1::false_type, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp> static void __destroy(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a, _Tp *__p) __attribute__((internal_linkage));
            template <class _Tp> static void __destroy(std::__1::false_type, std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &, _Tp *__p) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::size_type __max_size(std::__1::true_type, const std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a) throw() __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::size_type __max_size(std::__1::false_type, const std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &) throw() __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type __select_on_container_copy_construction(std::__1::true_type, const std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type __select_on_container_copy_construction(std::__1::false_type, const std::__1::allocator_traits<std::__1::allocator<wchar_t> >::allocator_type &__a) __attribute__((internal_linkage));
        };
template<> struct allocator_traits<std::__1::allocator<std::__1::basic_string<char> >> {
            typedef std::__1::allocator<std::__1::basic_string<char> > allocator_type;
            typedef typename allocator_type::value_type value_type;
            typedef typename __pointer_type<value_type, allocator_type>::type pointer;
            typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
            typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
            typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
            typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
            typedef typename __size_type<allocator_type, difference_type>::type size_type;
            typedef typename __propagate_on_container_copy_assignment<allocator_type>::type propagate_on_container_copy_assignment;
            typedef typename __propagate_on_container_move_assignment<allocator_type>::type propagate_on_container_move_assignment;
            typedef typename __propagate_on_container_swap<allocator_type>::type propagate_on_container_swap;
            typedef typename __is_always_equal<allocator_type>::type is_always_equal;
            template <class _Tp> struct rebind_alloc;
            template <class _Tp> struct rebind_traits;
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::pointer allocate(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) __attribute__((internal_linkage))             {
                return __a.allocate(__n);
            }
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::pointer allocate(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::const_void_pointer __hint) __attribute__((internal_linkage));
            static void deallocate(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::pointer __p, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) throw() __attribute__((internal_linkage))             {
                __a.deallocate(__p, __n);
            }
            template <class _Tp> static void construct(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &, _Tp *__p) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void construct(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template<> static void construct<std::__1::basic_string<char>, std::__1::basic_string<char>>(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::basic_string<char> *__p, const std::__1::basic_string<char> &__a0) __attribute__((internal_linkage))             {
                __construct(__has_construct<std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type, std::__1::basic_string<char> *, const std::__1::basic_string<char> &>(), __a, __p, __a0);
            }
;
            template <class _Tp, class _A0, class _A1> static void construct(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _Tp, class _A0, class _A1, class _A2> static void construct(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1, const _A2 &__a2) __attribute__((internal_linkage));
            template <class _Tp> static void destroy(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, _Tp *__p) __attribute__((internal_linkage));
            template<> static void destroy<std::__1::basic_string<char>>(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::basic_string<char> *__p) __attribute__((internal_linkage))             {
                __destroy(__has_destroy<std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type, std::__1::basic_string<char> *>(), __a, __p);
            }
;
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::size_type max_size(const std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a) throw() __attribute__((internal_linkage))             {
                return __max_size(__has_max_size<const std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type>(), __a);
            }
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type select_on_container_copy_construction(const std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a) __attribute__((internal_linkage));
            template <class _Ptr> static void __construct_forward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__begin2) __attribute__((internal_linkage));
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_forward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((internal_linkage));
            template <class _Iter, class _Ptr> static void __construct_range_forward(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, _Iter __begin1, _Iter __end1, _Ptr &__begin2) __attribute__((internal_linkage));
            template <class _SourceTp, class _DestTp, class _RawSourceTp = typename remove_const<_SourceTp>::type, class _RawDestTp = typename remove_const<_DestTp>::type> static typename enable_if<is_trivially_copy_constructible<_DestTp>::value && is_same<_RawSourceTp, _RawDestTp>::value && (__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _DestTp *, _SourceTp &>::value), void>::type __construct_range_forward(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &, _SourceTp *__begin1, _SourceTp *__end1, _DestTp *&__begin2) __attribute__((internal_linkage));
            template <class _Ptr> static void __construct_backward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__end2) __attribute__((internal_linkage));
            template<> static void __construct_backward_with_exception_guarantees<std::__1::basic_string<char> *>(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::basic_string<char> *__begin1, std::__1::basic_string<char> *__end1, std::__1::basic_string<char> *&__end2) __attribute__((internal_linkage))             {
                static_assert(__is_cpp17_move_insertable<allocator_type>::value, "The specified type does not meet the requirements of Cpp17MoveInsertable");
                while (__end1 != __begin1)
                    {
                        construct(__a, std::__1::__to_address(__end2 - 1), std::__1::move_if_noexcept(*--__end1));
                        --__end2;
                    }
            }
;
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_backward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__end2) __attribute__((internal_linkage));
        private:
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::pointer __allocate(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::const_void_pointer __hint, std::__1::true_type) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::pointer __allocate(std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::const_void_pointer, std::__1::false_type) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void __construct(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template<> static void __construct<std::__1::basic_string<char>, std::__1::basic_string<char>>(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::basic_string<char> *__p, const std::__1::basic_string<char> &__a0) __attribute__((internal_linkage))             {
                __a.construct(__p, __a0);
            }
;
            template <class _Tp, class _A0> static void __construct(std::__1::false_type, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp> static void __destroy(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, _Tp *__p) __attribute__((internal_linkage));
            template<> static void __destroy<std::__1::basic_string<char>>(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, std::__1::basic_string<char> *__p) __attribute__((internal_linkage))             {
                __a.destroy(__p);
            }
;
            template <class _Tp> static void __destroy(std::__1::false_type, std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &, _Tp *__p) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::size_type __max_size(std::__1::true_type, const std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a) throw() __attribute__((internal_linkage))             {
                return __a.max_size();
            }
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::size_type __max_size(std::__1::false_type, const std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &) throw() __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type __select_on_container_copy_construction(std::__1::true_type, const std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type __select_on_container_copy_construction(std::__1::false_type, const std::__1::allocator_traits<std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a) __attribute__((internal_linkage));
        };
template<> struct allocator_traits<std::__1::allocator<int>> {
            typedef std::__1::allocator<int> allocator_type;
            typedef typename allocator_type::value_type value_type;
            typedef typename __pointer_type<value_type, allocator_type>::type pointer;
            typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
            typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
            typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;
            typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
            typedef typename __size_type<allocator_type, difference_type>::type size_type;
            typedef typename __propagate_on_container_copy_assignment<allocator_type>::type propagate_on_container_copy_assignment;
            typedef typename __propagate_on_container_move_assignment<allocator_type>::type propagate_on_container_move_assignment;
            typedef typename __propagate_on_container_swap<allocator_type>::type propagate_on_container_swap;
            typedef typename __is_always_equal<allocator_type>::type is_always_equal;
            template <class _Tp> struct rebind_alloc;
            template <class _Tp> struct rebind_traits;
            static std::__1::allocator_traits<std::__1::allocator<int> >::pointer allocate(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<int> >::size_type __n) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<int> >::pointer allocate(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<int> >::size_type __n, std::__1::allocator_traits<std::__1::allocator<int> >::const_void_pointer __hint) __attribute__((internal_linkage));
            static void deallocate(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<int> >::pointer __p, std::__1::allocator_traits<std::__1::allocator<int> >::size_type __n) throw() __attribute__((internal_linkage));
            template <class _Tp> static void construct(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &, _Tp *__p) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void construct(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp, class _A0, class _A1> static void construct(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _Tp, class _A0, class _A1, class _A2> static void construct(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &, _Tp *__p, const _A0 &__a0, const _A1 &__a1, const _A2 &__a2) __attribute__((internal_linkage));
            template <class _Tp> static void destroy(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, _Tp *__p) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<int> >::size_type max_size(const std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a) throw() __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type select_on_container_copy_construction(const std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a) __attribute__((internal_linkage));
            template <class _Ptr> static void __construct_forward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__begin2) __attribute__((internal_linkage));
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_forward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__begin2) __attribute__((internal_linkage));
            template <class _Iter, class _Ptr> static void __construct_range_forward(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, _Iter __begin1, _Iter __end1, _Ptr &__begin2) __attribute__((internal_linkage));
            template <class _SourceTp, class _DestTp, class _RawSourceTp = typename remove_const<_SourceTp>::type, class _RawDestTp = typename remove_const<_DestTp>::type> static typename enable_if<is_trivially_copy_constructible<_DestTp>::value && is_same<_RawSourceTp, _RawDestTp>::value && (__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _DestTp *, _SourceTp &>::value), void>::type __construct_range_forward(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &, _SourceTp *__begin1, _SourceTp *__end1, _DestTp *&__begin2) __attribute__((internal_linkage));
            template <class _Ptr> static void __construct_backward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, _Ptr __begin1, _Ptr __end1, _Ptr &__end2) __attribute__((internal_linkage));
            template <class _Tp> static typename enable_if<(__is_default_allocator<allocator_type>::value || !__has_construct<allocator_type, _Tp *, _Tp>::value) && is_trivially_move_constructible<_Tp>::value, void>::type __construct_backward_with_exception_guarantees(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &, _Tp *__begin1, _Tp *__end1, _Tp *&__end2) __attribute__((internal_linkage));
        private:
            static std::__1::allocator_traits<std::__1::allocator<int> >::pointer __allocate(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<int> >::size_type __n, std::__1::allocator_traits<std::__1::allocator<int> >::const_void_pointer __hint, std::__1::true_type) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<int> >::pointer __allocate(std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, std::__1::allocator_traits<std::__1::allocator<int> >::size_type __n, std::__1::allocator_traits<std::__1::allocator<int> >::const_void_pointer, std::__1::false_type) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void __construct(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp, class _A0> static void __construct(std::__1::false_type, std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &, _Tp *__p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _Tp> static void __destroy(std::__1::true_type, std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a, _Tp *__p) __attribute__((internal_linkage));
            template <class _Tp> static void __destroy(std::__1::false_type, std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &, _Tp *__p) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<int> >::size_type __max_size(std::__1::true_type, const std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a) throw() __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<int> >::size_type __max_size(std::__1::false_type, const std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &) throw() __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type __select_on_container_copy_construction(std::__1::true_type, const std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a) __attribute__((internal_linkage));
            static std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type __select_on_container_copy_construction(std::__1::false_type, const std::__1::allocator_traits<std::__1::allocator<int> >::allocator_type &__a) __attribute__((internal_linkage));
        };
        template <class _Traits, class _Tp> struct __rebind_alloc_helper {
            typedef typename _Traits::template _Traits::rebind_alloc<_Tp>::other type;
        };
        template <class _Tp> class __attribute__((type_visibility("default"))) allocator {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef _Tp *pointer;
            typedef const _Tp *const_pointer;
            typedef _Tp &reference;
            typedef const _Tp &const_reference;
            typedef _Tp value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
            allocator<_Tp>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> allocator<_Tp>(const allocator<_Up> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::allocator::pointer address(std::__1::allocator::reference __x) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::addressof(__x);
            }
            std::__1::allocator::const_pointer address(std::__1::allocator::const_reference __x) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::addressof(__x);
            }
            std::__1::allocator::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__n > this->max_size())
                    __throw_length_error("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
                return static_cast<std::__1::allocator::pointer>(std::__1::__libcpp_allocate(__n * sizeof(_Tp), __alignof(_Tp)));
            }
            void deallocate(std::__1::allocator::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(_Tp), __alignof(_Tp));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::allocator::size_type(~0) / sizeof(_Tp);
            }
            void construct(std::__1::allocator::pointer __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp(());
            }
            template <class _A0> void construct(std::__1::allocator::pointer __p, _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp((__a0));
            }
            template <class _A0> void construct(std::__1::allocator::pointer __p, const _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp((__a0));
            }
            template <class _A0, class _A1> void construct(std::__1::allocator::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp((__a0, __a1));
            }
            template <class _A0, class _A1> void construct(std::__1::allocator::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp((__a0, __a1));
            }
            template <class _A0, class _A1> void construct(std::__1::allocator::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp((__a0, __a1));
            }
            template <class _A0, class _A1> void construct(std::__1::allocator::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)__p) _Tp((__a0, __a1));
            }
            void destroy(std::__1::allocator::pointer __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __p->~_Tp();
            }
        };
template<> class allocator<char> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef char *pointer;
            typedef const char *const_pointer;
            typedef char &reference;
            typedef const char &const_reference;
            typedef char value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage))             {
            }
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            template<> allocator<char>(const allocator<char> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<char>::pointer address(std::__1::allocator<char>::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<char>::const_pointer address(std::__1::allocator<char>::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<char>::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((internal_linkage))             {
                if (__n > this->max_size())
                    __throw_length_error("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
                return static_cast<std::__1::allocator<char>::pointer>(std::__1::__libcpp_allocate(__n * sizeof(char), __alignof(char)));
            }
            void deallocate(std::__1::allocator<char>::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(char), __alignof(char));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage))             {
                return std::__1::allocator::size_type(~0) / sizeof(char);
            }
            void construct(std::__1::allocator<char>::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<char>::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<char>::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<char>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<char>::pointer __p) __attribute__((internal_linkage));
        };
template<> class allocator<wchar_t> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef wchar_t *pointer;
            typedef const wchar_t *const_pointer;
            typedef wchar_t &reference;
            typedef const wchar_t &const_reference;
            typedef wchar_t value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage));
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<wchar_t>::pointer address(std::__1::allocator<wchar_t>::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<wchar_t>::const_pointer address(std::__1::allocator<wchar_t>::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<wchar_t>::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((internal_linkage));
            void deallocate(std::__1::allocator<wchar_t>::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(wchar_t), __alignof(wchar_t));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage));
            void construct(std::__1::allocator<wchar_t>::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<wchar_t>::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<wchar_t>::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<wchar_t>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<wchar_t>::pointer __p) __attribute__((internal_linkage));
        };
template<> class allocator<std::__1::basic_string<char>> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef std::__1::basic_string<char> *pointer;
            typedef const std::__1::basic_string<char> *const_pointer;
            typedef std::__1::basic_string<char> &reference;
            typedef const std::__1::basic_string<char> &const_reference;
            typedef std::__1::basic_string<char> value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage))             {
            }
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<std::__1::basic_string<char> >::pointer address(std::__1::allocator<std::__1::basic_string<char> >::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<std::__1::basic_string<char> >::const_pointer address(std::__1::allocator<std::__1::basic_string<char> >::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<std::__1::basic_string<char> >::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer = 0) __attribute__((internal_linkage))             {
                if (__n > this->max_size())
                    __throw_length_error("allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size");
                return static_cast<std::__1::allocator<std::__1::basic_string<char> >::pointer>(std::__1::__libcpp_allocate(__n * sizeof(std::__1::basic_string<char>), __alignof(std::__1::basic_string<char>)));
            }
            void deallocate(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(std::__1::basic_string<char>), __alignof(std::__1::basic_string<char>));
            }
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage))             {
                return std::__1::allocator::size_type(~0) / sizeof(std::__1::basic_string<char>);
            }
            void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template<> void construct<const std::__1::basic_string<char>>(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const std::__1::basic_string<char> &__a0) __attribute__((internal_linkage));
            template<> void construct<std::__1::basic_string<char>>(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, std::__1::basic_string<char> &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template<> void construct<std::__1::basic_string<char>>(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const std::__1::basic_string<char> &__a0) __attribute__((internal_linkage))             {
                ::new ((void *)__p) std::__1::basic_string<char>(__a0);
            }
;
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<std::__1::basic_string<char> >::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<std::__1::basic_string<char> >::pointer __p) __attribute__((internal_linkage))             {
                __p->~basic_string<char>();
            }
        };
template<> class allocator<int> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef int *pointer;
            typedef const int *const_pointer;
            typedef int &reference;
            typedef const int &const_reference;
            typedef int value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind;
            allocator() throw() __attribute__((internal_linkage));
            template <class _Up> allocator(const allocator<_Up> &) throw() __attribute__((internal_linkage));
            std::__1::allocator<int>::pointer address(std::__1::allocator<int>::reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<int>::const_pointer address(std::__1::allocator<int>::const_reference __x) const throw() __attribute__((internal_linkage));
            std::__1::allocator<int>::pointer allocate(std::__1::allocator::size_type __n, allocator<void>::const_pointer) __attribute__((internal_linkage));
            void deallocate(std::__1::allocator<int>::pointer __p, std::__1::allocator::size_type __n) throw() __attribute__((internal_linkage));
            std::__1::allocator::size_type max_size() const throw() __attribute__((internal_linkage));
            void construct(std::__1::allocator<int>::pointer __p) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<int>::pointer __p, _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0> void construct(std::__1::allocator<int>::pointer __p, const _A0 &__a0) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            template <class _A0, class _A1> void construct(std::__1::allocator<int>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((internal_linkage));
            void destroy(std::__1::allocator<int>::pointer __p) __attribute__((internal_linkage));
        };
        template <class _Tp> class __attribute__((type_visibility("default"))) allocator<const _Tp> {
        public:
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef const _Tp *pointer;
            typedef const _Tp *const_pointer;
            typedef const _Tp &reference;
            typedef const _Tp &const_reference;
            typedef const _Tp value_type;
            typedef std::__1::true_type propagate_on_container_move_assignment;
            typedef std::__1::true_type is_always_equal;
            template <class _Up> struct rebind {
                typedef allocator<_Up> other;
            };
            allocator<const type-parameter-0-0>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> allocator<const type-parameter-0-0>(const allocator<_Up> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::allocator<const type-parameter-0-0>::const_pointer address(std::__1::allocator<const type-parameter-0-0>::const_reference __x) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::addressof(__x);
            }
            std::__1::allocator<const type-parameter-0-0>::pointer allocate(std::__1::allocator<const type-parameter-0-0>::size_type __n, allocator<void>::const_pointer = 0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__n > this->max_size())
                    __throw_length_error("allocator<const T>::allocate(size_t n) 'n' exceeds maximum supported size");
                return static_cast<std::__1::allocator<const type-parameter-0-0>::pointer>(std::__1::__libcpp_allocate(__n * sizeof(_Tp), __alignof(_Tp)));
            }
            void deallocate(std::__1::allocator<const type-parameter-0-0>::pointer __p, std::__1::allocator<const type-parameter-0-0>::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::__libcpp_deallocate((void *)const_cast<_Tp *>(__p), __n * sizeof(_Tp), __alignof(_Tp));
            }
            std::__1::allocator<const type-parameter-0-0>::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::allocator<const type-parameter-0-0>::size_type(~0) / sizeof(_Tp);
            }
            void construct(std::__1::allocator<const type-parameter-0-0>::pointer __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)const_cast<_Tp *>(__p)) _Tp(());
            }
            template <class _A0> void construct(std::__1::allocator<const type-parameter-0-0>::pointer __p, _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0));
            }
            template <class _A0> void construct(std::__1::allocator<const type-parameter-0-0>::pointer __p, const _A0 &__a0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0));
            }
            template <class _A0, class _A1> void construct(std::__1::allocator<const type-parameter-0-0>::pointer __p, _A0 &__a0, _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0, __a1));
            }
            template <class _A0, class _A1> void construct(std::__1::allocator<const type-parameter-0-0>::pointer __p, const _A0 &__a0, _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0, __a1));
            }
            template <class _A0, class _A1> void construct(std::__1::allocator<const type-parameter-0-0>::pointer __p, _A0 &__a0, const _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0, __a1));
            }
            template <class _A0, class _A1> void construct(std::__1::allocator<const type-parameter-0-0>::pointer __p, const _A0 &__a0, const _A1 &__a1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0, __a1));
            }
            void destroy(std::__1::allocator<const type-parameter-0-0>::pointer __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __p->~_Tp();
            }
        };
        template <class _Tp, class _Up> inline bool operator==(const allocator<_Tp> &, const allocator<_Up> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return true;
        }
        template <class _Tp, class _Up> inline bool operator!=(const allocator<_Tp> &, const allocator<_Up> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return false;
        }
        template <class _OutputIterator, class _Tp> class __attribute__((type_visibility("default"))) raw_storage_iterator : public iterator<std::__1::output_iterator_tag, _Tp, ptrdiff_t, _Tp *, raw_storage_iterator<_OutputIterator, _Tp> &> {
        private:
            _OutputIterator __x_;
        public:
            explicit raw_storage_iterator<_OutputIterator, _Tp>(_OutputIterator __x) : __x_(__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            raw_storage_iterator<_OutputIterator, _Tp> &operator*() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            raw_storage_iterator<_OutputIterator, _Tp> &operator=(const _Tp &__element) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ::new (std::__1::addressof(*this->__x_)) _Tp((__element));
                return *this;
            }
            raw_storage_iterator<_OutputIterator, _Tp> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ++this->__x_;
                return *this;
            }
            raw_storage_iterator<_OutputIterator, _Tp> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                raw_storage_iterator<_OutputIterator, _Tp> __t(*this);
                ++this->__x_;
                return __t;
            }
        };
        template <class _Tp> pair<_Tp *, ptrdiff_t> get_temporary_buffer(ptrdiff_t __n) throw() __attribute__((no_sanitize("cfi")))         {
            pair<_Tp *, ptrdiff_t> __r(0, 0);
            const ptrdiff_t __m = (~ptrdiff_t(0) ^ ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1))) / sizeof(_Tp);
            if (__n > __m)
                __n = __m;
            while (__n > 0)
                {
                    if (__is_overaligned_for_new(__alignof(_Tp))) {
                        return __r;
                    }
                    __r.first = static_cast<_Tp *>(::operator new(__n * sizeof(_Tp), nothrow));
                    if (__r.first) {
                        __r.second = __n;
                        break;
                    }
                    __n /= 2;
                }
            return __r;
        }
        template <class _Tp> inline void return_temporary_buffer(_Tp *__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::__libcpp_deallocate_unsized((void *)__p, __alignof(_Tp));
        }
        template <class _Tp> struct auto_ptr_ref {
            _Tp *__ptr_;
        };
        template <class _Tp> class __attribute__((type_visibility("default"))) auto_ptr {
        private:
            _Tp *__ptr_;
        public:
            typedef _Tp element_type;
            explicit auto_ptr<_Tp>(_Tp *__p = 0) throw() : __ptr_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            auto_ptr<_Tp>(auto_ptr<_Tp> &__p) throw() : __ptr_(__p.release()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> auto_ptr<_Tp>(auto_ptr<_Up> &__p) throw() : __ptr_(__p.release()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            auto_ptr<_Tp> &operator=(auto_ptr<_Tp> &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->reset(__p.release());
                return *this;
            }
            template <class _Up> auto_ptr<_Tp> &operator=(auto_ptr<_Up> &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->reset(__p.release());
                return *this;
            }
            auto_ptr<_Tp> &operator=(auto_ptr_ref<_Tp> __p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->reset(__p.__ptr_);
                return *this;
            }
            ~auto_ptr<_Tp>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                delete this->__ptr_;
            }
            _Tp &operator*() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__ptr_;
            }
            _Tp *operator->() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_;
            }
            _Tp *get() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_;
            }
            _Tp *release() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                _Tp *__t = this->__ptr_;
                this->__ptr_ = 0;
                return __t;
            }
            void reset(_Tp *__p = 0) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__ptr_ != __p)
                    delete this->__ptr_;
                this->__ptr_ = __p;
            }
            auto_ptr<_Tp>(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> operator auto_ptr_ref<_Up>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                auto_ptr_ref<_Up> __t;
                __t.__ptr_ = this->release();
                return __t;
            }
            template <class _Up> operator auto_ptr<_Up>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return auto_ptr<_Up>(this->release());
            }
        };
        template<> class __attribute__((type_visibility("default"))) auto_ptr<void> {
        public:
            typedef void element_type;
        };
        struct __default_init_tag {
        };
        struct __value_init_tag {
        };
        template <class _Tp, int _Idx, bool _CanBeEmptyBase = is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value> struct __compressed_pair_elem {
            typedef _Tp _ParamT;
            typedef _Tp &reference;
            typedef const _Tp &const_reference;
            __compressed_pair_elem<_Tp, _Idx, _CanBeEmptyBase>(std::__1::__default_init_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __compressed_pair_elem<_Tp, _Idx, _CanBeEmptyBase>(std::__1::__value_init_tag) : __value_() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<_Tp, _Idx, _CanBeEmptyBase>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem<_Tp, _Idx, _CanBeEmptyBase>(_Up &&__u) : __value_(std::__1::forward<_Up>(__u)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__compressed_pair_elem::reference __get() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__value_;
            }
            std::__1::__compressed_pair_elem::const_reference __get() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__value_;
            }
        private:
            _Tp __value_;
        };
template<> struct __compressed_pair_elem<void *, 0, false> {
            typedef void *_ParamT;
            typedef void *&reference;
            typedef void *const &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<void *, 0, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            template<> explicit __compressed_pair_elem<void *&, void>(void *&__u) : __value_(std::__1::forward<void *&>(__u)) __attribute__((internal_linkage))             {
            }
;
            template<> explicit __compressed_pair_elem<void *, void>(void *&&__u) : __value_(std::__1::forward<void *>(__u)) __attribute__((internal_linkage))             {
            }
;
            std::__1::__compressed_pair_elem<void *, 0, false>::reference __get() throw() __attribute__((internal_linkage))             {
                return this->__value_;
            }
            std::__1::__compressed_pair_elem<void *, 0, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            void *__value_;
        };
template<> struct __compressed_pair_elem<std::__1::__builtin_new_allocator::__builtin_new_deleter, 1, false> {
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter _ParamT;
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter &reference;
            typedef const std::__1::__builtin_new_allocator::__builtin_new_deleter &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<__builtin_new_deleter, 1, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            template<> explicit __compressed_pair_elem<std::__1::__builtin_new_allocator::__builtin_new_deleter, void>(std::__1::__builtin_new_allocator::__builtin_new_deleter &&__u) : __value_(std::__1::forward<std::__1::__builtin_new_allocator::__builtin_new_deleter>(__u)) __attribute__((internal_linkage))             {
            }
;
            std::__1::__compressed_pair_elem<std::__1::__builtin_new_allocator::__builtin_new_deleter, 1, false>::reference __get() throw() __attribute__((internal_linkage))             {
                return this->__value_;
            }
            std::__1::__compressed_pair_elem<std::__1::__builtin_new_allocator::__builtin_new_deleter, 1, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            std::__1::__builtin_new_allocator::__builtin_new_deleter __value_;
        };
template<> struct __compressed_pair_elem<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, 0, false> {
            typedef std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep _ParamT;
            typedef std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep &reference;
            typedef const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) : __value_() __attribute__((internal_linkage))             {
            }
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<__rep, 0, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            template<> explicit __compressed_pair_elem<std::__1::__default_init_tag, void>(std::__1::__default_init_tag &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, 0, false>::reference __get() throw() __attribute__((internal_linkage))             {
                return this->__value_;
            }
            std::__1::__compressed_pair_elem<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, 0, false>::const_reference __get() const throw() __attribute__((internal_linkage))             {
                return this->__value_;
            }
        private:
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep __value_;
        };
template<> struct __compressed_pair_elem<std::__1::allocator<char>, 1, true> : private std::__1::allocator<char> {
            typedef std::__1::allocator<char> _ParamT;
            typedef std::__1::allocator<char> &reference;
            typedef const std::__1::allocator<char> &const_reference;
            typedef std::__1::allocator<char> __value_type;
            __compressed_pair_elem() __attribute__((internal_linkage)) = default
            __compressed_pair_elem(std::__1::__default_init_tag) : std::__1::allocator<char>() __attribute__((internal_linkage))             {
            }
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<allocator<char>, 1, true>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            template<> explicit __compressed_pair_elem<std::__1::__default_init_tag, void>(std::__1::__default_init_tag &&__u) __attribute__((internal_linkage));
            template<> explicit __compressed_pair_elem<const std::__1::allocator<char> &, void>(const std::__1::allocator<char> &__u) : std::__1::__compressed_pair_elem<std::__1::allocator<char>, 1, true>::__value_type(std::__1::forward<const std::__1::allocator<char> &>(__u)) __attribute__((internal_linkage))             {
            }
;
            std::__1::__compressed_pair_elem<std::__1::allocator<char>, 1, true>::reference __get() throw() __attribute__((internal_linkage))             {
                return *this;
            }
            std::__1::__compressed_pair_elem<std::__1::allocator<char>, 1, true>::const_reference __get() const throw() __attribute__((internal_linkage))             {
                return *this;
            }
        };
template<> struct __compressed_pair_elem<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, 0, false> {
            typedef std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep _ParamT;
            typedef std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep &reference;
            typedef const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<__rep, 0, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, 0, false>::reference __get() throw() __attribute__((internal_linkage))             {
                return this->__value_;
            }
            std::__1::__compressed_pair_elem<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, 0, false>::const_reference __get() const throw() __attribute__((internal_linkage))             {
                return this->__value_;
            }
        private:
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep __value_;
        };
template<> struct __compressed_pair_elem<std::__1::allocator<wchar_t>, 1, true> : private std::__1::allocator<wchar_t> {
            typedef std::__1::allocator<wchar_t> _ParamT;
            typedef std::__1::allocator<wchar_t> &reference;
            typedef const std::__1::allocator<wchar_t> &const_reference;
            typedef std::__1::allocator<wchar_t> __value_type;
            __compressed_pair_elem() __attribute__((internal_linkage)) = default
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<allocator<wchar_t>, 1, true>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<std::__1::allocator<wchar_t>, 1, true>::reference __get() throw() __attribute__((internal_linkage))             {
                return *this;
            }
            std::__1::__compressed_pair_elem<std::__1::allocator<wchar_t>, 1, true>::const_reference __get() const throw() __attribute__((internal_linkage));
        };
template<> struct __compressed_pair_elem<unsigned char *, 0, false> {
            typedef unsigned char *_ParamT;
            typedef unsigned char *&reference;
            typedef unsigned char *const &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<unsigned char *, 0, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<unsigned char *, 0, false>::reference __get() throw() __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<unsigned char *, 0, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            unsigned char *__value_;
        };
template<> struct __compressed_pair_elem<void (*)(void *), 1, false> {
            typedef void (*_ParamT)(void *);
            typedef void (*&reference)(void *);
            typedef void (*const &const_reference)(void *);
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<void (*)(void *), 1, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<void (*)(void *), 1, false>::reference __get() throw() __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<void (*)(void *), 1, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            void (*__value_)(void *);
        };
template<> struct __compressed_pair_elem<char *, 0, false> {
            typedef char *_ParamT;
            typedef char *&reference;
            typedef char *const &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<char *, 0, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<char *, 0, false>::reference __get() throw() __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<char *, 0, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            char *__value_;
        };
template<> struct __compressed_pair_elem<unsigned int *, 0, false> {
            typedef unsigned int *_ParamT;
            typedef unsigned int *&reference;
            typedef unsigned int *const &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<unsigned int *, 0, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<unsigned int *, 0, false>::reference __get() throw() __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<unsigned int *, 0, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            unsigned int *__value_;
        };
template<> struct __compressed_pair_elem<__sFILE *, 0, false> {
            typedef __sFILE *_ParamT;
            typedef __sFILE *&reference;
            typedef __sFILE *const &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<__sFILE *, 0, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<__sFILE *, 0, false>::reference __get() throw() __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<__sFILE *, 0, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            __sFILE *__value_;
        };
template<> struct __compressed_pair_elem<int (*)(__sFILE *), 1, false> {
            typedef int (*_ParamT)(__sFILE *);
            typedef int (*&reference)(__sFILE *);
            typedef int (*const &const_reference)(__sFILE *);
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<int (*)(__sFILE *), 1, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<int (*)(__sFILE *), 1, false>::reference __get() throw() __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<int (*)(__sFILE *), 1, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            int (*__value_)(__sFILE *);
        };
template<> struct __compressed_pair_elem<std::__1::basic_string<char> *, 0, false> {
            typedef std::__1::basic_string<char> *_ParamT;
            typedef std::__1::basic_string<char> *&reference;
            typedef std::__1::basic_string<char> *const &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<basic_string<char> *, 0, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            template<> explicit __compressed_pair_elem<std::__1::nullptr_t, void>(std::__1::nullptr_t &&__u) : __value_(std::__1::forward<std::__1::nullptr_t>(__u)) __attribute__((internal_linkage))             {
            }
;
            std::__1::__compressed_pair_elem<std::__1::basic_string<char> *, 0, false>::reference __get() throw() __attribute__((internal_linkage))             {
                return this->__value_;
            }
            std::__1::__compressed_pair_elem<std::__1::basic_string<char> *, 0, false>::const_reference __get() const throw() __attribute__((internal_linkage))             {
                return this->__value_;
            }
        private:
            std::__1::basic_string<char> *__value_;
        };
template<> struct __compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> >, 1, true> : private std::__1::allocator<std::__1::basic_string<char> > {
            typedef std::__1::allocator<std::__1::basic_string<char> > _ParamT;
            typedef std::__1::allocator<std::__1::basic_string<char> > &reference;
            typedef const std::__1::allocator<std::__1::basic_string<char> > &const_reference;
            typedef std::__1::allocator<std::__1::basic_string<char> > __value_type;
            __compressed_pair_elem() __attribute__((internal_linkage)) = default
            __compressed_pair_elem(std::__1::__default_init_tag) : std::__1::allocator<std::__1::basic_string<char> >() __attribute__((internal_linkage))             {
            }
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<allocator<basic_string<char> >, 1, true>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            template<> explicit __compressed_pair_elem<std::__1::__default_init_tag, void>(std::__1::__default_init_tag &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> >, 1, true>::reference __get() throw() __attribute__((internal_linkage))             {
                return *this;
            }
            std::__1::__compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> >, 1, true>::const_reference __get() const throw() __attribute__((internal_linkage))             {
                return *this;
            }
        };
template<> struct __compressed_pair_elem<int *, 0, false> {
            typedef int *_ParamT;
            typedef int *&reference;
            typedef int *const &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<int *, 0, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<int *, 0, false>::reference __get() throw() __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<int *, 0, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            int *__value_;
        };
template<> struct __compressed_pair_elem<std::__1::allocator<int>, 1, true> : private std::__1::allocator<int> {
            typedef std::__1::allocator<int> _ParamT;
            typedef std::__1::allocator<int> &reference;
            typedef const std::__1::allocator<int> &const_reference;
            typedef std::__1::allocator<int> __value_type;
            __compressed_pair_elem() __attribute__((internal_linkage)) = default
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<allocator<int>, 1, true>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<std::__1::allocator<int>, 1, true>::reference __get() throw() __attribute__((internal_linkage));
            std::__1::__compressed_pair_elem<std::__1::allocator<int>, 1, true>::const_reference __get() const throw() __attribute__((internal_linkage));
        };
template<> struct __compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> > &, 1, false> {
            typedef std::__1::allocator<std::__1::basic_string<char> > &_ParamT;
            typedef std::__1::allocator<std::__1::basic_string<char> > &reference;
            typedef std::__1::allocator<std::__1::basic_string<char> > &const_reference;
            __compressed_pair_elem(std::__1::__default_init_tag) __attribute__((internal_linkage));
            __compressed_pair_elem(std::__1::__value_init_tag) __attribute__((internal_linkage));
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<allocator<basic_string<char> > &, 1, false>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem(_Up &&__u) __attribute__((internal_linkage));
            template<> explicit __compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> > &, void>(std::__1::allocator<std::__1::basic_string<char> > &__u) : __value_(std::__1::forward<std::__1::allocator<std::__1::basic_string<char> > &>(__u)) __attribute__((internal_linkage))             {
            }
;
            std::__1::__compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> > &, 1, false>::reference __get() throw() __attribute__((internal_linkage))             {
                return this->__value_;
            }
            std::__1::__compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> > &, 1, false>::const_reference __get() const throw() __attribute__((internal_linkage));
        private:
            std::__1::allocator<std::__1::basic_string<char> > &__value_;
        };
        template <class _Tp, int _Idx> struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
            typedef _Tp _ParamT;
            typedef _Tp &reference;
            typedef const _Tp &const_reference;
            typedef _Tp __value_type;
            __compressed_pair_elem<type-parameter-0-0, _Idx, true>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = default
            __compressed_pair_elem<type-parameter-0-0, _Idx, true>(std::__1::__default_init_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __compressed_pair_elem<type-parameter-0-0, _Idx, true>(std::__1::__value_init_tag) : std::__1::__compressed_pair_elem<type-parameter-0-0, _Idx, true>::__value_type() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up, class = typename enable_if<!is_same<__compressed_pair_elem<type-parameter-0-0, _Idx, true>, typename decay<_Up>::type>::value>::type> explicit __compressed_pair_elem<type-parameter-0-0, _Idx, true>(_Up &&__u) : std::__1::__compressed_pair_elem<type-parameter-0-0, _Idx, true>::__value_type(std::__1::forward<_Up>(__u)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__compressed_pair_elem<type-parameter-0-0, _Idx, true>::reference __get() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            std::__1::__compressed_pair_elem<type-parameter-0-0, _Idx, true>::const_reference __get() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
        };
        template <class _T1, class _T2> class __compressed_pair : private __compressed_pair_elem<_T1, 0>, private __compressed_pair_elem<_T2, 1> {
            typedef __compressed_pair_elem<_T1, 0> _Base1;
            typedef __compressed_pair_elem<_T2, 1> _Base2;
            static_assert((!is_same<_T1, _T2>::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<_T1>, _Dummy>::value && __dependent_type<is_default_constructible<_T2>, _Dummy>::value>::type> __compressed_pair<_T1, _T2>() : std::__1::__compressed_pair::_Base1(std::__1::__value_init_tag()), std::__1::__compressed_pair::_Base2(std::__1::__value_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _U1, class _U2> __compressed_pair<_T1, _T2>(_U1 &&__t1, _U2 &&__t2) : std::__1::__compressed_pair::_Base1(std::forward<_U1>(__t1)), std::__1::__compressed_pair::_Base2(std::forward<_U2>(__t2)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            typename _Base1::reference first() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair::_Base1 &>(*this).__get();
            }
            typename _Base1::const_reference first() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<const std::__1::__compressed_pair::_Base1 &>(*this).__get();
            }
            typename _Base2::reference second() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair::_Base2 &>(*this).__get();
            }
            typename _Base2::const_reference second() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<const std::__1::__compressed_pair::_Base2 &>(*this).__get();
            }
            void swap(__compressed_pair<_T1, _T2> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                using std::swap;
                swap(first(), __x.first());
                swap(second(), __x.second());
            }
        };
template<> class __compressed_pair<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter> : private __compressed_pair_elem<void *, 0>, private __compressed_pair_elem<std::__1::__builtin_new_allocator::__builtin_new_deleter, 1> {
            typedef __compressed_pair_elem<void *, 0> _Base1;
            typedef __compressed_pair_elem<std::__1::__builtin_new_allocator::__builtin_new_deleter, 1> _Base2;
            static_assert((!is_same<void *, __builtin_new_deleter>::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<void *>, _Dummy>::value && __dependent_type<is_default_constructible<__builtin_new_deleter>, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            template<> __compressed_pair<void *&, std::__1::__builtin_new_allocator::__builtin_new_deleter>(void *&__t1, std::__1::__builtin_new_allocator::__builtin_new_deleter &&__t2) : std::__1::__compressed_pair<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter>::_Base1(std::forward<void *&>(__t1)), std::__1::__compressed_pair<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter>::_Base2(std::forward<std::__1::__builtin_new_allocator::__builtin_new_deleter>(__t2)) __attribute__((internal_linkage))             {
            }
;
            template<> __compressed_pair<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter>(void *&&__t1, std::__1::__builtin_new_allocator::__builtin_new_deleter &&__t2) : std::__1::__compressed_pair<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter>::_Base1(std::forward<void *>(__t1)), std::__1::__compressed_pair<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter>::_Base2(std::forward<std::__1::__builtin_new_allocator::__builtin_new_deleter>(__t2)) __attribute__((internal_linkage))             {
            }
;
            typename _Base1::reference first() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter>::_Base1 &>(*this).__get();
            }
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage));
            typename _Base2::reference second() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter>::_Base2 &>(*this).__get();
            }
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage));
            void swap(std::__1::__compressed_pair<void *, std::__1::__builtin_new_allocator::__builtin_new_deleter> &__x) __attribute__((internal_linkage));
        };
template<> class __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char>> : private __compressed_pair_elem<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, 0>, private __compressed_pair_elem<std::__1::allocator<char>, 1> {
            typedef __compressed_pair_elem<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, 0> _Base1;
            typedef __compressed_pair_elem<std::__1::allocator<char>, 1> _Base2;
            static_assert((!is_same<__rep, allocator<char> >::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<__rep>, _Dummy>::value && __dependent_type<is_default_constructible<allocator<char> >, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            template<> __compressed_pair<std::__1::__default_init_tag, std::__1::__default_init_tag>(std::__1::__default_init_tag &&__t1, std::__1::__default_init_tag &&__t2) : std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >::_Base1(std::forward<std::__1::__default_init_tag>(__t1)), std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >::_Base2(std::forward<std::__1::__default_init_tag>(__t2)) __attribute__((internal_linkage))             {
            }
;
            template<> __compressed_pair<std::__1::__default_init_tag, const std::__1::allocator<char> &>(std::__1::__default_init_tag &&__t1, const std::__1::allocator<char> &__t2) : std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >::_Base1(std::forward<std::__1::__default_init_tag>(__t1)), std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >::_Base2(std::forward<const std::__1::allocator<char> &>(__t2)) __attribute__((internal_linkage))             {
            }
;
            typename _Base1::reference first() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >::_Base1 &>(*this).__get();
            }
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage))             {
                return static_cast<const std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >::_Base1 &>(*this).__get();
            }
            typename _Base2::reference second() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >::_Base2 &>(*this).__get();
            }
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage))             {
                return static_cast<const std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >::_Base2 &>(*this).__get();
            }
            void swap(std::__1::__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > &__x) __attribute__((internal_linkage));
        };
template<> class __compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t>> : private __compressed_pair_elem<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, 0>, private __compressed_pair_elem<std::__1::allocator<wchar_t>, 1> {
            typedef __compressed_pair_elem<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, 0> _Base1;
            typedef __compressed_pair_elem<std::__1::allocator<wchar_t>, 1> _Base2;
            static_assert((!is_same<__rep, allocator<wchar_t> >::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<__rep>, _Dummy>::value && __dependent_type<is_default_constructible<allocator<wchar_t> >, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            typename _Base1::reference first() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> >::_Base1 &>(*this).__get();
            }
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage))             {
                return static_cast<const std::__1::__compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> >::_Base1 &>(*this).__get();
            }
            typename _Base2::reference second() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> >::_Base2 &>(*this).__get();
            }
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage));
            void swap(std::__1::__compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::allocator<wchar_t> > &__x) __attribute__((internal_linkage));
        };
template<> class __compressed_pair<unsigned char *, void (*)(void *)> : private __compressed_pair_elem<unsigned char *, 0>, private __compressed_pair_elem<void (*)(void *), 1> {
            typedef __compressed_pair_elem<unsigned char *, 0> _Base1;
            typedef __compressed_pair_elem<void (*)(void *), 1> _Base2;
            static_assert((!is_same<unsigned char *, void (*)(void *)>::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<unsigned char *>, _Dummy>::value && __dependent_type<is_default_constructible<void (*)(void *)>, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            typename _Base1::reference first() throw() __attribute__((internal_linkage));
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage));
            typename _Base2::reference second() throw() __attribute__((internal_linkage));
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage));
            void swap(std::__1::__compressed_pair<unsigned char *, void (*)(void *)> &__x) __attribute__((internal_linkage));
        };
template<> class __compressed_pair<char *, void (*)(void *)> : private __compressed_pair_elem<char *, 0>, private __compressed_pair_elem<void (*)(void *), 1> {
            typedef __compressed_pair_elem<char *, 0> _Base1;
            typedef __compressed_pair_elem<void (*)(void *), 1> _Base2;
            static_assert((!is_same<char *, void (*)(void *)>::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<char *>, _Dummy>::value && __dependent_type<is_default_constructible<void (*)(void *)>, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            typename _Base1::reference first() throw() __attribute__((internal_linkage));
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage));
            typename _Base2::reference second() throw() __attribute__((internal_linkage));
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage));
            void swap(std::__1::__compressed_pair<char *, void (*)(void *)> &__x) __attribute__((internal_linkage));
        };
template<> class __compressed_pair<unsigned int *, void (*)(void *)> : private __compressed_pair_elem<unsigned int *, 0>, private __compressed_pair_elem<void (*)(void *), 1> {
            typedef __compressed_pair_elem<unsigned int *, 0> _Base1;
            typedef __compressed_pair_elem<void (*)(void *), 1> _Base2;
            static_assert((!is_same<unsigned int *, void (*)(void *)>::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<unsigned int *>, _Dummy>::value && __dependent_type<is_default_constructible<void (*)(void *)>, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            typename _Base1::reference first() throw() __attribute__((internal_linkage));
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage));
            typename _Base2::reference second() throw() __attribute__((internal_linkage));
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage));
            void swap(std::__1::__compressed_pair<unsigned int *, void (*)(void *)> &__x) __attribute__((internal_linkage));
        };
template<> class __compressed_pair<__sFILE *, int (*)(__sFILE *)> : private __compressed_pair_elem<__sFILE *, 0>, private __compressed_pair_elem<int (*)(__sFILE *), 1> {
            typedef __compressed_pair_elem<__sFILE *, 0> _Base1;
            typedef __compressed_pair_elem<int (*)(__sFILE *), 1> _Base2;
            static_assert((!is_same<__sFILE *, int (*)(__sFILE *)>::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<__sFILE *>, _Dummy>::value && __dependent_type<is_default_constructible<int (*)(__sFILE *)>, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            typename _Base1::reference first() throw() __attribute__((internal_linkage));
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage));
            typename _Base2::reference second() throw() __attribute__((internal_linkage));
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage));
            void swap(std::__1::__compressed_pair<__sFILE *, int (*)(__sFILE *)> &__x) __attribute__((internal_linkage));
        };
template<> class __compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> >> : private __compressed_pair_elem<std::__1::basic_string<char> *, 0>, private __compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> >, 1> {
            typedef __compressed_pair_elem<std::__1::basic_string<char> *, 0> _Base1;
            typedef __compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> >, 1> _Base2;
            static_assert((!is_same<basic_string<char> *, allocator<basic_string<char> > >::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<basic_string<char> *>, _Dummy>::value && __dependent_type<is_default_constructible<allocator<basic_string<char> > >, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            template<> __compressed_pair<std::__1::nullptr_t, std::__1::__default_init_tag>(std::__1::nullptr_t &&__t1, std::__1::__default_init_tag &&__t2) : std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >::_Base1(std::forward<std::__1::nullptr_t>(__t1)), std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >::_Base2(std::forward<std::__1::__default_init_tag>(__t2)) __attribute__((internal_linkage))             {
            }
;
            typename _Base1::reference first() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >::_Base1 &>(*this).__get();
            }
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage))             {
                return static_cast<const std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >::_Base1 &>(*this).__get();
            }
            typename _Base2::reference second() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >::_Base2 &>(*this).__get();
            }
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage))             {
                return static_cast<const std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >::_Base2 &>(*this).__get();
            }
            void swap(std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > > &__x) __attribute__((internal_linkage));
        };
template<> class __compressed_pair<int *, std::__1::allocator<int>> : private __compressed_pair_elem<int *, 0>, private __compressed_pair_elem<std::__1::allocator<int>, 1> {
            typedef __compressed_pair_elem<int *, 0> _Base1;
            typedef __compressed_pair_elem<std::__1::allocator<int>, 1> _Base2;
            static_assert((!is_same<int *, allocator<int> >::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<int *>, _Dummy>::value && __dependent_type<is_default_constructible<allocator<int> >, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            typename _Base1::reference first() throw() __attribute__((internal_linkage));
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage));
            typename _Base2::reference second() throw() __attribute__((internal_linkage));
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage));
            void swap(std::__1::__compressed_pair<int *, std::__1::allocator<int> > &__x) __attribute__((internal_linkage));
        };
template<> class __compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > &> : private __compressed_pair_elem<std::__1::basic_string<char> *, 0>, private __compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> > &, 1> {
            typedef __compressed_pair_elem<std::__1::basic_string<char> *, 0> _Base1;
            typedef __compressed_pair_elem<std::__1::allocator<std::__1::basic_string<char> > &, 1> _Base2;
            static_assert((!is_same<basic_string<char> *, allocator<basic_string<char> > &>::value), "__compressed_pair cannot be instantated when T1 and T2 are the same type; The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
        public:
            template <bool _Dummy = true, class = typename enable_if<__dependent_type<is_default_constructible<basic_string<char> *>, _Dummy>::value && __dependent_type<is_default_constructible<allocator<basic_string<char> > &>, _Dummy>::value>::type> __compressed_pair() __attribute__((internal_linkage));
            template <class _U1, class _U2> __compressed_pair(_U1 &&__t1, _U2 &&__t2) __attribute__((internal_linkage));
            template<> __compressed_pair<std::__1::nullptr_t, std::__1::allocator<std::__1::basic_string<char> > &>(std::__1::nullptr_t &&__t1, std::__1::allocator<std::__1::basic_string<char> > &__t2) : std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > &>::_Base1(std::forward<std::__1::nullptr_t>(__t1)), std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > &>::_Base2(std::forward<std::__1::allocator<std::__1::basic_string<char> > &>(__t2)) __attribute__((internal_linkage))             {
            }
;
            typename _Base1::reference first() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > &>::_Base1 &>(*this).__get();
            }
            typename _Base1::const_reference first() const throw() __attribute__((internal_linkage))             {
                return static_cast<const std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > &>::_Base1 &>(*this).__get();
            }
            typename _Base2::reference second() throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > &>::_Base2 &>(*this).__get();
            }
            typename _Base2::const_reference second() const throw() __attribute__((internal_linkage));
            void swap(std::__1::__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > &> &__x) __attribute__((internal_linkage));
        };
        template <class _T1, class _T2> inline void swap(__compressed_pair<_T1, _T2> &__x, __compressed_pair<_T1, _T2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _Tp> struct __attribute__((type_visibility("default"))) default_delete {
            static_assert(!is_function<_Tp>::value, "default_delete cannot be instantiated for function types");
            default_delete<_Tp>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> default_delete<_Tp>(const default_delete<_Up> &, typename enable_if<is_convertible<_Up *, _Tp *>::value>::type * = 0) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void operator()(_Tp *__ptr) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(sizeof(_Tp) > 0, "default_delete can not delete incomplete type");
                static_assert(!is_void<_Tp>::value, "default_delete can not delete incomplete type");
                delete __ptr;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) default_delete<_Tp []> {
        private:
            template <class _Up> struct _EnableIfConvertible : enable_if<is_convertible<_Up (*)[], _Tp (*)[]>::value> {
            };
        public:
            default_delete<type-parameter-0-0 []>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> default_delete<type-parameter-0-0 []>(const default_delete<_Up []> &, typename _EnableIfConvertible<_Up>::type * = 0) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> typename _EnableIfConvertible<_Up>::type operator()(_Up *__ptr) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(sizeof(_Tp) > 0, "default_delete can not delete incomplete type");
                static_assert(!is_void<_Tp>::value, "default_delete can not delete void type");
                delete [] __ptr;
            }
        };
        template <class _Deleter> struct __unique_ptr_deleter_sfinae {
            static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
            typedef const _Deleter &__lval_ref_type;
            typedef _Deleter &&__good_rval_ref_type;
            typedef std::__1::true_type __enable_rval_overload;
        };
template<> struct __unique_ptr_deleter_sfinae<std::__1::__builtin_new_allocator::__builtin_new_deleter> {
            static_assert(!is_reference<__builtin_new_deleter>::value, "incorrect specialization");
            typedef const std::__1::__builtin_new_allocator::__builtin_new_deleter &__lval_ref_type;
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter &&__good_rval_ref_type;
            typedef std::__1::true_type __enable_rval_overload;
        };
template<> struct __unique_ptr_deleter_sfinae<void (*)(void *)> {
            static_assert(!is_reference<void (*)(void *)>::value, "incorrect specialization");
            typedef void (*const &__lval_ref_type)(void *);
            typedef void (*&&__good_rval_ref_type)(void *);
            typedef std::__1::true_type __enable_rval_overload;
        };
        template <class _Deleter> struct __unique_ptr_deleter_sfinae<const _Deleter &> {
            typedef const _Deleter &__lval_ref_type;
            typedef const _Deleter &&__bad_rval_ref_type;
            typedef std::__1::false_type __enable_rval_overload;
        };
        template <class _Deleter> struct __unique_ptr_deleter_sfinae<_Deleter &> {
            typedef _Deleter &__lval_ref_type;
            typedef _Deleter &&__bad_rval_ref_type;
            typedef std::__1::false_type __enable_rval_overload;
        };
        template <class _Tp, class _Dp = default_delete<_Tp>> class __attribute__((type_visibility("default"))) unique_ptr {
        public:
            typedef _Tp element_type;
            typedef _Dp deleter_type;
            typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
            static_assert(!is_rvalue_reference<deleter_type>::value, "the specified deleter type cannot be an rvalue reference");
        private:
            __compressed_pair<std::__1::unique_ptr::pointer, std::__1::unique_ptr::deleter_type> __ptr_;
            struct __nat {
                int __for_bool_;
            };
            typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
            template <bool _Dummy> using _LValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
            template <bool _Dummy> using _GoodRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
            template <bool _Dummy> using _BadRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
            template <bool _Dummy, class _Deleter = typename __dependent_type<__identity<deleter_type>, _Dummy>::type> using _EnableIfDeleterDefaultConstructible = typename enable_if<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>::type;
            template <class _ArgType> using _EnableIfDeleterConstructible = typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
            template <class _UPtr, class _Up> using _EnableIfMoveConvertible = typename enable_if<is_convertible<typename _UPtr::pointer, pointer>::value && !is_array<_Up>::value>::type;
            template <class _UDel> using _EnableIfDeleterConvertible = typename enable_if<(is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) || (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)>::type;
            template <class _UDel> using _EnableIfDeleterAssignable = typename enable_if<is_assignable<_Dp &, _UDel &&>::value>::type;
        public:
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr<_Tp, _Dp>() throw() : __ptr_(std::__1::unique_ptr::pointer(), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr<_Tp, _Dp>(std::__1::nullptr_t) throw() : __ptr_(std::__1::unique_ptr::pointer(), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> explicit unique_ptr<_Tp, _Dp>(std::__1::unique_ptr::pointer __p) throw() : __ptr_(__p, std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >> unique_ptr<_Tp, _Dp>(std::__1::unique_ptr::pointer __p, _LValRefType<_Dummy> __d) throw() : __ptr_(__p, __d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >> unique_ptr<_Tp, _Dp>(std::__1::unique_ptr::pointer __p, _GoodRValRefType<_Dummy> __d) throw() : __ptr_(__p, std::__1::move(__d)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
            }
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >> unique_ptr<_Tp, _Dp>(std::__1::unique_ptr::pointer __p, _BadRValRefType<_Dummy> __d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = delete
            unique_ptr<_Tp, _Dp>(unique_ptr<_Tp, _Dp> &&__u) throw() : __ptr_(__u.release(), std::__1::forward<std::__1::unique_ptr::deleter_type>(__u.get_deleter())) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterConvertible<_Ep>> unique_ptr<_Tp, _Dp>(unique_ptr<_Up, _Ep> &&__u) throw() : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up> unique_ptr<_Tp, _Dp>(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, _Tp *>::value && is_same<_Dp, default_delete<_Tp> >::value, __nat>::type = std::__1::unique_ptr::__nat()) throw() : __ptr_(__p.release(), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            unique_ptr<_Tp, _Dp> &operator=(unique_ptr<_Tp, _Dp> &&__u) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->reset(__u.release());
                this->__ptr_.second() = std::__1::forward<std::__1::unique_ptr::deleter_type>(__u.get_deleter());
                return *this;
            }
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterAssignable<_Ep>> unique_ptr<_Tp, _Dp> &operator=(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->reset(__u.release());
                this->__ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
                return *this;
            }
            template <class _Up> typename enable_if<is_convertible<_Up *, _Tp *>::value && is_same<_Dp, default_delete<_Tp> >::value, unique_ptr<_Tp, _Dp> &>::type operator=(auto_ptr<_Up> __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->reset(__p.release());
                return *this;
            }
            unique_ptr<_Tp, _Dp>(const unique_ptr<_Tp, _Dp> &) = delete
            unique_ptr<_Tp, _Dp> &operator=(const unique_ptr<_Tp, _Dp> &) = delete
            ~unique_ptr<_Tp, _Dp>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->reset();
            }
            unique_ptr<_Tp, _Dp> &operator=(std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->reset();
                return *this;
            }
            typename add_lvalue_reference<_Tp>::type operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__ptr_.first();
            }
            std::__1::unique_ptr::pointer operator->() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.first();
            }
            std::__1::unique_ptr::pointer get() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.first();
            }
            std::__1::unique_ptr::deleter_type &get_deleter() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.second();
            }
            const std::__1::unique_ptr::deleter_type &get_deleter() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.second();
            }
            operator bool() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.first() != std::__1::__get_nullptr_t();
            }
            std::__1::unique_ptr::pointer release() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::unique_ptr::pointer __t = this->__ptr_.first();
                this->__ptr_.first() = std::__1::unique_ptr::pointer();
                return __t;
            }
            void reset(std::__1::unique_ptr::pointer __p = std::__1::unique_ptr::pointer()) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::unique_ptr::pointer __tmp = this->__ptr_.first();
                this->__ptr_.first() = __p;
                if (__tmp)
                    this->__ptr_.second()(__tmp);
            }
            void swap(unique_ptr<_Tp, _Dp> &__u) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__ptr_.swap(__u.__ptr_);
            }
        };
template<> class unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> {
        public:
            typedef void element_type;
            typedef std::__1::__builtin_new_allocator::__builtin_new_deleter deleter_type;
            typedef typename __pointer_type<void, deleter_type>::type pointer;
            static_assert(!is_rvalue_reference<deleter_type>::value, "the specified deleter type cannot be an rvalue reference");
        private:
            __compressed_pair<std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer, std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::deleter_type> __ptr_;
            struct __nat;
            typedef __unique_ptr_deleter_sfinae<std::__1::__builtin_new_allocator::__builtin_new_deleter> _DeleterSFINAE;
            template <bool _Dummy> using _LValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
            template <bool _Dummy> using _GoodRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
            template <bool _Dummy> using _BadRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
            template <bool _Dummy, class _Deleter = typename __dependent_type<__identity<deleter_type>, _Dummy>::type> using _EnableIfDeleterDefaultConstructible = typename enable_if<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>::type;
            template <class _ArgType> using _EnableIfDeleterConstructible = typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
            template <class _UPtr, class _Up> using _EnableIfMoveConvertible = typename enable_if<is_convertible<typename _UPtr::pointer, pointer>::value && !is_array<_Up>::value>::type;
            template <class _UDel> using _EnableIfDeleterConvertible = typename enable_if<(is_reference<__builtin_new_deleter>::value && is_same<__builtin_new_deleter, _UDel>::value) || (!is_reference<__builtin_new_deleter>::value && is_convertible<_UDel, __builtin_new_deleter>::value)>::type;
            template <class _UDel> using _EnableIfDeleterAssignable = typename enable_if<is_assignable<__builtin_new_deleter &, _UDel &&>::value>::type;
        public:
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr() throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> explicit unique_ptr(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer __p) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer __p, _LValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template<> unique_ptr<true, void>(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer __p, _LValRefType<true> __d) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer __p, _GoodRValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template<> unique_ptr<true, void>(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer __p, _GoodRValRefType<true> __d) throw() : __ptr_(__p, std::__1::move(__d)) __attribute__((internal_linkage))             {
                static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
            }
;
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer __p, _BadRValRefType<_Dummy> __d) __attribute__((internal_linkage)) = delete
            unique_ptr(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &&__u) throw() : __ptr_(__u.release(), std::__1::forward<std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::deleter_type>(__u.get_deleter())) __attribute__((internal_linkage))             {
            }
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterConvertible<_Ep>> unique_ptr(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template<> unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter, void, void>(unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> unique_ptr(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, void *>::value && is_same<__builtin_new_deleter, default_delete<void> >::value, __nat>::type) throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &operator=(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterAssignable<_Ep>> std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &operator=(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> typename enable_if<is_convertible<_Up *, void *>::value && is_same<__builtin_new_deleter, default_delete<void> >::value, unique_ptr<void, __builtin_new_deleter> &>::type operator=(auto_ptr<_Up> __p) __attribute__((internal_linkage));
            unique_ptr(const std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &) = delete
            std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &operator=(const std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &) = delete
            ~unique_ptr<void, __builtin_new_deleter>() __attribute__((internal_linkage))             {
                this->reset();
            }
            std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &operator=(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            typename add_lvalue_reference<void>::type operator*() const __attribute__((internal_linkage));
            std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer get() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::deleter_type &get_deleter() throw() __attribute__((internal_linkage))             {
                return this->__ptr_.second();
            }
            const std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::deleter_type &get_deleter() const throw() __attribute__((internal_linkage));
            operator bool() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer release() throw() __attribute__((internal_linkage))             {
                std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer __t = this->__ptr_.first();
                this->__ptr_.first() = std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer();
                return __t;
            }
            void reset(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer __p = std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer()) throw() __attribute__((internal_linkage))             {
                std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter>::pointer __tmp = this->__ptr_.first();
                this->__ptr_.first() = __p;
                if (__tmp)
                    this->__ptr_.second()(__tmp);
            }
            void swap(std::__1::unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> &__u) throw() __attribute__((internal_linkage));
        };
template<> class unique_ptr<unsigned char, void (*)(void *)> {
        public:
            typedef unsigned char element_type;
            typedef void (*deleter_type)(void *);
            typedef typename __pointer_type<unsigned char, deleter_type>::type pointer;
            static_assert(!is_rvalue_reference<deleter_type>::value, "the specified deleter type cannot be an rvalue reference");
        private:
            __compressed_pair<std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer, std::__1::unique_ptr<unsigned char, void (*)(void *)>::deleter_type> __ptr_;
            struct __nat;
            typedef __unique_ptr_deleter_sfinae<void (*)(void *)> _DeleterSFINAE;
            template <bool _Dummy> using _LValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
            template <bool _Dummy> using _GoodRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
            template <bool _Dummy> using _BadRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
            template <bool _Dummy, class _Deleter = typename __dependent_type<__identity<deleter_type>, _Dummy>::type> using _EnableIfDeleterDefaultConstructible = typename enable_if<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>::type;
            template <class _ArgType> using _EnableIfDeleterConstructible = typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
            template <class _UPtr, class _Up> using _EnableIfMoveConvertible = typename enable_if<is_convertible<typename _UPtr::pointer, pointer>::value && !is_array<_Up>::value>::type;
            template <class _UDel> using _EnableIfDeleterConvertible = typename enable_if<(is_reference<void (*)(void *)>::value && is_same<void (*)(void *), _UDel>::value) || (!is_reference<void (*)(void *)>::value && is_convertible<_UDel, void (*)(void *)>::value)>::type;
            template <class _UDel> using _EnableIfDeleterAssignable = typename enable_if<is_assignable<void (*&)(void *), _UDel &&>::value>::type;
        public:
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr() throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> explicit unique_ptr(std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer __p) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer __p, _LValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template<> unique_ptr<true, void>(std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer __p, _LValRefType<true> __d) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer __p, _GoodRValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template<> unique_ptr<true, void>(std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer __p, _GoodRValRefType<true> __d) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer __p, _BadRValRefType<_Dummy> __d) __attribute__((internal_linkage)) = delete
            unique_ptr(std::__1::unique_ptr<unsigned char, void (*)(void *)> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterConvertible<_Ep>> unique_ptr(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> unique_ptr(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, unsigned char *>::value && is_same<void (*)(void *), default_delete<unsigned char> >::value, __nat>::type) throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned char, void (*)(void *)> &operator=(std::__1::unique_ptr<unsigned char, void (*)(void *)> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterAssignable<_Ep>> std::__1::unique_ptr<unsigned char, void (*)(void *)> &operator=(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> typename enable_if<is_convertible<_Up *, unsigned char *>::value && is_same<void (*)(void *), default_delete<unsigned char> >::value, unique_ptr<unsigned char, void (*)(void *)> &>::type operator=(auto_ptr<_Up> __p) __attribute__((internal_linkage));
            unique_ptr(const std::__1::unique_ptr<unsigned char, void (*)(void *)> &) = delete
            std::__1::unique_ptr<unsigned char, void (*)(void *)> &operator=(const std::__1::unique_ptr<unsigned char, void (*)(void *)> &) = delete
            ~unique_ptr<unsigned char, void (*)(void *)>() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned char, void (*)(void *)> &operator=(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            typename add_lvalue_reference<unsigned char>::type operator*() const __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer get() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned char, void (*)(void *)>::deleter_type &get_deleter() throw() __attribute__((internal_linkage));
            const std::__1::unique_ptr<unsigned char, void (*)(void *)>::deleter_type &get_deleter() const throw() __attribute__((internal_linkage));
            operator bool() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer release() throw() __attribute__((internal_linkage));
            void reset(std::__1::unique_ptr<unsigned char, void (*)(void *)>::pointer __p) throw() __attribute__((internal_linkage));
            void swap(std::__1::unique_ptr<unsigned char, void (*)(void *)> &__u) throw() __attribute__((internal_linkage));
        };
template<> class unique_ptr<char, void (*)(void *)> {
        public:
            typedef char element_type;
            typedef void (*deleter_type)(void *);
            typedef typename __pointer_type<char, deleter_type>::type pointer;
            static_assert(!is_rvalue_reference<deleter_type>::value, "the specified deleter type cannot be an rvalue reference");
        private:
            __compressed_pair<std::__1::unique_ptr<char, void (*)(void *)>::pointer, std::__1::unique_ptr<char, void (*)(void *)>::deleter_type> __ptr_;
            struct __nat;
            typedef __unique_ptr_deleter_sfinae<void (*)(void *)> _DeleterSFINAE;
            template <bool _Dummy> using _LValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
            template <bool _Dummy> using _GoodRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
            template <bool _Dummy> using _BadRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
            template <bool _Dummy, class _Deleter = typename __dependent_type<__identity<deleter_type>, _Dummy>::type> using _EnableIfDeleterDefaultConstructible = typename enable_if<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>::type;
            template <class _ArgType> using _EnableIfDeleterConstructible = typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
            template <class _UPtr, class _Up> using _EnableIfMoveConvertible = typename enable_if<is_convertible<typename _UPtr::pointer, pointer>::value && !is_array<_Up>::value>::type;
            template <class _UDel> using _EnableIfDeleterConvertible = typename enable_if<(is_reference<void (*)(void *)>::value && is_same<void (*)(void *), _UDel>::value) || (!is_reference<void (*)(void *)>::value && is_convertible<_UDel, void (*)(void *)>::value)>::type;
            template <class _UDel> using _EnableIfDeleterAssignable = typename enable_if<is_assignable<void (*&)(void *), _UDel &&>::value>::type;
        public:
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr() throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> explicit unique_ptr(std::__1::unique_ptr<char, void (*)(void *)>::pointer __p) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<char, void (*)(void *)>::pointer __p, _LValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template<> unique_ptr<true, void>(std::__1::unique_ptr<char, void (*)(void *)>::pointer __p, _LValRefType<true> __d) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<char, void (*)(void *)>::pointer __p, _GoodRValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template<> unique_ptr<true, void>(std::__1::unique_ptr<char, void (*)(void *)>::pointer __p, _GoodRValRefType<true> __d) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<char, void (*)(void *)>::pointer __p, _BadRValRefType<_Dummy> __d) __attribute__((internal_linkage)) = delete
            unique_ptr(std::__1::unique_ptr<char, void (*)(void *)> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterConvertible<_Ep>> unique_ptr(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> unique_ptr(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, char *>::value && is_same<void (*)(void *), default_delete<char> >::value, __nat>::type) throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<char, void (*)(void *)> &operator=(std::__1::unique_ptr<char, void (*)(void *)> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterAssignable<_Ep>> std::__1::unique_ptr<char, void (*)(void *)> &operator=(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> typename enable_if<is_convertible<_Up *, char *>::value && is_same<void (*)(void *), default_delete<char> >::value, unique_ptr<char, void (*)(void *)> &>::type operator=(auto_ptr<_Up> __p) __attribute__((internal_linkage));
            unique_ptr(const std::__1::unique_ptr<char, void (*)(void *)> &) = delete
            std::__1::unique_ptr<char, void (*)(void *)> &operator=(const std::__1::unique_ptr<char, void (*)(void *)> &) = delete
            ~unique_ptr<char, void (*)(void *)>() __attribute__((internal_linkage));
            std::__1::unique_ptr<char, void (*)(void *)> &operator=(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            typename add_lvalue_reference<char>::type operator*() const __attribute__((internal_linkage));
            std::__1::unique_ptr<char, void (*)(void *)>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<char, void (*)(void *)>::pointer get() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<char, void (*)(void *)>::deleter_type &get_deleter() throw() __attribute__((internal_linkage));
            const std::__1::unique_ptr<char, void (*)(void *)>::deleter_type &get_deleter() const throw() __attribute__((internal_linkage));
            operator bool() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<char, void (*)(void *)>::pointer release() throw() __attribute__((internal_linkage));
            void reset(std::__1::unique_ptr<char, void (*)(void *)>::pointer __p) throw() __attribute__((internal_linkage));
            void swap(std::__1::unique_ptr<char, void (*)(void *)> &__u) throw() __attribute__((internal_linkage));
        };
template<> class unique_ptr<unsigned int, void (*)(void *)> {
        public:
            typedef unsigned int element_type;
            typedef void (*deleter_type)(void *);
            typedef typename __pointer_type<unsigned int, deleter_type>::type pointer;
            static_assert(!is_rvalue_reference<deleter_type>::value, "the specified deleter type cannot be an rvalue reference");
        private:
            __compressed_pair<std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer, std::__1::unique_ptr<unsigned int, void (*)(void *)>::deleter_type> __ptr_;
            struct __nat;
            typedef __unique_ptr_deleter_sfinae<void (*)(void *)> _DeleterSFINAE;
            template <bool _Dummy> using _LValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
            template <bool _Dummy> using _GoodRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
            template <bool _Dummy> using _BadRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
            template <bool _Dummy, class _Deleter = typename __dependent_type<__identity<deleter_type>, _Dummy>::type> using _EnableIfDeleterDefaultConstructible = typename enable_if<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>::type;
            template <class _ArgType> using _EnableIfDeleterConstructible = typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
            template <class _UPtr, class _Up> using _EnableIfMoveConvertible = typename enable_if<is_convertible<typename _UPtr::pointer, pointer>::value && !is_array<_Up>::value>::type;
            template <class _UDel> using _EnableIfDeleterConvertible = typename enable_if<(is_reference<void (*)(void *)>::value && is_same<void (*)(void *), _UDel>::value) || (!is_reference<void (*)(void *)>::value && is_convertible<_UDel, void (*)(void *)>::value)>::type;
            template <class _UDel> using _EnableIfDeleterAssignable = typename enable_if<is_assignable<void (*&)(void *), _UDel &&>::value>::type;
        public:
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr() throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> explicit unique_ptr(std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer __p) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer __p, _LValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template<> unique_ptr<true, void>(std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer __p, _LValRefType<true> __d) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer __p, _GoodRValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template<> unique_ptr<true, void>(std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer __p, _GoodRValRefType<true> __d) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer __p, _BadRValRefType<_Dummy> __d) __attribute__((internal_linkage)) = delete
            unique_ptr(std::__1::unique_ptr<unsigned int, void (*)(void *)> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterConvertible<_Ep>> unique_ptr(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> unique_ptr(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, unsigned int *>::value && is_same<void (*)(void *), default_delete<unsigned int> >::value, __nat>::type) throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned int, void (*)(void *)> &operator=(std::__1::unique_ptr<unsigned int, void (*)(void *)> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterAssignable<_Ep>> std::__1::unique_ptr<unsigned int, void (*)(void *)> &operator=(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> typename enable_if<is_convertible<_Up *, unsigned int *>::value && is_same<void (*)(void *), default_delete<unsigned int> >::value, unique_ptr<unsigned int, void (*)(void *)> &>::type operator=(auto_ptr<_Up> __p) __attribute__((internal_linkage));
            unique_ptr(const std::__1::unique_ptr<unsigned int, void (*)(void *)> &) = delete
            std::__1::unique_ptr<unsigned int, void (*)(void *)> &operator=(const std::__1::unique_ptr<unsigned int, void (*)(void *)> &) = delete
            ~unique_ptr<unsigned int, void (*)(void *)>() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned int, void (*)(void *)> &operator=(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            typename add_lvalue_reference<unsigned int>::type operator*() const __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer get() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned int, void (*)(void *)>::deleter_type &get_deleter() throw() __attribute__((internal_linkage));
            const std::__1::unique_ptr<unsigned int, void (*)(void *)>::deleter_type &get_deleter() const throw() __attribute__((internal_linkage));
            operator bool() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer release() throw() __attribute__((internal_linkage));
            void reset(std::__1::unique_ptr<unsigned int, void (*)(void *)>::pointer __p) throw() __attribute__((internal_linkage));
            void swap(std::__1::unique_ptr<unsigned int, void (*)(void *)> &__u) throw() __attribute__((internal_linkage));
        };
template<> class unique_ptr<__sFILE, int (*)(__sFILE *)> {
        public:
            typedef __sFILE element_type;
            typedef int (*deleter_type)(__sFILE *);
            typedef typename __pointer_type<__sFILE, deleter_type>::type pointer;
            static_assert(!is_rvalue_reference<deleter_type>::value, "the specified deleter type cannot be an rvalue reference");
        private:
            __compressed_pair<std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::pointer, std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::deleter_type> __ptr_;
            struct __nat;
            typedef __unique_ptr_deleter_sfinae<int (*)(__sFILE *)> _DeleterSFINAE;
            template <bool _Dummy> using _LValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
            template <bool _Dummy> using _GoodRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
            template <bool _Dummy> using _BadRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
            template <bool _Dummy, class _Deleter = typename __dependent_type<__identity<deleter_type>, _Dummy>::type> using _EnableIfDeleterDefaultConstructible = typename enable_if<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>::type;
            template <class _ArgType> using _EnableIfDeleterConstructible = typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
            template <class _UPtr, class _Up> using _EnableIfMoveConvertible = typename enable_if<is_convertible<typename _UPtr::pointer, pointer>::value && !is_array<_Up>::value>::type;
            template <class _UDel> using _EnableIfDeleterConvertible = typename enable_if<(is_reference<int (*)(__sFILE *)>::value && is_same<int (*)(__sFILE *), _UDel>::value) || (!is_reference<int (*)(__sFILE *)>::value && is_convertible<_UDel, int (*)(__sFILE *)>::value)>::type;
            template <class _UDel> using _EnableIfDeleterAssignable = typename enable_if<is_assignable<int (*&)(__sFILE *), _UDel &&>::value>::type;
        public:
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr() throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> explicit unique_ptr(std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::pointer __p) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::pointer __p, _LValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::pointer __p, _GoodRValRefType<_Dummy> __d) throw() __attribute__((internal_linkage));
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >> unique_ptr(std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::pointer __p, _BadRValRefType<_Dummy> __d) __attribute__((internal_linkage)) = delete
            unique_ptr(std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterConvertible<_Ep>> unique_ptr(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> unique_ptr(auto_ptr<_Up> &&__p, typename enable_if<is_convertible<_Up *, __sFILE *>::value && is_same<int (*)(__sFILE *), default_delete<__sFILE> >::value, __nat>::type) throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)> &operator=(std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterAssignable<_Ep>> std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)> &operator=(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((internal_linkage));
            template <class _Up> typename enable_if<is_convertible<_Up *, __sFILE *>::value && is_same<int (*)(__sFILE *), default_delete<__sFILE> >::value, unique_ptr<__sFILE, int (*)(__sFILE *)> &>::type operator=(auto_ptr<_Up> __p) __attribute__((internal_linkage));
            unique_ptr(const std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)> &) = delete
            std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)> &operator=(const std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)> &) = delete
            ~unique_ptr<__sFILE, int (*)(__sFILE *)>() __attribute__((internal_linkage));
            std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)> &operator=(std::__1::nullptr_t) throw() __attribute__((internal_linkage));
            typename add_lvalue_reference<__sFILE>::type operator*() const __attribute__((internal_linkage));
            std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::pointer operator->() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::pointer get() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::deleter_type &get_deleter() throw() __attribute__((internal_linkage));
            const std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::deleter_type &get_deleter() const throw() __attribute__((internal_linkage));
            operator bool() const throw() __attribute__((internal_linkage));
            std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::pointer release() throw() __attribute__((internal_linkage));
            void reset(std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)>::pointer __p) throw() __attribute__((internal_linkage));
            void swap(std::__1::unique_ptr<__sFILE, int (*)(__sFILE *)> &__u) throw() __attribute__((internal_linkage));
        };
        template <class _Tp, class _Dp> class __attribute__((type_visibility("default"))) unique_ptr<_Tp [], _Dp> {
        public:
            typedef _Tp element_type;
            typedef _Dp deleter_type;
            typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
        private:
            __compressed_pair<std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer, std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::deleter_type> __ptr_;
            template <class _From> struct _CheckArrayPointerConversion : is_same<_From, std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer> {
            };
            template <class _FromElem> struct _CheckArrayPointerConversion<_FromElem *> : integral_constant<bool, is_same<_FromElem *, pointer>::value || (is_same<pointer, element_type *>::value && is_convertible<_FromElem (*)[], element_type (*)[]>::value)> {
            };
            typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
            template <bool _Dummy> using _LValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
            template <bool _Dummy> using _GoodRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
            template <bool _Dummy> using _BadRValRefType = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
            template <bool _Dummy, class _Deleter = typename __dependent_type<__identity<deleter_type>, _Dummy>::type> using _EnableIfDeleterDefaultConstructible = typename enable_if<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>::type;
            template <class _ArgType> using _EnableIfDeleterConstructible = typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
            template <class _Pp> using _EnableIfPointerConvertible = typename enable_if<_CheckArrayPointerConversion<_Pp>::value>::type;
            template <class _UPtr, class _Up, class _ElemT = typename _UPtr::element_type> using _EnableIfMoveConvertible = typename enable_if<is_array<_Up>::value && is_same<pointer, element_type *>::value && is_same<typename _UPtr::pointer, _ElemT *>::value && is_convertible<_ElemT (*)[], element_type (*)[]>::value>::type;
            template <class _UDel> using _EnableIfDeleterConvertible = typename enable_if<(is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) || (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)>::type;
            template <class _UDel> using _EnableIfDeleterAssignable = typename enable_if<is_assignable<_Dp &, _UDel &&>::value>::type;
        public:
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>() throw() : __ptr_(std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer(), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(std::__1::nullptr_t) throw() : __ptr_(std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer(), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Pp, bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy>, class = _EnableIfPointerConvertible<_Pp>> explicit unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Pp __p) throw() : __ptr_(__p, std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Pp, bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >, class = _EnableIfPointerConvertible<_Pp>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Pp __p, _LValRefType<_Dummy> __d) throw() : __ptr_(__p, __d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(std::__1::nullptr_t, _LValRefType<_Dummy> __d) throw() : __ptr_(std::__1::__get_nullptr_t(), __d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Pp, bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >, class = _EnableIfPointerConvertible<_Pp>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Pp __p, _GoodRValRefType<_Dummy> __d) throw() : __ptr_(__p, std::__1::move(__d)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
            }
            template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(std::__1::nullptr_t, _GoodRValRefType<_Dummy> __d) throw() : __ptr_(std::__1::__get_nullptr_t(), std::__1::move(__d)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
            }
            template <class _Pp, bool _Dummy = true, class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >, class = _EnableIfPointerConvertible<_Pp>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(_Pp __p, _BadRValRefType<_Dummy> __d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = delete
            unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &&__u) throw() : __ptr_(__u.release(), std::__1::forward<std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::deleter_type>(__u.get_deleter())) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &&__u) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                reset(__u.release());
                this->__ptr_.second() = std::__1::forward<std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::deleter_type>(__u.get_deleter());
                return *this;
            }
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterConvertible<_Ep>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(unique_ptr<_Up, _Ep> &&__u) throw() : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Up, class _Ep, class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>, class = _EnableIfDeleterAssignable<_Ep>> unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(unique_ptr<_Up, _Ep> &&__u) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                reset(__u.release());
                this->__ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
                return *this;
            }
            unique_ptr<type-parameter-0-0 [], type-parameter-0-1>(const unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &) = delete
            unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(const unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &) = delete
        public:
            ~unique_ptr<type-parameter-0-0 [], type-parameter-0-1>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                reset();
            }
            unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &operator=(std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                reset();
                return *this;
            }
            typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.first()[__i];
            }
            std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer get() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.first();
            }
            std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::deleter_type &get_deleter() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.second();
            }
            const std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::deleter_type &get_deleter() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.second();
            }
            operator bool() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_.first() != std::__1::__get_nullptr_t();
            }
            std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer release() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer __t = this->__ptr_.first();
                this->__ptr_.first() = std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer();
                return __t;
            }
            template <class _Pp> typename enable_if<_CheckArrayPointerConversion<_Pp>::value>::type reset(_Pp __p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer __tmp = this->__ptr_.first();
                this->__ptr_.first() = __p;
                if (__tmp)
                    this->__ptr_.second()(__tmp);
            }
            void reset(std::__1::nullptr_t = std::__1::__get_nullptr_t()) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::unique_ptr<type-parameter-0-0 [], type-parameter-0-1>::pointer __tmp = this->__ptr_.first();
                this->__ptr_.first() = std::__1::__get_nullptr_t();
                if (__tmp)
                    this->__ptr_.second()(__tmp);
            }
            void swap(unique_ptr<type-parameter-0-0 [], type-parameter-0-1> &__u) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__ptr_.swap(__u.__ptr_);
            }
        };
        template <class _Tp, class _Dp> inline typename enable_if<__is_swappable<_Dp>::value, void>::type swap(unique_ptr<_Tp, _Dp> &__x, unique_ptr<_Tp, _Dp> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator==(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.get() == __y.get();
        }
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator!=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator<(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename unique_ptr<_T1, _D1>::pointer _P1;
            typedef typename unique_ptr<_T2, _D2>::pointer _P2;
            typedef typename common_type<_P1, _P2>::type _Vp;
            return less<_Vp>()(__x.get(), __y.get());
        }
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator>(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator<=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _T1, class _D1, class _T2, class _D2> inline bool operator>=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _T1, class _D1> inline bool operator==(const unique_ptr<_T1, _D1> &__x, std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !__x;
        }
        template <class _T1, class _D1> inline bool operator==(std::__1::nullptr_t, const unique_ptr<_T1, _D1> &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !__x;
        }
        template <class _T1, class _D1> inline bool operator!=(const unique_ptr<_T1, _D1> &__x, std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return static_cast<bool>(__x);
        }
        template <class _T1, class _D1> inline bool operator!=(std::__1::nullptr_t, const unique_ptr<_T1, _D1> &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return static_cast<bool>(__x);
        }
        template <class _T1, class _D1> inline bool operator<(const unique_ptr<_T1, _D1> &__x, std::__1::nullptr_t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename unique_ptr<_T1, _D1>::pointer _P1;
            return less<_P1>()(__x.get(), std::__1::__get_nullptr_t());
        }
        template <class _T1, class _D1> inline bool operator<(std::__1::nullptr_t, const unique_ptr<_T1, _D1> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename unique_ptr<_T1, _D1>::pointer _P1;
            return less<_P1>()(std::__1::__get_nullptr_t(), __x.get());
        }
        template <class _T1, class _D1> inline bool operator>(const unique_ptr<_T1, _D1> &__x, std::__1::nullptr_t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__get_nullptr_t() < __x;
        }
        template <class _T1, class _D1> inline bool operator>(std::__1::nullptr_t, const unique_ptr<_T1, _D1> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x < std::__1::__get_nullptr_t();
        }
        template <class _T1, class _D1> inline bool operator<=(const unique_ptr<_T1, _D1> &__x, std::__1::nullptr_t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(std::__1::__get_nullptr_t() < __x);
        }
        template <class _T1, class _D1> inline bool operator<=(std::__1::nullptr_t, const unique_ptr<_T1, _D1> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < std::__1::__get_nullptr_t());
        }
        template <class _T1, class _D1> inline bool operator>=(const unique_ptr<_T1, _D1> &__x, std::__1::nullptr_t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < std::__1::__get_nullptr_t());
        }
        template <class _T1, class _D1> inline bool operator>=(std::__1::nullptr_t, const unique_ptr<_T1, _D1> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(std::__1::__get_nullptr_t() < __x);
        }
        template <class _Tp, class _Dp> struct __attribute__((type_visibility("default"))) hash<unique_ptr<_Tp, _Dp>> {
            typedef unique_ptr<_Tp, _Dp> argument_type;
            typedef size_t result_type;
            std::__1::hash<unique_ptr<type-parameter-0-0, type-parameter-0-1> >::result_type operator()(const std::__1::hash<unique_ptr<type-parameter-0-0, type-parameter-0-1> >::argument_type &__ptr) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef typename argument_type::pointer pointer;
                return hash<pointer>()(__ptr.get());
            }
        };
        struct __destruct_n {
        private:
            size_t __size_;
            template <class _Tp> void __process(_Tp *__p, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (size_t __i = 0; __i < this->__size_; ++__i , ++__p)
                    __p->~_Tp();
            }
            template <class _Tp> void __process(_Tp *, std::__1::true_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __incr(std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ++this->__size_;
            }
            void __incr(std::__1::true_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __set(size_t __s, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__size_ = __s;
            }
            void __set(size_t, std::__1::true_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        public:
            explicit __destruct_n(size_t __s) throw() : __size_(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Tp> void __incr(_Tp *) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());
            }
            template <class _Tp> void __set(size_t __s, _Tp *) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());
            }
            template <class _Tp> void operator()(_Tp *__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());
            }
        };
        template <class _Alloc> class __allocator_destructor {
            typedef allocator_traits<_Alloc> __alloc_traits;
        public:
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::size_type size_type;
        private:
            _Alloc &__alloc_;
            std::__1::__allocator_destructor::size_type __s_;
        public:
            __allocator_destructor<_Alloc>(_Alloc &__a, std::__1::__allocator_destructor::size_type __s) throw() : __alloc_(__a), __s_(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void operator()(std::__1::__allocator_destructor::pointer __p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __alloc_traits::deallocate(this->__alloc_, __p, this->__s_);
            }
        };
        template <class _InputIterator, class _ForwardIterator> _ForwardIterator uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            _ForwardIterator __s = __r;
            try {
                for (; __f != __l; ++__f , (void)++__r)
                    ::new (static_cast<void *>(std::__1::addressof(*__r))) value_type((*__f));
            } catch (...) {
                for (; __s != __r; ++__s)
                    __s->~value_type();
                throw;
            }
            return __r;
        }
        template <class _InputIterator, class _Size, class _ForwardIterator> _ForwardIterator uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            _ForwardIterator __s = __r;
            try {
                for (; __n > 0; ++__f , (void)++__r , (void)--__n)
                    ::new (static_cast<void *>(std::__1::addressof(*__r))) value_type((*__f));
            } catch (...) {
                for (; __s != __r; ++__s)
                    __s->~value_type();
                throw;
            }
            return __r;
        }
        template <class _ForwardIterator, class _Tp> void uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp &__x)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            _ForwardIterator __s = __f;
            try {
                for (; __f != __l; ++__f)
                    ::new (static_cast<void *>(std::__1::addressof(*__f))) value_type((__x));
            } catch (...) {
                for (; __s != __f; ++__s)
                    __s->~value_type();
                throw;
            }
        }
        template <class _ForwardIterator, class _Size, class _Tp> _ForwardIterator uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp &__x)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            _ForwardIterator __s = __f;
            try {
                for (; __n > 0; ++__f , (void)--__n)
                    ::new (static_cast<void *>(std::__1::addressof(*__f))) value_type((__x));
            } catch (...) {
                for (; __s != __f; ++__s)
                    __s->~value_type();
                throw;
            }
            return __f;
        }
        template <class _Tp> inline _Tp __libcpp_atomic_refcount_increment(_Tp &__t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __atomic_add_fetch(&__t, 1, 0);
        }
        template<> inline long __libcpp_atomic_refcount_increment<long>(long &__t) throw() __attribute__((internal_linkage))         {
            return __atomic_add_fetch(&__t, 1, 0);
        }
        template <class _Tp> inline _Tp __libcpp_atomic_refcount_decrement(_Tp &__t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __atomic_add_fetch(&__t, -1, 4);
        }
        template<> inline long __libcpp_atomic_refcount_decrement<long>(long &__t) throw() __attribute__((internal_linkage))         {
            return __atomic_add_fetch(&__t, -1, 4);
        }
        class __attribute__((visibility("default"))) bad_weak_ptr : public std::exception {
        public:
            virtual ~bad_weak_ptr() throw();
            virtual const char *what() const throw();
        };
        inline void __throw_bad_weak_ptr() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::__1::bad_weak_ptr();
        }
        template <class _Tp> class __attribute__((type_visibility("default"))) weak_ptr;
        class __attribute__((visibility("default"))) __shared_count {
            __shared_count(const std::__1::__shared_count &);
            std::__1::__shared_count &operator=(const std::__1::__shared_count &);
        protected:
            long __shared_owners_;
            virtual ~__shared_count();
        private:
            virtual void __on_zero_shared() throw() = 0;
        public:
            explicit __shared_count(long __refs = 0) throw() : __shared_owners_(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __add_shared() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __libcpp_atomic_refcount_increment(this->__shared_owners_);
            }
            bool __release_shared() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__libcpp_atomic_refcount_decrement(this->__shared_owners_) == -1) {
                    this->__on_zero_shared();
                    return true;
                }
                return false;
            }
            long use_count() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __libcpp_relaxed_load(&this->__shared_owners_) + 1;
            }
        };
        class __attribute__((visibility("default"))) __shared_weak_count : private std::__1::__shared_count {
            long __shared_weak_owners_;
        public:
            explicit __shared_weak_count(long __refs = 0) throw() : std::__1::__shared_count(__refs), __shared_weak_owners_(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        protected:
            virtual ~__shared_weak_count();
        public:
            void __add_shared() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__shared_count::__add_shared();
            }
            void __add_weak() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __libcpp_atomic_refcount_increment(this->__shared_weak_owners_);
            }
            void __release_shared() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__shared_count::__release_shared())
                    this->__release_weak();
            }
            void __release_weak() throw();
            long use_count() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__shared_count::use_count();
            }
            std::__1::__shared_weak_count *lock() throw();
            virtual const void *__get_deleter(const std::type_info &) const throw();
        private:
            virtual void __on_zero_shared_weak() throw() = 0;
        };
        template <class _Tp, class _Dp, class _Alloc> class __shared_ptr_pointer : public std::__1::__shared_weak_count {
            __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
        public:
            __shared_ptr_pointer<_Tp, _Dp, _Alloc>(_Tp __p, _Dp __d, _Alloc __a) : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)), std::__1::move(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual const void *__get_deleter(const std::type_info &) const throw();
        private:
            virtual void __on_zero_shared() throw();
            virtual void __on_zero_shared_weak() throw();
        };
        template <class _Tp, class _Dp, class _Alloc> const void *__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const std::type_info &__t) const throw()         {
            return __t == typeid(_Dp) ? std::__1::addressof(this->__data_.first().second()) : std::__1::__get_nullptr_t();
        }
        template <class _Tp, class _Dp, class _Alloc> void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() throw()         {
            this->__data_.first().second()(this->__data_.first().first());
            this->__data_.first().second().~_Dp();
        }
        template <class _Tp, class _Dp, class _Alloc> void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() throw()         {
            typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer<_Tp, _Dp, _Alloc> >::type _Al;
            typedef allocator_traits<_Al> _ATraits;
            typedef pointer_traits<typename _ATraits::pointer> _PTraits;
            _Al __a(this->__data_.second());
            this->__data_.second().~_Alloc();
            __a.deallocate(_PTraits::pointer_to(*this), 1);
        }
        template <class _Tp, class _Alloc> class __shared_ptr_emplace : public std::__1::__shared_weak_count {
            __compressed_pair<_Alloc, _Tp> __data_;
        public:
            __shared_ptr_emplace<_Tp, _Alloc>(_Alloc __a) : __data_(std::__1::move(__a), std::__1::__value_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _A0> __shared_ptr_emplace<_Tp, _Alloc>(_Alloc __a, _A0 &__a0) : __data_(__a, _Tp(__a0)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _A0, class _A1> __shared_ptr_emplace<_Tp, _Alloc>(_Alloc __a, _A0 &__a0, _A1 &__a1) : __data_(__a, _Tp(__a0, __a1)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _A0, class _A1, class _A2> __shared_ptr_emplace<_Tp, _Alloc>(_Alloc __a, _A0 &__a0, _A1 &__a1, _A2 &__a2) : __data_(__a, _Tp(__a0, __a1, __a2)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        private:
            virtual void __on_zero_shared() throw();
            virtual void __on_zero_shared_weak() throw();
        public:
            _Tp *get() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::addressof(this->__data_.second());
            }
        };
        template <class _Tp, class _Alloc> void __shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() throw()         {
            this->__data_.second().~_Tp();
        }
        template <class _Tp, class _Alloc> void __shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() throw()         {
            typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace<_Tp, _Alloc> >::type _Al;
            typedef allocator_traits<_Al> _ATraits;
            typedef pointer_traits<typename _ATraits::pointer> _PTraits;
            _Al __a(this->__data_.first());
            this->__data_.first().~_Alloc();
            __a.deallocate(_PTraits::pointer_to(*this), 1);
        }
        struct __shared_ptr_dummy_rebind_allocator_type;
        template<> class __attribute__((type_visibility("default"))) allocator<std::__1::__shared_ptr_dummy_rebind_allocator_type> {
        public:
            template <class _Other> struct rebind {
                typedef allocator<_Other> other;
            };
        };
        template <class _Tp> class __attribute__((type_visibility("default"))) enable_shared_from_this;
        template <class _Tp> class __attribute__((type_visibility("default"))) shared_ptr {
        public:
            typedef _Tp element_type;
        private:
            std::__1::shared_ptr::element_type *__ptr_;
            std::__1::__shared_weak_count *__cntrl_;
            struct __nat {
                int __for_bool_;
            };
        public:
            shared_ptr<_Tp>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            shared_ptr<_Tp>(std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> explicit shared_ptr<_Tp>(_Yp *__p, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp, class _Dp> shared_ptr<_Tp>(_Yp *__p, _Dp __d, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp, class _Dp, class _Alloc> shared_ptr<_Tp>(_Yp *__p, _Dp __d, _Alloc __a, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Dp> shared_ptr<_Tp>(std::__1::nullptr_t __p, _Dp __d);
            template <class _Dp, class _Alloc> shared_ptr<_Tp>(std::__1::nullptr_t __p, _Dp __d, _Alloc __a);
            template <class _Yp> shared_ptr<_Tp>(const shared_ptr<_Yp> &__r, std::__1::shared_ptr::element_type *__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            shared_ptr<_Tp>(const shared_ptr<_Tp> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> shared_ptr<_Tp>(const shared_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> explicit shared_ptr<_Tp>(const weak_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp> shared_ptr<_Tp>(auto_ptr<_Yp> __r, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp, class _Dp> shared_ptr<_Tp>(unique_ptr<_Yp, _Dp>, typename enable_if<!is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            template <class _Yp, class _Dp> shared_ptr<_Tp>(unique_ptr<_Yp, _Dp>, typename enable_if<is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat());
            ~shared_ptr<_Tp>();
            shared_ptr<_Tp> &operator=(const shared_ptr<_Tp> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, shared_ptr<_Tp> &>::type operator=(const shared_ptr<_Yp> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> typename enable_if<!is_array<_Yp>::value && is_convertible<_Yp *, element_type *>::value, shared_ptr<_Tp> &>::type operator=(auto_ptr<_Yp> __r) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp, class _Dp> typename enable_if<!is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, shared_ptr<_Tp> &>::type operator=(unique_ptr<_Yp, _Dp> __r) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void swap(shared_ptr<_Tp> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void reset() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type reset(_Yp *__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp, class _Dp> typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type reset(_Yp *__p, _Dp __d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp, class _Dp, class _Alloc> typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type reset(_Yp *__p, _Dp __d, _Alloc __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::shared_ptr::element_type *get() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_;
            }
            typename add_lvalue_reference<element_type>::type operator*() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__ptr_;
            }
            std::__1::shared_ptr::element_type *operator->() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_;
            }
            long use_count() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cntrl_ ? this->__cntrl_->use_count() : 0;
            }
            bool unique() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->use_count() == 1;
            }
            operator bool() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->get() != 0;
            }
            template <class _Up> bool owner_before(const shared_ptr<_Up> &__p) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cntrl_ < __p.__cntrl_;
            }
            template <class _Up> bool owner_before(const weak_ptr<_Up> &__p) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cntrl_ < __p.__cntrl_;
            }
            bool __owner_equivalent(const shared_ptr<_Tp> &__p) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cntrl_ == __p.__cntrl_;
            }
            template <class _Dp> _Dp *__get_deleter() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<_Dp *>(this->__cntrl_ ? const_cast<void *>(this->__cntrl_->__get_deleter(typeid(_Dp))) : std::__1::__get_nullptr_t());
            }
            template <class _Yp, class _CntrlBlk> static shared_ptr<_Tp> __create_with_control_block(_Yp *__p, _CntrlBlk *__cntrl)             {
                shared_ptr<_Tp> __r;
                __r.__ptr_ = __p;
                __r.__cntrl_ = __cntrl;
                __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
                return __r;
            }
            template <class _Alloc, class ..._Args> static shared_ptr<_Tp> allocate_shared(const _Alloc &__a, _Args &&...__args);
        private:
            template <class _Yp, bool = is_function<_Yp>::value> struct __shared_ptr_default_allocator {
                typedef allocator<_Yp> type;
            };
            template <class _Yp> struct __shared_ptr_default_allocator<_Yp, true> {
                typedef allocator<std::__1::__shared_ptr_dummy_rebind_allocator_type> type;
            };
            template <class _Yp, class _OrigPtr> typename enable_if<is_convertible<_OrigPtr *, const enable_shared_from_this<_Yp> *>::value, void>::type __enable_weak_this(const enable_shared_from_this<_Yp> *__e, _OrigPtr *__ptr) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef typename remove_cv<_Yp>::type _RawYp;
                if (__e && __e->__weak_this_.expired()) {
                    __e->__weak_this_ = shared_ptr<_RawYp>(*this, const_cast<_RawYp *>(static_cast<const _Yp *>(__ptr)));
                }
            }
            void __enable_weak_this(...) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _Up> class __attribute__((type_visibility("default"))) shared_ptr;
            friend template <class _Up> class __attribute__((type_visibility("default"))) weak_ptr;
        };
        template <class _Tp> inline shared_ptr<_Tp>::shared_ptr<_Tp>() throw() : __ptr_(0), __cntrl_(0)         {
        }
        template <class _Tp> inline shared_ptr<_Tp>::shared_ptr<_Tp>(std::__1::nullptr_t) throw() : __ptr_(0), __cntrl_(0)         {
        }
        template <class _Tp> template <class _Yp> explicit shared_ptr<_Tp>::shared_ptr<_Tp>(_Yp *__p, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__p)         {
            unique_ptr<_Yp> __hold(__p);
            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<_Yp *, default_delete<_Yp>, _AllocT> _CntrlBlk;
            this->__cntrl_ = new _CntrlBlk((__p, default_delete<_Yp>(), _AllocT()));
            __hold.release();
            __enable_weak_this(__p, __p);
        }
        template <class _Tp> template <class _Yp, class _Dp> shared_ptr<_Tp>::shared_ptr<_Tp>(_Yp *__p, _Dp __d, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__p)         {
            try {
                typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
                typedef __shared_ptr_pointer<_Yp *, _Dp, _AllocT> _CntrlBlk;
                this->__cntrl_ = new _CntrlBlk((__p, __d, _AllocT()));
                __enable_weak_this(__p, __p);
            } catch (...) {
                __d(__p);
                throw;
            }
        }
        template <class _Tp> template <class _Dp> shared_ptr<_Tp>::shared_ptr<_Tp>(std::__1::nullptr_t __p, _Dp __d) : __ptr_(0)         {
            try {
                typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
                typedef __shared_ptr_pointer<std::__1::nullptr_t, _Dp, _AllocT> _CntrlBlk;
                this->__cntrl_ = new _CntrlBlk((__p, __d, _AllocT()));
            } catch (...) {
                __d(__p);
                throw;
            }
        }
        template <class _Tp> template <class _Yp, class _Dp, class _Alloc> shared_ptr<_Tp>::shared_ptr<_Tp>(_Yp *__p, _Dp __d, _Alloc __a, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__p)         {
            try {
                typedef __shared_ptr_pointer<_Yp *, _Dp, _Alloc> _CntrlBlk;
                typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
                typedef __allocator_destructor<_A2> _D2;
                _A2 __a2(__a);
                unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
                ::new (static_cast<void *>(std::__1::addressof(*__hold2.get()))) _CntrlBlk((__p, __d, __a));
                this->__cntrl_ = std::__1::addressof(*__hold2.release());
                __enable_weak_this(__p, __p);
            } catch (...) {
                __d(__p);
                throw;
            }
        }
        template <class _Tp> template <class _Dp, class _Alloc> shared_ptr<_Tp>::shared_ptr<_Tp>(std::__1::nullptr_t __p, _Dp __d, _Alloc __a) : __ptr_(0)         {
            try {
                typedef __shared_ptr_pointer<std::__1::nullptr_t, _Dp, _Alloc> _CntrlBlk;
                typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
                typedef __allocator_destructor<_A2> _D2;
                _A2 __a2(__a);
                unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
                ::new (static_cast<void *>(std::__1::addressof(*__hold2.get()))) _CntrlBlk((__p, __d, __a));
                this->__cntrl_ = std::__1::addressof(*__hold2.release());
            } catch (...) {
                __d(__p);
                throw;
            }
        }
        template <class _Tp> template <class _Yp> inline shared_ptr<_Tp>::shared_ptr<_Tp>(const shared_ptr<_Yp> &__r, std::__1::shared_ptr::element_type *__p) throw() : __ptr_(__p), __cntrl_(__r.__cntrl_)         {
            if (this->__cntrl_)
                this->__cntrl_->__add_shared();
        }
        template <class _Tp> inline shared_ptr<_Tp>::shared_ptr<_Tp>(const shared_ptr<_Tp> &__r) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_)         {
            if (this->__cntrl_)
                this->__cntrl_->__add_shared();
        }
        template <class _Tp> template <class _Yp> inline shared_ptr<_Tp>::shared_ptr<_Tp>(const shared_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_)         {
            if (this->__cntrl_)
                this->__cntrl_->__add_shared();
        }
        template <class _Tp> template <class _Yp> shared_ptr<_Tp>::shared_ptr<_Tp>(auto_ptr<_Yp> __r, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__r.get())         {
            typedef __shared_ptr_pointer<_Yp *, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
            this->__cntrl_ = new _CntrlBlk((__r.get(), default_delete<_Yp>(), allocator<_Yp>()));
            __enable_weak_this(__r.get(), __r.get());
            __r.release();
        }
        template <class _Tp> template <class _Yp, class _Dp> shared_ptr<_Tp>::shared_ptr<_Tp>(unique_ptr<_Yp, _Dp> __r, typename enable_if<!is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__r.get())         {
            {
                typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
                typedef __shared_ptr_pointer<_Yp *, _Dp, _AllocT> _CntrlBlk;
                this->__cntrl_ = new _CntrlBlk((__r.get(), __r.get_deleter(), _AllocT()));
                __enable_weak_this(__r.get(), __r.get());
            }
            __r.release();
        }
        template <class _Tp> template <class _Yp, class _Dp> shared_ptr<_Tp>::shared_ptr<_Tp>(unique_ptr<_Yp, _Dp> __r, typename enable_if<is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__r.get())         {
            {
                typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
                typedef __shared_ptr_pointer<_Yp *, reference_wrapper<typename remove_reference<_Dp>::type>, _AllocT> _CntrlBlk;
                this->__cntrl_ = new _CntrlBlk((__r.get(), ref(__r.get_deleter()), _AllocT()));
                __enable_weak_this(__r.get(), __r.get());
            }
            __r.release();
        }
        template <class _Tp> template <class _Alloc, class ..._Args> shared_ptr<_Tp> shared_ptr<_Tp>::allocate_shared(const _Alloc &__a, _Args &&...__args)         {
            static_assert(is_constructible<_Tp, _Args...>::value, "Can't construct object in allocate_shared");
            typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
            typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2(__a);
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new (static_cast<void *>(std::__1::addressof(*__hold2.get()))) _CntrlBlk((__a, std::__1::forward<_Args>(__args)...));
            shared_ptr<_Tp> __r;
            __r.__ptr_ = __hold2.get()->get();
            __r.__cntrl_ = std::__1::addressof(*__hold2.release());
            __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
            return __r;
        }
        template <class _Tp> shared_ptr<_Tp>::~shared_ptr<_Tp>()         {
            if (this->__cntrl_)
                this->__cntrl_->__release_shared();
        }
        template <class _Tp> inline shared_ptr<_Tp> &shared_ptr<_Tp>::operator=(const shared_ptr<_Tp> &__r) throw()         {
            shared_ptr<_Tp>(__r).swap(*this);
            return *this;
        }
        template <class _Tp> template <class _Yp> inline typename enable_if<is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value, shared_ptr<_Tp> &>::type shared_ptr<_Tp>::operator=(const shared_ptr<_Yp> &__r) throw()         {
            shared_ptr<_Tp>(__r).swap(*this);
            return *this;
        }
        template <class _Tp> template <class _Yp> inline typename enable_if<!is_array<_Yp>::value && is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value, shared_ptr<_Tp> &>::type shared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            shared_ptr<_Tp>(__r).swap(*this);
            return *this;
        }
        template <class _Tp> template <class _Yp, class _Dp> inline typename enable_if<!is_array<_Yp>::value && is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, typename shared_ptr<_Tp>::element_type *>::value, shared_ptr<_Tp> &>::type shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            shared_ptr<_Tp>(std::__1::move(__r)).swap(*this);
            return *this;
        }
        template <class _Tp> inline void shared_ptr<_Tp>::swap(shared_ptr<_Tp> &__r) throw()         {
            std::__1::swap(this->__ptr_, __r.__ptr_);
            std::__1::swap(this->__cntrl_, __r.__cntrl_);
        }
        template <class _Tp> inline void shared_ptr<_Tp>::reset() throw()         {
            shared_ptr<_Tp>().swap(*this);
        }
        template <class _Tp> template <class _Yp> inline typename enable_if<is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value, void>::type shared_ptr<_Tp>::reset(_Yp *__p)         {
            shared_ptr<_Tp>(__p).swap(*this);
        }
        template <class _Tp> template <class _Yp, class _Dp> inline typename enable_if<is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value, void>::type shared_ptr<_Tp>::reset(_Yp *__p, _Dp __d)         {
            shared_ptr<_Tp>(__p, __d).swap(*this);
        }
        template <class _Tp> template <class _Yp, class _Dp, class _Alloc> inline typename enable_if<is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value, void>::type shared_ptr<_Tp>::reset(_Yp *__p, _Dp __d, _Alloc __a)         {
            shared_ptr<_Tp>(__p, __d, __a).swap(*this);
        }
        template <class _Tp, class ..._Args> inline typename enable_if<!is_array<_Tp>::value, shared_ptr<_Tp> >::type make_shared(_Args &&...__args) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(is_constructible<_Tp, _Args...>::value, "Can't construct object in make_shared");
            typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
            typedef allocator<_CntrlBlk> _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2;
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new (__hold2.get()) _CntrlBlk((__a2, std::__1::forward<_Args>(__args)...));
            _Tp *__ptr = __hold2.get()->get();
            return shared_ptr<_Tp>::__create_with_control_block(__ptr, __hold2.release());
        }
        template <class _Tp, class _Alloc, class ..._Args> inline typename enable_if<!is_array<_Tp>::value, shared_ptr<_Tp> >::type allocate_shared(const _Alloc &__a, _Args &&...__args) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return shared_ptr<_Tp>::allocate_shared(__a, std::__1::forward<_Args>(__args)...);
        }
        template <class _Tp, class _Up> inline bool operator==(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.get() == __y.get();
        }
        template <class _Tp, class _Up> inline bool operator!=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Tp, class _Up> inline bool operator<(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename common_type<_Tp *, _Up *>::type _Vp;
            return less<_Vp>()(__x.get(), __y.get());
        }
        template <class _Tp, class _Up> inline bool operator>(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Tp, class _Up> inline bool operator<=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Tp, class _Up> inline bool operator>=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Tp> inline bool operator==(const shared_ptr<_Tp> &__x, std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !__x;
        }
        template <class _Tp> inline bool operator==(std::__1::nullptr_t, const shared_ptr<_Tp> &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !__x;
        }
        template <class _Tp> inline bool operator!=(const shared_ptr<_Tp> &__x, std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return static_cast<bool>(__x);
        }
        template <class _Tp> inline bool operator!=(std::__1::nullptr_t, const shared_ptr<_Tp> &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return static_cast<bool>(__x);
        }
        template <class _Tp> inline bool operator<(const shared_ptr<_Tp> &__x, std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return less<_Tp *>()(__x.get(), std::__1::__get_nullptr_t());
        }
        template <class _Tp> inline bool operator<(std::__1::nullptr_t, const shared_ptr<_Tp> &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return less<_Tp *>()(std::__1::__get_nullptr_t(), __x.get());
        }
        template <class _Tp> inline bool operator>(const shared_ptr<_Tp> &__x, std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__get_nullptr_t() < __x;
        }
        template <class _Tp> inline bool operator>(std::__1::nullptr_t, const shared_ptr<_Tp> &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x < std::__1::__get_nullptr_t();
        }
        template <class _Tp> inline bool operator<=(const shared_ptr<_Tp> &__x, std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(std::__1::__get_nullptr_t() < __x);
        }
        template <class _Tp> inline bool operator<=(std::__1::nullptr_t, const shared_ptr<_Tp> &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < std::__1::__get_nullptr_t());
        }
        template <class _Tp> inline bool operator>=(const shared_ptr<_Tp> &__x, std::__1::nullptr_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < std::__1::__get_nullptr_t());
        }
        template <class _Tp> inline bool operator>=(std::__1::nullptr_t, const shared_ptr<_Tp> &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(std::__1::__get_nullptr_t() < __x);
        }
        template <class _Tp> inline void swap(shared_ptr<_Tp> &__x, shared_ptr<_Tp> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _Tp, class _Up> inline typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value, shared_ptr<_Tp> >::type static_pointer_cast(const shared_ptr<_Up> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return shared_ptr<_Tp>(__r, static_cast<_Tp *>(__r.get()));
        }
        template <class _Tp, class _Up> inline typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value, shared_ptr<_Tp> >::type dynamic_pointer_cast(const shared_ptr<_Up> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            _Tp *__p = dynamic_cast<_Tp *>(__r.get());
            return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
        }
        template <class _Tp, class _Up> typename enable_if<is_array<_Tp>::value == is_array<_Up>::value, shared_ptr<_Tp> >::type const_pointer_cast(const shared_ptr<_Up> &__r) throw()         {
            typedef typename remove_extent<_Tp>::type _RTp;
            return shared_ptr<_Tp>(__r, const_cast<_RTp *>(__r.get()));
        }
        template <class _Dp, class _Tp> inline _Dp *get_deleter(const shared_ptr<_Tp> &__p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __p.template __get_deleter<_Dp>();
        }
        template <class _Tp> class __attribute__((type_visibility("default"))) weak_ptr {
        public:
            typedef _Tp element_type;
        private:
            std::__1::weak_ptr::element_type *__ptr_;
            std::__1::__shared_weak_count *__cntrl_;
        public:
            weak_ptr<_Tp>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> weak_ptr<_Tp>(const shared_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            weak_ptr<_Tp>(const weak_ptr<_Tp> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> weak_ptr<_Tp>(const weak_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            ~weak_ptr<_Tp>();
            weak_ptr<_Tp> &operator=(const weak_ptr<_Tp> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, weak_ptr<_Tp> &>::type operator=(const weak_ptr<_Yp> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Yp> typename enable_if<is_convertible<_Yp *, element_type *>::value, weak_ptr<_Tp> &>::type operator=(const shared_ptr<_Yp> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void swap(weak_ptr<_Tp> &__r) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void reset() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            long use_count() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cntrl_ ? this->__cntrl_->use_count() : 0;
            }
            bool expired() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cntrl_ == 0 || this->__cntrl_->use_count() == 0;
            }
            shared_ptr<_Tp> lock() const throw();
            template <class _Up> bool owner_before(const shared_ptr<_Up> &__r) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cntrl_ < __r.__cntrl_;
            }
            template <class _Up> bool owner_before(const weak_ptr<_Up> &__r) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cntrl_ < __r.__cntrl_;
            }
            friend template <class _Up> class __attribute__((type_visibility("default"))) weak_ptr;
            friend template <class _Up> class __attribute__((type_visibility("default"))) shared_ptr;
        };
        template <class _Tp> inline weak_ptr<_Tp>::weak_ptr<_Tp>() throw() : __ptr_(0), __cntrl_(0)         {
        }
        template <class _Tp> inline weak_ptr<_Tp>::weak_ptr<_Tp>(const weak_ptr<_Tp> &__r) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_)         {
            if (this->__cntrl_)
                this->__cntrl_->__add_weak();
        }
        template <class _Tp> template <class _Yp> inline weak_ptr<_Tp>::weak_ptr<_Tp>(const shared_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_)         {
            if (this->__cntrl_)
                this->__cntrl_->__add_weak();
        }
        template <class _Tp> template <class _Yp> inline weak_ptr<_Tp>::weak_ptr<_Tp>(const weak_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type = 0) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_)         {
            if (this->__cntrl_)
                this->__cntrl_->__add_weak();
        }
        template <class _Tp> weak_ptr<_Tp>::~weak_ptr<_Tp>()         {
            if (this->__cntrl_)
                this->__cntrl_->__release_weak();
        }
        template <class _Tp> inline weak_ptr<_Tp> &weak_ptr<_Tp>::operator=(const weak_ptr<_Tp> &__r) throw()         {
            weak_ptr<_Tp>(__r).swap(*this);
            return *this;
        }
        template <class _Tp> template <class _Yp> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, weak_ptr<_Tp> &>::type weak_ptr<_Tp>::operator=(const weak_ptr<_Yp> &__r) throw()         {
            weak_ptr<_Tp>(__r).swap(*this);
            return *this;
        }
        template <class _Tp> template <class _Yp> inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, weak_ptr<_Tp> &>::type weak_ptr<_Tp>::operator=(const shared_ptr<_Yp> &__r) throw()         {
            weak_ptr<_Tp>(__r).swap(*this);
            return *this;
        }
        template <class _Tp> inline void weak_ptr<_Tp>::swap(weak_ptr<_Tp> &__r) throw()         {
            std::__1::swap(this->__ptr_, __r.__ptr_);
            std::__1::swap(this->__cntrl_, __r.__cntrl_);
        }
        template <class _Tp> inline void swap(weak_ptr<_Tp> &__x, weak_ptr<_Tp> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _Tp> inline void weak_ptr<_Tp>::reset() throw()         {
            weak_ptr<_Tp>().swap(*this);
        }
        template <class _Tp> template <class _Yp> explicit shared_ptr<_Tp>::shared_ptr<_Tp>(const weak_ptr<_Yp> &__r, typename enable_if<is_convertible<_Yp *, element_type *>::value, __nat>::type = std::__1::shared_ptr::__nat()) : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)         {
            if (this->__cntrl_ == 0)
                __throw_bad_weak_ptr();
        }
        template <class _Tp> shared_ptr<_Tp> weak_ptr<_Tp>::lock() const throw()         {
            shared_ptr<_Tp> __r;
            __r.__cntrl_ = this->__cntrl_ ? this->__cntrl_->lock() : this->__cntrl_;
            if (__r.__cntrl_)
                __r.__ptr_ = this->__ptr_;
            return __r;
        }
        template <class _Tp> struct owner_less;
        template <class _Tp> struct __attribute__((type_visibility("default"))) owner_less<shared_ptr<_Tp>> : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool> {
            typedef bool result_type;
            bool operator()(const shared_ptr<_Tp> &__x, const shared_ptr<_Tp> &__y) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.owner_before(__y);
            }
            bool operator()(const shared_ptr<_Tp> &__x, const weak_ptr<_Tp> &__y) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.owner_before(__y);
            }
            bool operator()(const weak_ptr<_Tp> &__x, const shared_ptr<_Tp> &__y) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.owner_before(__y);
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) owner_less<weak_ptr<_Tp>> : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool> {
            typedef bool result_type;
            bool operator()(const weak_ptr<_Tp> &__x, const weak_ptr<_Tp> &__y) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.owner_before(__y);
            }
            bool operator()(const shared_ptr<_Tp> &__x, const weak_ptr<_Tp> &__y) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.owner_before(__y);
            }
            bool operator()(const weak_ptr<_Tp> &__x, const shared_ptr<_Tp> &__y) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.owner_before(__y);
            }
        };
        template <class _Tp> class __attribute__((type_visibility("default"))) enable_shared_from_this {
            mutable weak_ptr<_Tp> __weak_this_;
        protected:
            enable_shared_from_this<_Tp>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            enable_shared_from_this<_Tp>(const enable_shared_from_this<_Tp> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            enable_shared_from_this<_Tp> &operator=(const enable_shared_from_this<_Tp> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            ~enable_shared_from_this<_Tp>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        public:
            shared_ptr<_Tp> shared_from_this() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return shared_ptr<_Tp>(this->__weak_this_);
            }
            shared_ptr<const _Tp> shared_from_this() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return shared_ptr<const _Tp>(this->__weak_this_);
            }
            friend template <class _Up> class shared_ptr;
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) hash<shared_ptr<_Tp>> {
            typedef shared_ptr<_Tp> argument_type;
            typedef size_t result_type;
            std::__1::hash<shared_ptr<type-parameter-0-0> >::result_type operator()(const std::__1::hash<shared_ptr<type-parameter-0-0> >::argument_type &__ptr) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return hash<_Tp *>()(__ptr.get());
            }
        };
        template <class _CharT, class _Traits, class _Yp> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const shared_ptr<_Yp> &__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        class __attribute__((visibility("default"))) __sp_mut {
            void *__lx;
        public:
            void lock() throw();
            void unlock() throw();
        private:
            __sp_mut(void *) throw();
            __sp_mut(const std::__1::__sp_mut &);
            std::__1::__sp_mut &operator=(const std::__1::__sp_mut &);
            friend std::__1::__sp_mut &__get_sp_mut(const void *) __attribute__((visibility("default")));
        };
        std::__1::__sp_mut &__get_sp_mut(const void *) __attribute__((visibility("default"))) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
        template <class _Tp> inline bool atomic_is_lock_free(const shared_ptr<_Tp> *) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return false;
        }
        template <class _Tp> shared_ptr<_Tp> atomic_load(const shared_ptr<_Tp> *__p) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            std::__1::__sp_mut &__m = __get_sp_mut(__p);
            __m.lock();
            shared_ptr<_Tp> __q = *__p;
            __m.unlock();
            return __q;
        }
        template <class _Tp> inline shared_ptr<_Tp> atomic_load_explicit(const shared_ptr<_Tp> *__p, std::__1::memory_order) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            return atomic_load(__p);
        }
        template <class _Tp> void atomic_store(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            std::__1::__sp_mut &__m = __get_sp_mut(__p);
            __m.lock();
            __p->swap(__r);
            __m.unlock();
        }
        template <class _Tp> inline void atomic_store_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, std::__1::memory_order) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            atomic_store(__p, __r);
        }
        template <class _Tp> shared_ptr<_Tp> atomic_exchange(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            std::__1::__sp_mut &__m = __get_sp_mut(__p);
            __m.lock();
            __p->swap(__r);
            __m.unlock();
            return __r;
        }
        template <class _Tp> inline shared_ptr<_Tp> atomic_exchange_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, std::__1::memory_order) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            return atomic_exchange(__p, __r);
        }
        template <class _Tp> bool atomic_compare_exchange_strong(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            shared_ptr<_Tp> __temp;
            std::__1::__sp_mut &__m = __get_sp_mut(__p);
            __m.lock();
            if (__p->__owner_equivalent(*__v)) {
                std::__1::swap(__temp, *__p);
                *__p = __w;
                __m.unlock();
                return true;
            }
            std::__1::swap(__temp, *__v);
            *__v = *__p;
            __m.unlock();
            return false;
        }
        template <class _Tp> inline bool atomic_compare_exchange_weak(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            return atomic_compare_exchange_strong(__p, __v, __w);
        }
        template <class _Tp> inline bool atomic_compare_exchange_strong_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w, std::__1::memory_order, std::__1::memory_order) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            return atomic_compare_exchange_strong(__p, __v, __w);
        }
        template <class _Tp> inline bool atomic_compare_exchange_weak_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w, std::__1::memory_order, std::__1::memory_order) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)))         {
            return atomic_compare_exchange_weak(__p, __v, __w);
        }
        struct __attribute__((visibility("default"))) pointer_safety {
            enum __lx {
                relaxed,
                preferred,
                strict
            };
            std::__1::pointer_safety::__lx __v_;
            pointer_safety() : __v_(/*implicit*/(std::__1::pointer_safety::__lx)0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            pointer_safety(std::__1::pointer_safety::__lx __v) : __v_(__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            operator int() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__v_;
            }
        };
        inline std::__1::pointer_safety get_pointer_safety() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return pointer_safety::relaxed;
        }
        void declare_reachable(void *__p) __attribute__((visibility("default")));
        void declare_no_pointers(char *__p, size_t __n) __attribute__((visibility("default")));
        void undeclare_no_pointers(char *__p, size_t __n) __attribute__((visibility("default")));
        void *__undeclare_reachable(void *__p) __attribute__((visibility("default")));
        template <class _Tp> inline _Tp *undeclare_reachable(_Tp *__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return static_cast<_Tp *>(__undeclare_reachable(__p));
        }
        void *align(size_t __align, size_t __sz, void *&__ptr, size_t &__space) __attribute__((visibility("default")));
        template <typename _Alloc> inline void __swap_allocator(_Alloc &__a1, _Alloc &__a2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __swap_allocator(__a1, __a2, integral_constant<bool, std::__1::allocator_traits<_Alloc>::propagate_on_container_swap::value>());
        }
        template <typename _Alloc> void __swap_allocator(_Alloc &__a1, _Alloc &__a2, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            using std::__1::swap;
            swap(__a1, __a2);
        }
        template <typename _Alloc> inline void __swap_allocator(_Alloc &, _Alloc &, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        template <typename _Alloc, typename _Traits = allocator_traits<_Alloc>> struct __noexcept_move_assign_container : public integral_constant<bool, _Traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<_Alloc>::value> {
        };
        template <typename _Alloc, typename = void, typename = void> struct __is_allocator : std::__1::false_type {
        };
template<> struct __is_allocator<std::__1::allocator<char>, void, void> : std::__1::true_type {
        };
template<> struct __is_allocator<std::__1::allocator<wchar_t>, void, void> : std::__1::true_type {
        };
        template <typename _Alloc> struct __is_allocator<_Alloc, typename __void_t<typename _Alloc::value_type>::type, typename __void_t<decltype(std::__1::declval<_Alloc &>().allocate(size_t(0)))>::type> : std::__1::true_type {
        };
        struct __builtin_new_allocator {
            struct __builtin_new_deleter {
                typedef void *pointer_type;
                explicit __builtin_new_deleter(size_t __size, size_t __align) : __size_(__size), __align_(__align)                 {
                }
                void operator()(void *p) const throw()                 {
                    std::__libcpp_deallocate(p, this->__size_, this->__align_);
                }
            private:
                size_t __size_;
                size_t __align_;
            };
            typedef unique_ptr<void, std::__1::__builtin_new_allocator::__builtin_new_deleter> __holder_t;
            static std::__1::__builtin_new_allocator::__holder_t __allocate_bytes(size_t __s, size_t __align)             {
                return std::__1::__builtin_new_allocator::__holder_t(std::__libcpp_allocate(__s, __align), std::__1::__builtin_new_allocator::__builtin_new_deleter(__s, __align));
            }
            static void __deallocate_bytes(void *__p, size_t __s, size_t __align) throw()             {
                std::__libcpp_deallocate(__p, __s, __align);
            }
            template <class _Tp> static std::__1::__builtin_new_allocator::__holder_t __allocate_type(size_t __n) __attribute__((nodebug)) __attribute__((always_inline))             {
                return __allocate_bytes(__n * sizeof(_Tp), __alignof(_Tp));
            }
            template <class _Tp> static void __deallocate_type(void *__p, size_t __n) throw() __attribute__((nodebug)) __attribute__((always_inline))             {
                __deallocate_bytes(__p, __n * sizeof(_Tp), __alignof(_Tp));
            }
        };
    }
}
namespace std {
    inline namespace __1 {
        template <class _Tp> struct __attribute__((type_visibility("default"))) plus : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x + __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) minus : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x - __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) multiplies : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x * __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) divides : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x / __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) modulus : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x % __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) negate : unary_function<_Tp, _Tp> {
            _Tp operator()(const _Tp &__x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return - __x;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) equal_to : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x == __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) not_equal_to : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x != __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) greater : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x > __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) greater_equal : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x >= __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) less_equal : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x <= __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) logical_and : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x && __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) logical_or : binary_function<_Tp, _Tp, bool> {
            bool operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x || __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) logical_not : unary_function<_Tp, bool> {
            bool operator()(const _Tp &__x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !__x;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) bit_and : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x & __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) bit_or : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x | __y;
            }
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp> {
            _Tp operator()(const _Tp &__x, const _Tp &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x ^ __y;
            }
        };
        template <class _Predicate> class __attribute__((type_visibility("default"))) unary_negate : public unary_function<typename _Predicate::argument_type, bool> {
            _Predicate __pred_;
        public:
            explicit unary_negate<_Predicate>(const _Predicate &__pred) : __pred_(__pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            bool operator()(const typename _Predicate::argument_type &__x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !this->__pred_(__x);
            }
        };
        template <class _Predicate> inline unary_negate<_Predicate> not1(const _Predicate &__pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return unary_negate<_Predicate>(__pred);
        }
        template <class _Predicate> class __attribute__((type_visibility("default"))) binary_negate : public binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool> {
            _Predicate __pred_;
        public:
            explicit binary_negate<_Predicate>(const _Predicate &__pred) : __pred_(__pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !this->__pred_(__x, __y);
            }
        };
        template <class _Predicate> inline binary_negate<_Predicate> not2(const _Predicate &__pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return binary_negate<_Predicate>(__pred);
        }
        template <class __Operation> class __attribute__((type_visibility("default"))) binder1st : public unary_function<typename __Operation::second_argument_type, typename __Operation::result_type> {
        protected:
            __Operation op;
            typename __Operation::first_argument_type value;
        public:
            binder1st<__Operation>(const __Operation &__x, const typename __Operation::first_argument_type __y) : op(__x), value(__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            typename __Operation::result_type operator()(typename __Operation::second_argument_type &__x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->op(this->value, __x);
            }
            typename __Operation::result_type operator()(const typename __Operation::second_argument_type &__x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->op(this->value, __x);
            }
        };
        template <class __Operation, class _Tp> inline binder1st<__Operation> bind1st(const __Operation &__op, const _Tp &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return binder1st<__Operation>(__op, __x);
        }
        template <class __Operation> class __attribute__((type_visibility("default"))) binder2nd : public unary_function<typename __Operation::first_argument_type, typename __Operation::result_type> {
        protected:
            __Operation op;
            typename __Operation::second_argument_type value;
        public:
            binder2nd<__Operation>(const __Operation &__x, const typename __Operation::second_argument_type __y) : op(__x), value(__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            typename __Operation::result_type operator()(typename __Operation::first_argument_type &__x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->op(__x, this->value);
            }
            typename __Operation::result_type operator()(const typename __Operation::first_argument_type &__x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->op(__x, this->value);
            }
        };
        template <class __Operation, class _Tp> inline binder2nd<__Operation> bind2nd(const __Operation &__op, const _Tp &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return binder2nd<__Operation>(__op, __x);
        }
        template <class _Arg, class _Result> class __attribute__((type_visibility("default"))) pointer_to_unary_function : public unary_function<_Arg, _Result> {
            _Result (*__f_)(_Arg);
        public:
            explicit pointer_to_unary_function<_Arg, _Result>(_Result (*__f)(_Arg)) : __f_(__f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Result operator()(_Arg __x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__f_(__x);
            }
        };
        template <class _Arg, class _Result> inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__f)(_Arg)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return pointer_to_unary_function<_Arg, _Result>(__f);
        }
        template <class _Arg1, class _Arg2, class _Result> class __attribute__((type_visibility("default"))) pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result> {
            _Result (*__f_)(_Arg1, _Arg2);
        public:
            explicit pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Result (*__f)(_Arg1, _Arg2)) : __f_(__f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Result operator()(_Arg1 __x, _Arg2 __y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__f_(__x, __y);
            }
        };
        template <class _Arg1, class _Arg2, class _Result> inline pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__f)(_Arg1, _Arg2)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__f);
        }
        template <class _Sp, class _Tp> class __attribute__((type_visibility("default"))) mem_fun_t : public unary_function<_Tp *, _Sp> {
            _Sp (_Tp::*__p_)();
        public:
            explicit mem_fun_t<_Sp, _Tp>(_Sp (_Tp::*__p)()) : __p_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Sp operator()(_Tp *__p) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__p ->* this->__p_)();
            }
        };
        template <class _Sp, class _Tp, class _Ap> class __attribute__((type_visibility("default"))) mem_fun1_t : public binary_function<_Tp *, _Ap, _Sp> {
            _Sp (_Tp::*__p_)(_Ap);
        public:
            explicit mem_fun1_t<_Sp, _Tp, _Ap>(_Sp (_Tp::*__p)(_Ap)) : __p_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Sp operator()(_Tp *__p, _Ap __x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__p ->* this->__p_)(__x);
            }
        };
        template <class _Sp, class _Tp> inline mem_fun_t<_Sp, _Tp> mem_fun(_Sp (_Tp::*__f)()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return mem_fun_t<_Sp, _Tp>(__f);
        }
        template <class _Sp, class _Tp, class _Ap> inline mem_fun1_t<_Sp, _Tp, _Ap> mem_fun(_Sp (_Tp::*__f)(_Ap)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return mem_fun1_t<_Sp, _Tp, _Ap>(__f);
        }
        template <class _Sp, class _Tp> class __attribute__((type_visibility("default"))) mem_fun_ref_t : public unary_function<_Tp, _Sp> {
            _Sp (_Tp::*__p_)();
        public:
            explicit mem_fun_ref_t<_Sp, _Tp>(_Sp (_Tp::*__p)()) : __p_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Sp operator()(_Tp &__p) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__p .* this->__p_)();
            }
        };
        template <class _Sp, class _Tp, class _Ap> class __attribute__((type_visibility("default"))) mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp> {
            _Sp (_Tp::*__p_)(_Ap);
        public:
            explicit mem_fun1_ref_t<_Sp, _Tp, _Ap>(_Sp (_Tp::*__p)(_Ap)) : __p_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Sp operator()(_Tp &__p, _Ap __x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__p .* this->__p_)(__x);
            }
        };
        template <class _Sp, class _Tp> inline mem_fun_ref_t<_Sp, _Tp> mem_fun_ref(_Sp (_Tp::*__f)()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return mem_fun_ref_t<_Sp, _Tp>(__f);
        }
        template <class _Sp, class _Tp, class _Ap> inline mem_fun1_ref_t<_Sp, _Tp, _Ap> mem_fun_ref(_Sp (_Tp::*__f)(_Ap)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
        }
        template <class _Sp, class _Tp> class __attribute__((type_visibility("default"))) const_mem_fun_t : public unary_function<const _Tp *, _Sp> {
            _Sp (_Tp::*__p_)() const;
        public:
            explicit const_mem_fun_t<_Sp, _Tp>(_Sp (_Tp::*__p)() const) : __p_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Sp operator()(const _Tp *__p) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__p ->* this->__p_)();
            }
        };
        template <class _Sp, class _Tp, class _Ap> class __attribute__((type_visibility("default"))) const_mem_fun1_t : public binary_function<const _Tp *, _Ap, _Sp> {
            _Sp (_Tp::*__p_)(_Ap) const;
        public:
            explicit const_mem_fun1_t<_Sp, _Tp, _Ap>(_Sp (_Tp::*__p)(_Ap) const) : __p_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Sp operator()(const _Tp *__p, _Ap __x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__p ->* this->__p_)(__x);
            }
        };
        template <class _Sp, class _Tp> inline const_mem_fun_t<_Sp, _Tp> mem_fun(_Sp (_Tp::*__f)() const) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return const_mem_fun_t<_Sp, _Tp>(__f);
        }
        template <class _Sp, class _Tp, class _Ap> inline const_mem_fun1_t<_Sp, _Tp, _Ap> mem_fun(_Sp (_Tp::*__f)(_Ap) const) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return const_mem_fun1_t<_Sp, _Tp, _Ap>(__f);
        }
        template <class _Sp, class _Tp> class __attribute__((type_visibility("default"))) const_mem_fun_ref_t : public unary_function<_Tp, _Sp> {
            _Sp (_Tp::*__p_)() const;
        public:
            explicit const_mem_fun_ref_t<_Sp, _Tp>(_Sp (_Tp::*__p)() const) : __p_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Sp operator()(const _Tp &__p) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__p .* this->__p_)();
            }
        };
        template <class _Sp, class _Tp, class _Ap> class __attribute__((type_visibility("default"))) const_mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp> {
            _Sp (_Tp::*__p_)(_Ap) const;
        public:
            explicit const_mem_fun1_ref_t<_Sp, _Tp, _Ap>(_Sp (_Tp::*__p)(_Ap) const) : __p_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            _Sp operator()(const _Tp &__p, _Ap __x) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__p .* this->__p_)(__x);
            }
        };
        template <class _Sp, class _Tp> inline const_mem_fun_ref_t<_Sp, _Tp> mem_fun_ref(_Sp (_Tp::*__f)() const) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return const_mem_fun_ref_t<_Sp, _Tp>(__f);
        }
        template <class _Sp, class _Tp, class _Ap> inline const_mem_fun1_ref_t<_Sp, _Tp, _Ap> mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return const_mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
        }
        template <class _Tp> class __mem_fn : public __weak_result_type<_Tp> {
        public:
            typedef _Tp type;
        private:
            std::__1::__mem_fn::type __f_;
        public:
            __mem_fn<_Tp>(std::__1::__mem_fn::type __f) throw() : __f_(__f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _A0> typename __invoke_return0<type, _A0>::type operator()(_A0 &__a0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0);
            }
            template <class _A0> typename __invoke_return0<type, const _A0>::type operator()(const _A0 &__a0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0);
            }
            template <class _A0, class _A1> typename __invoke_return1<type, _A0, _A1>::type operator()(_A0 &__a0, _A1 &__a1) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1);
            }
            template <class _A0, class _A1> typename __invoke_return1<type, const _A0, _A1>::type operator()(const _A0 &__a0, _A1 &__a1) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1);
            }
            template <class _A0, class _A1> typename __invoke_return1<type, _A0, const _A1>::type operator()(_A0 &__a0, const _A1 &__a1) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1);
            }
            template <class _A0, class _A1> typename __invoke_return1<type, const _A0, const _A1>::type operator()(const _A0 &__a0, const _A1 &__a1) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, _A0, _A1, _A2>::type operator()(_A0 &__a0, _A1 &__a1, _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, const _A0, _A1, _A2>::type operator()(const _A0 &__a0, _A1 &__a1, _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, _A0, const _A1, _A2>::type operator()(_A0 &__a0, const _A1 &__a1, _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, _A0, _A1, const _A2>::type operator()(_A0 &__a0, _A1 &__a1, const _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, const _A0, const _A1, _A2>::type operator()(const _A0 &__a0, const _A1 &__a1, _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, const _A0, _A1, const _A2>::type operator()(const _A0 &__a0, _A1 &__a1, const _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, _A0, const _A1, const _A2>::type operator()(_A0 &__a0, const _A1 &__a1, const _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1, __a2);
            }
            template <class _A0, class _A1, class _A2> typename __invoke_return2<type, const _A0, const _A1, const _A2>::type operator()(const _A0 &__a0, const _A1 &__a1, const _A2 &__a2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __invoke(this->__f_, __a0, __a1, __a2);
            }
        };
        template <class _Rp, class _Tp> inline __mem_fn<_Rp _Tp::*> mem_fn(_Rp _Tp::*__pm) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __mem_fn<_Rp _Tp::*>(__pm);
        }
        class __attribute__((visibility("default"))) bad_function_call : public std::exception {
        };
        inline void __throw_bad_function_call() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw std::__1::bad_function_call();
        }
        template <class _Fp> class __attribute__((type_visibility("default"))) function;
        namespace __function {
            template <class _Rp> struct __maybe_derive_from_unary_function {
            };
            template <class _Rp, class _A1> struct __maybe_derive_from_unary_function<_Rp (_A1)> : public unary_function<_A1, _Rp> {
            };
            template <class _Rp> struct __maybe_derive_from_binary_function {
            };
            template <class _Rp, class _A1, class _A2> struct __maybe_derive_from_binary_function<_Rp (_A1, _A2)> : public binary_function<_A1, _A2, _Rp> {
            };
            template <class _Fp> bool __not_null(const _Fp &) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return true;
            }
            template <class _Fp> bool __not_null(_Fp *__ptr) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __ptr;
            }
            template <class _Ret, class _Class> bool __not_null(_Ret _Class::*__ptr) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __ptr;
            }
            template <class _Fp> bool __not_null(const function<_Fp> &__f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !!__f;
            }
            template <class _Rp, class ..._Args> bool __not_null(_Rp (^__p)(_Args...)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __p;
            }
        }
        namespace __function {
            template <class _Fp> class __base;
            template <class _Rp> class __base<_Rp ()> {
                __base<type-parameter-0-0 ()>(const __base<type-parameter-0-0 ()> &);
                __base<type-parameter-0-0 ()> &operator=(const __base<type-parameter-0-0 ()> &);
            public:
                __base<type-parameter-0-0 ()>()                 {
                }
                virtual ~__base<type-parameter-0-0 ()>()                 {
                }
                virtual __base<type-parameter-0-0 ()> *__clone() const = 0;
                virtual void __clone(__base<type-parameter-0-0 ()> *) const = 0;
                virtual void destroy() = 0;
                virtual void destroy_deallocate() = 0;
                virtual _Rp operator()() = 0;
                virtual const void *target(const std::type_info &) const = 0;
                virtual const std::type_info &target_type() const = 0;
            };
            template <class _Rp, class _A0> class __base<_Rp (_A0)> {
                __base<type-parameter-0-0 (type-parameter-0-1)>(const __base<type-parameter-0-0 (type-parameter-0-1)> &);
                __base<type-parameter-0-0 (type-parameter-0-1)> &operator=(const __base<type-parameter-0-0 (type-parameter-0-1)> &);
            public:
                __base<type-parameter-0-0 (type-parameter-0-1)>()                 {
                }
                virtual ~__base<type-parameter-0-0 (type-parameter-0-1)>()                 {
                }
                virtual __base<type-parameter-0-0 (type-parameter-0-1)> *__clone() const = 0;
                virtual void __clone(__base<type-parameter-0-0 (type-parameter-0-1)> *) const = 0;
                virtual void destroy() = 0;
                virtual void destroy_deallocate() = 0;
                virtual _Rp operator()(_A0) = 0;
                virtual const void *target(const std::type_info &) const = 0;
                virtual const std::type_info &target_type() const = 0;
            };
            template <class _Rp, class _A0, class _A1> class __base<_Rp (_A0, _A1)> {
                __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(const __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &);
                __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &operator=(const __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &);
            public:
                __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>()                 {
                }
                virtual ~__base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>()                 {
                }
                virtual __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> *__clone() const = 0;
                virtual void __clone(__base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> *) const = 0;
                virtual void destroy() = 0;
                virtual void destroy_deallocate() = 0;
                virtual _Rp operator()(_A0, _A1) = 0;
                virtual const void *target(const std::type_info &) const = 0;
                virtual const std::type_info &target_type() const = 0;
            };
            template <class _Rp, class _A0, class _A1, class _A2> class __base<_Rp (_A0, _A1, _A2)> {
                __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(const __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &);
                __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &operator=(const __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &);
            public:
                __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>()                 {
                }
                virtual ~__base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>()                 {
                }
                virtual __base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> *__clone() const = 0;
                virtual void __clone(__base<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> *) const = 0;
                virtual void destroy() = 0;
                virtual void destroy_deallocate() = 0;
                virtual _Rp operator()(_A0, _A1, _A2) = 0;
                virtual const void *target(const std::type_info &) const = 0;
                virtual const std::type_info &target_type() const = 0;
            };
            template <class _FD, class _Alloc, class _FB> class __func;
            template <class _Fp, class _Alloc, class _Rp> class __func<_Fp, _Alloc, _Rp ()> : public __base<_Rp ()> {
                __compressed_pair<_Fp, _Alloc> __f_;
            public:
                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 ()>(_Fp __f) : __f_(std::__1::move(__f), std::__1::__default_init_tag())                 {
                }
                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 ()>(_Fp __f, _Alloc __a) : __f_(std::__1::move(__f), std::__1::move(__a))                 {
                }
                virtual __base<_Rp ()> *__clone() const;
                virtual void __clone(__base<_Rp ()> *) const;
                virtual void destroy();
                virtual void destroy_deallocate();
                virtual _Rp operator()();
                virtual const void *target(const std::type_info &) const;
                virtual const std::type_info &target_type() const;
            };
            template <class _Fp, class _Alloc, class _Rp> __base<_Rp ()> *__func<_Fp, _Alloc, _Rp ()>::__clone() const             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 ()> >::type _Ap;
                _Ap __a(this->__f_.second());
                typedef __allocator_destructor<_Ap> _Dp;
                unique_ptr<__func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 ()>, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                ::new (__hold.get()) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 ()>((this->__f_.first(), _Alloc(__a)));
                return __hold.release();
            }
            template <class _Fp, class _Alloc, class _Rp> void __func<_Fp, _Alloc, _Rp ()>::__clone(__base<_Rp ()> *__p) const             {
                ::new (__p) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 ()>((this->__f_.first(), this->__f_.second()));
            }
            template <class _Fp, class _Alloc, class _Rp> void __func<_Fp, _Alloc, _Rp ()>::destroy()             {
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
            }
            template <class _Fp, class _Alloc, class _Rp> void __func<_Fp, _Alloc, _Rp ()>::destroy_deallocate()             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 ()> >::type _Ap;
                _Ap __a(this->__f_.second());
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
                __a.deallocate(this, 1);
            }
            template <class _Fp, class _Alloc, class _Rp> _Rp __func<_Fp, _Alloc, _Rp ()>::operator()()             {
                typedef __invoke_void_return_wrapper<_Rp> _Invoker;
                return _Invoker::__call(this->__f_.first());
            }
            template <class _Fp, class _Alloc, class _Rp> const void *__func<_Fp, _Alloc, _Rp ()>::target(const std::type_info &__ti) const             {
                if (__ti == typeid(_Fp))
                    return &this->__f_.first();
                return (const void *)0;
            }
            template <class _Fp, class _Alloc, class _Rp> const std::type_info &__func<_Fp, _Alloc, _Rp ()>::target_type() const             {
                return typeid(_Fp);
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0> class __func<_Fp, _Alloc, _Rp (_A0)> : public __base<_Rp (_A0)> {
                __compressed_pair<_Fp, _Alloc> __f_;
            public:
                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3)>(_Fp __f) : __f_(std::__1::move(__f), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3)>(_Fp __f, _Alloc __a) : __f_(std::__1::move(__f), std::__1::move(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                virtual __base<_Rp (_A0)> *__clone() const;
                virtual void __clone(__base<_Rp (_A0)> *) const;
                virtual void destroy();
                virtual void destroy_deallocate();
                virtual _Rp operator()(_A0);
                virtual const void *target(const std::type_info &) const;
                virtual const std::type_info &target_type() const;
            };
            template <class _Fp, class _Alloc, class _Rp, class _A0> __base<_Rp (_A0)> *__func<_Fp, _Alloc, _Rp (_A0)>::__clone() const             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3)> >::type _Ap;
                _Ap __a(this->__f_.second());
                typedef __allocator_destructor<_Ap> _Dp;
                unique_ptr<__func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3)>, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                ::new (__hold.get()) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3)>((this->__f_.first(), _Alloc(__a)));
                return __hold.release();
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0> void __func<_Fp, _Alloc, _Rp (_A0)>::__clone(__base<_Rp (_A0)> *__p) const             {
                ::new (__p) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3)>((this->__f_.first(), this->__f_.second()));
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0> void __func<_Fp, _Alloc, _Rp (_A0)>::destroy()             {
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0> void __func<_Fp, _Alloc, _Rp (_A0)>::destroy_deallocate()             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3)> >::type _Ap;
                _Ap __a(this->__f_.second());
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
                __a.deallocate(this, 1);
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0> _Rp __func<_Fp, _Alloc, _Rp (_A0)>::operator()(_A0 __a0)             {
                typedef __invoke_void_return_wrapper<_Rp> _Invoker;
                return _Invoker::__call(this->__f_.first(), __a0);
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0> const void *__func<_Fp, _Alloc, _Rp (_A0)>::target(const std::type_info &__ti) const             {
                if (__ti == typeid(_Fp))
                    return &this->__f_.first();
                return (const void *)0;
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0> const std::type_info &__func<_Fp, _Alloc, _Rp (_A0)>::target_type() const             {
                return typeid(_Fp);
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1> class __func<_Fp, _Alloc, _Rp (_A0, _A1)> : public __base<_Rp (_A0, _A1)> {
                __compressed_pair<_Fp, _Alloc> __f_;
            public:
                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4)>(_Fp __f) : __f_(std::__1::move(__f), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4)>(_Fp __f, _Alloc __a) : __f_(std::__1::move(__f), std::__1::move(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                virtual __base<_Rp (_A0, _A1)> *__clone() const;
                virtual void __clone(__base<_Rp (_A0, _A1)> *) const;
                virtual void destroy();
                virtual void destroy_deallocate();
                virtual _Rp operator()(_A0, _A1);
                virtual const void *target(const std::type_info &) const;
                virtual const std::type_info &target_type() const;
            };
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1> __base<_Rp (_A0, _A1)> *__func<_Fp, _Alloc, _Rp (_A0, _A1)>::__clone() const             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4)> >::type _Ap;
                _Ap __a(this->__f_.second());
                typedef __allocator_destructor<_Ap> _Dp;
                unique_ptr<__func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4)>, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                ::new (__hold.get()) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4)>((this->__f_.first(), _Alloc(__a)));
                return __hold.release();
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1> void __func<_Fp, _Alloc, _Rp (_A0, _A1)>::__clone(__base<_Rp (_A0, _A1)> *__p) const             {
                ::new (__p) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4)>((this->__f_.first(), this->__f_.second()));
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1> void __func<_Fp, _Alloc, _Rp (_A0, _A1)>::destroy()             {
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1> void __func<_Fp, _Alloc, _Rp (_A0, _A1)>::destroy_deallocate()             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4)> >::type _Ap;
                _Ap __a(this->__f_.second());
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
                __a.deallocate(this, 1);
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1> _Rp __func<_Fp, _Alloc, _Rp (_A0, _A1)>::operator()(_A0 __a0, _A1 __a1)             {
                typedef __invoke_void_return_wrapper<_Rp> _Invoker;
                return _Invoker::__call(this->__f_.first(), __a0, __a1);
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1> const void *__func<_Fp, _Alloc, _Rp (_A0, _A1)>::target(const std::type_info &__ti) const             {
                if (__ti == typeid(_Fp))
                    return &this->__f_.first();
                return (const void *)0;
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1> const std::type_info &__func<_Fp, _Alloc, _Rp (_A0, _A1)>::target_type() const             {
                return typeid(_Fp);
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2> class __func<_Fp, _Alloc, _Rp (_A0, _A1, _A2)> : public __base<_Rp (_A0, _A1, _A2)> {
                __compressed_pair<_Fp, _Alloc> __f_;
            public:
                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4, type-parameter-0-5)>(_Fp __f) : __f_(std::__1::move(__f), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                explicit __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4, type-parameter-0-5)>(_Fp __f, _Alloc __a) : __f_(std::__1::move(__f), std::__1::move(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                virtual __base<_Rp (_A0, _A1, _A2)> *__clone() const;
                virtual void __clone(__base<_Rp (_A0, _A1, _A2)> *) const;
                virtual void destroy();
                virtual void destroy_deallocate();
                virtual _Rp operator()(_A0, _A1, _A2);
                virtual const void *target(const std::type_info &) const;
                virtual const std::type_info &target_type() const;
            };
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2> __base<_Rp (_A0, _A1, _A2)> *__func<_Fp, _Alloc, _Rp (_A0, _A1, _A2)>::__clone() const             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4, type-parameter-0-5)> >::type _Ap;
                _Ap __a(this->__f_.second());
                typedef __allocator_destructor<_Ap> _Dp;
                unique_ptr<__func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4, type-parameter-0-5)>, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                ::new (__hold.get()) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4, type-parameter-0-5)>((this->__f_.first(), _Alloc(__a)));
                return __hold.release();
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2> void __func<_Fp, _Alloc, _Rp (_A0, _A1, _A2)>::__clone(__base<_Rp (_A0, _A1, _A2)> *__p) const             {
                ::new (__p) __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4, type-parameter-0-5)>((this->__f_.first(), this->__f_.second()));
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2> void __func<_Fp, _Alloc, _Rp (_A0, _A1, _A2)>::destroy()             {
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2> void __func<_Fp, _Alloc, _Rp (_A0, _A1, _A2)>::destroy_deallocate()             {
                typedef allocator_traits<_Alloc> __alloc_traits;
                typedef typename __rebind_alloc_helper<__alloc_traits, __func<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2 (type-parameter-0-3, type-parameter-0-4, type-parameter-0-5)> >::type _Ap;
                _Ap __a(this->__f_.second());
                this->__f_.~__compressed_pair<_Fp, _Alloc>();
                __a.deallocate(this, 1);
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2> _Rp __func<_Fp, _Alloc, _Rp (_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2)             {
                typedef __invoke_void_return_wrapper<_Rp> _Invoker;
                return _Invoker::__call(this->__f_.first(), __a0, __a1, __a2);
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2> const void *__func<_Fp, _Alloc, _Rp (_A0, _A1, _A2)>::target(const std::type_info &__ti) const             {
                if (__ti == typeid(_Fp))
                    return &this->__f_.first();
                return (const void *)0;
            }
            template <class _Fp, class _Alloc, class _Rp, class _A0, class _A1, class _A2> const std::type_info &__func<_Fp, _Alloc, _Rp (_A0, _A1, _A2)>::target_type() const             {
                return typeid(_Fp);
            }
        }
        template <class _Rp> class __attribute__((type_visibility("default"))) function<_Rp ()> {
            typedef __function::__base<_Rp ()> __base;
            aligned_storage<3 * sizeof(void *)>::type __buf_;
            std::__1::function<type-parameter-0-0 ()>::__base *__f_;
        public:
            typedef _Rp result_type;
            explicit function<type-parameter-0-0 ()>() : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            function<type-parameter-0-0 ()>(std::__1::nullptr_t) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            function<type-parameter-0-0 ()>(const function<type-parameter-0-0 ()> &);
            template <class _Fp> function<type-parameter-0-0 ()>(_Fp, typename enable_if<!is_integral<_Fp>::value>::type * = 0);
            template <class _Alloc> function<type-parameter-0-0 ()>(std::__1::allocator_arg_t, const _Alloc &) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> function<type-parameter-0-0 ()>(std::__1::allocator_arg_t, const _Alloc &, std::__1::nullptr_t) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> function<type-parameter-0-0 ()>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 ()> &);
            template <class _Fp, class _Alloc> function<type-parameter-0-0 ()>(std::__1::allocator_arg_t, const _Alloc &__a, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0);
            function<type-parameter-0-0 ()> &operator=(const function<type-parameter-0-0 ()> &);
            function<type-parameter-0-0 ()> &operator=(std::__1::nullptr_t);
            template <class _Fp> typename enable_if<!is_integral<_Fp>::value, function<type-parameter-0-0 ()> &>::type operator=(_Fp);
            ~function<type-parameter-0-0 ()>();
            void swap(function<type-parameter-0-0 ()> &);
            template <class _Fp, class _Alloc> void assign(_Fp __f, const _Alloc &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                function<type-parameter-0-0 ()>(allocator_arg, __a, __f).swap(*this);
            }
            operator bool() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__f_;
            }
        private:
            template <class _R2> bool operator==(const function<_R2 ()> &) const;
            template <class _R2> bool operator!=(const function<_R2 ()> &) const;
        public:
            _Rp operator()() const;
            const std::type_info &target_type() const;
            template <typename _Tp> _Tp *target();
            template <typename _Tp> const _Tp *target() const;
        };
        template <class _Rp> function<_Rp ()>::function<type-parameter-0-0 ()>(const function<type-parameter-0-0 ()> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const std::__1::function<type-parameter-0-0 ()>::__base *)&__f.__buf_) {
                this->__f_ = (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }
        template <class _Rp> template <class _Alloc> function<_Rp ()>::function<type-parameter-0-0 ()>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 ()> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const std::__1::function<type-parameter-0-0 ()>::__base *)&__f.__buf_) {
                this->__f_ = (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }
        template <class _Rp> template <class _Fp> function<_Rp ()>::function<type-parameter-0-0 ()>(_Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0) : __f_(0)         {
            if (__function::__not_null(__f)) {
                typedef __function::__func<_Fp, allocator<_Fp>, _Rp ()> _FF;
                if (sizeof(_FF) <= sizeof (this->__buf_)) {
                    this->__f_ = (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_;
                    ::new (this->__f_) _FF((__f));
                } else {
                    typedef allocator<_FF> _Ap;
                    _Ap __a;
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<std::__1::function<type-parameter-0-0 ()>::__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((__f, allocator<_Fp>(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }
        template <class _Rp> template <class _Fp, class _Alloc> function<_Rp ()>::function<type-parameter-0-0 ()>(std::__1::allocator_arg_t, const _Alloc &__a0, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0) : __f_(0)         {
            typedef allocator_traits<_Alloc> __alloc_traits;
            if (__function::__not_null(__f)) {
                typedef __function::__func<_Fp, _Alloc, _Rp ()> _FF;
                if (sizeof(_FF) <= sizeof (this->__buf_)) {
                    this->__f_ = (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_;
                    ::new (this->__f_) _FF((__f, __a0));
                } else {
                    typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;
                    _Ap __a(__a0);
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<std::__1::function<type-parameter-0-0 ()>::__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((__f, _Alloc(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }
        template <class _Rp> function<_Rp ()> &function<_Rp ()>::operator=(const function<type-parameter-0-0 ()> &__f)         {
            if (__f)
                function<type-parameter-0-0 ()>(__f).swap(*this);
            else
                *this = std::__1::__get_nullptr_t();
            return *this;
        }
        template <class _Rp> function<_Rp ()> &function<_Rp ()>::operator=(std::__1::nullptr_t)         {
            std::__1::function<type-parameter-0-0 ()>::__base *__t = this->__f_;
            this->__f_ = 0;
            if (__t == (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_)
                __t->destroy();
            else if (__t)
                __t->destroy_deallocate();
            return *this;
        }
        template <class _Rp> template <class _Fp> typename enable_if<!is_integral<_Fp>::value, function<_Rp ()> &>::type function<_Rp ()>::operator=(_Fp __f)         {
            function<type-parameter-0-0 ()>(std::__1::move(__f)).swap(*this);
            return *this;
        }
        template <class _Rp> function<_Rp ()>::~function<type-parameter-0-0 ()>()         {
            if (this->__f_ == (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_)
                this->__f_->destroy();
            else if (this->__f_)
                this->__f_->destroy_deallocate();
        }
        template <class _Rp> void function<_Rp ()>::swap(function<type-parameter-0-0 ()> &__f)         {
            if (std::__1::addressof(__f) == this)
                return;
            if (this->__f_ == (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_ && __f.__f_ == (std::__1::function<type-parameter-0-0 ()>::__base *)&__f.__buf_) {
                typename aligned_storage<sizeof (this->__buf_)>::type __tempbuf;
                std::__1::function<type-parameter-0-0 ()>::__base *__t = (std::__1::function<type-parameter-0-0 ()>::__base *)&__tempbuf;
                this->__f_->__clone(__t);
                this->__f_->destroy();
                this->__f_ = 0;
                __f.__f_->__clone((std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = 0;
                this->__f_ = (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_;
                __t->__clone((std::__1::function<type-parameter-0-0 ()>::__base *)&__f.__buf_);
                __t->destroy();
                __f.__f_ = (std::__1::function<type-parameter-0-0 ()>::__base *)&__f.__buf_;
            } else if (this->__f_ == (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_) {
                this->__f_->__clone((std::__1::function<type-parameter-0-0 ()>::__base *)&__f.__buf_);
                this->__f_->destroy();
                this->__f_ = __f.__f_;
                __f.__f_ = (std::__1::function<type-parameter-0-0 ()>::__base *)&__f.__buf_;
            } else if (__f.__f_ == (std::__1::function<type-parameter-0-0 ()>::__base *)&__f.__buf_) {
                __f.__f_->__clone((std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = this->__f_;
                this->__f_ = (std::__1::function<type-parameter-0-0 ()>::__base *)&this->__buf_;
            } else
                std::__1::swap(this->__f_, __f.__f_);
        }
        template <class _Rp> _Rp function<_Rp ()>::operator()() const         {
            if (this->__f_ == 0)
                __throw_bad_function_call();
            return (*this->__f_)();
        }
        template <class _Rp> const std::type_info &function<_Rp ()>::target_type() const         {
            if (this->__f_ == 0)
                return typeid(void);
            return this->__f_->target_type();
        }
        template <class _Rp> template <typename _Tp> _Tp *function<_Rp ()>::target()         {
            if (this->__f_ == 0)
                return (_Tp *)0;
            return (_Tp *)const_cast<void *>(this->__f_->target(typeid(_Tp)));
        }
        template <class _Rp> template <typename _Tp> const _Tp *function<_Rp ()>::target() const         {
            if (this->__f_ == 0)
                return (const _Tp *)0;
            return (const _Tp *)this->__f_->target(typeid(_Tp));
        }
        template <class _Rp, class _A0> class __attribute__((type_visibility("default"))) function<_Rp (_A0)> : public unary_function<_A0, _Rp> {
            typedef __function::__base<_Rp (_A0)> __base;
            aligned_storage<3 * sizeof(void *)>::type __buf_;
            std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *__f_;
        public:
            typedef _Rp result_type;
            explicit function<type-parameter-0-0 (type-parameter-0-1)>() : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            function<type-parameter-0-0 (type-parameter-0-1)>(std::__1::nullptr_t) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            function<type-parameter-0-0 (type-parameter-0-1)>(const function<type-parameter-0-0 (type-parameter-0-1)> &);
            template <class _Fp> function<type-parameter-0-0 (type-parameter-0-1)>(_Fp, typename enable_if<!is_integral<_Fp>::value>::type * = 0);
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1)>(std::__1::allocator_arg_t, const _Alloc &) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1)>(std::__1::allocator_arg_t, const _Alloc &, std::__1::nullptr_t) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1)>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 (type-parameter-0-1)> &);
            template <class _Fp, class _Alloc> function<type-parameter-0-0 (type-parameter-0-1)>(std::__1::allocator_arg_t, const _Alloc &__a, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0);
            function<type-parameter-0-0 (type-parameter-0-1)> &operator=(const function<type-parameter-0-0 (type-parameter-0-1)> &);
            function<type-parameter-0-0 (type-parameter-0-1)> &operator=(std::__1::nullptr_t);
            template <class _Fp> typename enable_if<!is_integral<_Fp>::value, function<type-parameter-0-0 (type-parameter-0-1)> &>::type operator=(_Fp);
            ~function<type-parameter-0-0 (type-parameter-0-1)>();
            void swap(function<type-parameter-0-0 (type-parameter-0-1)> &);
            template <class _Fp, class _Alloc> void assign(_Fp __f, const _Alloc &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                function<type-parameter-0-0 (type-parameter-0-1)>(allocator_arg, __a, __f).swap(*this);
            }
            operator bool() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__f_;
            }
        private:
            template <class _R2, class _B0> bool operator==(const function<_R2 (_B0)> &) const;
            template <class _R2, class _B0> bool operator!=(const function<_R2 (_B0)> &) const;
        public:
            _Rp operator()(_A0) const;
            const std::type_info &target_type() const;
            template <typename _Tp> _Tp *target();
            template <typename _Tp> const _Tp *target() const;
        };
        template <class _Rp, class _A0> function<_Rp (_A0)>::function<type-parameter-0-0 (type-parameter-0-1)>(const function<type-parameter-0-0 (type-parameter-0-1)> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&__f.__buf_) {
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }
        template <class _Rp, class _A0> template <class _Alloc> function<_Rp (_A0)>::function<type-parameter-0-0 (type-parameter-0-1)>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 (type-parameter-0-1)> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&__f.__buf_) {
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }
        template <class _Rp, class _A0> template <class _Fp> function<_Rp (_A0)>::function<type-parameter-0-0 (type-parameter-0-1)>(_Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0) : __f_(0)         {
            if (__function::__not_null(__f)) {
                typedef __function::__func<_Fp, allocator<_Fp>, _Rp (_A0)> _FF;
                if (sizeof(_FF) <= sizeof (this->__buf_)) {
                    this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_;
                    ::new (this->__f_) _FF((__f));
                } else {
                    typedef allocator<_FF> _Ap;
                    _Ap __a;
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((__f, allocator<_Fp>(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }
        template <class _Rp, class _A0> template <class _Fp, class _Alloc> function<_Rp (_A0)>::function<type-parameter-0-0 (type-parameter-0-1)>(std::__1::allocator_arg_t, const _Alloc &__a0, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0) : __f_(0)         {
            typedef allocator_traits<_Alloc> __alloc_traits;
            if (__function::__not_null(__f)) {
                typedef __function::__func<_Fp, _Alloc, _Rp (_A0)> _FF;
                if (sizeof(_FF) <= sizeof (this->__buf_)) {
                    this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_;
                    ::new (this->__f_) _FF((__f, __a0));
                } else {
                    typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;
                    _Ap __a(__a0);
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((__f, _Alloc(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }
        template <class _Rp, class _A0> function<_Rp (_A0)> &function<_Rp (_A0)>::operator=(const function<type-parameter-0-0 (type-parameter-0-1)> &__f)         {
            if (__f)
                function<type-parameter-0-0 (type-parameter-0-1)>(__f).swap(*this);
            else
                *this = std::__1::__get_nullptr_t();
            return *this;
        }
        template <class _Rp, class _A0> function<_Rp (_A0)> &function<_Rp (_A0)>::operator=(std::__1::nullptr_t)         {
            std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *__t = this->__f_;
            this->__f_ = 0;
            if (__t == (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_)
                __t->destroy();
            else if (__t)
                __t->destroy_deallocate();
            return *this;
        }
        template <class _Rp, class _A0> template <class _Fp> typename enable_if<!is_integral<_Fp>::value, function<_Rp (_A0)> &>::type function<_Rp (_A0)>::operator=(_Fp __f)         {
            function<type-parameter-0-0 (type-parameter-0-1)>(std::__1::move(__f)).swap(*this);
            return *this;
        }
        template <class _Rp, class _A0> function<_Rp (_A0)>::~function<type-parameter-0-0 (type-parameter-0-1)>()         {
            if (this->__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_)
                this->__f_->destroy();
            else if (this->__f_)
                this->__f_->destroy_deallocate();
        }
        template <class _Rp, class _A0> void function<_Rp (_A0)>::swap(function<type-parameter-0-0 (type-parameter-0-1)> &__f)         {
            if (std::__1::addressof(__f) == this)
                return;
            if (this->__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_ && __f.__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&__f.__buf_) {
                typename aligned_storage<sizeof (this->__buf_)>::type __tempbuf;
                std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *__t = (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&__tempbuf;
                this->__f_->__clone(__t);
                this->__f_->destroy();
                this->__f_ = 0;
                __f.__f_->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = 0;
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_;
                __t->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&__f.__buf_);
                __t->destroy();
                __f.__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&__f.__buf_;
            } else if (this->__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_) {
                this->__f_->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&__f.__buf_);
                this->__f_->destroy();
                this->__f_ = __f.__f_;
                __f.__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&__f.__buf_;
            } else if (__f.__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&__f.__buf_) {
                __f.__f_->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = this->__f_;
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1)>::__base *)&this->__buf_;
            } else
                std::__1::swap(this->__f_, __f.__f_);
        }
        template <class _Rp, class _A0> _Rp function<_Rp (_A0)>::operator()(_A0 __a0) const         {
            if (this->__f_ == 0)
                __throw_bad_function_call();
            return (*this->__f_)(__a0);
        }
        template <class _Rp, class _A0> const std::type_info &function<_Rp (_A0)>::target_type() const         {
            if (this->__f_ == 0)
                return typeid(void);
            return this->__f_->target_type();
        }
        template <class _Rp, class _A0> template <typename _Tp> _Tp *function<_Rp (_A0)>::target()         {
            if (this->__f_ == 0)
                return (_Tp *)0;
            return (_Tp *)const_cast<void *>(this->__f_->target(typeid(_Tp)));
        }
        template <class _Rp, class _A0> template <typename _Tp> const _Tp *function<_Rp (_A0)>::target() const         {
            if (this->__f_ == 0)
                return (const _Tp *)0;
            return (const _Tp *)this->__f_->target(typeid(_Tp));
        }
        template <class _Rp, class _A0, class _A1> class __attribute__((type_visibility("default"))) function<_Rp (_A0, _A1)> : public binary_function<_A0, _A1, _Rp> {
            typedef __function::__base<_Rp (_A0, _A1)> __base;
            aligned_storage<3 * sizeof(void *)>::type __buf_;
            std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *__f_;
        public:
            typedef _Rp result_type;
            explicit function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>() : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(std::__1::nullptr_t) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &);
            template <class _Fp> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(_Fp, typename enable_if<!is_integral<_Fp>::value>::type * = 0);
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(std::__1::allocator_arg_t, const _Alloc &) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(std::__1::allocator_arg_t, const _Alloc &, std::__1::nullptr_t) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &);
            template <class _Fp, class _Alloc> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(std::__1::allocator_arg_t, const _Alloc &__a, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0);
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &operator=(const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &);
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &operator=(std::__1::nullptr_t);
            template <class _Fp> typename enable_if<!is_integral<_Fp>::value, function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &>::type operator=(_Fp);
            ~function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>();
            void swap(function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &);
            template <class _Fp, class _Alloc> void assign(_Fp __f, const _Alloc &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(allocator_arg, __a, __f).swap(*this);
            }
            operator bool() const             {
                return this->__f_;
            }
        private:
            template <class _R2, class _B0, class _B1> bool operator==(const function<_R2 (_B0, _B1)> &) const;
            template <class _R2, class _B0, class _B1> bool operator!=(const function<_R2 (_B0, _B1)> &) const;
        public:
            _Rp operator()(_A0, _A1) const;
            const std::type_info &target_type() const;
            template <typename _Tp> _Tp *target();
            template <typename _Tp> const _Tp *target() const;
        };
        template <class _Rp, class _A0, class _A1> function<_Rp (_A0, _A1)>::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&__f.__buf_) {
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }
        template <class _Rp, class _A0, class _A1> template <class _Alloc> function<_Rp (_A0, _A1)>::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&__f.__buf_) {
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }
        template <class _Rp, class _A0, class _A1> template <class _Fp> function<_Rp (_A0, _A1)>::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(_Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0) : __f_(0)         {
            if (__function::__not_null(__f)) {
                typedef __function::__func<_Fp, allocator<_Fp>, _Rp (_A0, _A1)> _FF;
                if (sizeof(_FF) <= sizeof (this->__buf_)) {
                    this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_;
                    ::new (this->__f_) _FF((__f));
                } else {
                    typedef allocator<_FF> _Ap;
                    _Ap __a;
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((__f, allocator<_Fp>(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }
        template <class _Rp, class _A0, class _A1> template <class _Fp, class _Alloc> function<_Rp (_A0, _A1)>::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(std::__1::allocator_arg_t, const _Alloc &__a0, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0) : __f_(0)         {
            typedef allocator_traits<_Alloc> __alloc_traits;
            if (__function::__not_null(__f)) {
                typedef __function::__func<_Fp, _Alloc, _Rp (_A0, _A1)> _FF;
                if (sizeof(_FF) <= sizeof (this->__buf_)) {
                    this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_;
                    ::new (this->__f_) _FF((__f, __a0));
                } else {
                    typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;
                    _Ap __a(__a0);
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((__f, _Alloc(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }
        template <class _Rp, class _A0, class _A1> function<_Rp (_A0, _A1)> &function<_Rp (_A0, _A1)>::operator=(const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &__f)         {
            if (__f)
                function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(__f).swap(*this);
            else
                *this = std::__1::__get_nullptr_t();
            return *this;
        }
        template <class _Rp, class _A0, class _A1> function<_Rp (_A0, _A1)> &function<_Rp (_A0, _A1)>::operator=(std::__1::nullptr_t)         {
            std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *__t = this->__f_;
            this->__f_ = 0;
            if (__t == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_)
                __t->destroy();
            else if (__t)
                __t->destroy_deallocate();
            return *this;
        }
        template <class _Rp, class _A0, class _A1> template <class _Fp> typename enable_if<!is_integral<_Fp>::value, function<_Rp (_A0, _A1)> &>::type function<_Rp (_A0, _A1)>::operator=(_Fp __f)         {
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>(std::__1::move(__f)).swap(*this);
            return *this;
        }
        template <class _Rp, class _A0, class _A1> function<_Rp (_A0, _A1)>::~function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>()         {
            if (this->__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_)
                this->__f_->destroy();
            else if (this->__f_)
                this->__f_->destroy_deallocate();
        }
        template <class _Rp, class _A0, class _A1> void function<_Rp (_A0, _A1)>::swap(function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)> &__f)         {
            if (std::__1::addressof(__f) == this)
                return;
            if (this->__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_ && __f.__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&__f.__buf_) {
                typename aligned_storage<sizeof (this->__buf_)>::type __tempbuf;
                std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *__t = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&__tempbuf;
                this->__f_->__clone(__t);
                this->__f_->destroy();
                this->__f_ = 0;
                __f.__f_->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = 0;
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_;
                __t->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&__f.__buf_);
                __t->destroy();
                __f.__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&__f.__buf_;
            } else if (this->__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_) {
                this->__f_->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&__f.__buf_);
                this->__f_->destroy();
                this->__f_ = __f.__f_;
                __f.__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&__f.__buf_;
            } else if (__f.__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&__f.__buf_) {
                __f.__f_->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = this->__f_;
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2)>::__base *)&this->__buf_;
            } else
                std::__1::swap(this->__f_, __f.__f_);
        }
        template <class _Rp, class _A0, class _A1> _Rp function<_Rp (_A0, _A1)>::operator()(_A0 __a0, _A1 __a1) const         {
            if (this->__f_ == 0)
                __throw_bad_function_call();
            return (*this->__f_)(__a0, __a1);
        }
        template <class _Rp, class _A0, class _A1> const std::type_info &function<_Rp (_A0, _A1)>::target_type() const         {
            if (this->__f_ == 0)
                return typeid(void);
            return this->__f_->target_type();
        }
        template <class _Rp, class _A0, class _A1> template <typename _Tp> _Tp *function<_Rp (_A0, _A1)>::target()         {
            if (this->__f_ == 0)
                return (_Tp *)0;
            return (_Tp *)const_cast<void *>(this->__f_->target(typeid(_Tp)));
        }
        template <class _Rp, class _A0, class _A1> template <typename _Tp> const _Tp *function<_Rp (_A0, _A1)>::target() const         {
            if (this->__f_ == 0)
                return (const _Tp *)0;
            return (const _Tp *)this->__f_->target(typeid(_Tp));
        }
        template <class _Rp, class _A0, class _A1, class _A2> class __attribute__((type_visibility("default"))) function<_Rp (_A0, _A1, _A2)> {
            typedef __function::__base<_Rp (_A0, _A1, _A2)> __base;
            aligned_storage<3 * sizeof(void *)>::type __buf_;
            std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *__f_;
        public:
            typedef _Rp result_type;
            explicit function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>() : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(std::__1::nullptr_t) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &);
            template <class _Fp> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(_Fp, typename enable_if<!is_integral<_Fp>::value>::type * = 0);
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(std::__1::allocator_arg_t, const _Alloc &) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(std::__1::allocator_arg_t, const _Alloc &, std::__1::nullptr_t) : __f_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &);
            template <class _Fp, class _Alloc> function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(std::__1::allocator_arg_t, const _Alloc &__a, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0);
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &operator=(const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &);
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &operator=(std::__1::nullptr_t);
            template <class _Fp> typename enable_if<!is_integral<_Fp>::value, function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &>::type operator=(_Fp);
            ~function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>();
            void swap(function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &);
            template <class _Fp, class _Alloc> void assign(_Fp __f, const _Alloc &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(allocator_arg, __a, __f).swap(*this);
            }
            operator bool() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__f_;
            }
        private:
            template <class _R2, class _B0, class _B1, class _B2> bool operator==(const function<_R2 (_B0, _B1, _B2)> &) const;
            template <class _R2, class _B0, class _B1, class _B2> bool operator!=(const function<_R2 (_B0, _B1, _B2)> &) const;
        public:
            _Rp operator()(_A0, _A1, _A2) const;
            const std::type_info &target_type() const;
            template <typename _Tp> _Tp *target();
            template <typename _Tp> const _Tp *target() const;
        };
        template <class _Rp, class _A0, class _A1, class _A2> function<_Rp (_A0, _A1, _A2)>::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&__f.__buf_) {
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }
        template <class _Rp, class _A0, class _A1, class _A2> template <class _Alloc> function<_Rp (_A0, _A1, _A2)>::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(std::__1::allocator_arg_t, const _Alloc &, const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &__f)         {
            if (__f.__f_ == 0)
                this->__f_ = 0;
            else if (__f.__f_ == (const std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&__f.__buf_) {
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_;
                __f.__f_->__clone(this->__f_);
            } else
                this->__f_ = __f.__f_->__clone();
        }
        template <class _Rp, class _A0, class _A1, class _A2> template <class _Fp> function<_Rp (_A0, _A1, _A2)>::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(_Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0) : __f_(0)         {
            if (__function::__not_null(__f)) {
                typedef __function::__func<_Fp, allocator<_Fp>, _Rp (_A0, _A1, _A2)> _FF;
                if (sizeof(_FF) <= sizeof (this->__buf_)) {
                    this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_;
                    ::new (this->__f_) _FF((__f));
                } else {
                    typedef allocator<_FF> _Ap;
                    _Ap __a;
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((__f, allocator<_Fp>(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }
        template <class _Rp, class _A0, class _A1, class _A2> template <class _Fp, class _Alloc> function<_Rp (_A0, _A1, _A2)>::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(std::__1::allocator_arg_t, const _Alloc &__a0, _Fp __f, typename enable_if<!is_integral<_Fp>::value>::type * = 0) : __f_(0)         {
            typedef allocator_traits<_Alloc> __alloc_traits;
            if (__function::__not_null(__f)) {
                typedef __function::__func<_Fp, _Alloc, _Rp (_A0, _A1, _A2)> _FF;
                if (sizeof(_FF) <= sizeof (this->__buf_)) {
                    this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_;
                    ::new (this->__f_) _FF((__f, __a0));
                } else {
                    typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;
                    _Ap __a(__a0);
                    typedef __allocator_destructor<_Ap> _Dp;
                    unique_ptr<std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
                    ::new (__hold.get()) _FF((__f, _Alloc(__a)));
                    this->__f_ = __hold.release();
                }
            }
        }
        template <class _Rp, class _A0, class _A1, class _A2> function<_Rp (_A0, _A1, _A2)> &function<_Rp (_A0, _A1, _A2)>::operator=(const function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &__f)         {
            if (__f)
                function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(__f).swap(*this);
            else
                *this = std::__1::__get_nullptr_t();
            return *this;
        }
        template <class _Rp, class _A0, class _A1, class _A2> function<_Rp (_A0, _A1, _A2)> &function<_Rp (_A0, _A1, _A2)>::operator=(std::__1::nullptr_t)         {
            std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *__t = this->__f_;
            this->__f_ = 0;
            if (__t == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_)
                __t->destroy();
            else if (__t)
                __t->destroy_deallocate();
            return *this;
        }
        template <class _Rp, class _A0, class _A1, class _A2> template <class _Fp> typename enable_if<!is_integral<_Fp>::value, function<_Rp (_A0, _A1, _A2)> &>::type function<_Rp (_A0, _A1, _A2)>::operator=(_Fp __f)         {
            function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>(std::__1::move(__f)).swap(*this);
            return *this;
        }
        template <class _Rp, class _A0, class _A1, class _A2> function<_Rp (_A0, _A1, _A2)>::~function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>()         {
            if (this->__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_)
                this->__f_->destroy();
            else if (this->__f_)
                this->__f_->destroy_deallocate();
        }
        template <class _Rp, class _A0, class _A1, class _A2> void function<_Rp (_A0, _A1, _A2)>::swap(function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)> &__f)         {
            if (std::__1::addressof(__f) == this)
                return;
            if (this->__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_ && __f.__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&__f.__buf_) {
                typename aligned_storage<sizeof (this->__buf_)>::type __tempbuf;
                std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *__t = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&__tempbuf;
                this->__f_->__clone(__t);
                this->__f_->destroy();
                this->__f_ = 0;
                __f.__f_->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = 0;
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_;
                __t->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&__f.__buf_);
                __t->destroy();
                __f.__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&__f.__buf_;
            } else if (this->__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_) {
                this->__f_->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&__f.__buf_);
                this->__f_->destroy();
                this->__f_ = __f.__f_;
                __f.__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&__f.__buf_;
            } else if (__f.__f_ == (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&__f.__buf_) {
                __f.__f_->__clone((std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_);
                __f.__f_->destroy();
                __f.__f_ = this->__f_;
                this->__f_ = (std::__1::function<type-parameter-0-0 (type-parameter-0-1, type-parameter-0-2, type-parameter-0-3)>::__base *)&this->__buf_;
            } else
                std::__1::swap(this->__f_, __f.__f_);
        }
        template <class _Rp, class _A0, class _A1, class _A2> _Rp function<_Rp (_A0, _A1, _A2)>::operator()(_A0 __a0, _A1 __a1, _A2 __a2) const         {
            if (this->__f_ == 0)
                __throw_bad_function_call();
            return (*this->__f_)(__a0, __a1, __a2);
        }
        template <class _Rp, class _A0, class _A1, class _A2> const std::type_info &function<_Rp (_A0, _A1, _A2)>::target_type() const         {
            if (this->__f_ == 0)
                return typeid(void);
            return this->__f_->target_type();
        }
        template <class _Rp, class _A0, class _A1, class _A2> template <typename _Tp> _Tp *function<_Rp (_A0, _A1, _A2)>::target()         {
            if (this->__f_ == 0)
                return (_Tp *)0;
            return (_Tp *)const_cast<void *>(this->__f_->target(typeid(_Tp)));
        }
        template <class _Rp, class _A0, class _A1, class _A2> template <typename _Tp> const _Tp *function<_Rp (_A0, _A1, _A2)>::target() const         {
            if (this->__f_ == 0)
                return (const _Tp *)0;
            return (const _Tp *)this->__f_->target(typeid(_Tp));
        }
        template <class _Fp> inline bool operator==(const function<_Fp> &__f, std::__1::nullptr_t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !__f;
        }
        template <class _Fp> inline bool operator==(std::__1::nullptr_t, const function<_Fp> &__f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !__f;
        }
        template <class _Fp> inline bool operator!=(const function<_Fp> &__f, std::__1::nullptr_t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (bool)__f;
        }
        template <class _Fp> inline bool operator!=(std::__1::nullptr_t, const function<_Fp> &__f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (bool)__f;
        }
        template <class _Fp> inline void swap(function<_Fp> &__x, function<_Fp> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.swap(__y);
        }
        template <class _Tp> struct __is_bind_expression : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_bind_expression : public __is_bind_expression<typename remove_cv<_Tp>::type> {
        };
        template <class _Tp> struct __is_placeholder : public integral_constant<int, 0> {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_placeholder : public __is_placeholder<typename remove_cv<_Tp>::type> {
        };
        namespace placeholders {
            template <int _Np> struct __ph {
            };
            extern const __ph<1> _1 __attribute__((visibility("default")));
            extern const __ph<2> _2 __attribute__((visibility("default")));
            extern const __ph<3> _3 __attribute__((visibility("default")));
            extern const __ph<4> _4 __attribute__((visibility("default")));
            extern const __ph<5> _5 __attribute__((visibility("default")));
            extern const __ph<6> _6 __attribute__((visibility("default")));
            extern const __ph<7> _7 __attribute__((visibility("default")));
            extern const __ph<8> _8 __attribute__((visibility("default")));
            extern const __ph<9> _9 __attribute__((visibility("default")));
            extern const __ph<10> _10 __attribute__((visibility("default")));
        }
        template <int _Np> struct __is_placeholder<placeholders::__ph<_Np>> : public integral_constant<int, _Np> {
        };
        template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2> pair<_ForwardIterator1, _ForwardIterator1> __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred, std::__1::forward_iterator_tag, std::__1::forward_iterator_tag)         {
            if (__first2 == __last2)
                return make_pair(__first1, __first1);
            while (true)
                {
                    while (true)
                        {
                            if (__first1 == __last1)
                                return make_pair(__last1, __last1);
                            if (__pred(*__first1, *__first2))
                                break;
                            ++__first1;
                        }
                    _ForwardIterator1 __m1 = __first1;
                    _ForwardIterator2 __m2 = __first2;
                    while (true)
                        {
                            if (++__m2 == __last2)
                                return make_pair(__first1, __m1);
                            if (++__m1 == __last1)
                                return make_pair(__last1, __last1);
                            if (!__pred(*__m1, *__m2)) {
                                ++__first1;
                                break;
                            }
                        }
                }
        }
        template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2> pair<_RandomAccessIterator1, _RandomAccessIterator1> __search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, std::__1::random_access_iterator_tag, std::__1::random_access_iterator_tag)         {
            typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
            typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;
            const _D2 __len2 = __last2 - __first2;
            if (__len2 == 0)
                return make_pair(__first1, __first1);
            const _D1 __len1 = __last1 - __first1;
            if (__len1 < __len2)
                return make_pair(__last1, __last1);
            const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);
            while (true)
                {
                    while (true)
                        {
                            if (__first1 == __s)
                                return make_pair(__last1, __last1);
                            if (__pred(*__first1, *__first2))
                                break;
                            ++__first1;
                        }
                    _RandomAccessIterator1 __m1 = __first1;
                    _RandomAccessIterator2 __m2 = __first2;
                    while (true)
                        {
                            if (++__m2 == __last2)
                                return make_pair(__first1, __first1 + __len2);
                            ++__m1;
                            if (!__pred(*__m1, *__m2)) {
                                ++__first1;
                                break;
                            }
                        }
                }
        }
        template <class _Container, class _Predicate> inline void __libcpp_erase_if_container(_Container &__c, _Predicate __pred)         {
            for (typename _Container::iterator __iter = __c.begin(), __last = __c.end(); __iter != __last;) {
                if (__pred(*__iter))
                    __iter = __c.erase(__iter);
                else
                    ++__iter;
            }
        }
    }
}
namespace std {
    inline namespace __1 {
        inline int __libcpp_ctz(unsigned int __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_ctz(__x);
        }
        inline int __libcpp_ctz(unsigned long __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_ctzl(__x);
        }
        inline int __libcpp_ctz(unsigned long long __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_ctzll(__x);
        }
        inline int __libcpp_clz(unsigned int __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_clz(__x);
        }
        inline int __libcpp_clz(unsigned long __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_clzl(__x);
        }
        inline int __libcpp_clz(unsigned long long __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_clzll(__x);
        }
        inline int __libcpp_popcount(unsigned int __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_popcount(__x);
        }
        inline int __libcpp_popcount(unsigned long __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_popcountl(__x);
        }
        inline int __libcpp_popcount(unsigned long long __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __builtin_popcountll(__x);
        }
        template <class _Tp> using __bitop_unsigned_integer = integral_constant<bool, is_integral<_Tp>::value && is_unsigned<_Tp>::value && _IsNotSame<typename remove_cv<_Tp>::type, bool>::value && _IsNotSame<typename remove_cv<_Tp>::type, signed char>::value && _IsNotSame<typename remove_cv<_Tp>::type, wchar_t>::value && _IsNotSame<typename remove_cv<_Tp>::type, char16_t>::value && _IsNotSame<typename remove_cv<_Tp>::type, char32_t>::value>;
        template <class _Tp> _Tp __rotl(_Tp __t, unsigned int __cnt) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__bitop_unsigned_integer<_Tp>::value, "__rotl requires unsigned");
            const unsigned int __dig = numeric_limits<_Tp>::digits;
            if ((__cnt % __dig) == 0)
                return __t;
            return (__t << (__cnt % __dig)) | (__t >> (__dig - (__cnt % __dig)));
        }
        template <class _Tp> _Tp __rotr(_Tp __t, unsigned int __cnt) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__bitop_unsigned_integer<_Tp>::value, "__rotr requires unsigned");
            const unsigned int __dig = numeric_limits<_Tp>::digits;
            if ((__cnt % __dig) == 0)
                return __t;
            return (__t >> (__cnt % __dig)) | (__t << (__dig - (__cnt % __dig)));
        }
        template <class _Tp> int __countr_zero(_Tp __t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__bitop_unsigned_integer<_Tp>::value, "__countr_zero requires unsigned");
            if (__t == 0)
                return numeric_limits<_Tp>::digits;
            if (sizeof(_Tp) <= sizeof(unsigned int))
                return __libcpp_ctz(static_cast<unsigned int>(__t));
            else if (sizeof(_Tp) <= sizeof(unsigned long))
                return __libcpp_ctz(static_cast<unsigned long>(__t));
            else if (sizeof(_Tp) <= sizeof(unsigned long long))
                return __libcpp_ctz(static_cast<unsigned long long>(__t));
            else {
                int __ret = 0;
                int __iter = 0;
                const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
                while ((__iter = __libcpp_ctz(static_cast<unsigned long long>(__t))) == __ulldigits)
                    {
                        __ret += __iter;
                        __t >>= __ulldigits;
                    }
                return __ret + __iter;
            }
        }
        template <class _Tp> int __countl_zero(_Tp __t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__bitop_unsigned_integer<_Tp>::value, "__countl_zero requires unsigned");
            if (__t == 0)
                return numeric_limits<_Tp>::digits;
            if (sizeof(_Tp) <= sizeof(unsigned int))
                return __libcpp_clz(static_cast<unsigned int>(__t)) - (numeric_limits<unsigned int>::digits - numeric_limits<_Tp>::digits);
            else if (sizeof(_Tp) <= sizeof(unsigned long))
                return __libcpp_clz(static_cast<unsigned long>(__t)) - (numeric_limits<unsigned long>::digits - numeric_limits<_Tp>::digits);
            else if (sizeof(_Tp) <= sizeof(unsigned long long))
                return __libcpp_clz(static_cast<unsigned long long>(__t)) - (numeric_limits<unsigned long long>::digits - numeric_limits<_Tp>::digits);
            else {
                int __ret = 0;
                int __iter = 0;
                const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
                while (true)
                    {
                        __t = __rotr(__t, __ulldigits);
                        if ((__iter = __countl_zero(static_cast<unsigned long long>(__t))) != __ulldigits)
                            break;
                        __ret += __iter;
                    }
                return __ret + __iter;
            }
        }
        template<> int __countl_zero<unsigned long long>(unsigned long long __t) throw() __attribute__((internal_linkage))        template <class _Tp> int __countl_one(_Tp __t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__bitop_unsigned_integer<_Tp>::value, "__countl_one requires unsigned");
            return __t != numeric_limits<_Tp>::max() ? __countl_zero(static_cast<_Tp>(~__t)) : numeric_limits<_Tp>::digits;
        }
        template <class _Tp> int __countr_one(_Tp __t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__bitop_unsigned_integer<_Tp>::value, "__countr_one requires unsigned");
            return __t != numeric_limits<_Tp>::max() ? __countr_zero(static_cast<_Tp>(~__t)) : numeric_limits<_Tp>::digits;
        }
        template <class _Tp> int __popcount(_Tp __t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__bitop_unsigned_integer<_Tp>::value, "__libcpp_popcount requires unsigned");
            if (sizeof(_Tp) <= sizeof(unsigned int))
                return __libcpp_popcount(static_cast<unsigned int>(__t));
            else if (sizeof(_Tp) <= sizeof(unsigned long))
                return __libcpp_popcount(static_cast<unsigned long>(__t));
            else if (sizeof(_Tp) <= sizeof(unsigned long long))
                return __libcpp_popcount(static_cast<unsigned long long>(__t));
            else {
                int __ret = 0;
                while (__t != 0)
                    {
                        __ret += __libcpp_popcount(static_cast<unsigned long long>(__t));
                        __t >>= numeric_limits<unsigned long long>::digits;
                    }
                return __ret;
            }
        }
        template <class _Tp> unsigned int __bit_log2(_Tp __t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__bitop_unsigned_integer<_Tp>::value, "__bit_log2 requires unsigned");
            return std::numeric_limits<_Tp>::digits - 1 - __countl_zero(__t);
        }
        template <class _Tp> bool __ispow2(_Tp __t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__bitop_unsigned_integer<_Tp>::value, "__ispow2 requires unsigned");
            return __t != 0 && (((__t & (__t - 1)) == 0));
        }
    }
}
namespace std {
    inline namespace __1 {
        template <class _T1, class _T2 = _T1> struct __equal_to {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x == __y;
            }
            bool operator()(const _T1 &__x, const _T2 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x == __y;
            }
            bool operator()(const _T2 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x == __y;
            }
            bool operator()(const _T2 &__x, const _T2 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x == __y;
            }
        };
template<> struct __equal_to<std::__1::basic_string<char>, std::__1::basic_string<char>> {
            bool operator()(const std::__1::basic_string<char> &__x, const std::__1::basic_string<char> &__y) const __attribute__((internal_linkage))             {
                return __x == __y;
            }
        };
        template <class _T1> struct __equal_to<_T1, _T1> {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x == __y;
            }
        };
        template <class _T1> struct __equal_to<const _T1, _T1> {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x == __y;
            }
        };
        template <class _T1> struct __equal_to<_T1, const _T1> {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x == __y;
            }
        };
        template <class _T1, class _T2 = _T1> struct __less {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x < __y;
            }
            bool operator()(const _T1 &__x, const _T2 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x < __y;
            }
            bool operator()(const _T2 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x < __y;
            }
            bool operator()(const _T2 &__x, const _T2 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x < __y;
            }
        };
template<> struct __less<unsigned long, unsigned long> {
            bool operator()(const unsigned long &__x, const unsigned long &__y) const __attribute__((internal_linkage))             {
                return __x < __y;
            }
        };
        template <class _T1> struct __less<_T1, _T1> {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x < __y;
            }
        };
        template <class _T1> struct __less<const _T1, _T1> {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x < __y;
            }
        };
        template <class _T1> struct __less<_T1, const _T1> {
            bool operator()(const _T1 &__x, const _T1 &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x < __y;
            }
        };
        template <class _Predicate> class __invert {
        private:
            _Predicate __p_;
        public:
            __invert<_Predicate>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit __invert<_Predicate>(_Predicate __p) : __p_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _T1> bool operator()(const _T1 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !this->__p_(__x);
            }
            template <class _T1, class _T2> bool operator()(const _T1 &__x, const _T2 &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__p_(__y, __x);
            }
        };
        template <typename _Integral> typename enable_if<is_integral<_Integral>::value, _Integral>::type __half_positive(_Integral __value) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return static_cast<_Integral>(static_cast<typename make_unsigned<_Integral>::type>(__value) / 2);
        }
        template <typename _Tp> typename enable_if<!is_integral<_Tp>::value, _Tp>::type __half_positive(_Tp __value) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __value / 2;
        }
        template <class _Comp> struct __comp_ref_type {
            typedef typename add_lvalue_reference<_Comp>::type type;
        };
        template <class _InputIterator, class _Predicate> inline bool all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                if (!__pred(*__first))
                    return false;
            return true;
        }
        template <class _InputIterator, class _Predicate> inline bool any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                if (__pred(*__first))
                    return true;
            return false;
        }
        template <class _InputIterator, class _Predicate> inline bool none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                if (__pred(*__first))
                    return false;
            return true;
        }
        template <class _InputIterator, class _Function> inline _Function for_each(_InputIterator __first, _InputIterator __last, _Function __f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                __f(*__first);
            return __f;
        }
        template <class _InputIterator, class _Tp> inline _InputIterator find(_InputIterator __first, _InputIterator __last, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                if (*__first == __value_)
                    break;
            return __first;
        }
        template <class _InputIterator, class _Predicate> inline _InputIterator find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                if (__pred(*__first))
                    break;
            return __first;
        }
        template <class _InputIterator, class _Predicate> inline _InputIterator find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                if (!__pred(*__first))
                    break;
            return __first;
        }
        template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2> _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred, std::__1::forward_iterator_tag, std::__1::forward_iterator_tag)         {
            _ForwardIterator1 __r = __last1;
            if (__first2 == __last2)
                return __r;
            while (true)
                {
                    while (true)
                        {
                            if (__first1 == __last1)
                                return __r;
                            if (__pred(*__first1, *__first2))
                                break;
                            ++__first1;
                        }
                    _ForwardIterator1 __m1 = __first1;
                    _ForwardIterator2 __m2 = __first2;
                    while (true)
                        {
                            if (++__m2 == __last2) {
                                __r = __first1;
                                ++__first1;
                                break;
                            }
                            if (++__m1 == __last1)
                                return __r;
                            if (!__pred(*__m1, *__m2)) {
                                ++__first1;
                                break;
                            }
                        }
                }
        }
        template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2> _BidirectionalIterator1 __find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred, std::__1::bidirectional_iterator_tag, std::__1::bidirectional_iterator_tag)         {
            if (__first2 == __last2)
                return __last1;
            _BidirectionalIterator1 __l1 = __last1;
            _BidirectionalIterator2 __l2 = __last2;
            --__l2;
            while (true)
                {
                    while (true)
                        {
                            if (__first1 == __l1)
                                return __last1;
                            if (__pred(*--__l1, *__l2))
                                break;
                        }
                    _BidirectionalIterator1 __m1 = __l1;
                    _BidirectionalIterator2 __m2 = __l2;
                    while (true)
                        {
                            if (__m2 == __first2)
                                return __m1;
                            if (__m1 == __first1)
                                return __last1;
                            if (!__pred(*--__m1, *--__m2)) {
                                break;
                            }
                        }
                }
        }
        template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2> _RandomAccessIterator1 __find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, std::__1::random_access_iterator_tag, std::__1::random_access_iterator_tag)         {
            typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
            if (__len2 == 0)
                return __last1;
            typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
            if (__len1 < __len2)
                return __last1;
            const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
            _RandomAccessIterator1 __l1 = __last1;
            _RandomAccessIterator2 __l2 = __last2;
            --__l2;
            while (true)
                {
                    while (true)
                        {
                            if (__s == __l1)
                                return __last1;
                            if (__pred(*--__l1, *__l2))
                                break;
                        }
                    _RandomAccessIterator1 __m1 = __l1;
                    _RandomAccessIterator2 __m2 = __l2;
                    while (true)
                        {
                            if (__m2 == __first2)
                                return __m1;
                            if (!__pred(*--__m1, *--__m2)) {
                                break;
                            }
                        }
                }
        }
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>(__first1, __last1, __first2, __last2, __pred, typename iterator_traits<_ForwardIterator1>::iterator_category(), typename iterator_traits<_ForwardIterator2>::iterator_category());
        }
        template <class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
            typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
            return std::__1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
        }
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> _ForwardIterator1 __find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)         {
            for (; __first1 != __last1; ++__first1)
                for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                    if (__pred(*__first1, *__j))
                        return __first1;
            return __last1;
        }
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _ForwardIterator1 find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
        }
        template <class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
            typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
            return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
        }
        template <class _ForwardIterator, class _BinaryPredicate> inline _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (__pred(*__first, *__i))
                            return __first;
                        __first = __i;
                    }
            }
            return __last;
        }
        template <class _ForwardIterator> inline _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_ForwardIterator>::value_type __v;
            return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
        }
        template <class _InputIterator, class _Tp> inline typename iterator_traits<_InputIterator>::difference_type count(_InputIterator __first, _InputIterator __last, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typename iterator_traits<_InputIterator>::difference_type __r(0);
            for (; __first != __last; ++__first)
                if (*__first == __value_)
                    ++__r;
            return __r;
        }
        template <class _InputIterator, class _Predicate> inline typename iterator_traits<_InputIterator>::difference_type count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typename iterator_traits<_InputIterator>::difference_type __r(0);
            for (; __first != __last; ++__first)
                if (__pred(*__first))
                    ++__r;
            return __r;
        }
        template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                if (!__pred(*__first1, *__first2))
                    break;
            return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
        }
        template <class _InputIterator1, class _InputIterator2> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_InputIterator1>::value_type __v1;
            typedef typename iterator_traits<_InputIterator2>::value_type __v2;
            return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
        }
        template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate> inline bool equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                if (!__pred(*__first1, *__first2))
                    return false;
            return true;
        }
        template<> inline bool equal<std::__1::__wrap_iter<const std::__1::basic_string<char> *>, std::__1::__wrap_iter<const std::__1::basic_string<char> *>, std::__1::__equal_to<std::__1::basic_string<char>, std::__1::basic_string<char> >>(std::__1::__wrap_iter<const std::__1::basic_string<char> *> __first1, std::__1::__wrap_iter<const std::__1::basic_string<char> *> __last1, std::__1::__wrap_iter<const std::__1::basic_string<char> *> __first2, std::__1::__equal_to<std::__1::basic_string<char>, std::__1::basic_string<char> > __pred) __attribute__((internal_linkage))         {
            for (; __first1 != __last1; ++ __first1 , (void)++ __first2)
                if (!__pred(* __first1, * __first2))
                    return false;
            return true;
        }
        template <class _InputIterator1, class _InputIterator2> inline bool equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_InputIterator1>::value_type __v1;
            typedef typename iterator_traits<_InputIterator2>::value_type __v2;
            return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
        }
        template<> inline bool equal<std::__1::__wrap_iter<const std::__1::basic_string<char> *>, std::__1::__wrap_iter<const std::__1::basic_string<char> *>>(std::__1::__wrap_iter<const std::__1::basic_string<char> *> __first1, std::__1::__wrap_iter<const std::__1::basic_string<char> *> __last1, std::__1::__wrap_iter<const std::__1::basic_string<char> *> __first2) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<__wrap_iter<const basic_string<char> *> >::value_type __v1;
            typedef typename iterator_traits<__wrap_iter<const basic_string<char> *> >::value_type __v2;
            return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
        }
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                if (!__pred(*__first1, *__first2))
                    break;
            if (__first1 == __last1)
                return true;
            typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
            _D1 __l1 = std::__1::distance(__first1, __last1);
            if (__l1 == _D1(1))
                return false;
            _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);
            for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i) {
                _ForwardIterator1 __match = __first1;
                for (; __match != __i; ++__match)
                    if (__pred(*__match, *__i))
                        break;
                if (__match == __i) {
                    _D1 __c2 = 0;
                    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                        if (__pred(*__i, *__j))
                            ++__c2;
                    if (__c2 == 0)
                        return false;
                    _D1 __c1 = 1;
                    for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
                        if (__pred(*__i, *__j))
                            ++__c1;
                    if (__c1 != __c2)
                        return false;
                }
            }
            return true;
        }
        template <class _ForwardIterator1, class _ForwardIterator2> inline bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
            typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
            return std::__1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
        }
        template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>(__first1, __last1, __first2, __last2, __pred, typename iterator_traits<_ForwardIterator1>::iterator_category(), typename iterator_traits<_ForwardIterator2>::iterator_category()).first;
        }
        template <class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
            typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
            return std::__1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
        }
        template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp> _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp &__value_, _BinaryPredicate __pred, std::__1::forward_iterator_tag)         {
            if (__count <= 0)
                return __first;
            while (true)
                {
                    while (true)
                        {
                            if (__first == __last)
                                return __last;
                            if (__pred(*__first, __value_))
                                break;
                            ++__first;
                        }
                    _ForwardIterator __m = __first;
                    _Size __c(0);
                    while (true)
                        {
                            if (++__c == __count)
                                return __first;
                            if (++__m == __last)
                                return __last;
                            if (!__pred(*__m, __value_)) {
                                __first = __m;
                                ++__first;
                                break;
                            }
                        }
                }
        }
        template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp> _RandomAccessIterator __search_n(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __count, const _Tp &__value_, _BinaryPredicate __pred, std::__1::random_access_iterator_tag)         {
            if (__count <= 0)
                return __first;
            _Size __len = static_cast<_Size>(__last - __first);
            if (__len < __count)
                return __last;
            const _RandomAccessIterator __s = __last - (__count - 1);
            while (true)
                {
                    while (true)
                        {
                            if (__first >= __s)
                                return __last;
                            if (__pred(*__first, __value_))
                                break;
                            ++__first;
                        }
                    _RandomAccessIterator __m = __first;
                    _Size __c(0);
                    while (true)
                        {
                            if (++__c == __count)
                                return __first;
                            ++__m;
                            if (!__pred(*__m, __value_)) {
                                __first = __m;
                                ++__first;
                                break;
                            }
                        }
                }
        }
        template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate> inline _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp &__value_, _BinaryPredicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>(__first, __last, __convert_to_integral(__count), __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
        }
        template <class _ForwardIterator, class _Size, class _Tp> inline _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_ForwardIterator>::value_type __v;
            return std::__1::search_n(__first, __last, __convert_to_integral(__count), __value_, __equal_to<__v, _Tp>());
        }
        template <class _Iter> inline _Iter __unwrap_iter(_Iter __i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __i;
        }
        template<> inline const char *__unwrap_iter<const char *>(const char *__i) __attribute__((internal_linkage))         {
            return __i;
        }
        template<> inline char *__unwrap_iter<char *>(char *__i) __attribute__((internal_linkage))         {
            return __i;
        }
        template<> inline const wchar_t *__unwrap_iter<const wchar_t *>(const wchar_t *__i) __attribute__((internal_linkage))         {
            return __i;
        }
        template<> inline wchar_t *__unwrap_iter<wchar_t *>(wchar_t *__i) __attribute__((internal_linkage))         {
            return __i;
        }
        template <class _Tp> inline typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(move_iterator<_Tp *> __i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __i.base();
        }
        template <class _Tp> inline typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type __unwrap_iter(__wrap_iter<_Tp *> __i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __i.base();
        }
        template <class _Tp> inline typename enable_if<is_trivially_copy_assignable<_Tp>::value, const _Tp *>::type __unwrap_iter(__wrap_iter<const _Tp *> __i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __i.base();
        }
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator __copy_constexpr(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first , (void)++__result)
                *__result = *__first;
            return __result;
        }
        template<> inline char *__copy_constexpr<const char *, char *>(const char *__first, const char *__last, char *__result) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first , (void)++__result)
                *__result = *__first;
            return __result;
        }
        template<> inline wchar_t *__copy_constexpr<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first , (void)++__result)
                *__result = *__first;
            return __result;
        }
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator __copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __copy_constexpr(__first, __last, __result);
        }
        template<> inline char *__copy<const char *, char *>(const char *__first, const char *__last, char *__result) __attribute__((internal_linkage))        template<> inline wchar_t *__copy<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result) __attribute__((internal_linkage))        template <class _Tp, class _Up> inline typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value && is_trivially_copy_assignable<_Up>::value, _Up *>::type __copy(_Tp *__first, _Tp *__last, _Up *__result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0)
                std::__1::memmove(__result, __first, __n * sizeof(_Up));
            return __result + __n;
        }
        template<> inline typename enable_if<is_same<typename remove_const<const char>::type, char>::value && is_trivially_copy_assignable<char>::value, char *>::type __copy<const char, char>(const char *__first, const char *__last, char *__result) __attribute__((internal_linkage))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0)
                std::__1::memmove(__result, __first, __n * sizeof(char));
            return __result + __n;
        }
        template<> inline typename enable_if<is_same<typename remove_const<const wchar_t>::type, wchar_t>::value && is_trivially_copy_assignable<wchar_t>::value, wchar_t *>::type __copy<const wchar_t, wchar_t>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result) __attribute__((internal_linkage))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0)
                std::__1::memmove(__result, __first, __n * sizeof(wchar_t));
            return __result + __n;
        }
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__libcpp_is_constant_evaluated()) {
                return std::__1::__copy_constexpr(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            } else {
                return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            }
        }
        template<> inline char *copy<const char *, char *>(const char *__first, const char *__last, char *__result) __attribute__((internal_linkage))         {
            if (__libcpp_is_constant_evaluated()) {
                return std::__1::__copy_constexpr(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            } else {
                return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            }
        }
        template<> inline wchar_t *copy<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result) __attribute__((internal_linkage))         {
            if (__libcpp_is_constant_evaluated()) {
                return std::__1::__copy_constexpr(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            } else {
                return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            }
        }
        template <class _BidirectionalIterator, class _OutputIterator> inline _OutputIterator __copy_backward_constexpr(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }
        template<> inline char *__copy_backward_constexpr<const char *, char *>(const char *__first, const char *__last, char *__result) __attribute__((internal_linkage))         {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }
        template<> inline wchar_t *__copy_backward_constexpr<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result) __attribute__((internal_linkage))         {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }
        template <class _BidirectionalIterator, class _OutputIterator> inline _OutputIterator __copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __copy_backward_constexpr(__first, __last, __result);
        }
        template<> inline char *__copy_backward<const char *, char *>(const char *__first, const char *__last, char *__result) __attribute__((internal_linkage))        template<> inline wchar_t *__copy_backward<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result) __attribute__((internal_linkage))        template <class _Tp, class _Up> inline typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value && is_trivially_copy_assignable<_Up>::value, _Up *>::type __copy_backward(_Tp *__first, _Tp *__last, _Up *__result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0) {
                __result -= __n;
                std::__1::memmove(__result, __first, __n * sizeof(_Up));
            }
            return __result;
        }
        template<> inline typename enable_if<is_same<typename remove_const<const char>::type, char>::value && is_trivially_copy_assignable<char>::value, char *>::type __copy_backward<const char, char>(const char *__first, const char *__last, char *__result) __attribute__((internal_linkage))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0) {
                __result -= __n;
                std::__1::memmove(__result, __first, __n * sizeof(char));
            }
            return __result;
        }
        template<> inline typename enable_if<is_same<typename remove_const<const wchar_t>::type, wchar_t>::value && is_trivially_copy_assignable<wchar_t>::value, wchar_t *>::type __copy_backward<const wchar_t, wchar_t>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result) __attribute__((internal_linkage))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0) {
                __result -= __n;
                std::__1::memmove(__result, __first, __n * sizeof(wchar_t));
            }
            return __result;
        }
        template <class _BidirectionalIterator1, class _BidirectionalIterator2> inline _BidirectionalIterator2 copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, _BidirectionalIterator2 __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__libcpp_is_constant_evaluated()) {
                return std::__1::__copy_backward_constexpr(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            } else {
                return std::__1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            }
        }
        template<> inline char *copy_backward<const char *, char *>(const char *__first, const char *__last, char *__result) __attribute__((internal_linkage))         {
            if (__libcpp_is_constant_evaluated()) {
                return std::__1::__copy_backward_constexpr(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            } else {
                return std::__1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            }
        }
        template<> inline wchar_t *copy_backward<const wchar_t *, wchar_t *>(const wchar_t *__first, const wchar_t *__last, wchar_t *__result) __attribute__((internal_linkage))         {
            if (__libcpp_is_constant_evaluated()) {
                return std::__1::__copy_backward_constexpr(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            } else {
                return std::__1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
            }
        }
        template <class _InputIterator, class _OutputIterator, class _Predicate> inline _OutputIterator copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first) {
                if (__pred(*__first)) {
                    *__result = *__first;
                    ++__result;
                }
            }
            return __result;
        }
        template <class _InputIterator, class _Size, class _OutputIterator> inline typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_random_access_iterator<_InputIterator>::value, _OutputIterator>::type copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
            _IntegralSize __n = __orig_n;
            if (__n > 0) {
                *__result = *__first;
                ++__result;
                for (--__n; __n > 0; --__n) {
                    ++__first;
                    *__result = *__first;
                    ++__result;
                }
            }
            return __result;
        }
        template <class _InputIterator, class _Size, class _OutputIterator> inline typename enable_if<__is_cpp17_random_access_iterator<_InputIterator>::value, _OutputIterator>::type copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
            _IntegralSize __n = __orig_n;
            return std::__1::copy(__first, __first + __n, __result);
        }
        template<> inline typename enable_if<__is_cpp17_random_access_iterator<const char *>::value, char *>::type copy_n<const char *, unsigned long, char *>(const char *__first, unsigned long __orig_n, char *__result) __attribute__((internal_linkage))         {
            typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
            _IntegralSize __n = __orig_n;
            return std::__1::copy(__first, __first + __n, __result);
        }
        template<> inline typename enable_if<__is_cpp17_random_access_iterator<const wchar_t *>::value, wchar_t *>::type copy_n<const wchar_t *, unsigned long, wchar_t *>(const wchar_t *__first, unsigned long __orig_n, wchar_t *__result) __attribute__((internal_linkage))         {
            typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
            _IntegralSize __n = __orig_n;
            return std::__1::copy(__first, __first + __n, __result);
        }
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator __move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first , (void)++__result)
                *__result = std::__1::move(*__first);
            return __result;
        }
        template <class _Tp, class _Up> inline typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value && is_trivially_copy_assignable<_Up>::value, _Up *>::type __move(_Tp *__first, _Tp *__last, _Up *__result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0)
                std::__1::memmove(__result, __first, __n * sizeof(_Up));
            return __result + __n;
        }
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
        }
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator __move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            while (__first != __last)
                *--__result = std::__1::move(*--__last);
            return __result;
        }
        template <class _Tp, class _Up> inline typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value && is_trivially_copy_assignable<_Up>::value, _Up *>::type __move_backward(_Tp *__first, _Tp *__last, _Up *__result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            const size_t __n = static_cast<size_t>(__last - __first);
            if (__n > 0) {
                __result -= __n;
                std::__1::memmove(__result, __first, __n * sizeof(_Up));
            }
            return __result;
        }
        template <class _BidirectionalIterator1, class _BidirectionalIterator2> inline _BidirectionalIterator2 move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, _BidirectionalIterator2 __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
        }
        template <class _InputIterator, class _OutputIterator, class _UnaryOperation> inline _OutputIterator transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first , (void)++__result)
                *__result = __op(*__first);
            return __result;
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation> inline _OutputIterator transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2 , ++__result)
                *__result = __binary_op(*__first1, *__first2);
            return __result;
        }
        template <class _ForwardIterator, class _Tp> inline void replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__old_value, const _Tp &__new_value) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                if (*__first == __old_value)
                    *__first = __new_value;
        }
        template <class _ForwardIterator, class _Predicate, class _Tp> inline void replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &__new_value) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                if (__pred(*__first))
                    *__first = __new_value;
        }
        template <class _InputIterator, class _OutputIterator, class _Tp> inline _OutputIterator replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__old_value, const _Tp &__new_value) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first , (void)++__result)
                if (*__first == __old_value)
                    *__result = __new_value;
                else
                    *__result = *__first;
            return __result;
        }
        template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp> inline _OutputIterator replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &__new_value) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first , (void)++__result)
                if (__pred(*__first))
                    *__result = __new_value;
                else
                    *__result = *__first;
            return __result;
        }
        template <class _OutputIterator, class _Size, class _Tp> inline _OutputIterator __fill_n(_OutputIterator __first, _Size __n, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __n > 0; ++__first , (void)--__n)
                *__first = __value_;
            return __first;
        }
        template<> inline char *__fill_n<char *, unsigned long, char>(char *__first, unsigned long __n, const char &__value_) __attribute__((internal_linkage))         {
            for (; __n > 0; ++__first , (void)--__n)
                *__first = __value_;
            return __first;
        }
        template<> inline wchar_t *__fill_n<wchar_t *, unsigned long, wchar_t>(wchar_t *__first, unsigned long __n, const wchar_t &__value_) __attribute__((internal_linkage))         {
            for (; __n > 0; ++__first , (void)--__n)
                *__first = __value_;
            return __first;
        }
        template <class _OutputIterator, class _Size, class _Tp> inline _OutputIterator fill_n(_OutputIterator __first, _Size __n, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__fill_n(__first, __convert_to_integral(__n), __value_);
        }
        template<> inline char *fill_n<char *, unsigned long, char>(char *__first, unsigned long __n, const char &__value_) __attribute__((internal_linkage))         {
            return std::__1::__fill_n(__first, __convert_to_integral(__n), __value_);
        }
        template<> inline wchar_t *fill_n<wchar_t *, unsigned long, wchar_t>(wchar_t *__first, unsigned long __n, const wchar_t &__value_) __attribute__((internal_linkage))         {
            return std::__1::__fill_n(__first, __convert_to_integral(__n), __value_);
        }
        template <class _ForwardIterator, class _Tp> inline void __fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, std::__1::forward_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                *__first = __value_;
        }
        template <class _RandomAccessIterator, class _Tp> inline void __fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__value_, std::__1::random_access_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::fill_n(__first, __last - __first, __value_);
        }
        template <class _ForwardIterator, class _Tp> inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
        }
        template <class _ForwardIterator, class _Generator> inline void generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first)
                *__first = __gen();
        }
        template <class _OutputIterator, class _Size, class _Generator> inline _OutputIterator generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
            _IntegralSize __n = __orig_n;
            for (; __n > 0; ++__first , (void)--__n)
                *__first = __gen();
            return __first;
        }
        template <class _ForwardIterator, class _Tp> _ForwardIterator remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_)         {
            __first = std::__1::find(__first, __last, __value_);
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (!(*__i == __value_)) {
                            *__first = std::__1::move(*__i);
                            ++__first;
                        }
                    }
            }
            return __first;
        }
        template <class _ForwardIterator, class _Predicate> _ForwardIterator remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)         {
            __first = std::__1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred);
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (!__pred(*__i)) {
                            *__first = std::__1::move(*__i);
                            ++__first;
                        }
                    }
            }
            return __first;
        }
        template <class _InputIterator, class _OutputIterator, class _Tp> inline _OutputIterator remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first) {
                if (!(*__first == __value_)) {
                    *__result = *__first;
                    ++__result;
                }
            }
            return __result;
        }
        template <class _InputIterator, class _OutputIterator, class _Predicate> inline _OutputIterator remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__first) {
                if (!__pred(*__first)) {
                    *__result = *__first;
                    ++__result;
                }
            }
            return __result;
        }
        template <class _ForwardIterator, class _BinaryPredicate> _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)         {
            __first = std::__1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>(__first, __last, __pred);
            if (__first != __last) {
                _ForwardIterator __i = __first;
                for (++__i; ++__i != __last;)
                    if (!__pred(*__first, *__i))
                        *++__first = std::__1::move(*__i);
                ++__first;
            }
            return __first;
        }
        template <class _ForwardIterator> inline _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_ForwardIterator>::value_type __v;
            return std::__1::unique(__first, __last, __equal_to<__v>());
        }
        template <class _BinaryPredicate, class _InputIterator, class _OutputIterator> _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred, std::__1::input_iterator_tag, std::__1::output_iterator_tag)         {
            if (__first != __last) {
                typename iterator_traits<_InputIterator>::value_type __t(*__first);
                *__result = __t;
                ++__result;
                while (++__first != __last)
                    {
                        if (!__pred(__t, *__first)) {
                            __t = *__first;
                            *__result = __t;
                            ++__result;
                        }
                    }
            }
            return __result;
        }
        template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator> _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred, std::__1::forward_iterator_tag, std::__1::output_iterator_tag)         {
            if (__first != __last) {
                _ForwardIterator __i = __first;
                *__result = *__i;
                ++__result;
                while (++__first != __last)
                    {
                        if (!__pred(*__i, *__first)) {
                            *__result = *__first;
                            ++__result;
                            __i = __first;
                        }
                    }
            }
            return __result;
        }
        template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator> _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred, std::__1::input_iterator_tag, std::__1::forward_iterator_tag)         {
            if (__first != __last) {
                *__result = *__first;
                while (++__first != __last)
                    if (!__pred(*__result, *__first))
                        *++__result = *__first;
                ++__result;
            }
            return __result;
        }
        template <class _InputIterator, class _OutputIterator, class _BinaryPredicate> inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>(__first, __last, __result, __pred, typename iterator_traits<_InputIterator>::iterator_category(), typename iterator_traits<_OutputIterator>::iterator_category());
        }
        template <class _InputIterator, class _OutputIterator> inline _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_InputIterator>::value_type __v;
            return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
        }
        template <class _BidirectionalIterator> inline void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, std::__1::bidirectional_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            while (__first != __last)
                {
                    if (__first == --__last)
                        break;
                    std::__1::iter_swap(__first, __last);
                    ++__first;
                }
        }
        template <class _RandomAccessIterator> inline void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, std::__1::random_access_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__first != __last)
                for (; __first < --__last; ++__first)
                    std::__1::iter_swap(__first, __last);
        }
        template <class _BidirectionalIterator> inline void reverse(_BidirectionalIterator __first, _BidirectionalIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
        }
        template<> inline void reverse<char *>(char *__first, char *__last) __attribute__((internal_linkage))        template <class _BidirectionalIterator, class _OutputIterator> inline _OutputIterator reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            for (; __first != __last; ++__result)
                *__result = *--__last;
            return __result;
        }
        template <class _ForwardIterator> _ForwardIterator __rotate_left(_ForwardIterator __first, _ForwardIterator __last)         {
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            value_type __tmp = std::__1::move(*__first);
            _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
            *__lm1 = std::__1::move(__tmp);
            return __lm1;
        }
        template <class _BidirectionalIterator> _BidirectionalIterator __rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)         {
            typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
            _BidirectionalIterator __lm1 = std::__1::prev(__last);
            value_type __tmp = std::__1::move(*__lm1);
            _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
            *__first = std::__1::move(__tmp);
            return __fp1;
        }
        template <class _ForwardIterator> _ForwardIterator __rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)         {
            _ForwardIterator __i = __middle;
            while (true)
                {
                    swap(*__first, *__i);
                    ++__first;
                    if (++__i == __last)
                        break;
                    if (__first == __middle)
                        __middle = __i;
                }
            _ForwardIterator __r = __first;
            if (__first != __middle) {
                __i = __middle;
                while (true)
                    {
                        swap(*__first, *__i);
                        ++__first;
                        if (++__i == __last) {
                            if (__first == __middle)
                                break;
                            __i = __middle;
                        } else if (__first == __middle)
                            __middle = __i;
                    }
            }
            return __r;
        }
        template <typename _Integral> inline _Integral __algo_gcd(_Integral __x, _Integral __y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            do {
                _Integral __t = __x % __y;
                __x = __y;
                __y = __t;
            } while (__y);
            return __x;
        }
        template <typename _RandomAccessIterator> _RandomAccessIterator __rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            const difference_type __m1 = __middle - __first;
            const difference_type __m2 = __last - __middle;
            if (__m1 == __m2) {
                std::__1::swap_ranges(__first, __middle, __middle);
                return __middle;
            }
            const difference_type __g = std::__1::__algo_gcd(__m1, __m2);
            for (_RandomAccessIterator __p = __first + __g; __p != __first;) {
                value_type __t(std::__1::move(*--__p));
                _RandomAccessIterator __p1 = __p;
                _RandomAccessIterator __p2 = __p1 + __m1;
                do {
                    *__p1 = std::__1::move(*__p2);
                    __p1 = __p2;
                    const difference_type __d = __last - __p2;
                    if (__m1 < __d)
                        __p2 += __m1;
                    else
                        __p2 = __first + (__m1 - __d);
                } while (__p2 != __p);
                *__p1 = std::__1::move(__t);
            }
            return __first + __m2;
        }
        template <class _ForwardIterator> inline _ForwardIterator __rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, std::__1::forward_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
            if (std::__1::is_trivially_move_assignable<value_type>::value) {
                if (std::__1::next(__first) == __middle)
                    return std::__1::__rotate_left(__first, __last);
            }
            return std::__1::__rotate_forward(__first, __middle, __last);
        }
        template <class _BidirectionalIterator> inline _BidirectionalIterator __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, std::__1::bidirectional_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type value_type;
            if (std::__1::is_trivially_move_assignable<value_type>::value) {
                if (std::__1::next(__first) == __middle)
                    return std::__1::__rotate_left(__first, __last);
                if (std::__1::next(__middle) == __last)
                    return std::__1::__rotate_right(__first, __last);
            }
            return std::__1::__rotate_forward(__first, __middle, __last);
        }
        template <class _RandomAccessIterator> inline _RandomAccessIterator __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, std::__1::random_access_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type value_type;
            if (std::__1::is_trivially_move_assignable<value_type>::value) {
                if (std::__1::next(__first) == __middle)
                    return std::__1::__rotate_left(__first, __last);
                if (std::__1::next(__middle) == __last)
                    return std::__1::__rotate_right(__first, __last);
                return std::__1::__rotate_gcd(__first, __middle, __last);
            }
            return std::__1::__rotate_forward(__first, __middle, __last);
        }
        template <class _ForwardIterator> inline _ForwardIterator rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__first == __middle)
                return __last;
            if (__middle == __last)
                return __first;
            return std::__1::__rotate(__first, __middle, __last, typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
        }
        template <class _ForwardIterator, class _OutputIterator> inline _OutputIterator rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::copy(__first, __middle, std::__1::copy(__middle, __last, __result));
        }
        template <class _ForwardIterator, class _Compare> inline _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value, "std::min_element requires a ForwardIterator");
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    if (__comp(*__i, *__first))
                        __first = __i;
            }
            return __first;
        }
        template <class _ForwardIterator> inline _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::min_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }
        template <class _Tp, class _Compare> inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __comp(__b, __a) ? __b : __a;
        }
        template<> inline const unsigned long &min<unsigned long, std::__1::__less<unsigned long, unsigned long>>(const unsigned long &__a, const unsigned long &__b, std::__1::__less<unsigned long, unsigned long> __comp) __attribute__((internal_linkage))         {
            return __comp(__b, __a) ? __b : __a;
        }
        template <class _Tp> inline const _Tp &min(const _Tp &__a, const _Tp &__b) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::min(__a, __b, __less<_Tp>());
        }
        template<> inline const unsigned long &min<unsigned long>(const unsigned long &__a, const unsigned long &__b) __attribute__((internal_linkage))         {
            return std::__1::min(__a, __b, __less<unsigned long>());
        }
        template<> inline const long &min<long>(const long &__a, const long &__b) __attribute__((internal_linkage))        template <class _ForwardIterator, class _Compare> inline _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value, "std::max_element requires a ForwardIterator");
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    if (__comp(*__first, *__i))
                        __first = __i;
            }
            return __first;
        }
        template <class _ForwardIterator> inline _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::max_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }
        template <class _Tp, class _Compare> inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __comp(__a, __b) ? __b : __a;
        }
        template<> inline const unsigned long &max<unsigned long, std::__1::__less<unsigned long, unsigned long>>(const unsigned long &__a, const unsigned long &__b, std::__1::__less<unsigned long, unsigned long> __comp) __attribute__((internal_linkage))         {
            return __comp(__a, __b) ? __b : __a;
        }
        template <class _Tp> inline const _Tp &max(const _Tp &__a, const _Tp &__b) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::max(__a, __b, __less<_Tp>());
        }
        template<> inline const long &max<long>(const long &__a, const long &__b) __attribute__((internal_linkage))        template<> inline const unsigned long &max<unsigned long>(const unsigned long &__a, const unsigned long &__b) __attribute__((internal_linkage))         {
            return std::__1::max(__a, __b, __less<unsigned long>());
        }
        template <class _ForwardIterator, class _Compare> std::pair<_ForwardIterator, _ForwardIterator> minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)         {
            static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value, "std::minmax_element requires a ForwardIterator");
            std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
            if (__first != __last) {
                if (++__first != __last) {
                    if (__comp(*__first, *__result.first))
                        __result.first = __first;
                    else
                        __result.second = __first;
                    while (++__first != __last)
                        {
                            _ForwardIterator __i = __first;
                            if (++__first == __last) {
                                if (__comp(*__i, *__result.first))
                                    __result.first = __i;
                                else if (!__comp(*__i, *__result.second))
                                    __result.second = __i;
                                break;
                            } else {
                                if (__comp(*__first, *__i)) {
                                    if (__comp(*__first, *__result.first))
                                        __result.first = __first;
                                    if (!__comp(*__i, *__result.second))
                                        __result.second = __i;
                                } else {
                                    if (__comp(*__i, *__result.first))
                                        __result.first = __i;
                                    if (!__comp(*__first, *__result.second))
                                        __result.second = __first;
                                }
                            }
                        }
                }
            }
            return __result;
        }
        template <class _ForwardIterator> inline std::pair<_ForwardIterator, _ForwardIterator> minmax_element(_ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::minmax_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }
        template <class _Tp, class _Compare> inline pair<const _Tp &, const _Tp &> minmax(const _Tp &__a, const _Tp &__b, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __comp(__b, __a) ? pair<const _Tp &, const _Tp &>(__b, __a) : pair<const _Tp &, const _Tp &>(__a, __b);
        }
        template <class _Tp> inline pair<const _Tp &, const _Tp &> minmax(const _Tp &__a, const _Tp &__b) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::minmax(__a, __b, __less<_Tp>());
        }
        template <unsigned long long _Xp, size_t _Rp> struct __log2_imp {
            static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp : __log2_imp<_Xp, _Rp - 1>::value;
        };
        template <unsigned long long _Xp> struct __log2_imp<_Xp, 0> {
            static const size_t value = 0;
        };
        template <size_t _Rp> struct __log2_imp<0, _Rp> {
            static const size_t value = _Rp + 1;
        };
        template <class _UIntType, _UIntType _Xp> struct __log2 {
            static const size_t value = __log2_imp<_Xp, sizeof(_UIntType) * 8 - 1>::value;
        };
        template <class _Engine, class _UIntType> class __independent_bits_engine {
        public:
            typedef _UIntType result_type;
        private:
            typedef typename _Engine::result_type _Engine_result_type;
            typedef typename conditional<sizeof(_Engine_result_type) <= sizeof(result_type), result_type, _Engine_result_type>::type _Working_result_type;
            _Engine &__e_;
            size_t __w_;
            size_t __w0_;
            size_t __n_;
            size_t __n0_;
            std::__1::__independent_bits_engine::_Working_result_type __y0_;
            std::__1::__independent_bits_engine::_Working_result_type __y1_;
            std::__1::__independent_bits_engine::_Engine_result_type __mask0_;
            std::__1::__independent_bits_engine::_Engine_result_type __mask1_;
            static const std::__1::__independent_bits_engine::_Working_result_type _Rp = _Engine::_Max - _Engine::_Min + std::__1::__independent_bits_engine::_Working_result_type(1);
            static const size_t __m = __log2<_Working_result_type, _Rp>::value;
            static const size_t _WDt = numeric_limits<_Working_result_type>::digits;
            static const size_t _EDt = numeric_limits<_Engine_result_type>::digits;
        public:
            __independent_bits_engine<_Engine, _UIntType>(_Engine &__e, size_t __w);
            std::__1::__independent_bits_engine::result_type operator()()             {
                return __eval(integral_constant<bool, _Rp != 0>());
            }
        private:
            std::__1::__independent_bits_engine::result_type __eval(std::__1::false_type);
            std::__1::__independent_bits_engine::result_type __eval(std::__1::true_type);
        };
        template <class _Engine, class _UIntType> __independent_bits_engine<_Engine, _UIntType>::__independent_bits_engine<_Engine, _UIntType>(_Engine &__e, size_t __w) : __e_(__e), __w_(__w)         {
            this->__n_ = this->__w_ / __m + (this->__w_ % __m != 0);
            this->__w0_ = this->__w_ / this->__n_;
            if (_Rp == 0)
                this->__y0_ = _Rp;
            else if (this->__w0_ < _WDt)
                this->__y0_ = (_Rp >> this->__w0_) << this->__w0_;
            else
                this->__y0_ = 0;
            if (_Rp - this->__y0_ > this->__y0_ / this->__n_) {
                ++this->__n_;
                this->__w0_ = this->__w_ / this->__n_;
                if (this->__w0_ < _WDt)
                    this->__y0_ = (_Rp >> this->__w0_) << this->__w0_;
                else
                    this->__y0_ = 0;
            }
            this->__n0_ = this->__n_ - this->__w_ % this->__n_;
            if (this->__w0_ < _WDt - 1)
                this->__y1_ = (_Rp >> (this->__w0_ + 1)) << (this->__w0_ + 1);
            else
                this->__y1_ = 0;
            this->__mask0_ = this->__w0_ > 0 ? std::__1::__independent_bits_engine::_Engine_result_type(~0) >> (_EDt - this->__w0_) : std::__1::__independent_bits_engine::_Engine_result_type(0);
            this->__mask1_ = this->__w0_ < _EDt - 1 ? std::__1::__independent_bits_engine::_Engine_result_type(~0) >> (_EDt - (this->__w0_ + 1)) : std::__1::__independent_bits_engine::_Engine_result_type(~0);
        }
        template <class _Engine, class _UIntType> inline _UIntType __independent_bits_engine<_Engine, _UIntType>::__eval(std::__1::false_type)         {
            return static_cast<std::__1::__independent_bits_engine::result_type>(this->__e_() & this->__mask0_);
        }
        template <class _Engine, class _UIntType> _UIntType __independent_bits_engine<_Engine, _UIntType>::__eval(std::__1::true_type)         {
            const size_t _WRt = numeric_limits<result_type>::digits;
            std::__1::__independent_bits_engine::result_type _Sp = 0;
            for (size_t __k = 0; __k < this->__n0_; ++__k) {
                std::__1::__independent_bits_engine::_Engine_result_type __u;
                do {
                    __u = this->__e_() - _Engine::min();
                } while (__u >= this->__y0_);
                if (this->__w0_ < _WRt)
                    _Sp <<= this->__w0_;
                else
                    _Sp = 0;
                _Sp += __u & this->__mask0_;
            }
            for (size_t __k = this->__n0_; __k < this->__n_; ++__k) {
                std::__1::__independent_bits_engine::_Engine_result_type __u;
                do {
                    __u = this->__e_() - _Engine::min();
                } while (__u >= this->__y1_);
                if (this->__w0_ < _WRt - 1)
                    _Sp <<= this->__w0_ + 1;
                else
                    _Sp = 0;
                _Sp += __u & this->__mask1_;
            }
            return _Sp;
        }
        template <class _IntType = int> class uniform_int_distribution {
        public:
            typedef _IntType result_type;
            class param_type {
                std::__1::uniform_int_distribution::result_type __a_;
                std::__1::uniform_int_distribution::result_type __b_;
            public:
                typedef uniform_int_distribution<_IntType> distribution_type;
                explicit param_type(std::__1::uniform_int_distribution::result_type __a = 0, std::__1::uniform_int_distribution::result_type __b = numeric_limits<result_type>::max()) : __a_(__a), __b_(__b)                 {
                }
                std::__1::uniform_int_distribution::result_type a() const                 {
                    return this->__a_;
                }
                std::__1::uniform_int_distribution::result_type b() const                 {
                    return this->__b_;
                }
                friend bool operator==(const std::__1::uniform_int_distribution::param_type &__x, const std::__1::uniform_int_distribution::param_type &__y)                 {
                    return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;
                }
;
                friend bool operator!=(const std::__1::uniform_int_distribution::param_type &__x, const std::__1::uniform_int_distribution::param_type &__y)                 {
                    return !(__x == __y);
                }
;
            };
        private:
            std::__1::uniform_int_distribution::param_type __p_;
        public:
            explicit uniform_int_distribution<_IntType>(std::__1::uniform_int_distribution::result_type __a = 0, std::__1::uniform_int_distribution::result_type __b = numeric_limits<result_type>::max()) : __p_(std::__1::uniform_int_distribution::param_type(__a, __b))             {
            }
            explicit uniform_int_distribution<_IntType>(const std::__1::uniform_int_distribution::param_type &__p) : __p_(__p)             {
            }
            void reset()             {
            }
            template <class _URNG> std::__1::uniform_int_distribution::result_type operator()(_URNG &__g)             {
                return (*this)(__g, this->__p_);
            }
            template <class _URNG> std::__1::uniform_int_distribution::result_type operator()(_URNG &__g, const std::__1::uniform_int_distribution::param_type &__p);
            std::__1::uniform_int_distribution::result_type a() const             {
                return this->__p_.a();
            }
            std::__1::uniform_int_distribution::result_type b() const             {
                return this->__p_.b();
            }
            std::__1::uniform_int_distribution::param_type param() const             {
                return this->__p_;
            }
            void param(const std::__1::uniform_int_distribution::param_type &__p)             {
                this->__p_ = __p;
            }
            std::__1::uniform_int_distribution::result_type min() const             {
                return this->a();
            }
            std::__1::uniform_int_distribution::result_type max() const             {
                return this->b();
            }
            friend bool operator==(const uniform_int_distribution<_IntType> &__x, const uniform_int_distribution<_IntType> &__y)             {
                return __x.__p_ == __y.__p_;
            }
;
            friend bool operator!=(const uniform_int_distribution<_IntType> &__x, const uniform_int_distribution<_IntType> &__y)             {
                return !(__x == __y);
            }
;
        };
template<> class uniform_int_distribution<long> {
        public:
            typedef long result_type;
            class param_type {
                std::__1::uniform_int_distribution<long>::result_type __a_;
                std::__1::uniform_int_distribution<long>::result_type __b_;
            public:
                typedef std::__1::uniform_int_distribution<long> distribution_type;
                friend bool operator==(const std::__1::uniform_int_distribution<long>::param_type &__x, const std::__1::uniform_int_distribution<long>::param_type &__y);
                friend bool operator!=(const std::__1::uniform_int_distribution<long>::param_type &__x, const std::__1::uniform_int_distribution<long>::param_type &__y);
            };
        private:
            std::__1::uniform_int_distribution<long>::param_type __p_;
        public:
            explicit uniform_int_distribution(std::__1::uniform_int_distribution<long>::result_type __a = 0, std::__1::uniform_int_distribution<long>::result_type __b = numeric_limits<result_type>::max());
            explicit uniform_int_distribution(const std::__1::uniform_int_distribution<long>::param_type &__p);
            void reset();
            template <class _URNG> std::__1::uniform_int_distribution<long>::result_type operator()(_URNG &__g);
            template <class _URNG> std::__1::uniform_int_distribution<long>::result_type operator()(_URNG &__g, const std::__1::uniform_int_distribution<long>::param_type &__p) __attribute__((no_sanitize("unsigned-integer-overflow")));
            template<> std::__1::uniform_int_distribution<long>::result_type operator()<std::__1::__rs_default>(std::__1::__rs_default &__g, const std::__1::uniform_int_distribution<long>::param_type &__p) __attribute__((no_sanitize("unsigned-integer-overflow")));
            std::__1::uniform_int_distribution<long>::result_type a() const;
            std::__1::uniform_int_distribution<long>::result_type b() const;
            std::__1::uniform_int_distribution<long>::param_type param() const;
            void param(const std::__1::uniform_int_distribution<long>::param_type &__p);
            std::__1::uniform_int_distribution<long>::result_type min() const;
            std::__1::uniform_int_distribution<long>::result_type max() const;
            friend bool operator==(const std::__1::uniform_int_distribution<long> &__x, const std::__1::uniform_int_distribution<long> &__y);
            friend bool operator!=(const std::__1::uniform_int_distribution<long> &__x, const std::__1::uniform_int_distribution<long> &__y);
        };
        template <class _IntType> template <class _URNG> typename uniform_int_distribution<_IntType>::result_type uniform_int_distribution<_IntType>::operator()(_URNG &__g, const std::__1::uniform_int_distribution::param_type &__p) __attribute__((no_sanitize("unsigned-integer-overflow")))         {
            typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t), uint32_t, uint64_t>::type _UIntType;
            const _UIntType _Rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);
            if (_Rp == 1)
                return __p.a();
            const size_t _Dt = numeric_limits<_UIntType>::digits;
            typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
            if (_Rp == 0)
                return static_cast<std::__1::uniform_int_distribution::result_type>(_Eng(__g, _Dt)());
            size_t __w = _Dt - __libcpp_clz(_Rp) - 1;
            if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
                ++__w;
            _Eng __e(__g, __w);
            _UIntType __u;
            do {
                __u = __e();
            } while (__u >= _Rp);
            return static_cast<std::__1::uniform_int_distribution::result_type>(__u + __p.a());
        }
        class __attribute__((visibility("default"))) __rs_default;
        std::__1::__rs_default __rs_get() __attribute__((visibility("default")));
        class __attribute__((visibility("default"))) __rs_default {
            static unsigned int __c_;
            __rs_default();
        public:
            typedef uint_fast32_t result_type;
            static const std::__1::__rs_default::result_type _Min = 0;
            static const std::__1::__rs_default::result_type _Max = 4294967295U;
            __rs_default(const std::__1::__rs_default &);
            ~__rs_default();
            std::__1::__rs_default::result_type operator()();
            static std::__1::__rs_default::result_type min()             {
                return _Min;
            }
            static std::__1::__rs_default::result_type max()             {
                return _Max;
            }
            friend std::__1::__rs_default __rs_get() __attribute__((visibility("default")));
        };
        std::__1::__rs_default __rs_get() __attribute__((visibility("default")));
        template <class _RandomAccessIterator> void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef uniform_int_distribution<ptrdiff_t> _Dp;
            typedef typename _Dp::param_type _Pp;
            difference_type __d = __last - __first;
            if (__d > 1) {
                _Dp __uid;
                std::__1::__rs_default __g = __rs_get();
                for (--__last , (void)--__d; __first < __last; ++__first , (void)--__d) {
                    difference_type __i = __uid(__g, _Pp(0, __d));
                    if (__i != difference_type(0))
                        swap(*__first, *(__first + __i));
                }
            }
        }
        template <class _RandomAccessIterator, class _RandomNumberGenerator> void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &__rand)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            difference_type __d = __last - __first;
            if (__d > 1) {
                for (--__last; __first < __last; ++__first , (void)--__d) {
                    difference_type __i = __rand(__d);
                    if (__i != difference_type(0))
                        swap(*__first, *(__first + __i));
                }
            }
        }
        template <class _PopulationIterator, class _SampleIterator, class _Distance, class _UniformRandomNumberGenerator> _SampleIterator __sample(_PopulationIterator __first, _PopulationIterator __last, _SampleIterator __output_iter, _Distance __n, _UniformRandomNumberGenerator &__g, std::__1::input_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            _Distance __k = 0;
            for (; __first != __last && __k < __n; ++__first , (void)++__k)
                __output_iter[__k] = *__first;
            _Distance __sz = __k;
            for (; __first != __last; ++__first , (void)++__k) {
                _Distance __r = std::__1::uniform_int_distribution<_Distance>(0, __k)(__g);
                if (__r < __sz)
                    __output_iter[__r] = *__first;
            }
            return __output_iter + std::__1::min(__n, __k);
        }
        template <class _PopulationIterator, class _SampleIterator, class _Distance, class _UniformRandomNumberGenerator> _SampleIterator __sample(_PopulationIterator __first, _PopulationIterator __last, _SampleIterator __output_iter, _Distance __n, _UniformRandomNumberGenerator &__g, std::__1::forward_iterator_tag) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            _Distance __unsampled_sz = std::__1::distance(__first, __last);
            for (__n = std::__1::min(__n, __unsampled_sz); __n != 0; ++__first) {
                _Distance __r = std::__1::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
                if (__r < __n) {
                    *__output_iter++ = *__first;
                    --__n;
                }
            }
            return __output_iter;
        }
        template <class _PopulationIterator, class _SampleIterator, class _Distance, class _UniformRandomNumberGenerator> _SampleIterator __sample(_PopulationIterator __first, _PopulationIterator __last, _SampleIterator __output_iter, _Distance __n, _UniformRandomNumberGenerator &__g) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_PopulationIterator>::iterator_category _PopCategory;
            typedef typename iterator_traits<_PopulationIterator>::difference_type _Difference;
            static_assert(__is_cpp17_forward_iterator<_PopulationIterator>::value || __is_cpp17_random_access_iterator<_SampleIterator>::value, "SampleIterator must meet the requirements of RandomAccessIterator");
            typedef typename common_type<_Distance, _Difference>::type _CommonType;
            ((void)0);
            return std::__1::__sample(__first, __last, __output_iter, _CommonType(__n), __g, _PopCategory());
        }
        template <class _RandomAccessIterator, class _UniformRandomNumberGenerator> void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator &&__g)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef uniform_int_distribution<ptrdiff_t> _Dp;
            typedef typename _Dp::param_type _Pp;
            difference_type __d = __last - __first;
            if (__d > 1) {
                _Dp __uid;
                for (--__last , (void)--__d; __first < __last; ++__first , (void)--__d) {
                    difference_type __i = __uid(__g, _Pp(0, __d));
                    if (__i != difference_type(0))
                        swap(*__first, *(__first + __i));
                }
            }
        }
        template <class _InputIterator, class _Predicate> bool is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)         {
            for (; __first != __last; ++__first)
                if (!__pred(*__first))
                    break;
            if (__first == __last)
                return true;
            ++__first;
            for (; __first != __last; ++__first)
                if (__pred(*__first))
                    return false;
            return true;
        }
        template <class _Predicate, class _ForwardIterator> _ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, std::__1::forward_iterator_tag)         {
            while (true)
                {
                    if (__first == __last)
                        return __first;
                    if (!__pred(*__first))
                        break;
                    ++__first;
                }
            for (_ForwardIterator __p = __first; ++__p != __last;) {
                if (__pred(*__p)) {
                    swap(*__first, *__p);
                    ++__first;
                }
            }
            return __first;
        }
        template <class _Predicate, class _BidirectionalIterator> _BidirectionalIterator __partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, std::__1::bidirectional_iterator_tag)         {
            while (true)
                {
                    while (true)
                        {
                            if (__first == __last)
                                return __first;
                            if (!__pred(*__first))
                                break;
                            ++__first;
                        }
                    do {
                        if (__first == --__last)
                            return __first;
                    } while (!__pred(*__last));
                    swap(*__first, *__last);
                    ++__first;
                }
        }
        template <class _ForwardIterator, class _Predicate> inline _ForwardIterator partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
        }
        template <class _InputIterator, class _OutputIterator1, class _OutputIterator2, class _Predicate> pair<_OutputIterator1, _OutputIterator2> partition_copy(_InputIterator __first, _InputIterator __last, _OutputIterator1 __out_true, _OutputIterator2 __out_false, _Predicate __pred)         {
            for (; __first != __last; ++__first) {
                if (__pred(*__first)) {
                    *__out_true = *__first;
                    ++__out_true;
                } else {
                    *__out_false = *__first;
                    ++__out_false;
                }
            }
            return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
        }
        template <class _ForwardIterator, class _Predicate> _ForwardIterator partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)         {
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            difference_type __len = std::__1::distance(__first, __last);
            while (__len != 0)
                {
                    difference_type __l2 = std::__1::__half_positive(__len);
                    _ForwardIterator __m = __first;
                    std::__1::advance(__m, __l2);
                    if (__pred(*__m)) {
                        __first = ++__m;
                        __len -= __l2 + 1;
                    } else
                        __len = __l2;
                }
            return __first;
        }
        template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair> _ForwardIterator __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pair __p, std::__1::forward_iterator_tag __fit)         {
            if (__len == 1)
                return __first;
            if (__len == 2) {
                _ForwardIterator __m = __first;
                if (__pred(*++__m)) {
                    swap(*__first, *__m);
                    return __m;
                }
                return __first;
            }
            if (__len <= __p.second) {
                typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h(__p.first, __d);
                value_type *__t = __p.first;
                ::new (__t) value_type((std::__1::move(*__first)));
                __d.__incr((value_type *)0);
                ++__t;
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (__pred(*__i)) {
                            *__first = std::__1::move(*__i);
                            ++__first;
                        } else {
                            ::new (__t) value_type((std::__1::move(*__i)));
                            __d.__incr((value_type *)0);
                            ++__t;
                        }
                    }
                __i = __first;
                for (value_type *__t2 = __p.first; __t2 < __t; ++__t2 , (void)++__i)
                    *__i = std::__1::move(*__t2);
                return __first;
            }
            _ForwardIterator __m = __first;
            _Distance __len2 = __len / 2;
            std::__1::advance(__m, __len2);
            typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
            _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);
            _ForwardIterator __m1 = __m;
            _ForwardIterator __second_false = __last;
            _Distance __len_half = __len - __len2;
            while (__pred(*__m1))
                {
                    if (++__m1 == __last)
                        goto __second_half_done;
                    --__len_half;
                }
            __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
          __second_half_done:
            return std::__1::rotate(__first_false, __m, __second_false);
        }
        struct __return_temporary_buffer {
            template <class _Tp> void operator()(_Tp *__p) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::return_temporary_buffer(__p);
            }
        };
        template <class _Predicate, class _ForwardIterator> _ForwardIterator __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, std::__1::forward_iterator_tag)         {
            const unsigned int __alloc_limit = 3;
            while (true)
                {
                    if (__first == __last)
                        return __first;
                    if (!__pred(*__first))
                        break;
                    ++__first;
                }
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
            difference_type __len = std::__1::distance(__first, __last);
            pair<value_type *, ptrdiff_t> __p(0, 0);
            unique_ptr<value_type, std::__1::__return_temporary_buffer> __h;
            if (__len >= __alloc_limit) {
                __p = std::__1::get_temporary_buffer<value_type>(__len);
                __h.reset(__p.first);
            }
            return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred, __len, __p, std::__1::forward_iterator_tag());
        }
        template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair> _BidirectionalIterator __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, _Distance __len, _Pair __p, std::__1::bidirectional_iterator_tag __bit)         {
            if (__len == 2) {
                swap(*__first, *__last);
                return __last;
            }
            if (__len == 3) {
                _BidirectionalIterator __m = __first;
                if (__pred(*++__m)) {
                    swap(*__first, *__m);
                    swap(*__m, *__last);
                    return __last;
                }
                swap(*__m, *__last);
                swap(*__first, *__m);
                return __m;
            }
            if (__len <= __p.second) {
                typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h(__p.first, __d);
                value_type *__t = __p.first;
                ::new (__t) value_type((std::__1::move(*__first)));
                __d.__incr((value_type *)0);
                ++__t;
                _BidirectionalIterator __i = __first;
                while (++__i != __last)
                    {
                        if (__pred(*__i)) {
                            *__first = std::__1::move(*__i);
                            ++__first;
                        } else {
                            ::new (__t) value_type((std::__1::move(*__i)));
                            __d.__incr((value_type *)0);
                            ++__t;
                        }
                    }
                *__first = std::__1::move(*__i);
                __i = ++__first;
                for (value_type *__t2 = __p.first; __t2 < __t; ++__t2 , (void)++__i)
                    *__i = std::__1::move(*__t2);
                return __first;
            }
            _BidirectionalIterator __m = __first;
            _Distance __len2 = __len / 2;
            std::__1::advance(__m, __len2);
            _BidirectionalIterator __m1 = __m;
            _BidirectionalIterator __first_false = __first;
            _Distance __len_half = __len2;
            while (!__pred(*--__m1))
                {
                    if (__m1 == __first)
                        goto __first_half_done;
                    --__len_half;
                }
            typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
            __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
          __first_half_done:
            __m1 = __m;
            _BidirectionalIterator __second_false = __last;
            ++__second_false;
            __len_half = __len - __len2;
            while (__pred(*__m1))
                {
                    if (++__m1 == __last)
                        goto __second_half_done;
                    --__len_half;
                }
            __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
          __second_half_done:
            return std::__1::rotate(__first_false, __m, __second_false);
        }
        template <class _Predicate, class _BidirectionalIterator> _BidirectionalIterator __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, std::__1::bidirectional_iterator_tag)         {
            typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
            typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
            const difference_type __alloc_limit = 4;
            while (true)
                {
                    if (__first == __last)
                        return __first;
                    if (!__pred(*__first))
                        break;
                    ++__first;
                }
            do {
                if (__first == --__last)
                    return __first;
            } while (!__pred(*__last));
            difference_type __len = std::__1::distance(__first, __last) + 1;
            pair<value_type *, ptrdiff_t> __p(0, 0);
            unique_ptr<value_type, std::__1::__return_temporary_buffer> __h;
            if (__len >= __alloc_limit) {
                __p = std::__1::get_temporary_buffer<value_type>(__len);
                __h.reset(__p.first);
            }
            return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred, __len, __p, std::__1::bidirectional_iterator_tag());
        }
        template <class _ForwardIterator, class _Predicate> inline _ForwardIterator stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
        }
        template <class _ForwardIterator, class _Compare> _ForwardIterator is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)         {
            if (__first != __last) {
                _ForwardIterator __i = __first;
                while (++__i != __last)
                    {
                        if (__comp(*__i, *__first))
                            return __i;
                        __first = __i;
                    }
            }
            return __last;
        }
        template <class _ForwardIterator> inline _ForwardIterator is_sorted_until(_ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }
        template <class _ForwardIterator, class _Compare> inline bool is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::is_sorted_until(__first, __last, __comp) == __last;
        }
        template <class _ForwardIterator> inline bool is_sorted(_ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
        }
        template <class _Compare, class _ForwardIterator> unsigned int __sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)         {
            unsigned int __r = 0;
            if (!__c(*__y, *__x)) {
                if (!__c(*__z, *__y))
                    return __r;
                swap(*__y, *__z);
                __r = 1;
                if (__c(*__y, *__x)) {
                    swap(*__x, *__y);
                    __r = 2;
                }
                return __r;
            }
            if (__c(*__z, *__y)) {
                swap(*__x, *__z);
                __r = 1;
                return __r;
            }
            swap(*__x, *__y);
            __r = 1;
            if (__c(*__z, *__y)) {
                swap(*__y, *__z);
                __r = 2;
            }
            return __r;
        }
        template <class _Compare, class _ForwardIterator> unsigned int __sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _Compare __c)         {
            unsigned int __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
            if (__c(*__x4, *__x3)) {
                swap(*__x3, *__x4);
                ++__r;
                if (__c(*__x3, *__x2)) {
                    swap(*__x2, *__x3);
                    ++__r;
                    if (__c(*__x2, *__x1)) {
                        swap(*__x1, *__x2);
                        ++__r;
                    }
                }
            }
            return __r;
        }
        template <class _Compare, class _ForwardIterator> unsigned int __sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c) __attribute__((visibility("hidden")))         {
            unsigned int __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
            if (__c(*__x5, *__x4)) {
                swap(*__x4, *__x5);
                ++__r;
                if (__c(*__x4, *__x3)) {
                    swap(*__x3, *__x4);
                    ++__r;
                    if (__c(*__x3, *__x2)) {
                        swap(*__x2, *__x3);
                        ++__r;
                        if (__c(*__x2, *__x1)) {
                            swap(*__x1, *__x2);
                            ++__r;
                        }
                    }
                }
            }
            return __r;
        }
        template <class _Compare, class _BirdirectionalIterator> void __selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)         {
            _BirdirectionalIterator __lm1 = __last;
            for (--__lm1; __first != __lm1; ++__first) {
                _BirdirectionalIterator __i = std::__1::min_element<_BirdirectionalIterator, typename add_lvalue_reference<_Compare>::type>(__first, __last, __comp);
                if (__i != __first)
                    swap(*__first, *__i);
            }
        }
        template <class _Compare, class _BirdirectionalIterator> void __insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
            if (__first != __last) {
                _BirdirectionalIterator __i = __first;
                for (++__i; __i != __last; ++__i) {
                    _BirdirectionalIterator __j = __i;
                    value_type __t(std::__1::move(*__j));
                    for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                        *__j = std::__1::move(*__k);
                    *__j = std::__1::move(__t);
                }
            }
        }
        template <class _Compare, class _RandomAccessIterator> void __insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            _RandomAccessIterator __j = __first + 2;
            __sort3<_Compare>(__first, __first + 1, __j, __comp);
            for (_RandomAccessIterator __i = __j + 1; __i != __last; ++__i) {
                if (__comp(*__i, *__j)) {
                    value_type __t(std::__1::move(*__i));
                    _RandomAccessIterator __k = __j;
                    __j = __i;
                    do {
                        *__j = std::__1::move(*__k);
                        __j = __k;
                    } while (__j != __first && __comp(__t, *--__k));
                    *__j = std::__1::move(__t);
                }
                __j = __i;
            }
        }
        template <class _Compare, class _RandomAccessIterator> bool __insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            switch (__last - __first) {
              case 0:
              case 1:
                return true;
              case 2:
                if (__comp(*--__last, *__first))
                    swap(*__first, *__last);
                return true;
              case 3:
                std::__1::__sort3<_Compare>(__first, __first + 1, --__last, __comp);
                return true;
              case 4:
                std::__1::__sort4<_Compare>(__first, __first + 1, __first + 2, --__last, __comp);
                return true;
              case 5:
                std::__1::__sort5<_Compare>(__first, __first + 1, __first + 2, __first + 3, --__last, __comp);
                return true;
            }
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            _RandomAccessIterator __j = __first + 2;
            __sort3<_Compare>(__first, __first + 1, __j, __comp);
            const unsigned int __limit = 8;
            unsigned int __count = 0;
            for (_RandomAccessIterator __i = __j + 1; __i != __last; ++__i) {
                if (__comp(*__i, *__j)) {
                    value_type __t(std::__1::move(*__i));
                    _RandomAccessIterator __k = __j;
                    __j = __i;
                    do {
                        *__j = std::__1::move(*__k);
                        __j = __k;
                    } while (__j != __first && __comp(__t, *--__k));
                    *__j = std::__1::move(__t);
                    if (++__count == __limit)
                        return ++__i == __last;
                }
                __j = __i;
            }
            return true;
        }
        template <class _Compare, class _BirdirectionalIterator> void __insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1, typename iterator_traits<_BirdirectionalIterator>::value_type *__first2, _Compare __comp)         {
            typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
            if (__first1 != __last1) {
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h(__first2, __d);
                value_type *__last2 = __first2;
                ::new (__last2) value_type((std::__1::move(*__first1)));
                __d.__incr((value_type *)0);
                for (++__last2; ++__first1 != __last1; ++__last2) {
                    value_type *__j2 = __last2;
                    value_type *__i2 = __j2;
                    if (__comp(*__first1, *--__i2)) {
                        ::new (__j2) value_type((std::__1::move(*__i2)));
                        __d.__incr((value_type *)0);
                        for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                            *__j2 = std::__1::move(*__i2);
                        *__j2 = std::__1::move(*__first1);
                    } else {
                        ::new (__j2) value_type((std::__1::move(*__first1)));
                        __d.__incr((value_type *)0);
                    }
                }
                __h.release();
            }
        }
        template <class _Compare, class _RandomAccessIterator> void __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            const difference_type __limit = is_trivially_copy_constructible<value_type>::value && is_trivially_copy_assignable<value_type>::value ? 30 : 6;
            while (true)
                {
                  __restart:
                    difference_type __len = __last - __first;
                    switch (__len) {
                      case 0:
                      case 1:
                        return;
                      case 2:
                        if (__comp(*--__last, *__first))
                            swap(*__first, *__last);
                        return;
                      case 3:
                        std::__1::__sort3<_Compare>(__first, __first + 1, --__last, __comp);
                        return;
                      case 4:
                        std::__1::__sort4<_Compare>(__first, __first + 1, __first + 2, --__last, __comp);
                        return;
                      case 5:
                        std::__1::__sort5<_Compare>(__first, __first + 1, __first + 2, __first + 3, --__last, __comp);
                        return;
                    }
                    if (__len <= __limit) {
                        std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
                        return;
                    }
                    _RandomAccessIterator __m = __first;
                    _RandomAccessIterator __lm1 = __last;
                    --__lm1;
                    unsigned int __n_swaps;
                    {
                        difference_type __delta;
                        if (__len >= 1000) {
                            __delta = __len / 2;
                            __m += __delta;
                            __delta /= 2;
                            __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m, __m + __delta, __lm1, __comp);
                        } else {
                            __delta = __len / 2;
                            __m += __delta;
                            __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
                        }
                    }
                    _RandomAccessIterator __i = __first;
                    _RandomAccessIterator __j = __lm1;
                    if (!__comp(*__i, *__m)) {
                        while (true)
                            {
                                if (__i == --__j) {
                                    ++__i;
                                    __j = __last;
                                    if (!__comp(*__first, *--__j)) {
                                        while (true)
                                            {
                                                if (__i == __j)
                                                    return;
                                                if (__comp(*__first, *__i)) {
                                                    swap(*__i, *__j);
                                                    ++__n_swaps;
                                                    ++__i;
                                                    break;
                                                }
                                                ++__i;
                                            }
                                    }
                                    if (__i == __j)
                                        return;
                                    while (true)
                                        {
                                            while (!__comp(*__first, *__i))
                                                ++__i;
                                            while (__comp(*__first, *--__j))
                                                ;
                                            if (__i >= __j)
                                                break;
                                            swap(*__i, *__j);
                                            ++__n_swaps;
                                            ++__i;
                                        }
                                    __first = __i;
                                    goto __restart;
                                }
                                if (__comp(*__j, *__m)) {
                                    swap(*__i, *__j);
                                    ++__n_swaps;
                                    break;
                                }
                            }
                    }
                    ++__i;
                    if (__i < __j) {
                        while (true)
                            {
                                while (__comp(*__i, *__m))
                                    ++__i;
                                while (!__comp(*--__j, *__m))
                                    ;
                                if (__i > __j)
                                    break;
                                swap(*__i, *__j);
                                ++__n_swaps;
                                if (__m == __i)
                                    __m = __j;
                                ++__i;
                            }
                    }
                    if (__i != __m && __comp(*__m, *__i)) {
                        swap(*__i, *__m);
                        ++__n_swaps;
                    }
                    if (__n_swaps == 0) {
                        bool __fs = std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
                        if (std::__1::__insertion_sort_incomplete<_Compare>(__i + 1, __last, __comp)) {
                            if (__fs)
                                return;
                            __last = __i;
                            continue;
                        } else {
                            if (__fs) {
                                __first = ++__i;
                                continue;
                            }
                        }
                    }
                    if (__i - __first < __last - __i) {
                        std::__1::__sort<_Compare>(__first, __i, __comp);
                        __first = ++__i;
                    } else {
                        std::__1::__sort<_Compare>(__i + 1, __last, __comp);
                        __last = __i;
                    }
                }
        }
        template <class _RandomAccessIterator, class _Compare> inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            std::__1::__sort<_Comp_ref>(__first, __last, _Comp_ref(__comp));
        }
        template<> inline void sort<unsigned long *, std::__1::__less<unsigned long, unsigned long>>(unsigned long *__first, unsigned long *__last, std::__1::__less<unsigned long, unsigned long> __comp) __attribute__((internal_linkage))        template <class _RandomAccessIterator> inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _Tp> inline void sort(_Tp **__first, _Tp **__last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::sort((size_t *)__first, (size_t *)__last, __less<size_t>());
        }
        template <class _Tp> inline void sort(__wrap_iter<_Tp *> __first, __wrap_iter<_Tp *> __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::sort(__first.base(), __last.base());
        }
        template <class _Tp, class _Compare> inline void sort(__wrap_iter<_Tp *> __first, __wrap_iter<_Tp *> __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            std::__1::sort<_Tp *, _Comp_ref>(__first.base(), __last.base(), __comp);
        }
        template <class _Compare, class _ForwardIterator, class _Tp> _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp)         {
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            difference_type __len = std::__1::distance(__first, __last);
            while (__len != 0)
                {
                    difference_type __l2 = std::__1::__half_positive(__len);
                    _ForwardIterator __m = __first;
                    std::__1::advance(__m, __l2);
                    if (__comp(*__m, __value_)) {
                        __first = ++__m;
                        __len -= __l2 + 1;
                    } else
                        __len = __l2;
                }
            return __first;
        }
        template <class _ForwardIterator, class _Tp, class _Compare> inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);
        }
        template <class _ForwardIterator, class _Tp> inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::lower_bound(__first, __last, __value_, __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
        }
        template <class _Compare, class _ForwardIterator, class _Tp> _ForwardIterator __upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp)         {
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            difference_type __len = std::__1::distance(__first, __last);
            while (__len != 0)
                {
                    difference_type __l2 = std::__1::__half_positive(__len);
                    _ForwardIterator __m = __first;
                    std::__1::advance(__m, __l2);
                    if (__comp(__value_, *__m))
                        __len = __l2;
                    else {
                        __first = ++__m;
                        __len -= __l2 + 1;
                    }
                }
            return __first;
        }
        template <class _ForwardIterator, class _Tp, class _Compare> inline _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
            return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);
        }
        template <class _ForwardIterator, class _Tp> inline _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::upper_bound(__first, __last, __value_, __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
        }
        template <class _Compare, class _ForwardIterator, class _Tp> pair<_ForwardIterator, _ForwardIterator> __equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp)         {
            typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
            difference_type __len = std::__1::distance(__first, __last);
            while (__len != 0)
                {
                    difference_type __l2 = std::__1::__half_positive(__len);
                    _ForwardIterator __m = __first;
                    std::__1::advance(__m, __l2);
                    if (__comp(*__m, __value_)) {
                        __first = ++__m;
                        __len -= __l2 + 1;
                    } else if (__comp(__value_, *__m)) {
                        __last = __m;
                        __len = __l2;
                    } else {
                        _ForwardIterator __mp1 = __m;
                        return pair<_ForwardIterator, _ForwardIterator>(__lower_bound<_Compare>(__first, __m, __value_, __comp), __upper_bound<_Compare>(++__mp1, __last, __value_, __comp));
                    }
                }
            return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
        }
        template <class _ForwardIterator, class _Tp, class _Compare> inline pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);
        }
        template <class _ForwardIterator, class _Tp> inline pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::equal_range(__first, __last, __value_, __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
        }
        template <class _Compare, class _ForwardIterator, class _Tp> inline bool __binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
            return __first != __last && !__comp(__value_, *__first);
        }
        template <class _ForwardIterator, class _Tp, class _Compare> inline bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);
        }
        template <class _ForwardIterator, class _Tp> inline bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::binary_search(__first, __last, __value_, __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            for (; __first1 != __last1; ++__result) {
                if (__first2 == __last2)
                    return std::__1::copy(__first1, __last1, __result);
                if (__comp(*__first2, *__first1)) {
                    *__result = *__first2;
                    ++__first2;
                } else {
                    *__result = *__first1;
                    ++__first1;
                }
            }
            return std::__1::copy(__first2, __last2, __result);
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_InputIterator1>::value_type __v1;
            typedef typename iterator_traits<_InputIterator2>::value_type __v2;
            return std::__1::merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            for (; __first1 != __last1; ++__result) {
                if (__first2 == __last2) {
                    std::__1::move(__first1, __last1, __result);
                    return;
                }
                if (__comp(*__first2, *__first1)) {
                    *__result = std::__1::move(*__first2);
                    ++__first2;
                } else {
                    *__result = std::__1::move(*__first1);
                    ++__first1;
                }
            }
        }
        template <class _Compare, class _BidirectionalIterator> void __buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1, typename iterator_traits<_BidirectionalIterator>::difference_type __len2, typename iterator_traits<_BidirectionalIterator>::value_type *__buff)         {
            typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
            std::__1::__destruct_n __d(0);
            unique_ptr<value_type, std::__1::__destruct_n &> __h2(__buff, __d);
            if (__len1 <= __len2) {
                value_type *__p = __buff;
                for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type *)0) , (void)++__i , (void)++__p)
                    ::new (__p) value_type((std::__1::move(*__i)));
                __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);
            } else {
                value_type *__p = __buff;
                for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type *)0) , (void)++__i , (void)++__p)
                    ::new (__p) value_type((std::__1::move(*__i)));
                typedef reverse_iterator<_BidirectionalIterator> _RBi;
                typedef reverse_iterator<value_type *> _Rv;
                __half_inplace_merge(_Rv(__p), _Rv(__buff), _RBi(__middle), _RBi(__first), _RBi(__last), __invert<_Compare>(__comp));
            }
        }
        template <class _Compare, class _BidirectionalIterator> void __inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1, typename iterator_traits<_BidirectionalIterator>::difference_type __len2, typename iterator_traits<_BidirectionalIterator>::value_type *__buff, ptrdiff_t __buff_size)         {
            typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
            while (true)
                {
                    if (__len2 == 0)
                        return;
                    if (__len1 <= __buff_size || __len2 <= __buff_size)
                        return __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);
                    for (; true; ++__first , (void)--__len1) {
                        if (__len1 == 0)
                            return;
                        if (__comp(*__middle, *__first))
                            break;
                    }
                    _BidirectionalIterator __m1;
                    _BidirectionalIterator __m2;
                    difference_type __len11;
                    difference_type __len21;
                    if (__len1 < __len2) {
                        __len21 = __len2 / 2;
                        __m2 = __middle;
                        std::__1::advance(__m2, __len21);
                        __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
                        __len11 = std::__1::distance(__first, __m1);
                    } else {
                        if (__len1 == 1) {
                            swap(*__first, *__middle);
                            return;
                        }
                        __len11 = __len1 / 2;
                        __m1 = __first;
                        std::__1::advance(__m1, __len11);
                        __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
                        __len21 = std::__1::distance(__middle, __m2);
                    }
                    difference_type __len12 = __len1 - __len11;
                    difference_type __len22 = __len2 - __len21;
                    __middle = std::__1::rotate(__m1, __middle, __m2);
                    if (__len11 + __len21 < __len12 + __len22) {
                        __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
                        __first = __middle;
                        __middle = __m2;
                        __len1 = __len12;
                        __len2 = __len22;
                    } else {
                        __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
                        __last = __middle;
                        __middle = __m1;
                        __len1 = __len11;
                        __len2 = __len21;
                    }
                }
        }
        template <class _BidirectionalIterator, class _Compare> inline void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
            typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
            difference_type __len1 = std::__1::distance(__first, __middle);
            difference_type __len2 = std::__1::distance(__middle, __last);
            difference_type __buf_size = std::__1::min(__len1, __len2);
            pair<value_type *, ptrdiff_t> __buf = std::__1::get_temporary_buffer<value_type>(__buf_size);
            unique_ptr<value_type, std::__1::__return_temporary_buffer> __h(__buf.first);
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2, __buf.first, __buf.second);
        }
        template <class _BidirectionalIterator> inline void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::inplace_merge(__first, __middle, __last, __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2> void __merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, typename iterator_traits<_InputIterator1>::value_type *__result, _Compare __comp)         {
            typedef typename iterator_traits<_InputIterator1>::value_type value_type;
            std::__1::__destruct_n __d(0);
            unique_ptr<value_type, std::__1::__destruct_n &> __h(__result, __d);
            for (; true; ++__result) {
                if (__first1 == __last1) {
                    for (; __first2 != __last2; ++__first2 , ++__result , (void)__d.__incr((value_type *)0))
                        ::new (__result) value_type((std::__1::move(*__first2)));
                    __h.release();
                    return;
                }
                if (__first2 == __last2) {
                    for (; __first1 != __last1; ++__first1 , ++__result , (void)__d.__incr((value_type *)0))
                        ::new (__result) value_type((std::__1::move(*__first1)));
                    __h.release();
                    return;
                }
                if (__comp(*__first2, *__first1)) {
                    ::new (__result) value_type((std::__1::move(*__first2)));
                    __d.__incr((value_type *)0);
                    ++__first2;
                } else {
                    ::new (__result) value_type((std::__1::move(*__first1)));
                    __d.__incr((value_type *)0);
                    ++__first1;
                }
            }
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> void __merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            for (; __first1 != __last1; ++__result) {
                if (__first2 == __last2) {
                    for (; __first1 != __last1; ++__first1 , (void)++__result)
                        *__result = std::__1::move(*__first1);
                    return;
                }
                if (__comp(*__first2, *__first1)) {
                    *__result = std::__1::move(*__first2);
                    ++__first2;
                } else {
                    *__result = std::__1::move(*__first1);
                    ++__first1;
                }
            }
            for (; __first2 != __last2; ++__first2 , (void)++__result)
                *__result = std::__1::move(*__first2);
        }
        template <class _Compare, class _RandomAccessIterator> void __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len, typename iterator_traits<_RandomAccessIterator>::value_type *__buff, ptrdiff_t __buff_size);
        template <class _Compare, class _RandomAccessIterator> void __stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len, typename iterator_traits<_RandomAccessIterator>::value_type *__first2)         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            switch (__len) {
              case 0:
                return;
              case 1:
                ::new (__first2) value_type((std::__1::move(*__first1)));
                return;
              case 2:
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h2(__first2, __d);
                if (__comp(*--__last1, *__first1)) {
                    ::new (__first2) value_type((std::__1::move(*__last1)));
                    __d.__incr((value_type *)0);
                    ++__first2;
                    ::new (__first2) value_type((std::__1::move(*__first1)));
                } else {
                    ::new (__first2) value_type((std::__1::move(*__first1)));
                    __d.__incr((value_type *)0);
                    ++__first2;
                    ::new (__first2) value_type((std::__1::move(*__last1)));
                }
                __h2.release();
                return;
            }
            if (__len <= 8) {
                __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
                return;
            }
            typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
            _RandomAccessIterator __m = __first1 + __l2;
            __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
            __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
            __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
        }
        template <class _Tp> struct __stable_sort_switch {
            static const unsigned int value = 128 * is_trivially_copy_assignable<_Tp>::value;
        };
        template <class _Compare, class _RandomAccessIterator> void __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len, typename iterator_traits<_RandomAccessIterator>::value_type *__buff, ptrdiff_t __buff_size)         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            switch (__len) {
              case 0:
              case 1:
                return;
              case 2:
                if (__comp(*--__last, *__first))
                    swap(*__first, *__last);
                return;
            }
            if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
                __insertion_sort<_Compare>(__first, __last, __comp);
                return;
            }
            typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
            _RandomAccessIterator __m = __first + __l2;
            if (__len <= __buff_size) {
                std::__1::__destruct_n __d(0);
                unique_ptr<value_type, std::__1::__destruct_n &> __h2(__buff, __d);
                __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
                __d.__set(__l2, (value_type *)0);
                __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
                __d.__set(__len, (value_type *)0);
                __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);
                return;
            }
            __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
            __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
            __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
        }
        template <class _RandomAccessIterator, class _Compare> inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            difference_type __len = __last - __first;
            pair<value_type *, ptrdiff_t> __buf(0, 0);
            unique_ptr<value_type, std::__1::__return_temporary_buffer> __h;
            if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
                __buf = std::__1::get_temporary_buffer<value_type>(__len);
                __h.reset(__buf.first);
            }
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);
        }
        template <class _RandomAccessIterator> inline void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _RandomAccessIterator, class _Compare> _RandomAccessIterator is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            difference_type __len = __last - __first;
            difference_type __p = 0;
            difference_type __c = 1;
            _RandomAccessIterator __pp = __first;
            while (__c < __len)
                {
                    _RandomAccessIterator __cp = __first + __c;
                    if (__comp(*__pp, *__cp))
                        return __cp;
                    ++__c;
                    ++__cp;
                    if (__c == __len)
                        return __last;
                    if (__comp(*__pp, *__cp))
                        return __cp;
                    ++__p;
                    ++__pp;
                    __c = 2 * __p + 1;
                }
            return __last;
        }
        template <class _RandomAccessIterator> inline _RandomAccessIterator is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _RandomAccessIterator, class _Compare> inline bool is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::is_heap_until(__first, __last, __comp) == __last;
        }
        template <class _RandomAccessIterator> inline bool is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _Compare, class _RandomAccessIterator> void __sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len)         {
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            if (__len > 1) {
                __len = (__len - 2) / 2;
                _RandomAccessIterator __ptr = __first + __len;
                if (__comp(*__ptr, *--__last)) {
                    value_type __t(std::__1::move(*__last));
                    do {
                        *__last = std::__1::move(*__ptr);
                        __last = __ptr;
                        if (__len == 0)
                            break;
                        __len = (__len - 1) / 2;
                        __ptr = __first + __len;
                    } while (__comp(*__ptr, __t));
                    *__last = std::__1::move(__t);
                }
            }
        }
        template <class _RandomAccessIterator, class _Compare> inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);
        }
        template <class _RandomAccessIterator> inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _Compare, class _RandomAccessIterator> void __sift_down(_RandomAccessIterator __first, _RandomAccessIterator, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len, _RandomAccessIterator __start)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
            difference_type __child = __start - __first;
            if (__len < 2 || (__len - 2) / 2 < __child)
                return;
            __child = 2 * __child + 1;
            _RandomAccessIterator __child_i = __first + __child;
            if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {
                ++__child_i;
                ++__child;
            }
            if (__comp(*__child_i, *__start))
                return;
            value_type __top(std::__1::move(*__start));
            do {
                *__start = std::__1::move(*__child_i);
                __start = __child_i;
                if ((__len - 2) / 2 < __child)
                    break;
                __child = 2 * __child + 1;
                __child_i = __first + __child;
                if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {
                    ++__child_i;
                    ++__child;
                }
            } while (!__comp(*__child_i, __top));
            *__start = std::__1::move(__top);
        }
        template <class _Compare, class _RandomAccessIterator> inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits<_RandomAccessIterator>::difference_type __len) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__len > 1) {
                swap(*__first, *--__last);
                __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
            }
        }
        template <class _RandomAccessIterator, class _Compare> inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);
        }
        template <class _RandomAccessIterator> inline void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _Compare, class _RandomAccessIterator> void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            difference_type __n = __last - __first;
            if (__n > 1) {
                for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start) {
                    __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
                }
            }
        }
        template <class _RandomAccessIterator, class _Compare> inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            __make_heap<_Comp_ref>(__first, __last, __comp);
        }
        template <class _RandomAccessIterator> inline void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _Compare, class _RandomAccessIterator> void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            for (difference_type __n = __last - __first; __n > 1; --__last , (void)--__n)
                __pop_heap<_Compare>(__first, __last, __comp, __n);
        }
        template <class _RandomAccessIterator, class _Compare> inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            __sort_heap<_Comp_ref>(__first, __last, __comp);
        }
        template <class _RandomAccessIterator> inline void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _Compare, class _RandomAccessIterator> void __partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)         {
            __make_heap<_Compare>(__first, __middle, __comp);
            typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
            for (_RandomAccessIterator __i = __middle; __i != __last; ++__i) {
                if (__comp(*__i, *__first)) {
                    swap(*__i, *__first);
                    __sift_down<_Compare>(__first, __middle, __comp, __len, __first);
                }
            }
            __sort_heap<_Compare>(__first, __middle, __comp);
        }
        template <class _RandomAccessIterator, class _Compare> inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);
        }
        template <class _RandomAccessIterator> inline void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::partial_sort(__first, __middle, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _Compare, class _InputIterator, class _RandomAccessIterator> _RandomAccessIterator __partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)         {
            _RandomAccessIterator __r = __result_first;
            if (__r != __result_last) {
                for (; __first != __last && __r != __result_last; ++__first , (void)++__r)
                    *__r = *__first;
                __make_heap<_Compare>(__result_first, __r, __comp);
                typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
                for (; __first != __last; ++__first)
                    if (__comp(*__first, *__result_first)) {
                        *__result_first = *__first;
                        __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);
                    }
                __sort_heap<_Compare>(__result_first, __r, __comp);
            }
            return __r;
        }
        template <class _InputIterator, class _RandomAccessIterator, class _Compare> inline _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);
        }
        template <class _InputIterator, class _RandomAccessIterator> inline _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::partial_sort_copy(__first, __last, __result_first, __result_last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _Compare, class _RandomAccessIterator> void __nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)         {
            typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
            const difference_type __limit = 7;
            while (true)
                {
                  __restart:
                    if (__nth == __last)
                        return;
                    difference_type __len = __last - __first;
                    switch (__len) {
                      case 0:
                      case 1:
                        return;
                      case 2:
                        if (__comp(*--__last, *__first))
                            swap(*__first, *__last);
                        return;
                      case 3:
                        {
                            _RandomAccessIterator __m = __first;
                            std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
                            return;
                        }
                    }
                    if (__len <= __limit) {
                        __selection_sort<_Compare>(__first, __last, __comp);
                        return;
                    }
                    _RandomAccessIterator __m = __first + __len / 2;
                    _RandomAccessIterator __lm1 = __last;
                    unsigned int __n_swaps = std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);
                    _RandomAccessIterator __i = __first;
                    _RandomAccessIterator __j = __lm1;
                    if (!__comp(*__i, *__m)) {
                        while (true)
                            {
                                if (__i == --__j) {
                                    ++__i;
                                    __j = __last;
                                    if (!__comp(*__first, *--__j)) {
                                        while (true)
                                            {
                                                if (__i == __j)
                                                    return;
                                                if (__comp(*__first, *__i)) {
                                                    swap(*__i, *__j);
                                                    ++__n_swaps;
                                                    ++__i;
                                                    break;
                                                }
                                                ++__i;
                                            }
                                    }
                                    if (__i == __j)
                                        return;
                                    while (true)
                                        {
                                            while (!__comp(*__first, *__i))
                                                ++__i;
                                            while (__comp(*__first, *--__j))
                                                ;
                                            if (__i >= __j)
                                                break;
                                            swap(*__i, *__j);
                                            ++__n_swaps;
                                            ++__i;
                                        }
                                    if (__nth < __i)
                                        return;
                                    __first = __i;
                                    goto __restart;
                                }
                                if (__comp(*__j, *__m)) {
                                    swap(*__i, *__j);
                                    ++__n_swaps;
                                    break;
                                }
                            }
                    }
                    ++__i;
                    if (__i < __j) {
                        while (true)
                            {
                                while (__comp(*__i, *__m))
                                    ++__i;
                                while (!__comp(*--__j, *__m))
                                    ;
                                if (__i >= __j)
                                    break;
                                swap(*__i, *__j);
                                ++__n_swaps;
                                if (__m == __i)
                                    __m = __j;
                                ++__i;
                            }
                    }
                    if (__i != __m && __comp(*__m, *__i)) {
                        swap(*__i, *__m);
                        ++__n_swaps;
                    }
                    if (__nth == __i)
                        return;
                    if (__n_swaps == 0) {
                        if (__nth < __i) {
                            __j = __m = __first;
                            while (++__j != __i)
                                {
                                    if (__comp(*__j, *__m))
                                        goto not_sorted;
                                    __m = __j;
                                }
                            return;
                        } else {
                            __j = __m = __i;
                            while (++__j != __last)
                                {
                                    if (__comp(*__j, *__m))
                                        goto not_sorted;
                                    __m = __j;
                                }
                            return;
                        }
                    }
                  not_sorted:
                    if (__nth < __i) {
                        __last = __i;
                    } else {
                        __first = ++__i;
                    }
                }
        }
        template <class _RandomAccessIterator, class _Compare> inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            __nth_element<_Comp_ref>(__first, __nth, __last, __comp);
        }
        template <class _RandomAccessIterator> inline void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2> bool __includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)         {
            for (; __first2 != __last2; ++__first1) {
                if (__first1 == __last1 || __comp(*__first2, *__first1))
                    return false;
                if (!__comp(*__first1, *__first2))
                    ++__first2;
            }
            return true;
        }
        template <class _InputIterator1, class _InputIterator2, class _Compare> inline bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
        }
        template <class _InputIterator1, class _InputIterator2> inline bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::includes(__first1, __last1, __first2, __last2, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            for (; __first1 != __last1; ++__result) {
                if (__first2 == __last2)
                    return std::__1::copy(__first1, __last1, __result);
                if (__comp(*__first2, *__first1)) {
                    *__result = *__first2;
                    ++__first2;
                } else {
                    if (!__comp(*__first1, *__first2))
                        ++__first2;
                    *__result = *__first1;
                    ++__first1;
                }
            }
            return std::__1::copy(__first2, __last2, __result);
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::set_union(__first1, __last1, __first2, __last2, __result, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            while (__first1 != __last1 && __first2 != __last2)
                {
                    if (__comp(*__first1, *__first2))
                        ++__first1;
                    else {
                        if (!__comp(*__first2, *__first1)) {
                            *__result = *__first1;
                            ++__result;
                            ++__first1;
                        }
                        ++__first2;
                    }
                }
            return __result;
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::set_intersection(__first1, __last1, __first2, __last2, __result, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            while (__first1 != __last1)
                {
                    if (__first2 == __last2)
                        return std::__1::copy(__first1, __last1, __result);
                    if (__comp(*__first1, *__first2)) {
                        *__result = *__first1;
                        ++__result;
                        ++__first1;
                    } else {
                        if (!__comp(*__first2, *__first1))
                            ++__first1;
                        ++__first2;
                    }
                }
            return __result;
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::set_difference(__first1, __last1, __first2, __last2, __result, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)         {
            while (__first1 != __last1)
                {
                    if (__first2 == __last2)
                        return std::__1::copy(__first1, __last1, __result);
                    if (__comp(*__first1, *__first2)) {
                        *__result = *__first1;
                        ++__result;
                        ++__first1;
                    } else {
                        if (__comp(*__first2, *__first1)) {
                            *__result = *__first2;
                            ++__result;
                        } else
                            ++__first1;
                        ++__first2;
                    }
                }
            return std::__1::copy(__first2, __last2, __result);
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);
        }
        template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }
        template <class _Compare, class _InputIterator1, class _InputIterator2> bool __lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)         {
            for (; __first2 != __last2; ++__first1 , (void)++__first2) {
                if (__first1 == __last1 || __comp(*__first1, *__first2))
                    return true;
                if (__comp(*__first2, *__first1))
                    return false;
            }
            return false;
        }
        template <class _InputIterator1, class _InputIterator2, class _Compare> inline bool lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
        }
        template <class _InputIterator1, class _InputIterator2> inline bool lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::lexicographical_compare(__first1, __last1, __first2, __last2, __less<typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>());
        }
        template <class _Compare, class _BidirectionalIterator> bool __next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)         {
            _BidirectionalIterator __i = __last;
            if (__first == __last || __first == --__i)
                return false;
            while (true)
                {
                    _BidirectionalIterator __ip1 = __i;
                    if (__comp(*--__i, *__ip1)) {
                        _BidirectionalIterator __j = __last;
                        while (!__comp(*__i, *--__j))
                            ;
                        swap(*__i, *__j);
                        std::__1::reverse(__ip1, __last);
                        return true;
                    }
                    if (__i == __first) {
                        std::__1::reverse(__first, __last);
                        return false;
                    }
                }
        }
        template <class _BidirectionalIterator, class _Compare> inline bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __next_permutation<_Comp_ref>(__first, __last, __comp);
        }
        template <class _BidirectionalIterator> inline bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::next_permutation(__first, __last, __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
        }
        template <class _Compare, class _BidirectionalIterator> bool __prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)         {
            _BidirectionalIterator __i = __last;
            if (__first == __last || __first == --__i)
                return false;
            while (true)
                {
                    _BidirectionalIterator __ip1 = __i;
                    if (__comp(*__ip1, *--__i)) {
                        _BidirectionalIterator __j = __last;
                        while (!__comp(*--__j, *__i))
                            ;
                        swap(*__i, *__j);
                        std::__1::reverse(__ip1, __last);
                        return true;
                    }
                    if (__i == __first) {
                        std::__1::reverse(__first, __last);
                        return false;
                    }
                }
        }
        template <class _BidirectionalIterator, class _Compare> inline bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
            return __prev_permutation<_Comp_ref>(__first, __last, __comp);
        }
        template <class _BidirectionalIterator> inline bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::prev_permutation(__first, __last, __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
        }
    }
}
namespace std {
    inline namespace __1 {
        template <class _Tp, size_t _Size> struct __attribute__((type_visibility("default"))) array {
            typedef array<_Tp, _Size> __self;
            typedef _Tp value_type;
            typedef std::__1::array::value_type &reference;
            typedef const std::__1::array::value_type &const_reference;
            typedef std::__1::array::value_type *iterator;
            typedef const std::__1::array::value_type *const_iterator;
            typedef std::__1::array::value_type *pointer;
            typedef const std::__1::array::value_type *const_pointer;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            _Tp __elems_[_Size];
            void fill(const std::__1::array::value_type &__u) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::fill_n(this->__elems_, _Size, __u);
            }
            void swap(array<_Tp, _Size> &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::swap_ranges(this->__elems_, this->__elems_ + _Size, __a.__elems_);
            }
            std::__1::array::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array::iterator(data());
            }
            std::__1::array::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array::const_iterator(data());
            }
            std::__1::array::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array::iterator(data() + _Size);
            }
            std::__1::array::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array::const_iterator(data() + _Size);
            }
            std::__1::array::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array::reverse_iterator(end());
            }
            std::__1::array::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array::const_reverse_iterator(end());
            }
            std::__1::array::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array::reverse_iterator(begin());
            }
            std::__1::array::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array::const_reverse_iterator(begin());
            }
            std::__1::array::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return begin();
            }
            std::__1::array::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return end();
            }
            std::__1::array::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rbegin();
            }
            std::__1::array::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rend();
            }
            std::__1::array::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return _Size;
            }
            std::__1::array::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return _Size;
            }
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return false;
            }
            std::__1::array::reference operator[](std::__1::array::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__elems_[__n];
            }
            std::__1::array::const_reference operator[](std::__1::array::size_type __n) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__elems_[__n];
            }
            std::__1::array::reference at(std::__1::array::size_type __n);
            std::__1::array::const_reference at(std::__1::array::size_type __n) const;
            std::__1::array::reference front() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__elems_[0];
            }
            std::__1::array::const_reference front() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__elems_[0];
            }
            std::__1::array::reference back() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__elems_[_Size - 1];
            }
            std::__1::array::const_reference back() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__elems_[_Size - 1];
            }
            std::__1::array::value_type *data() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__elems_;
            }
            const std::__1::array::value_type *data() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__elems_;
            }
        };
        template <class _Tp, size_t _Size> typename array<_Tp, _Size>::reference array<_Tp, _Size>::at(std::__1::array::size_type __n)         {
            if (__n >= _Size)
                __throw_out_of_range("array::at");
            return this->__elems_[__n];
        }
        template <class _Tp, size_t _Size> typename array<_Tp, _Size>::const_reference array<_Tp, _Size>::at(std::__1::array::size_type __n) const         {
            if (__n >= _Size)
                __throw_out_of_range("array::at");
            return this->__elems_[__n];
        }
        template <class _Tp> struct __attribute__((type_visibility("default"))) array<_Tp, 0> {
            typedef array<type-parameter-0-0, 0> __self;
            typedef _Tp value_type;
            typedef std::__1::array<type-parameter-0-0, 0>::value_type &reference;
            typedef const std::__1::array<type-parameter-0-0, 0>::value_type &const_reference;
            typedef std::__1::array<type-parameter-0-0, 0>::value_type *iterator;
            typedef const std::__1::array<type-parameter-0-0, 0>::value_type *const_iterator;
            typedef std::__1::array<type-parameter-0-0, 0>::value_type *pointer;
            typedef const std::__1::array<type-parameter-0-0, 0>::value_type *const_pointer;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef typename conditional<is_const<_Tp>::value, const char, char>::type _CharType;
            struct _ArrayInStructT {
                _Tp __data_[1];
            };
            std::__1::array<type-parameter-0-0, 0>::_CharType __elems_[sizeof(std::__1::array<type-parameter-0-0, 0>::_ArrayInStructT)] __attribute__((aligned(__alignof(std::__1::array<type-parameter-0-0, 0>::_ArrayInStructT))));
            void fill(const std::__1::array<type-parameter-0-0, 0>::value_type &) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(!is_const<_Tp>::value, "cannot fill zero-sized array of type 'const T'");
            }
            void swap(array<type-parameter-0-0, 0> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(!is_const<_Tp>::value, "cannot swap zero-sized array of type 'const T'");
            }
            std::__1::array<type-parameter-0-0, 0>::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array<type-parameter-0-0, 0>::iterator(data());
            }
            std::__1::array<type-parameter-0-0, 0>::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array<type-parameter-0-0, 0>::const_iterator(data());
            }
            std::__1::array<type-parameter-0-0, 0>::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array<type-parameter-0-0, 0>::iterator(data());
            }
            std::__1::array<type-parameter-0-0, 0>::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array<type-parameter-0-0, 0>::const_iterator(data());
            }
            std::__1::array<type-parameter-0-0, 0>::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array<type-parameter-0-0, 0>::reverse_iterator(end());
            }
            std::__1::array<type-parameter-0-0, 0>::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array<type-parameter-0-0, 0>::const_reverse_iterator(end());
            }
            std::__1::array<type-parameter-0-0, 0>::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array<type-parameter-0-0, 0>::reverse_iterator(begin());
            }
            std::__1::array<type-parameter-0-0, 0>::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::array<type-parameter-0-0, 0>::const_reverse_iterator(begin());
            }
            std::__1::array<type-parameter-0-0, 0>::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return begin();
            }
            std::__1::array<type-parameter-0-0, 0>::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return end();
            }
            std::__1::array<type-parameter-0-0, 0>::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rbegin();
            }
            std::__1::array<type-parameter-0-0, 0>::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rend();
            }
            std::__1::array<type-parameter-0-0, 0>::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return 0;
            }
            std::__1::array<type-parameter-0-0, 0>::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return 0;
            }
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return true;
            }
            std::__1::array<type-parameter-0-0, 0>::reference operator[](std::__1::array<type-parameter-0-0, 0>::size_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                __builtin_unreachable();
            }
            std::__1::array<type-parameter-0-0, 0>::const_reference operator[](std::__1::array<type-parameter-0-0, 0>::size_type) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                __builtin_unreachable();
            }
            std::__1::array<type-parameter-0-0, 0>::reference at(std::__1::array<type-parameter-0-0, 0>::size_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __throw_out_of_range("array<T, 0>::at");
                __builtin_unreachable();
            }
            std::__1::array<type-parameter-0-0, 0>::const_reference at(std::__1::array<type-parameter-0-0, 0>::size_type) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __throw_out_of_range("array<T, 0>::at");
                __builtin_unreachable();
            }
            std::__1::array<type-parameter-0-0, 0>::reference front() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                __builtin_unreachable();
            }
            std::__1::array<type-parameter-0-0, 0>::const_reference front() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                __builtin_unreachable();
            }
            std::__1::array<type-parameter-0-0, 0>::reference back() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                __builtin_unreachable();
            }
            std::__1::array<type-parameter-0-0, 0>::const_reference back() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                __builtin_unreachable();
            }
            std::__1::array<type-parameter-0-0, 0>::value_type *data() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return reinterpret_cast<std::__1::array<type-parameter-0-0, 0>::value_type *>(this->__elems_);
            }
            const std::__1::array<type-parameter-0-0, 0>::value_type *data() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return reinterpret_cast<const std::__1::array<type-parameter-0-0, 0>::value_type *>(this->__elems_);
            }
        };
        template <class _Tp, size_t _Size> inline bool operator==(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::equal(__x.begin(), __x.end(), __y.begin());
        }
        template <class _Tp, size_t _Size> inline bool operator!=(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Tp, size_t _Size> inline bool operator<(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
        }
        template <class _Tp, size_t _Size> inline bool operator>(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Tp, size_t _Size> inline bool operator<=(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Tp, size_t _Size> inline bool operator>=(const array<_Tp, _Size> &__x, const array<_Tp, _Size> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Tp, size_t _Size> inline typename enable_if<_Size == 0 || __is_swappable<_Tp>::value, void>::type swap(array<_Tp, _Size> &__x, array<_Tp, _Size> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _Tp, size_t _Size> struct __attribute__((type_visibility("default"))) tuple_size<array<_Tp, _Size>> : public integral_constant<size_t, _Size> {
        };
        template <size_t _Ip, class _Tp, size_t _Size> struct __attribute__((type_visibility("default"))) tuple_element<_Ip, array<_Tp, _Size>> {
            static_assert(_Ip < _Size, "Index out of bounds in std::tuple_element<> (std::array)");
            typedef _Tp type;
        };
        template <size_t _Ip, class _Tp, size_t _Size> inline _Tp &get(array<_Tp, _Size> &__a) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array)");
            return __a.__elems_[_Ip];
        }
        template <size_t _Ip, class _Tp, size_t _Size> inline const _Tp &get(const array<_Tp, _Size> &__a) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array)");
            return __a.__elems_[_Ip];
        }
    }
}
namespace std {
    inline namespace __1 {
        template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator
template<> class __bit_iterator<std::__1::__bitset<0, 0>, false, 0> {
        public:
            typedef typename __bitset<0, 0>::difference_type difference_type;
            typedef bool value_type;
            typedef std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> pointer;
            typedef typename conditional<false, __bit_const_reference<__bitset<0, 0> >, __bit_reference<__bitset<0, 0> > >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename conditional<false, typename __bitset<0, 0>::__const_storage_pointer, typename __bitset<0, 0>::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = __bitset<0, 0>::__bits_per_word;
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::__storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator() throw() __attribute__((internal_linkage));
            using __type_for_copy_to_const = _If<false, __bit_iterator<std::__1::__bitset<0, 0>, false>, struct __private_nat>;
            __bit_iterator(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::__type_for_copy_to_const &__it) throw() __attribute__((internal_linkage));
            using __type_for_abi_non_trivial_copy_ctor = _If<!false, std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>, struct __private_nat>;
            __bit_iterator(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::__type_for_abi_non_trivial_copy_ctor &__it) throw() : __seg_(__it.__seg_), __ctz_(__it.__ctz_) __attribute__((internal_linkage))             {
            }
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &) __attribute__((internal_linkage)) = default
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::reference operator*() const throw() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator++() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator++(int) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator--() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator--(int) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator+=(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator-=(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator+(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) const __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator-(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) const __attribute__((internal_linkage));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator+(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__it) __attribute__((internal_linkage));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type operator-(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::reference operator[](std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) const __attribute__((internal_linkage));
            friend bool operator==(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator!=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator<(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator>(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator<=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator>=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
        private:
            __bit_iterator(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::__storage_pointer __s, unsigned int __ctz) throw() : __seg_(__s), __ctz_(__ctz) __attribute__((internal_linkage))             {
            }
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        }
template<> class __bit_iterator<std::__1::__bitset<0, 0>, true, 0> {
        public:
            typedef typename __bitset<0, 0>::difference_type difference_type;
            typedef bool value_type;
            typedef std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> pointer;
            typedef typename conditional<true, __bit_const_reference<__bitset<0, 0> >, __bit_reference<__bitset<0, 0> > >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename conditional<true, typename __bitset<0, 0>::__const_storage_pointer, typename __bitset<0, 0>::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = __bitset<0, 0>::__bits_per_word;
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::__storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator() throw() __attribute__((internal_linkage));
            using __type_for_copy_to_const = _If<true, __bit_iterator<std::__1::__bitset<0, 0>, false>, struct __private_nat>;
            __bit_iterator(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::__type_for_copy_to_const &__it) throw() __attribute__((internal_linkage));
            using __type_for_abi_non_trivial_copy_ctor = _If<!true, std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>, struct __private_nat>;
            __bit_iterator(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::__type_for_abi_non_trivial_copy_ctor &__it) throw() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &) __attribute__((internal_linkage)) = default
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::reference operator*() const throw() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator++() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator++(int) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator--() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator--(int) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator+=(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator-=(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator+(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) const __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator-(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) const __attribute__((internal_linkage));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator+(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__it) __attribute__((internal_linkage));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type operator-(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::reference operator[](std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) const __attribute__((internal_linkage));
            friend bool operator==(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator!=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator<(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator>(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator<=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator>=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
        private:
            __bit_iterator(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::__storage_pointer __s, unsigned int __ctz) throw() : __seg_(__s), __ctz_(__ctz) __attribute__((internal_linkage))             {
            }
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        };
        template <class _Cp> class __bit_const_reference
template<> class __bit_const_reference<std::__1::__bitset<0, 0>> {
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename __bitset<0, 0>::__const_storage_pointer __storage_pointer;
            std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >::__storage_pointer __seg_;
            std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >::__storage_type __mask_;
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
        public:
            __bit_const_reference(const std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &) throw() : __seg_(.__seg_), __mask_(.__mask_) __attribute__((internal_linkage)) = default            __bit_const_reference(const __bit_reference<std::__1::__bitset<0, 0> > &__x) throw() __attribute__((internal_linkage));
            operator bool() const throw() __attribute__((internal_linkage));
            __bit_iterator<std::__1::__bitset<0, 0>, true> operator&() const throw() __attribute__((internal_linkage));
        private:
            __bit_const_reference(std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >::__storage_pointer __s, std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >::__storage_type __m) throw() : __seg_(__s), __mask_(__m) __attribute__((internal_linkage))             {
            }
            std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &operator=(const std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &) = delete
        };
        template <class _Tp> struct __has_storage_type {
            static const bool value = false;
        };
template<> struct __has_storage_type<std::__1::__bitset<0, 0>> {
            static const bool value = true;
        };
        template <class _Cp, bool = __has_storage_type<_Cp>::value> class __bit_reference {
            typedef typename _Cp::__storage_type __storage_type;
            typedef typename _Cp::__storage_pointer __storage_pointer;
            std::__1::__bit_reference::__storage_pointer __seg_;
            std::__1::__bit_reference::__storage_type __mask_;
            friend  typename _Cp::__self;
            friend  class __bit_const_reference<_Cp>;
            friend  class __bit_iterator<_Cp, false>;
        public:
            __bit_reference<_Cp, >(const __bit_reference<_Cp, > &) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = default
            operator bool() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<bool>(*this->__seg_ & this->__mask_);
            }
            bool operator~() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !static_cast<bool>(*this);
            }
            __bit_reference<_Cp, > &operator=(bool __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__x)
                    *this->__seg_ |= this->__mask_;
                else
                    *this->__seg_ &= ~this->__mask_;
                return *this;
            }
            __bit_reference<_Cp, > &operator=(const __bit_reference<_Cp, > &__x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return operator=(static_cast<bool>(__x));
            }
            void flip() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                *this->__seg_ ^= this->__mask_;
            }
            __bit_iterator<_Cp, false> operator&() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __bit_iterator<_Cp, false>(this->__seg_, static_cast<unsigned int>(__libcpp_ctz(this->__mask_)));
            }
        private:
            __bit_reference<_Cp, >(std::__1::__bit_reference::__storage_pointer __s, std::__1::__bit_reference::__storage_type __m) throw() : __seg_(__s), __mask_(__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
template<> class __bit_reference<std::__1::__bitset<0, 0>, true> {
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename __bitset<0, 0>::__storage_pointer __storage_pointer;
            std::__1::__bit_reference<std::__1::__bitset<0, 0>, true>::__storage_pointer __seg_;
            std::__1::__bit_reference<std::__1::__bitset<0, 0>, true>::__storage_type __mask_;
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, false>;
        public:
            __bit_reference(const std::__1::__bit_reference<std::__1::__bitset<0, 0>, true> &) throw() : __seg_(.__seg_), __mask_(.__mask_) __attribute__((internal_linkage)) = default            operator bool() const throw() __attribute__((internal_linkage));
            bool operator~() const throw() __attribute__((internal_linkage));
            std::__1::__bit_reference<std::__1::__bitset<0, 0>, true> &operator=(bool __x) throw() __attribute__((internal_linkage));
            std::__1::__bit_reference<std::__1::__bitset<0, 0>, true> &operator=(const std::__1::__bit_reference<std::__1::__bitset<0, 0>, true> &__x) throw() __attribute__((internal_linkage));
            void flip() throw() __attribute__((internal_linkage));
            __bit_iterator<std::__1::__bitset<0, 0>, false> operator&() const throw() __attribute__((internal_linkage));
        private:
            __bit_reference(std::__1::__bit_reference<std::__1::__bitset<0, 0>, true>::__storage_pointer __s, std::__1::__bit_reference<std::__1::__bitset<0, 0>, true>::__storage_type __m) throw() : __seg_(__s), __mask_(__m) __attribute__((internal_linkage))             {
            }
        };
        template <class _Cp> class __bit_reference<_Cp, false> {
        };
        template <class _Cp> inline void swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            bool __t = __x;
            __x = __y;
            __y = __t;
        }
        template <class _Cp, class _Dp> inline void swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            bool __t = __x;
            __x = __y;
            __y = __t;
        }
        template <class _Cp> inline void swap(__bit_reference<_Cp> __x, bool &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            bool __t = __x;
            __x = __y;
            __y = __t;
        }
        template <class _Cp> inline void swap(bool &__x, __bit_reference<_Cp> __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            bool __t = __x;
            __x = __y;
            __y = __t;
        }
        template <class _Cp> class __bit_const_reference {
            typedef typename _Cp::__storage_type __storage_type;
            typedef typename _Cp::__const_storage_pointer __storage_pointer;
            std::__1::__bit_const_reference::__storage_pointer __seg_;
            std::__1::__bit_const_reference::__storage_type __mask_;
            friend  typename _Cp::__self;
            friend  class __bit_iterator<_Cp, true>;
        public:
            __bit_const_reference<_Cp>(const __bit_const_reference<_Cp> &) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = default
            __bit_const_reference<_Cp>(const __bit_reference<_Cp> &__x) throw() : __seg_(__x.__seg_), __mask_(__x.__mask_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            operator bool() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<bool>(*this->__seg_ & this->__mask_);
            }
            __bit_iterator<_Cp, true> operator&() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __bit_iterator<_Cp, true>(this->__seg_, static_cast<unsigned int>(__libcpp_ctz(this->__mask_)));
            }
        private:
            __bit_const_reference<_Cp>(std::__1::__bit_const_reference::__storage_pointer __s, std::__1::__bit_const_reference::__storage_type __m) throw() : __seg_(__s), __mask_(__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __bit_const_reference<_Cp> &operator=(const __bit_const_reference<_Cp> &) = delete
        };
template<> class __bit_const_reference<std::__1::__bitset<0, 0>> {
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename __bitset<0, 0>::__const_storage_pointer __storage_pointer;
            std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >::__storage_pointer __seg_;
            std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >::__storage_type __mask_;
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
        public:
            __bit_const_reference(const std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &) throw() : __seg_(.__seg_), __mask_(.__mask_) __attribute__((internal_linkage)) = default            __bit_const_reference(const __bit_reference<std::__1::__bitset<0, 0> > &__x) throw() __attribute__((internal_linkage));
            operator bool() const throw() __attribute__((internal_linkage));
            __bit_iterator<std::__1::__bitset<0, 0>, true> operator&() const throw() __attribute__((internal_linkage));
        private:
            __bit_const_reference(std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >::__storage_pointer __s, std::__1::__bit_const_reference<std::__1::__bitset<0, 0> >::__storage_type __m) throw() : __seg_(__s), __mask_(__m) __attribute__((internal_linkage))             {
            }
            std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &operator=(const std::__1::__bit_const_reference<std::__1::__bitset<0, 0> > &) = delete
        };
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, _IsConst> __find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, _IsConst> _It;
            typedef typename _It::__storage_type __storage_type;
            static const int __bits_per_word = _It::__bits_per_word;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __storage_type __b = *__first.__seg_ & __m;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__libcpp_ctz(__b)));
                if (__n == __dn)
                    return __first + __n;
                __n -= __dn;
                ++__first.__seg_;
            }
            for (; __n >= __bits_per_word; ++__first.__seg_ , __n -= __bits_per_word)
                if (*__first.__seg_)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__libcpp_ctz(*__first.__seg_)));
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b = *__first.__seg_ & __m;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__libcpp_ctz(__b)));
            }
            return _It(__first.__seg_, static_cast<unsigned int>(__n));
        }
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, _IsConst> __find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, _IsConst> _It;
            typedef typename _It::__storage_type __storage_type;
            const int __bits_per_word = _It::__bits_per_word;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __storage_type __b = ~*__first.__seg_ & __m;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__libcpp_ctz(__b)));
                if (__n == __dn)
                    return __first + __n;
                __n -= __dn;
                ++__first.__seg_;
            }
            for (; __n >= __bits_per_word; ++__first.__seg_ , __n -= __bits_per_word) {
                __storage_type __b = ~*__first.__seg_;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__libcpp_ctz(__b)));
            }
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __storage_type __b = ~*__first.__seg_ & __m;
                if (__b)
                    return _It(__first.__seg_, static_cast<unsigned int>(std::__1::__libcpp_ctz(__b)));
            }
            return _It(__first.__seg_, static_cast<unsigned int>(__n));
        }
        template <class _Cp, bool _IsConst, class _Tp> inline __bit_iterator<_Cp, _IsConst> find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (static_cast<bool>(__value_))
                return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
            return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
        }
        template <class _Cp, bool _IsConst> typename __bit_iterator<_Cp, _IsConst>::difference_type __count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, _IsConst> _It;
            typedef typename _It::__storage_type __storage_type;
            typedef typename _It::difference_type difference_type;
            const int __bits_per_word = _It::__bits_per_word;
            difference_type __r = 0;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __r = std::__1::__libcpp_popcount(*__first.__seg_ & __m);
                __n -= __dn;
                ++__first.__seg_;
            }
            for (; __n >= __bits_per_word; ++__first.__seg_ , __n -= __bits_per_word)
                __r += std::__1::__libcpp_popcount(*__first.__seg_);
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __r += std::__1::__libcpp_popcount(*__first.__seg_ & __m);
            }
            return __r;
        }
        template <class _Cp, bool _IsConst> typename __bit_iterator<_Cp, _IsConst>::difference_type __count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, _IsConst> _It;
            typedef typename _It::__storage_type __storage_type;
            typedef typename _It::difference_type difference_type;
            const int __bits_per_word = _It::__bits_per_word;
            difference_type __r = 0;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                __r = std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
                __n -= __dn;
                ++__first.__seg_;
            }
            for (; __n >= __bits_per_word; ++__first.__seg_ , __n -= __bits_per_word)
                __r += std::__1::__libcpp_popcount(~*__first.__seg_);
            if (__n > 0) {
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __r += std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
            }
            return __r;
        }
        template <class _Cp, bool _IsConst, class _Tp> inline typename __bit_iterator<_Cp, _IsConst>::difference_type count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (static_cast<bool>(__value_))
                return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
            return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
        }
        template <class _Cp> void __fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, false> _It;
            typedef typename _It::__storage_type __storage_type;
            const int __bits_per_word = _It::__bits_per_word;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                *__first.__seg_ &= ~__m;
                __n -= __dn;
                ++__first.__seg_;
            }
            __storage_type __nw = __n / __bits_per_word;
            std::__1::memset(std::__1::__to_address(__first.__seg_), 0, __nw * sizeof(__storage_type));
            __n -= __nw * __bits_per_word;
            if (__n > 0) {
                __first.__seg_ += __nw;
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__first.__seg_ &= ~__m;
            }
        }
        template <class _Cp> void __fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)         {
            typedef __bit_iterator<_Cp, false> _It;
            typedef typename _It::__storage_type __storage_type;
            const int __bits_per_word = _It::__bits_per_word;
            if (__first.__ctz_ != 0) {
                __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
                __storage_type __dn = std::__1::min(__clz_f, __n);
                __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                *__first.__seg_ |= __m;
                __n -= __dn;
                ++__first.__seg_;
            }
            __storage_type __nw = __n / __bits_per_word;
            std::__1::memset(std::__1::__to_address(__first.__seg_), -1, __nw * sizeof(__storage_type));
            __n -= __nw * __bits_per_word;
            if (__n > 0) {
                __first.__seg_ += __nw;
                __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__first.__seg_ |= __m;
            }
        }
        template <class _Cp> inline void fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__n > 0) {
                if (__value_)
                    __fill_n_true(__first, __n);
                else
                    __fill_n_false(__first, __n);
            }
        }
        template <class _Cp> inline void fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
        }
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)         {
            typedef __bit_iterator<_Cp, _IsConst> _In;
            typedef typename _In::difference_type difference_type;
            typedef typename _In::__storage_type __storage_type;
            const int __bits_per_word = _In::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__first.__ctz_ != 0) {
                    unsigned int __clz = __bits_per_word - __first.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
                    __storage_type __b = *__first.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b;
                    __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__dn + __result.__ctz_) % __bits_per_word);
                    ++__first.__seg_;
                }
                __storage_type __nw = __n / __bits_per_word;
                std::__1::memmove(std::__1::__to_address(__result.__seg_), std::__1::__to_address(__first.__seg_), __nw * sizeof(__storage_type));
                __n -= __nw * __bits_per_word;
                __result.__seg_ += __nw;
                if (__n > 0) {
                    __first.__seg_ += __nw;
                    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b = *__first.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b;
                    __result.__ctz_ = static_cast<unsigned int>(__n);
                }
            }
            return __result;
        }
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)         {
            typedef __bit_iterator<_Cp, _IsConst> _In;
            typedef typename _In::difference_type difference_type;
            typedef typename _In::__storage_type __storage_type;
            static const int __bits_per_word = _In::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__first.__ctz_ != 0) {
                    unsigned int __clz_f = __bits_per_word - __first.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                    __storage_type __b = *__first.__seg_ & __m;
                    unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                    __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
                    __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
                    *__result.__seg_ &= ~__m;
                    if (__result.__ctz_ > __first.__ctz_)
                        *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
                    else
                        *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
                    __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__ddn + __result.__ctz_) % __bits_per_word);
                    __dn -= __ddn;
                    if (__dn > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                        *__result.__seg_ &= ~__m;
                        *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                        __result.__ctz_ = static_cast<unsigned int>(__dn);
                    }
                    ++__first.__seg_;
                }
                unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                __storage_type __m = ~__storage_type(0) << __result.__ctz_;
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first.__seg_) {
                    __storage_type __b = *__first.__seg_;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b << __result.__ctz_;
                    ++__result.__seg_;
                    *__result.__seg_ &= __m;
                    *__result.__seg_ |= __b >> __clz_r;
                }
                if (__n > 0) {
                    __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b = *__first.__seg_ & __m;
                    __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
                    __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b << __result.__ctz_;
                    __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__dn + __result.__ctz_) % __bits_per_word);
                    __n -= __dn;
                    if (__n > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __n);
                        *__result.__seg_ &= ~__m;
                        *__result.__seg_ |= __b >> __dn;
                        __result.__ctz_ = static_cast<unsigned int>(__n);
                    }
                }
            }
            return __result;
        }
        template <class _Cp, bool _IsConst> inline __bit_iterator<_Cp, false> copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__first.__ctz_ == __result.__ctz_)
                return __copy_aligned(__first, __last, __result);
            return __copy_unaligned(__first, __last, __result);
        }
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)         {
            typedef __bit_iterator<_Cp, _IsConst> _In;
            typedef typename _In::difference_type difference_type;
            typedef typename _In::__storage_type __storage_type;
            const int __bits_per_word = _In::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__last.__ctz_ != 0) {
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
                    __n -= __dn;
                    unsigned int __clz = __bits_per_word - __last.__ctz_;
                    __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
                    __storage_type __b = *__last.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b;
                    __result.__ctz_ = static_cast<unsigned int>(((- __dn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
                }
                __storage_type __nw = __n / __bits_per_word;
                __result.__seg_ -= __nw;
                __last.__seg_ -= __nw;
                std::__1::memmove(std::__1::__to_address(__result.__seg_), std::__1::__to_address(__last.__seg_), __nw * sizeof(__storage_type));
                __n -= __nw * __bits_per_word;
                if (__n > 0) {
                    __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
                    __storage_type __b = *--__last.__seg_ & __m;
                    *--__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b;
                    __result.__ctz_ = static_cast<unsigned int>(- __n & (__bits_per_word - 1));
                }
            }
            return __result;
        }
        template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)         {
            typedef __bit_iterator<_Cp, _IsConst> _In;
            typedef typename _In::difference_type difference_type;
            typedef typename _In::__storage_type __storage_type;
            const int __bits_per_word = _In::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__last.__ctz_ != 0) {
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
                    __n -= __dn;
                    unsigned int __clz_l = __bits_per_word - __last.__ctz_;
                    __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
                    __storage_type __b = *__last.__seg_ & __m;
                    unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                    __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
                    if (__ddn > 0) {
                        __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                        *__result.__seg_ &= ~__m;
                        if (__result.__ctz_ > __last.__ctz_)
                            *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                        else
                            *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                        __result.__ctz_ = static_cast<unsigned int>(((- __ddn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
                        __dn -= __ddn;
                    }
                    if (__dn > 0) {
                        --__result.__seg_;
                        __result.__ctz_ = static_cast<unsigned int>(- __dn & (__bits_per_word - 1));
                        __m = ~__storage_type(0) << __result.__ctz_;
                        *__result.__seg_ &= ~__m;
                        __last.__ctz_ -= __dn + __ddn;
                        *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                    }
                }
                unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                __storage_type __m = ~__storage_type(0) >> __clz_r;
                for (; __n >= __bits_per_word; __n -= __bits_per_word) {
                    __storage_type __b = *--__last.__seg_;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b >> __clz_r;
                    *--__result.__seg_ &= __m;
                    *__result.__seg_ |= __b << __result.__ctz_;
                }
                if (__n > 0) {
                    __m = ~__storage_type(0) << (__bits_per_word - __n);
                    __storage_type __b = *--__last.__seg_ & __m;
                    __clz_r = __bits_per_word - __result.__ctz_;
                    __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
                    __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
                    __result.__ctz_ = static_cast<unsigned int>(((- __dn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
                    __n -= __dn;
                    if (__n > 0) {
                        --__result.__seg_;
                        __result.__ctz_ = static_cast<unsigned int>(- __n & (__bits_per_word - 1));
                        __m = ~__storage_type(0) << __result.__ctz_;
                        *__result.__seg_ &= ~__m;
                        *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
                    }
                }
            }
            return __result;
        }
        template <class _Cp, bool _IsConst> inline __bit_iterator<_Cp, false> copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__last.__ctz_ == __result.__ctz_)
                return __copy_backward_aligned(__first, __last, __result);
            return __copy_backward_unaligned(__first, __last, __result);
        }
        template <class _Cp, bool _IsConst> inline __bit_iterator<_Cp, false> move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::copy(__first, __last, __result);
        }
        template <class _Cp, bool _IsConst> inline __bit_iterator<_Cp, false> move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::copy_backward(__first, __last, __result);
        }
        template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last, __bit_iterator<__C2, false> __result)         {
            typedef __bit_iterator<__C1, false> _I1;
            typedef typename _I1::difference_type difference_type;
            typedef typename _I1::__storage_type __storage_type;
            const int __bits_per_word = _I1::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__first.__ctz_ != 0) {
                    unsigned int __clz = __bits_per_word - __first.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
                    __storage_type __b1 = *__first.__seg_ & __m;
                    *__first.__seg_ &= ~__m;
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b1;
                    *__first.__seg_ |= __b2;
                    __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__dn + __result.__ctz_) % __bits_per_word);
                    ++__first.__seg_;
                }
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first.__seg_ , ++__result.__seg_)
                    swap(*__first.__seg_, *__result.__seg_);
                if (__n > 0) {
                    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b1 = *__first.__seg_ & __m;
                    *__first.__seg_ &= ~__m;
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b1;
                    *__first.__seg_ |= __b2;
                    __result.__ctz_ = static_cast<unsigned int>(__n);
                }
            }
            return __result;
        }
        template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last, __bit_iterator<__C2, false> __result)         {
            typedef __bit_iterator<__C1, false> _I1;
            typedef typename _I1::difference_type difference_type;
            typedef typename _I1::__storage_type __storage_type;
            const int __bits_per_word = _I1::__bits_per_word;
            difference_type __n = __last - __first;
            if (__n > 0) {
                if (__first.__ctz_ != 0) {
                    unsigned int __clz_f = __bits_per_word - __first.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                    __storage_type __b1 = *__first.__seg_ & __m;
                    *__first.__seg_ &= ~__m;
                    unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                    __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
                    __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    if (__result.__ctz_ > __first.__ctz_) {
                        unsigned int __s = __result.__ctz_ - __first.__ctz_;
                        *__result.__seg_ |= __b1 << __s;
                        *__first.__seg_ |= __b2 >> __s;
                    } else {
                        unsigned int __s = __first.__ctz_ - __result.__ctz_;
                        *__result.__seg_ |= __b1 >> __s;
                        *__first.__seg_ |= __b2 << __s;
                    }
                    __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__ddn + __result.__ctz_) % __bits_per_word);
                    __dn -= __ddn;
                    if (__dn > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                        __b2 = *__result.__seg_ & __m;
                        *__result.__seg_ &= ~__m;
                        unsigned int __s = __first.__ctz_ + __ddn;
                        *__result.__seg_ |= __b1 >> __s;
                        *__first.__seg_ |= __b2 << __s;
                        __result.__ctz_ = static_cast<unsigned int>(__dn);
                    }
                    ++__first.__seg_;
                }
                __storage_type __m = ~__storage_type(0) << __result.__ctz_;
                unsigned int __clz_r = __bits_per_word - __result.__ctz_;
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first.__seg_) {
                    __storage_type __b1 = *__first.__seg_;
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b1 << __result.__ctz_;
                    *__first.__seg_ = __b2 >> __result.__ctz_;
                    ++__result.__seg_;
                    __b2 = *__result.__seg_ & ~__m;
                    *__result.__seg_ &= __m;
                    *__result.__seg_ |= __b1 >> __clz_r;
                    *__first.__seg_ |= __b2 << __clz_r;
                }
                if (__n > 0) {
                    __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b1 = *__first.__seg_ & __m;
                    *__first.__seg_ &= ~__m;
                    __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
                    __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
                    __storage_type __b2 = *__result.__seg_ & __m;
                    *__result.__seg_ &= ~__m;
                    *__result.__seg_ |= __b1 << __result.__ctz_;
                    *__first.__seg_ |= __b2 >> __result.__ctz_;
                    __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
                    __result.__ctz_ = static_cast<unsigned int>((__dn + __result.__ctz_) % __bits_per_word);
                    __n -= __dn;
                    if (__n > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __n);
                        __b2 = *__result.__seg_ & __m;
                        *__result.__seg_ &= ~__m;
                        *__result.__seg_ |= __b1 >> __dn;
                        *__first.__seg_ |= __b2 << __dn;
                        __result.__ctz_ = static_cast<unsigned int>(__n);
                    }
                }
            }
            return __result;
        }
        template <class __C1, class __C2> inline __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1, __bit_iterator<__C2, false> __first2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__first1.__ctz_ == __first2.__ctz_)
                return __swap_ranges_aligned(__first1, __last1, __first2);
            return __swap_ranges_unaligned(__first1, __last1, __first2);
        }
        template <class _Cp> struct __bit_array {
            typedef typename _Cp::difference_type difference_type;
            typedef typename _Cp::__storage_type __storage_type;
            typedef typename _Cp::__storage_pointer __storage_pointer;
            typedef typename _Cp::iterator iterator;
            static const unsigned int __bits_per_word = _Cp::__bits_per_word;
            static const unsigned int _Np = 4;
            std::__1::__bit_array::difference_type __size_;
            std::__1::__bit_array::__storage_type __word_[_Np];
            static std::__1::__bit_array::difference_type capacity() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__bit_array::difference_type>(_Np * __bits_per_word);
            }
            explicit __bit_array<_Cp>(std::__1::__bit_array::difference_type __s) : __size_(__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__bit_array::iterator begin() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bit_array::iterator(pointer_traits<__storage_pointer>::pointer_to(this->__word_[0]), 0);
            }
            std::__1::__bit_array::iterator end() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bit_array::iterator(pointer_traits<__storage_pointer>::pointer_to(this->__word_[0]) + this->__size_ / __bits_per_word, static_cast<unsigned int>(this->__size_ % __bits_per_word));
            }
        };
        template <class _Cp> __bit_iterator<_Cp, false> rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)         {
            typedef __bit_iterator<_Cp, false> _I1;
            typedef typename _I1::difference_type difference_type;
            difference_type __d1 = __middle - __first;
            difference_type __d2 = __last - __middle;
            _I1 __r = __first + __d2;
            while (__d1 != 0 && __d2 != 0)
                {
                    if (__d1 <= __d2) {
                        if (__d1 <= __bit_array<_Cp>::capacity()) {
                            __bit_array<_Cp> __b(__d1);
                            std::__1::copy(__first, __middle, __b.begin());
                            std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                            break;
                        } else {
                            __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                            __first = __middle;
                            __middle = __mp;
                            __d2 -= __d1;
                        }
                    } else {
                        if (__d2 <= __bit_array<_Cp>::capacity()) {
                            __bit_array<_Cp> __b(__d2);
                            std::__1::copy(__middle, __last, __b.begin());
                            std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                            break;
                        } else {
                            __bit_iterator<_Cp, false> __mp = __first + __d2;
                            std::__1::swap_ranges(__first, __mp, __middle);
                            __first = __mp;
                            __d1 -= __d2;
                        }
                    }
                }
            return __r;
        }
        template <class _Cp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)         {
            typedef __bit_iterator<_Cp, _IC1> _It;
            typedef typename _It::difference_type difference_type;
            typedef typename _It::__storage_type __storage_type;
            static const int __bits_per_word = _It::__bits_per_word;
            difference_type __n = __last1 - __first1;
            if (__n > 0) {
                if (__first1.__ctz_ != 0) {
                    unsigned int __clz_f = __bits_per_word - __first1.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
                    __storage_type __b = *__first1.__seg_ & __m;
                    unsigned int __clz_r = __bits_per_word - __first2.__ctz_;
                    __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
                    __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
                    if (__first2.__ctz_ > __first1.__ctz_) {
                        if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                            return false;
                    } else {
                        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                            return false;
                    }
                    __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
                    __first2.__ctz_ = static_cast<unsigned int>((__ddn + __first2.__ctz_) % __bits_per_word);
                    __dn -= __ddn;
                    if (__dn > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                            return false;
                        __first2.__ctz_ = static_cast<unsigned int>(__dn);
                    }
                    ++__first1.__seg_;
                }
                unsigned int __clz_r = __bits_per_word - __first2.__ctz_;
                __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first1.__seg_) {
                    __storage_type __b = *__first1.__seg_;
                    if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                        return false;
                    ++__first2.__seg_;
                    if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                        return false;
                }
                if (__n > 0) {
                    __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    __storage_type __b = *__first1.__seg_ & __m;
                    __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
                    __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
                    if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                        return false;
                    __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
                    __first2.__ctz_ = static_cast<unsigned int>((__dn + __first2.__ctz_) % __bits_per_word);
                    __n -= __dn;
                    if (__n > 0) {
                        __m = ~__storage_type(0) >> (__bits_per_word - __n);
                        if ((*__first2.__seg_ & __m) != (__b >> __dn))
                            return false;
                    }
                }
            }
            return true;
        }
        template <class _Cp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)         {
            typedef __bit_iterator<_Cp, _IC1> _It;
            typedef typename _It::difference_type difference_type;
            typedef typename _It::__storage_type __storage_type;
            static const int __bits_per_word = _It::__bits_per_word;
            difference_type __n = __last1 - __first1;
            if (__n > 0) {
                if (__first1.__ctz_ != 0) {
                    unsigned int __clz = __bits_per_word - __first1.__ctz_;
                    difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
                    __n -= __dn;
                    __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
                    if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                        return false;
                    ++__first2.__seg_;
                    ++__first1.__seg_;
                }
                for (; __n >= __bits_per_word; __n -= __bits_per_word , ++__first1.__seg_ , ++__first2.__seg_)
                    if (*__first2.__seg_ != *__first1.__seg_)
                        return false;
                if (__n > 0) {
                    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
                    if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                        return false;
                }
            }
            return true;
        }
        template <class _Cp, bool _IC1, bool _IC2> inline bool equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__first1.__ctz_ == __first2.__ctz_)
                return __equal_aligned(__first1, __last1, __first2);
            return __equal_unaligned(__first1, __last1, __first2);
        }
        template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator {
        public:
            typedef typename _Cp::difference_type difference_type;
            typedef bool value_type;
            typedef __bit_iterator<_Cp, _IsConst, > pointer;
            typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename _Cp::__storage_type __storage_type;
            typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer, typename _Cp::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = _Cp::__bits_per_word;
            std::__1::__bit_iterator::__storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator<_Cp, _IsConst, >() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            struct __private_nat;
            using __type_for_copy_to_const = _If<_IsConst, __bit_iterator<_Cp, false>, struct __private_nat>;
            __bit_iterator<_Cp, _IsConst, >(const std::__1::__bit_iterator::__type_for_copy_to_const &__it) throw() : __seg_(__it.__seg_), __ctz_(__it.__ctz_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            using __type_for_abi_non_trivial_copy_ctor = _If<!_IsConst, __bit_iterator<_Cp, _IsConst, >, struct __private_nat>;
            __bit_iterator<_Cp, _IsConst, >(const std::__1::__bit_iterator::__type_for_abi_non_trivial_copy_ctor &__it) throw() : __seg_(__it.__seg_), __ctz_(__it.__ctz_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __bit_iterator<_Cp, _IsConst, > &operator=(const __bit_iterator<_Cp, _IsConst, > &) __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = default
            std::__1::__bit_iterator::reference operator*() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bit_iterator::reference(this->__seg_, std::__1::__bit_iterator::__storage_type(1) << this->__ctz_);
            }
            __bit_iterator<_Cp, _IsConst, > &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__ctz_ != __bits_per_word - 1)
                    ++this->__ctz_;
                else {
                    this->__ctz_ = 0;
                    ++this->__seg_;
                }
                return *this;
            }
            __bit_iterator<_Cp, _IsConst, > operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __bit_iterator<_Cp, _IsConst, > __tmp = *this;
                ++(*this);
                return __tmp;
            }
            __bit_iterator<_Cp, _IsConst, > &operator--() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__ctz_ != 0)
                    --this->__ctz_;
                else {
                    this->__ctz_ = __bits_per_word - 1;
                    --this->__seg_;
                }
                return *this;
            }
            __bit_iterator<_Cp, _IsConst, > operator--(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __bit_iterator<_Cp, _IsConst, > __tmp = *this;
                --(*this);
                return __tmp;
            }
            __bit_iterator<_Cp, _IsConst, > &operator+=(std::__1::__bit_iterator::difference_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__n >= 0)
                    this->__seg_ += (__n + this->__ctz_) / __bits_per_word;
                else
                    this->__seg_ += static_cast<std::__1::__bit_iterator::difference_type>(__n - __bits_per_word + this->__ctz_ + 1) / static_cast<std::__1::__bit_iterator::difference_type>(__bits_per_word);
                __n &= (__bits_per_word - 1);
                this->__ctz_ = static_cast<unsigned int>((__n + this->__ctz_) % __bits_per_word);
                return *this;
            }
            __bit_iterator<_Cp, _IsConst, > &operator-=(std::__1::__bit_iterator::difference_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this += - __n;
            }
            __bit_iterator<_Cp, _IsConst, > operator+(std::__1::__bit_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __bit_iterator<_Cp, _IsConst, > __t(*this);
                __t += __n;
                return __t;
            }
            __bit_iterator<_Cp, _IsConst, > operator-(std::__1::__bit_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __bit_iterator<_Cp, _IsConst, > __t(*this);
                __t -= __n;
                return __t;
            }
            friend __bit_iterator<_Cp, _IsConst, > operator+(std::__1::__bit_iterator::difference_type __n, const __bit_iterator<_Cp, _IsConst, > &__it) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __it + __n;
            }
;
            friend std::__1::__bit_iterator::difference_type operator-(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;
            }
;
            std::__1::__bit_iterator::reference operator[](std::__1::__bit_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *(*this + __n);
            }
            friend bool operator==(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;
            }
;
            friend bool operator!=(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x == __y);
            }
;
            friend bool operator<(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);
            }
;
            friend bool operator>(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __y < __x;
            }
;
            friend bool operator<=(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__y < __x);
            }
;
            friend bool operator>=(const __bit_iterator<_Cp, _IsConst, > &__x, const __bit_iterator<_Cp, _IsConst, > &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x < __y);
            }
;
        private:
            __bit_iterator<_Cp, _IsConst, >(std::__1::__bit_iterator::__storage_pointer __s, unsigned int __ctz) throw() : __seg_(__s), __ctz_(__ctz) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend  typename _Cp::__self;
            friend  class __bit_reference<_Cp>;
            friend  class __bit_const_reference<_Cp>;
            friend  class __bit_iterator<_Cp, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        };
template<> class __bit_iterator<std::__1::__bitset<0, 0>, false, 0> {
        public:
            typedef typename __bitset<0, 0>::difference_type difference_type;
            typedef bool value_type;
            typedef std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> pointer;
            typedef typename conditional<false, __bit_const_reference<__bitset<0, 0> >, __bit_reference<__bitset<0, 0> > >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename conditional<false, typename __bitset<0, 0>::__const_storage_pointer, typename __bitset<0, 0>::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = __bitset<0, 0>::__bits_per_word;
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::__storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator() throw() __attribute__((internal_linkage));
            using __type_for_copy_to_const = _If<false, __bit_iterator<std::__1::__bitset<0, 0>, false>, struct __private_nat>;
            __bit_iterator(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::__type_for_copy_to_const &__it) throw() __attribute__((internal_linkage));
            using __type_for_abi_non_trivial_copy_ctor = _If<!false, std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>, struct __private_nat>;
            __bit_iterator(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::__type_for_abi_non_trivial_copy_ctor &__it) throw() : __seg_(__it.__seg_), __ctz_(__it.__ctz_) __attribute__((internal_linkage))             {
            }
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &) __attribute__((internal_linkage)) = default
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::reference operator*() const throw() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator++() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator++(int) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator--() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator--(int) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator+=(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &operator-=(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator+(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) const __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator-(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) const __attribute__((internal_linkage));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> operator+(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__it) __attribute__((internal_linkage));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type operator-(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::reference operator[](std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::difference_type __n) const __attribute__((internal_linkage));
            friend bool operator==(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator!=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator<(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator>(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator<=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
            friend bool operator>=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0> &__y) __attribute__((internal_linkage));
        private:
            __bit_iterator(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, false, 0>::__storage_pointer __s, unsigned int __ctz) throw() : __seg_(__s), __ctz_(__ctz) __attribute__((internal_linkage))             {
            }
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        };
template<> class __bit_iterator<std::__1::__bitset<0, 0>, true, 0> {
        public:
            typedef typename __bitset<0, 0>::difference_type difference_type;
            typedef bool value_type;
            typedef std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> pointer;
            typedef typename conditional<true, __bit_const_reference<__bitset<0, 0> >, __bit_reference<__bitset<0, 0> > >::type reference;
            typedef std::__1::random_access_iterator_tag iterator_category;
        private:
            typedef typename __bitset<0, 0>::__storage_type __storage_type;
            typedef typename conditional<true, typename __bitset<0, 0>::__const_storage_pointer, typename __bitset<0, 0>::__storage_pointer>::type __storage_pointer;
            static const unsigned int __bits_per_word = __bitset<0, 0>::__bits_per_word;
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::__storage_pointer __seg_;
            unsigned int __ctz_;
        public:
            __bit_iterator() throw() __attribute__((internal_linkage));
            using __type_for_copy_to_const = _If<true, __bit_iterator<std::__1::__bitset<0, 0>, false>, struct __private_nat>;
            __bit_iterator(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::__type_for_copy_to_const &__it) throw() __attribute__((internal_linkage));
            using __type_for_abi_non_trivial_copy_ctor = _If<!true, std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>, struct __private_nat>;
            __bit_iterator(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::__type_for_abi_non_trivial_copy_ctor &__it) throw() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &) __attribute__((internal_linkage)) = default
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::reference operator*() const throw() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator++() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator++(int) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator--() __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator--(int) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator+=(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &operator-=(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator+(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) const __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator-(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) const __attribute__((internal_linkage));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> operator+(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__it) __attribute__((internal_linkage));
            friend std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type operator-(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::reference operator[](std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::difference_type __n) const __attribute__((internal_linkage));
            friend bool operator==(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator!=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator<(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator>(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator<=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
            friend bool operator>=(const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__x, const std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0> &__y) __attribute__((internal_linkage));
        private:
            __bit_iterator(std::__1::__bit_iterator<std::__1::__bitset<0, 0>, true, 0>::__storage_pointer __s, unsigned int __ctz) throw() : __seg_(__s), __ctz_(__ctz) __attribute__((internal_linkage))             {
            }
            friend  typename __bitset<0, 0>::__self;
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend template <class _Dp> struct __bit_array;
            friend template <class _Dp> void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp> void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class __C1, class __C2> __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>, __bit_iterator<__C1, false>, __bit_iterator<__C2, false>);
            friend template <class _Dp> __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC1, bool _IC2> bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
            friend template <class _Dp, bool _IC> typename __bit_iterator<_Dp, _IC>::difference_type __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
        };
    }
}
namespace std {
    inline namespace __1 {
        template <bool> class __split_buffer_common {
        protected:
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
template<> class __split_buffer_common<true> {
        protected:
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
        template <class _Tp, class _Allocator = allocator<_Tp>> struct __split_buffer : private __split_buffer_common<true> {
        private:
            __split_buffer<_Tp, _Allocator>(const __split_buffer<_Tp, _Allocator> &);
            __split_buffer<_Tp, _Allocator> &operator=(const __split_buffer<_Tp, _Allocator> &);
        public:
            typedef _Tp value_type;
            typedef _Allocator allocator_type;
            typedef typename remove_reference<allocator_type>::type __alloc_rr;
            typedef allocator_traits<std::__1::__split_buffer::__alloc_rr> __alloc_traits;
            typedef std::__1::__split_buffer::value_type &reference;
            typedef const std::__1::__split_buffer::value_type &const_reference;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            typedef std::__1::__split_buffer::pointer iterator;
            typedef std::__1::__split_buffer::const_pointer const_iterator;
            std::__1::__split_buffer::pointer __first_;
            std::__1::__split_buffer::pointer __begin_;
            std::__1::__split_buffer::pointer __end_;
            __compressed_pair<std::__1::__split_buffer::pointer, std::__1::__split_buffer::allocator_type> __end_cap_;
            typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
            typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;
            std::__1::__split_buffer::__alloc_rr &__alloc() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_cap_.second();
            }
            const std::__1::__split_buffer::__alloc_rr &__alloc() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_cap_.second();
            }
            std::__1::__split_buffer::pointer &__end_cap() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_cap_.first();
            }
            const std::__1::__split_buffer::pointer &__end_cap() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_cap_.first();
            }
            __split_buffer<_Tp, _Allocator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit __split_buffer<_Tp, _Allocator>(std::__1::__split_buffer::__alloc_rr &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit __split_buffer<_Tp, _Allocator>(const std::__1::__split_buffer::__alloc_rr &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            __split_buffer<_Tp, _Allocator>(std::__1::__split_buffer::size_type __cap, std::__1::__split_buffer::size_type __start, std::__1::__split_buffer::__alloc_rr &__a);
            ~__split_buffer<_Tp, _Allocator>();
            std::__1::__split_buffer::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__begin_;
            }
            std::__1::__split_buffer::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__begin_;
            }
            std::__1::__split_buffer::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_;
            }
            std::__1::__split_buffer::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_;
            }
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __destruct_at_end(this->__begin_);
            }
            std::__1::__split_buffer::size_type size() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__split_buffer::size_type>(this->__end_ - this->__begin_);
            }
            bool empty() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_ == this->__begin_;
            }
            std::__1::__split_buffer::size_type capacity() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__split_buffer::size_type>(__end_cap() - this->__first_);
            }
            std::__1::__split_buffer::size_type __front_spare() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__split_buffer::size_type>(this->__begin_ - this->__first_);
            }
            std::__1::__split_buffer::size_type __back_spare() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__split_buffer::size_type>(__end_cap() - this->__end_);
            }
            std::__1::__split_buffer::reference front() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__begin_;
            }
            std::__1::__split_buffer::const_reference front() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__begin_;
            }
            std::__1::__split_buffer::reference back() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *(this->__end_ - 1);
            }
            std::__1::__split_buffer::const_reference back() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *(this->__end_ - 1);
            }
            void reserve(std::__1::__split_buffer::size_type __n);
            void shrink_to_fit() throw();
            void push_front(std::__1::__split_buffer::const_reference __x);
            void push_back(std::__1::__split_buffer::const_reference __x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void pop_front() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __destruct_at_begin(this->__begin_ + 1);
            }
            void pop_back() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __destruct_at_end(this->__end_ - 1);
            }
            void __construct_at_end(std::__1::__split_buffer::size_type __n);
            void __construct_at_end(std::__1::__split_buffer::size_type __n, std::__1::__split_buffer::const_reference __x);
            template <class _InputIter> typename enable_if<__is_cpp17_input_iterator<_InputIter>::value && !__is_cpp17_forward_iterator<_InputIter>::value, void>::type __construct_at_end(_InputIter __first, _InputIter __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
            void __destruct_at_begin(std::__1::__split_buffer::pointer __new_begin) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __destruct_at_begin(__new_begin, is_trivially_destructible<std::__1::__split_buffer::value_type>());
            }
            void __destruct_at_begin(std::__1::__split_buffer::pointer __new_begin, std::__1::false_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __destruct_at_begin(std::__1::__split_buffer::pointer __new_begin, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __destruct_at_end(std::__1::__split_buffer::pointer __new_last) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __destruct_at_end(__new_last, std::__1::false_type());
            }
            void __destruct_at_end(std::__1::__split_buffer::pointer __new_last, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __destruct_at_end(std::__1::__split_buffer::pointer __new_last, std::__1::true_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void swap(__split_buffer<_Tp, _Allocator> &__x);
            bool __invariants() const;
        private:
            void __move_assign_alloc(__split_buffer<_Tp, _Allocator> &__c, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __alloc() = std::__1::move(__c.__alloc());
            }
            void __move_assign_alloc(__split_buffer<_Tp, _Allocator> &, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            struct _ConstructTransaction {
                explicit _ConstructTransaction(std::__1::__split_buffer::pointer *__p, std::__1::__split_buffer::size_type __n) throw() : __pos_(*__p), __end_(*__p + __n), __dest_(__p)                 {
                }
                ~_ConstructTransaction()                 {
                    *this->__dest_ = this->__pos_;
                }
                std::__1::__split_buffer::pointer __pos_;
                const std::__1::__split_buffer::pointer __end_;
            private:
                std::__1::__split_buffer::pointer *__dest_;
            };
        };
template<> struct __split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &> : private __split_buffer_common<true> {
        private:
            __split_buffer(const std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &> &);
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &> &operator=(const std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &> &);
        public:
            typedef std::__1::basic_string<char> value_type;
            typedef std::__1::allocator<std::__1::basic_string<char> > &allocator_type;
            typedef typename remove_reference<allocator_type>::type __alloc_rr;
            typedef allocator_traits<std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::__alloc_rr> __alloc_traits;
            typedef std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::value_type &reference;
            typedef const std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::value_type &const_reference;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            typedef std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer iterator;
            typedef std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::const_pointer const_iterator;
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer __first_;
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer __begin_;
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer __end_;
            __compressed_pair<std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer, std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::allocator_type> __end_cap_;
            typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
            typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::__alloc_rr &__alloc() throw() __attribute__((internal_linkage))             {
                return this->__end_cap_.second();
            }
            const std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::__alloc_rr &__alloc() const throw() __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer &__end_cap() throw() __attribute__((internal_linkage))             {
                return this->__end_cap_.first();
            }
            const std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer &__end_cap() const throw() __attribute__((internal_linkage))             {
                return this->__end_cap_.first();
            }
            __split_buffer();
            explicit __split_buffer(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::__alloc_rr &__a);
            explicit __split_buffer(const std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::__alloc_rr &__a);
            __split_buffer<basic_string<char>, allocator<basic_string<char> > &>::__split_buffer(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type __cap, std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type __start, std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::__alloc_rr &__a) : __split_buffer_common<true>(), __end_cap_(std::__1::__get_nullptr_t(), __a)             {
                this->__first_ = __cap != 0 ? __alloc_traits::allocate(this->__alloc(), __cap) : std::__1::__get_nullptr_t();
                this->__begin_ = this->__end_ = this->__first_ + __start;
                this->__end_cap() = this->__first_ + __cap;
            }
            __split_buffer<basic_string<char>, allocator<basic_string<char> > &>::~__split_buffer<basic_string<char>, allocator<basic_string<char> > &>()             {
                this->clear();
                if (this->__first_)
                    __alloc_traits::deallocate(this->__alloc(), this->__first_, this->capacity());
            }
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::iterator begin() throw() __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::const_iterator begin() const throw() __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::iterator end() throw() __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::const_iterator end() const throw() __attribute__((internal_linkage));
            void clear() throw() __attribute__((internal_linkage))             {
                this->__destruct_at_end(this->__begin_);
            }
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type size() const __attribute__((internal_linkage));
            bool empty() const __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type capacity() const __attribute__((internal_linkage))             {
                return static_cast<std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type>(this->__end_cap() - this->__first_);
            }
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type __front_spare() const __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type __back_spare() const __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::reference front() __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::const_reference front() const __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::reference back() __attribute__((internal_linkage));
            std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::const_reference back() const __attribute__((internal_linkage));
            void reserve(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type __n);
            void shrink_to_fit() throw();
            void push_front(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::const_reference __x);
            void push_back(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::const_reference __x) __attribute__((internal_linkage));
            void pop_front() __attribute__((internal_linkage));
            void pop_back() __attribute__((internal_linkage));
            void __construct_at_end(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type __n);
            void __construct_at_end(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::size_type __n, std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::const_reference __x);
            template <class _InputIter> typename enable_if<__is_cpp17_input_iterator<_InputIter>::value && !__is_cpp17_forward_iterator<_InputIter>::value, void>::type __construct_at_end(_InputIter __first, _InputIter __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
            void __destruct_at_begin(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer __new_begin) __attribute__((internal_linkage));
            void __destruct_at_begin(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer __new_begin, std::__1::false_type);
            void __destruct_at_begin(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer __new_begin, std::__1::true_type);
            void __destruct_at_end(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer __new_last) throw() __attribute__((internal_linkage))             {
                this->__destruct_at_end(__new_last, std::__1::false_type());
            }
            void __split_buffer<basic_string<char>, allocator<basic_string<char> > &>::__destruct_at_end(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer __new_last, std::__1::false_type) throw() __attribute__((internal_linkage))             {
                while (__new_last != this->__end_)
                    __alloc_traits::destroy(this->__alloc(), __to_address(--this->__end_));
            }
            void __destruct_at_end(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &>::pointer __new_last, std::__1::true_type) throw() __attribute__((internal_linkage));
            void swap(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &> &__x);
            bool __invariants() const;
        private:
            void __move_assign_alloc(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &> &__c, std::__1::true_type) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::__split_buffer<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > &> &, std::__1::false_type) throw() __attribute__((internal_linkage));
            struct _ConstructTransaction;
        };
        template <class _Tp, class _Allocator> bool __split_buffer<_Tp, _Allocator>::__invariants() const         {
            if (this->__first_ == std::__1::__get_nullptr_t()) {
                if (this->__begin_ != std::__1::__get_nullptr_t())
                    return false;
                if (this->__end_ != std::__1::__get_nullptr_t())
                    return false;
                if (__end_cap() != std::__1::__get_nullptr_t())
                    return false;
            } else {
                if (this->__begin_ < this->__first_)
                    return false;
                if (this->__end_ < this->__begin_)
                    return false;
                if (__end_cap() < this->__end_)
                    return false;
            }
            return true;
        }
        template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::__construct_at_end(std::__1::__split_buffer::size_type __n)         {
            std::__1::__split_buffer::_ConstructTransaction __tx(&this->__end_, __n);
            for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
                __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_));
            }
        }
        template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::__construct_at_end(std::__1::__split_buffer::size_type __n, std::__1::__split_buffer::const_reference __x)         {
            std::__1::__split_buffer::_ConstructTransaction __tx(&this->__end_, __n);
            for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
                __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_), __x);
            }
        }
        template <class _Tp, class _Allocator> template <class _InputIter> typename enable_if<__is_cpp17_input_iterator<_InputIter>::value && !__is_cpp17_forward_iterator<_InputIter>::value, void>::type __split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)         {
            std::__1::__split_buffer::__alloc_rr &__a = this->__alloc();
            for (; __first != __last; ++__first) {
                if (this->__end_ == __end_cap()) {
                    std::__1::__split_buffer::size_type __old_cap = __end_cap() - this->__first_;
                    std::__1::__split_buffer::size_type __new_cap = std::__1::max<std::__1::__split_buffer::size_type>(2 * __old_cap, 8);
                    __split_buffer<_Tp, _Allocator> __buf(__new_cap, 0, __a);
                    for (std::__1::__split_buffer::pointer __p = this->__begin_; __p != this->__end_; ++__p , ++__buf.__end_)
                        __alloc_traits::construct(__buf.__alloc(), std::__1::__to_address(__buf.__end_), std::__1::move(*__p));
                    this->swap(__buf);
                }
                __alloc_traits::construct(__a, std::__1::__to_address(this->__end_), *__first);
                ++this->__end_;
            }
        }
        template <class _Tp, class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)         {
            std::__1::__split_buffer::_ConstructTransaction __tx(&this->__end_, std::distance(__first, __last));
            for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_ , ++__first) {
                __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_), *__first);
            }
        }
        template <class _Tp, class _Allocator> inline void __split_buffer<_Tp, _Allocator>::__destruct_at_begin(std::__1::__split_buffer::pointer __new_begin, std::__1::false_type)         {
            while (this->__begin_ != __new_begin)
                __alloc_traits::destroy(__alloc(), __to_address(this->__begin_++));
        }
        template <class _Tp, class _Allocator> inline void __split_buffer<_Tp, _Allocator>::__destruct_at_begin(std::__1::__split_buffer::pointer __new_begin, std::__1::true_type)         {
            this->__begin_ = __new_begin;
        }
        template <class _Tp, class _Allocator> inline void __split_buffer<_Tp, _Allocator>::__destruct_at_end(std::__1::__split_buffer::pointer __new_last, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            while (__new_last != this->__end_)
                __alloc_traits::destroy(__alloc(), __to_address(--this->__end_));
        }
        template <class _Tp, class _Allocator> inline void __split_buffer<_Tp, _Allocator>::__destruct_at_end(std::__1::__split_buffer::pointer __new_last, std::__1::true_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->__end_ = __new_last;
        }
        template <class _Tp, class _Allocator> __split_buffer<_Tp, _Allocator>::__split_buffer<_Tp, _Allocator>(std::__1::__split_buffer::size_type __cap, std::__1::__split_buffer::size_type __start, std::__1::__split_buffer::__alloc_rr &__a) : __end_cap_(std::__1::__get_nullptr_t(), __a)         {
            this->__first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : std::__1::__get_nullptr_t();
            this->__begin_ = this->__end_ = this->__first_ + __start;
            __end_cap() = this->__first_ + __cap;
        }
        template <class _Tp, class _Allocator> inline __split_buffer<_Tp, _Allocator>::__split_buffer<_Tp, _Allocator>() : __first_(std::__1::__get_nullptr_t()), __begin_(std::__1::__get_nullptr_t()), __end_(std::__1::__get_nullptr_t()), __end_cap_(std::__1::__get_nullptr_t(), std::__1::__default_init_tag())         {
        }
        template <class _Tp, class _Allocator> inline explicit __split_buffer<_Tp, _Allocator>::__split_buffer<_Tp, _Allocator>(std::__1::__split_buffer::__alloc_rr &__a) : __first_(std::__1::__get_nullptr_t()), __begin_(std::__1::__get_nullptr_t()), __end_(std::__1::__get_nullptr_t()), __end_cap_(std::__1::__get_nullptr_t(), __a)         {
        }
        template <class _Tp, class _Allocator> inline explicit __split_buffer<_Tp, _Allocator>::__split_buffer<_Tp, _Allocator>(const std::__1::__split_buffer::__alloc_rr &__a) : __first_(std::__1::__get_nullptr_t()), __begin_(std::__1::__get_nullptr_t()), __end_(std::__1::__get_nullptr_t()), __end_cap_(std::__1::__get_nullptr_t(), __a)         {
        }
        template <class _Tp, class _Allocator> __split_buffer<_Tp, _Allocator>::~__split_buffer<_Tp, _Allocator>()         {
            this->clear();
            if (this->__first_)
                __alloc_traits::deallocate(__alloc(), this->__first_, this->capacity());
        }
        template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::swap(__split_buffer<_Tp, _Allocator> &__x)         {
            std::__1::swap(this->__first_, __x.__first_);
            std::__1::swap(this->__begin_, __x.__begin_);
            std::__1::swap(this->__end_, __x.__end_);
            std::__1::swap(__end_cap(), __x.__end_cap());
            __swap_allocator(__alloc(), __x.__alloc());
        }
        template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::reserve(std::__1::__split_buffer::size_type __n)         {
            if (__n < this->capacity()) {
                __split_buffer<std::__1::__split_buffer::value_type, std::__1::__split_buffer::__alloc_rr &> __t(__n, 0, __alloc());
                __t.__construct_at_end(move_iterator<std::__1::__split_buffer::pointer>(this->__begin_), move_iterator<std::__1::__split_buffer::pointer>(this->__end_));
                std::__1::swap(this->__first_, __t.__first_);
                std::__1::swap(this->__begin_, __t.__begin_);
                std::__1::swap(this->__end_, __t.__end_);
                std::__1::swap(__end_cap(), __t.__end_cap());
            }
        }
        template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::shrink_to_fit() throw()         {
            if (this->capacity() > this->size()) {
                try {
                    __split_buffer<std::__1::__split_buffer::value_type, std::__1::__split_buffer::__alloc_rr &> __t(this->size(), 0, __alloc());
                    __t.__construct_at_end(move_iterator<std::__1::__split_buffer::pointer>(this->__begin_), move_iterator<std::__1::__split_buffer::pointer>(this->__end_));
                    __t.__end_ = __t.__begin_ + (this->__end_ - this->__begin_);
                    std::__1::swap(this->__first_, __t.__first_);
                    std::__1::swap(this->__begin_, __t.__begin_);
                    std::__1::swap(this->__end_, __t.__end_);
                    std::__1::swap(__end_cap(), __t.__end_cap());
                } catch (...) {
                }
            }
        }
        template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::push_front(std::__1::__split_buffer::const_reference __x)         {
            if (this->__begin_ == this->__first_) {
                if (this->__end_ < __end_cap()) {
                    std::__1::__split_buffer::difference_type __d = __end_cap() - this->__end_;
                    __d = (__d + 1) / 2;
                    this->__begin_ = std::__1::move_backward(this->__begin_, this->__end_, this->__end_ + __d);
                    this->__end_ += __d;
                } else {
                    std::__1::__split_buffer::size_type __c = max<std::__1::__split_buffer::size_type>(2 * static_cast<size_t>(__end_cap() - this->__first_), 1);
                    __split_buffer<std::__1::__split_buffer::value_type, std::__1::__split_buffer::__alloc_rr &> __t(__c, (__c + 3) / 4, __alloc());
                    __t.__construct_at_end(move_iterator<std::__1::__split_buffer::pointer>(this->__begin_), move_iterator<std::__1::__split_buffer::pointer>(this->__end_));
                    std::__1::swap(this->__first_, __t.__first_);
                    std::__1::swap(this->__begin_, __t.__begin_);
                    std::__1::swap(this->__end_, __t.__end_);
                    std::__1::swap(__end_cap(), __t.__end_cap());
                }
            }
            __alloc_traits::construct(__alloc(), std::__1::__to_address(this->__begin_ - 1), __x);
            --this->__begin_;
        }
        template <class _Tp, class _Allocator> inline void __split_buffer<_Tp, _Allocator>::push_back(std::__1::__split_buffer::const_reference __x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (this->__end_ == __end_cap()) {
                if (this->__begin_ > this->__first_) {
                    std::__1::__split_buffer::difference_type __d = this->__begin_ - this->__first_;
                    __d = (__d + 1) / 2;
                    this->__end_ = std::__1::move(this->__begin_, this->__end_, this->__begin_ - __d);
                    this->__begin_ -= __d;
                } else {
                    std::__1::__split_buffer::size_type __c = max<std::__1::__split_buffer::size_type>(2 * static_cast<size_t>(__end_cap() - this->__first_), 1);
                    __split_buffer<std::__1::__split_buffer::value_type, std::__1::__split_buffer::__alloc_rr &> __t(__c, __c / 4, __alloc());
                    __t.__construct_at_end(move_iterator<std::__1::__split_buffer::pointer>(this->__begin_), move_iterator<std::__1::__split_buffer::pointer>(this->__end_));
                    std::__1::swap(this->__first_, __t.__first_);
                    std::__1::swap(this->__begin_, __t.__begin_);
                    std::__1::swap(this->__end_, __t.__end_);
                    std::__1::swap(__end_cap(), __t.__end_cap());
                }
            }
            __alloc_traits::construct(__alloc(), std::__1::__to_address(this->__end_), __x);
            ++this->__end_;
        }
        template <class _Tp, class _Allocator> inline void swap(__split_buffer<_Tp, _Allocator> &__x, __split_buffer<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
    }
}
namespace std {
    inline namespace __1 {
        template <bool> class __attribute__((type_visibility("default"))) __vector_base_common {
        protected:
            __vector_base_common<>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
        template <bool __b> void __vector_base_common<__b>::__throw_length_error() const         {
            std::__1::__throw_length_error("vector");
        }
        template <bool __b> void __vector_base_common<__b>::__throw_out_of_range() const         {
            std::__1::__throw_out_of_range("vector");
        }
        template<> class __attribute__((visibility("default"))) __vector_base_common<true> {
        protected:
            __vector_base_common() __attribute__((internal_linkage))             {
            }
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
        template <class _Tp, class _Allocator> class __vector_base : protected __vector_base_common<true> {
        public:
            typedef _Allocator allocator_type;
            typedef allocator_traits<std::__1::__vector_base::allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
        protected:
            typedef _Tp value_type;
            typedef std::__1::__vector_base::value_type &reference;
            typedef const std::__1::__vector_base::value_type &const_reference;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            typedef std::__1::__vector_base::pointer iterator;
            typedef std::__1::__vector_base::const_pointer const_iterator;
            std::__1::__vector_base::pointer __begin_;
            std::__1::__vector_base::pointer __end_;
            __compressed_pair<std::__1::__vector_base::pointer, std::__1::__vector_base::allocator_type> __end_cap_;
            std::__1::__vector_base::allocator_type &__alloc() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_cap_.second();
            }
            const std::__1::__vector_base::allocator_type &__alloc() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_cap_.second();
            }
            std::__1::__vector_base::pointer &__end_cap() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_cap_.first();
            }
            const std::__1::__vector_base::pointer &__end_cap() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__end_cap_.first();
            }
            __vector_base<_Tp, _Allocator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            __vector_base<_Tp, _Allocator>(const std::__1::__vector_base::allocator_type &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            ~__vector_base<_Tp, _Allocator>();
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__destruct_at_end(this->__begin_);
            }
            std::__1::__vector_base::size_type capacity() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__vector_base::size_type>(__end_cap() - this->__begin_);
            }
            void __destruct_at_end(std::__1::__vector_base::pointer __new_last) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __copy_assign_alloc(const __vector_base<_Tp, _Allocator> &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __copy_assign_alloc(__c, integral_constant<bool, __alloc_traits::propagate_on_container_copy_assignment::value>());
            }
            void __move_assign_alloc(__vector_base<_Tp, _Allocator> &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __move_assign_alloc(__c, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
            }
        private:
            void __copy_assign_alloc(const __vector_base<_Tp, _Allocator> &__c, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__alloc() != __c.__alloc()) {
                    this->clear();
                    __alloc_traits::deallocate(__alloc(), this->__begin_, this->capacity());
                    this->__begin_ = this->__end_ = __end_cap() = std::__1::__get_nullptr_t();
                }
                __alloc() = __c.__alloc();
            }
            void __copy_assign_alloc(const __vector_base<_Tp, _Allocator> &, std::__1::false_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __move_assign_alloc(__vector_base<_Tp, _Allocator> &__c, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __alloc() = std::__1::move(__c.__alloc());
            }
            void __move_assign_alloc(__vector_base<_Tp, _Allocator> &, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
template<> class __vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> >> : protected __vector_base_common<true> {
        public:
            typedef std::__1::allocator<std::__1::basic_string<char> > allocator_type;
            typedef allocator_traits<std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
        protected:
            typedef std::__1::basic_string<char> value_type;
            typedef std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type &reference;
            typedef const std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type &const_reference;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            typedef std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer iterator;
            typedef std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_pointer const_iterator;
            std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __begin_;
            std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __end_;
            __compressed_pair<std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer, std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type> __end_cap_;
            std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__alloc() throw() __attribute__((internal_linkage))             {
                return this->__end_cap_.second();
            }
            const std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__alloc() const throw() __attribute__((internal_linkage))             {
                return this->__end_cap_.second();
            }
            std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer &__end_cap() throw() __attribute__((internal_linkage))             {
                return this->__end_cap_.first();
            }
            const std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer &__end_cap() const throw() __attribute__((internal_linkage))             {
                return this->__end_cap_.first();
            }
            __vector_base<basic_string<char>, allocator<basic_string<char> > >::__vector_base() : __vector_base_common<true>(), __begin_(std::__1::__get_nullptr_t()), __end_(std::__1::__get_nullptr_t()), __end_cap_(std::__1::__get_nullptr_t(), std::__1::__default_init_tag()) __attribute__((internal_linkage))             {
            }
            __vector_base(const std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a) __attribute__((internal_linkage));
            __vector_base<basic_string<char>, allocator<basic_string<char> > >::~__vector_base<basic_string<char>, allocator<basic_string<char> > >()             {
                if (this->__begin_ != std::__1::__get_nullptr_t()) {
                    this->clear();
                    __alloc_traits::deallocate(this->__alloc(), this->__begin_, this->capacity());
                }
            }
            void clear() throw() __attribute__((internal_linkage))             {
                this->__destruct_at_end(this->__begin_);
            }
            std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type capacity() const throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type>(this->__end_cap() - this->__begin_);
            }
            void __vector_base<basic_string<char>, allocator<basic_string<char> > >::__destruct_at_end(std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __new_last) throw() __attribute__((internal_linkage))             {
                std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __soon_to_be_end = this->__end_;
                while (__new_last != __soon_to_be_end)
                    __alloc_traits::destroy(this->__alloc(), std::__1::__to_address(--__soon_to_be_end));
                this->__end_ = __new_last;
            }
            void __copy_assign_alloc(const std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__c) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__c) __attribute__((internal_linkage));
        private:
            void __copy_assign_alloc(const std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__c, std::__1::true_type) __attribute__((internal_linkage));
            void __copy_assign_alloc(const std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &, std::__1::false_type) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__c, std::__1::true_type) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::__vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &, std::__1::false_type) throw() __attribute__((internal_linkage));
        };
template<> class __vector_base<int, std::__1::allocator<int>> : protected __vector_base_common<true> {
        public:
            typedef std::__1::allocator<int> allocator_type;
            typedef allocator_traits<std::__1::__vector_base<int, std::__1::allocator<int> >::allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
        protected:
            typedef int value_type;
            typedef std::__1::__vector_base<int, std::__1::allocator<int> >::value_type &reference;
            typedef const std::__1::__vector_base<int, std::__1::allocator<int> >::value_type &const_reference;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            typedef std::__1::__vector_base<int, std::__1::allocator<int> >::pointer iterator;
            typedef std::__1::__vector_base<int, std::__1::allocator<int> >::const_pointer const_iterator;
            std::__1::__vector_base<int, std::__1::allocator<int> >::pointer __begin_;
            std::__1::__vector_base<int, std::__1::allocator<int> >::pointer __end_;
            __compressed_pair<std::__1::__vector_base<int, std::__1::allocator<int> >::pointer, std::__1::__vector_base<int, std::__1::allocator<int> >::allocator_type> __end_cap_;
            std::__1::__vector_base<int, std::__1::allocator<int> >::allocator_type &__alloc() throw() __attribute__((internal_linkage));
            const std::__1::__vector_base<int, std::__1::allocator<int> >::allocator_type &__alloc() const throw() __attribute__((internal_linkage));
            std::__1::__vector_base<int, std::__1::allocator<int> >::pointer &__end_cap() throw() __attribute__((internal_linkage));
            const std::__1::__vector_base<int, std::__1::allocator<int> >::pointer &__end_cap() const throw() __attribute__((internal_linkage));
            __vector_base() __attribute__((internal_linkage));
            __vector_base(const std::__1::__vector_base<int, std::__1::allocator<int> >::allocator_type &__a) __attribute__((internal_linkage));
            ~__vector_base<int, allocator<int> >();
            void clear() throw() __attribute__((internal_linkage));
            std::__1::__vector_base<int, std::__1::allocator<int> >::size_type capacity() const throw() __attribute__((internal_linkage));
            void __destruct_at_end(std::__1::__vector_base<int, std::__1::allocator<int> >::pointer __new_last) throw() __attribute__((internal_linkage));
            void __copy_assign_alloc(const std::__1::__vector_base<int, std::__1::allocator<int> > &__c) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::__vector_base<int, std::__1::allocator<int> > &__c) __attribute__((internal_linkage));
        private:
            void __copy_assign_alloc(const std::__1::__vector_base<int, std::__1::allocator<int> > &__c, std::__1::true_type) __attribute__((internal_linkage));
            void __copy_assign_alloc(const std::__1::__vector_base<int, std::__1::allocator<int> > &, std::__1::false_type) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::__vector_base<int, std::__1::allocator<int> > &__c, std::__1::true_type) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::__vector_base<int, std::__1::allocator<int> > &, std::__1::false_type) throw() __attribute__((internal_linkage));
        };
        template <class _Tp, class _Allocator> inline void __vector_base<_Tp, _Allocator>::__destruct_at_end(std::__1::__vector_base::pointer __new_last) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::__vector_base::pointer __soon_to_be_end = this->__end_;
            while (__new_last != __soon_to_be_end)
                __alloc_traits::destroy(__alloc(), std::__1::__to_address(--__soon_to_be_end));
            this->__end_ = __new_last;
        }
        template <class _Tp, class _Allocator> inline __vector_base<_Tp, _Allocator>::__vector_base<_Tp, _Allocator>() : __begin_(std::__1::__get_nullptr_t()), __end_(std::__1::__get_nullptr_t()), __end_cap_(std::__1::__get_nullptr_t(), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        template <class _Tp, class _Allocator> inline __vector_base<_Tp, _Allocator>::__vector_base<_Tp, _Allocator>(const std::__1::__vector_base::allocator_type &__a) : __begin_(std::__1::__get_nullptr_t()), __end_(std::__1::__get_nullptr_t()), __end_cap_(std::__1::__get_nullptr_t(), __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        template <class _Tp, class _Allocator> __vector_base<_Tp, _Allocator>::~__vector_base<_Tp, _Allocator>()         {
            if (this->__begin_ != std::__1::__get_nullptr_t()) {
                this->clear();
                __alloc_traits::deallocate(__alloc(), this->__begin_, this->capacity());
            }
        }
        template <class _Tp, class _Allocator = allocator<_Tp>> class __attribute__((type_visibility("default"))) vector : private __vector_base<_Tp, _Allocator> {
        private:
            typedef __vector_base<_Tp, _Allocator> __base;
            typedef allocator<_Tp> __default_allocator_type;
        public:
            typedef vector<_Tp, _Alloc> __self;
            typedef _Tp value_type;
            typedef _Allocator allocator_type;
            typedef typename __base::__alloc_traits __alloc_traits;
            typedef typename __base::reference reference;
            typedef typename __base::const_reference const_reference;
            typedef typename __base::size_type size_type;
            typedef typename __base::difference_type difference_type;
            typedef typename __base::pointer pointer;
            typedef typename __base::const_pointer const_pointer;
            typedef __wrap_iter<std::__1::vector::pointer> iterator;
            typedef __wrap_iter<std::__1::vector::const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            vector<_Tp, _Alloc>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit vector<_Tp, _Alloc>(const std::__1::vector::allocator_type &__a) : std::__1::vector::__base(__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit vector<_Tp, _Alloc>(std::__1::vector::size_type __n);
            vector<_Tp, _Alloc>(std::__1::vector::size_type __n, const std::__1::vector::value_type &__x);
            vector<_Tp, _Alloc>(std::__1::vector::size_type __n, const std::__1::vector::value_type &__x, const std::__1::vector::allocator_type &__a);
            template <class _InputIterator> vector<_Tp, _Alloc>(_InputIterator __first, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, _InputIterator>::type __last);
            template <class _InputIterator> vector<_Tp, _Alloc>(_InputIterator __first, _InputIterator __last, const std::__1::vector::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value>::type * = 0);
            template <class _ForwardIterator> vector<_Tp, _Alloc>(_ForwardIterator __first, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, _ForwardIterator>::type __last);
            template <class _ForwardIterator> vector<_Tp, _Alloc>(_ForwardIterator __first, _ForwardIterator __last, const std::__1::vector::allocator_type &__a, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value>::type * = 0);
            ~vector<_Tp, _Alloc>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__annotate_delete();
            }
            vector<_Tp, _Alloc>(const vector<_Tp, _Alloc> &__x);
            vector<_Tp, _Alloc>(const vector<_Tp, _Alloc> &__x, const std::__1::vector::allocator_type &__a);
            vector<_Tp, _Alloc> &operator=(const vector<_Tp, _Alloc> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, void>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, void>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            void assign(std::__1::vector::size_type __n, std::__1::vector::const_reference __u);
            std::__1::vector::allocator_type get_allocator() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__alloc();
            }
            std::__1::vector::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector::reverse_iterator(end());
            }
            std::__1::vector::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector::const_reverse_iterator(end());
            }
            std::__1::vector::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector::reverse_iterator(begin());
            }
            std::__1::vector::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector::const_reverse_iterator(begin());
            }
            std::__1::vector::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return begin();
            }
            std::__1::vector::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return end();
            }
            std::__1::vector::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rbegin();
            }
            std::__1::vector::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rend();
            }
            std::__1::vector::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::vector::size_type>(this->__end_ - this->__begin_);
            }
            std::__1::vector::size_type capacity() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::capacity();
            }
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__begin_ == this->__end_;
            }
            std::__1::vector::size_type max_size() const throw();
            void reserve(std::__1::vector::size_type __n);
            void shrink_to_fit() throw();
            std::__1::vector::reference operator[](std::__1::vector::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector::const_reference operator[](std::__1::vector::size_type __n) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector::reference at(std::__1::vector::size_type __n);
            std::__1::vector::const_reference at(std::__1::vector::size_type __n) const;
            std::__1::vector::reference front() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return *this->__begin_;
            }
            std::__1::vector::const_reference front() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return *this->__begin_;
            }
            std::__1::vector::reference back() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return *(this->__end_ - 1);
            }
            std::__1::vector::const_reference back() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return *(this->__end_ - 1);
            }
            std::__1::vector::value_type *data() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__to_address(this->__begin_);
            }
            const std::__1::vector::value_type *data() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__to_address(this->__begin_);
            }
            void __emplace_back(const std::__1::vector::value_type &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->push_back(__x);
            }
            void push_back(std::__1::vector::const_reference __x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void pop_back() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector::iterator insert(std::__1::vector::const_iterator __position, std::__1::vector::const_reference __x);
            std::__1::vector::iterator insert(std::__1::vector::const_iterator __position, std::__1::vector::size_type __n, std::__1::vector::const_reference __x);
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, iterator>::type insert(std::__1::vector::const_iterator __position, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, iterator>::type insert(std::__1::vector::const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
            std::__1::vector::iterator erase(std::__1::vector::const_iterator __position) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector::iterator erase(std::__1::vector::const_iterator __first, std::__1::vector::const_iterator __last);
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::vector::size_type __old_size = this->size();
                __base::clear();
                this->__annotate_shrink(__old_size);
                this->__invalidate_all_iterators();
            }
            void resize(std::__1::vector::size_type __sz);
            void resize(std::__1::vector::size_type __sz, std::__1::vector::const_reference __x);
            void swap(vector<_Tp, _Alloc> &);
            bool __invariants() const;
        private:
            void __invalidate_all_iterators() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __invalidate_iterators_past(std::__1::vector::pointer __new_last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __vallocate(std::__1::vector::size_type __n);
            void __vdeallocate() throw();
            std::__1::vector::size_type __recommend(std::__1::vector::size_type __new_size) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __construct_at_end(std::__1::vector::size_type __n);
            void __construct_at_end(std::__1::vector::size_type __n, std::__1::vector::const_reference __x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, std::__1::vector::size_type __n);
            void __append(std::__1::vector::size_type __n);
            void __append(std::__1::vector::size_type __n, std::__1::vector::const_reference __x);
            std::__1::vector::iterator __make_iter(std::__1::vector::pointer __p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector::const_iterator __make_iter(std::__1::vector::const_pointer __p) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __swap_out_circular_buffer(__split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> &__v);
            std::__1::vector::pointer __swap_out_circular_buffer(__split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> &__v, std::__1::vector::pointer __p);
            void __move_range(std::__1::vector::pointer __from_s, std::__1::vector::pointer __from_e, std::__1::vector::pointer __to);
            void __move_assign(vector<_Tp, _Alloc> &__c, std::__1::true_type);
            void __move_assign(vector<_Tp, _Alloc> &__c, std::__1::false_type);
            void __destruct_at_end(std::__1::vector::pointer __new_last) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__invalidate_iterators_past(__new_last);
                std::__1::vector::size_type __old_size = this->size();
                __base::__destruct_at_end(__new_last);
                this->__annotate_shrink(__old_size);
            }
            template <class _Up> inline void __push_back_slow_path(_Up &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __annotate_contiguous_container(const void *, const void *, const void *, const void *) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __annotate_new(std::__1::vector::size_type __current_size) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__annotate_contiguous_container(data(), data() + this->capacity(), data() + this->capacity(), data() + __current_size);
            }
            void __annotate_delete() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__annotate_contiguous_container(data(), data() + this->capacity(), data() + this->size(), data() + this->capacity());
            }
            void __annotate_increase(std::__1::vector::size_type __n) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__annotate_contiguous_container(data(), data() + this->capacity(), data() + this->size(), data() + this->size() + __n);
            }
            void __annotate_shrink(std::__1::vector::size_type __old_size) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__annotate_contiguous_container(data(), data() + this->capacity(), data() + __old_size, data() + this->size());
            }
            struct _ConstructTransaction {
                explicit _ConstructTransaction(vector<_Tp, _Alloc> &__v, std::__1::vector::size_type __n) : __v_(__v), __pos_(__v.__end_), __new_end_(__v.__end_ + __n)                 {
                }
                ~_ConstructTransaction()                 {
                    this->__v_.__end_ = this->__pos_;
                }
                vector<_Tp, _Alloc> &__v_;
                std::__1::vector::pointer __pos_;
                const std::__1::vector::const_pointer __new_end_;
            private:
                _ConstructTransaction(const std::__1::vector::_ConstructTransaction &) = delete
                std::__1::vector::_ConstructTransaction &operator=(const std::__1::vector::_ConstructTransaction &) = delete
            };
            template <class ..._Args> void __construct_one_at_end(_Args &&...__args) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::vector::_ConstructTransaction __tx(*this, 1);
                __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_), std::__1::forward<_Args>(__args)...);
                ++__tx.__pos_;
            }
        };
template<> class vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> >> : private __vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > {
        private:
            typedef __vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > __base;
            typedef allocator<std::__1::basic_string<char> > __default_allocator_type;
        public:
            typedef std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > __self;
            typedef std::__1::basic_string<char> value_type;
            typedef std::__1::allocator<std::__1::basic_string<char> > allocator_type;
            typedef typename __base::__alloc_traits __alloc_traits;
            typedef typename __base::reference reference;
            typedef typename __base::const_reference const_reference;
            typedef typename __base::size_type size_type;
            typedef typename __base::difference_type difference_type;
            typedef typename __base::pointer pointer;
            typedef typename __base::const_pointer const_pointer;
            typedef __wrap_iter<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer> iterator;
            typedef __wrap_iter<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            vector() : __vector_base<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >() __attribute__((internal_linkage))             {
            }
            explicit vector(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a) __attribute__((internal_linkage));
            explicit vector(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            vector(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type &__x);
            vector(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type &__x, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a);
            template <class _InputIterator> vector(_InputIterator __first, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, _InputIterator>::type __last);
            template <class _InputIterator> vector(_InputIterator __first, _InputIterator __last, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value>::type *);
            template <class _ForwardIterator> vector(_ForwardIterator __first, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, _ForwardIterator>::type __last);
            template <class _ForwardIterator> vector(_ForwardIterator __first, _ForwardIterator __last, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value>::type *);
            ~vector<basic_string<char>, allocator<basic_string<char> > >() __attribute__((internal_linkage))             {
                this->__annotate_delete();
            }
            vector(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__x);
            vector(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__x, const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &operator=(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__x) __attribute__((internal_linkage));
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, void>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, void>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            void assign(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __u);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type get_allocator() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator begin() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator vector<basic_string<char>, allocator<basic_string<char> > >::begin() const throw() __attribute__((internal_linkage))             {
                return this->__make_iter(this->__begin_);
            }
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator end() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator vector<basic_string<char>, allocator<basic_string<char> > >::end() const throw() __attribute__((internal_linkage))             {
                return this->__make_iter(this->__end_);
            }
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reverse_iterator rbegin() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reverse_iterator rbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reverse_iterator rend() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reverse_iterator rend() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator cbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator cend() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reverse_iterator crbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reverse_iterator crend() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type size() const throw() __attribute__((internal_linkage))             {
                return static_cast<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type>(this->__end_ - this->__begin_);
            }
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type capacity() const throw() __attribute__((internal_linkage))             {
                return this->__base::capacity();
            }
            bool empty() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type vector<basic_string<char>, allocator<basic_string<char> > >::max_size() const throw()             {
                return std::__1::min<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<difference_type>::max());
            }
            void reserve(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void shrink_to_fit() throw();
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reference operator[](std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference operator[](std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reference at(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference at(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) const;
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reference front() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference front() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::reference back() throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference back() const throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type *data() throw() __attribute__((internal_linkage));
            const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type *data() const throw() __attribute__((internal_linkage))             {
                return std::__1::__to_address(this->__begin_);
            }
            void __emplace_back(const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type &__x) __attribute__((internal_linkage));
            void vector<basic_string<char>, allocator<basic_string<char> > >::push_back(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x) __attribute__((internal_linkage))             {
                if (this->__end_ != this->__end_cap()) {
                    this->__construct_one_at_end(__x);
                } else
                    this->__push_back_slow_path(__x);
            }
            void pop_back();
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator insert(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator insert(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, iterator>::type insert(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, iterator>::type insert(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator erase(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __position) __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator erase(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __first, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator __last);
            void clear() throw() __attribute__((internal_linkage));
            void resize(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __sz);
            void resize(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __sz, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            void swap(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &);
            bool __invariants() const;
        private:
            void vector<basic_string<char>, allocator<basic_string<char> > >::__invalidate_all_iterators() __attribute__((internal_linkage))             {
            }
            void __invalidate_iterators_past(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __new_last) __attribute__((internal_linkage));
            void __vallocate(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void __vdeallocate() throw();
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type vector<basic_string<char>, allocator<basic_string<char> > >::__recommend(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __new_size) const __attribute__((internal_linkage))             {
                const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __ms = this->max_size();
                if (__new_size > __ms)
                    this->__throw_length_error();
                const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __cap = this->capacity();
                if (__cap >= __ms / 2)
                    return __ms;
                return std::__1::max<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type>(2 * __cap, __new_size);
            }
            void __construct_at_end(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void __construct_at_end(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void __append(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n);
            void __append(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_reference __x);
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::iterator __make_iter(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __p) throw() __attribute__((internal_linkage));
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator vector<basic_string<char>, allocator<basic_string<char> > >::__make_iter(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_pointer __p) const throw() __attribute__((internal_linkage))             {
                return std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_iterator(__p);
            }
            void vector<basic_string<char>, allocator<basic_string<char> > >::__swap_out_circular_buffer(__split_buffer<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &> &__v)             {
                this->__annotate_delete();
                __alloc_traits::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
                std::__1::swap(this->__begin_, __v.__begin_);
                std::__1::swap(this->__end_, __v.__end_);
                std::__1::swap(this->__end_cap(), __v.__end_cap());
                __v.__first_ = __v.__begin_;
                this->__annotate_new(this->size());
                this->__invalidate_all_iterators();
            }
            std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __swap_out_circular_buffer(__split_buffer<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &> &__v, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __p);
            void __move_range(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __from_s, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __from_e, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __to);
            void __move_assign(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__c, std::__1::true_type);
            void __move_assign(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__c, std::__1::false_type);
            void __destruct_at_end(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __new_last) throw() __attribute__((internal_linkage));
            template <class _Up> inline void __push_back_slow_path(_Up &__x);
            template<> inline void vector<basic_string<char>, allocator<basic_string<char> > >::__push_back_slow_path<const std::__1::basic_string<char>>(const std::__1::basic_string<char> &__x)             {
                std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &__a = this->__alloc();
                __split_buffer<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::value_type, std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::allocator_type &> __v(this->__recommend(this->size() + 1), this->size(), __a);
                __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_), std::__1::forward<const std::__1::basic_string<char> >(__x));
                __v.__end_++;
                this->__swap_out_circular_buffer(__v);
            }
;
            void __annotate_contiguous_container(const void *, const void *, const void *, const void *) const throw() __attribute__((internal_linkage))             {
            }
            void __annotate_new(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __current_size) const throw() __attribute__((internal_linkage))             {
                this->__annotate_contiguous_container(this->data(), this->data() + this->capacity(), this->data() + this->capacity(), this->data() + __current_size);
            }
            void __annotate_delete() const throw() __attribute__((internal_linkage))             {
                this->__annotate_contiguous_container(this->data(), this->data() + this->capacity(), this->data() + this->size(), this->data() + this->capacity());
            }
            void __annotate_increase(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __n) const throw() __attribute__((internal_linkage));
            void __annotate_shrink(std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::size_type __old_size) const throw() __attribute__((internal_linkage));
            struct _ConstructTransaction {
                std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__v_;
                std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::pointer __pos_;
                const std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::const_pointer __new_end_;
            private:
            };
            template <class ..._Args> void __construct_one_at_end(_Args &&...__args) __attribute__((internal_linkage));
            template<> void __construct_one_at_end<<const std::__1::basic_string<char> &>>(const std::__1::basic_string<char> &__args) __attribute__((internal_linkage))             {
                std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >::_ConstructTransaction __tx(*this, 1);
                __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_), std::__1::forward<const std::__1::basic_string<char> &>(__args));
                ++__tx.__pos_;
            }
;
        };
template<> class vector<int, std::__1::allocator<int>> : private __vector_base<int, std::__1::allocator<int> > {
        private:
            typedef __vector_base<int, std::__1::allocator<int> > __base;
            typedef allocator<int> __default_allocator_type;
        public:
            typedef std::__1::vector<int, std::__1::allocator<int> > __self;
            typedef int value_type;
            typedef std::__1::allocator<int> allocator_type;
            typedef typename __base::__alloc_traits __alloc_traits;
            typedef typename __base::reference reference;
            typedef typename __base::const_reference const_reference;
            typedef typename __base::size_type size_type;
            typedef typename __base::difference_type difference_type;
            typedef typename __base::pointer pointer;
            typedef typename __base::const_pointer const_pointer;
            typedef __wrap_iter<std::__1::vector<int, std::__1::allocator<int> >::pointer> iterator;
            typedef __wrap_iter<std::__1::vector<int, std::__1::allocator<int> >::const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            vector() __attribute__((internal_linkage));
            explicit vector(const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a) __attribute__((internal_linkage));
            explicit vector(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            vector(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, const std::__1::vector<int, std::__1::allocator<int> >::value_type &__x);
            vector(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, const std::__1::vector<int, std::__1::allocator<int> >::value_type &__x, const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a);
            template <class _InputIterator> vector(_InputIterator __first, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, _InputIterator>::type __last);
            template <class _InputIterator> vector(_InputIterator __first, _InputIterator __last, const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value>::type *);
            template <class _ForwardIterator> vector(_ForwardIterator __first, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, _ForwardIterator>::type __last);
            template <class _ForwardIterator> vector(_ForwardIterator __first, _ForwardIterator __last, const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value>::type *);
            ~vector<int, allocator<int> >() __attribute__((internal_linkage));
            vector(const std::__1::vector<int, std::__1::allocator<int> > &__x);
            vector(const std::__1::vector<int, std::__1::allocator<int> > &__x, const std::__1::vector<int, std::__1::allocator<int> >::allocator_type &__a);
            std::__1::vector<int, std::__1::allocator<int> > &operator=(const std::__1::vector<int, std::__1::allocator<int> > &__x) __attribute__((internal_linkage));
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, void>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, void>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            void assign(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, std::__1::vector<int, std::__1::allocator<int> >::const_reference __u);
            std::__1::vector<int, std::__1::allocator<int> >::allocator_type get_allocator() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::iterator begin() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator begin() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::iterator end() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator end() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::reverse_iterator rbegin() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reverse_iterator rbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::reverse_iterator rend() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reverse_iterator rend() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator cbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator cend() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reverse_iterator crbegin() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reverse_iterator crend() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::size_type size() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::size_type capacity() const throw() __attribute__((internal_linkage));
            bool empty() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::size_type max_size() const throw();
            void reserve(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void shrink_to_fit() throw();
            std::__1::vector<int, std::__1::allocator<int> >::reference operator[](std::__1::vector<int, std::__1::allocator<int> >::size_type __n) throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reference operator[](std::__1::vector<int, std::__1::allocator<int> >::size_type __n) const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::reference at(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            std::__1::vector<int, std::__1::allocator<int> >::const_reference at(std::__1::vector<int, std::__1::allocator<int> >::size_type __n) const;
            std::__1::vector<int, std::__1::allocator<int> >::reference front() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reference front() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::reference back() throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_reference back() const throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::value_type *data() throw() __attribute__((internal_linkage));
            const std::__1::vector<int, std::__1::allocator<int> >::value_type *data() const throw() __attribute__((internal_linkage));
            void __emplace_back(const std::__1::vector<int, std::__1::allocator<int> >::value_type &__x) __attribute__((internal_linkage));
            void push_back(std::__1::vector<int, std::__1::allocator<int> >::const_reference __x) __attribute__((internal_linkage));
            void pop_back();
            std::__1::vector<int, std::__1::allocator<int> >::iterator insert(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            std::__1::vector<int, std::__1::allocator<int> >::iterator insert(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position, std::__1::vector<int, std::__1::allocator<int> >::size_type __n, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, iterator>::type insert(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, iterator>::type insert(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
            std::__1::vector<int, std::__1::allocator<int> >::iterator erase(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __position) __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::iterator erase(std::__1::vector<int, std::__1::allocator<int> >::const_iterator __first, std::__1::vector<int, std::__1::allocator<int> >::const_iterator __last);
            void clear() throw() __attribute__((internal_linkage));
            void resize(std::__1::vector<int, std::__1::allocator<int> >::size_type __sz);
            void resize(std::__1::vector<int, std::__1::allocator<int> >::size_type __sz, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            void swap(std::__1::vector<int, std::__1::allocator<int> > &);
            bool __invariants() const;
        private:
            void __invalidate_all_iterators() __attribute__((internal_linkage));
            void __invalidate_iterators_past(std::__1::vector<int, std::__1::allocator<int> >::pointer __new_last) __attribute__((internal_linkage));
            void __vallocate(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void __vdeallocate() throw();
            std::__1::vector<int, std::__1::allocator<int> >::size_type __recommend(std::__1::vector<int, std::__1::allocator<int> >::size_type __new_size) const __attribute__((internal_linkage));
            void __construct_at_end(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void __construct_at_end(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void __append(std::__1::vector<int, std::__1::allocator<int> >::size_type __n);
            void __append(std::__1::vector<int, std::__1::allocator<int> >::size_type __n, std::__1::vector<int, std::__1::allocator<int> >::const_reference __x);
            std::__1::vector<int, std::__1::allocator<int> >::iterator __make_iter(std::__1::vector<int, std::__1::allocator<int> >::pointer __p) throw() __attribute__((internal_linkage));
            std::__1::vector<int, std::__1::allocator<int> >::const_iterator __make_iter(std::__1::vector<int, std::__1::allocator<int> >::const_pointer __p) const throw() __attribute__((internal_linkage));
            void __swap_out_circular_buffer(__split_buffer<std::__1::vector<int, std::__1::allocator<int> >::value_type, std::__1::vector<int, std::__1::allocator<int> >::allocator_type &> &__v);
            std::__1::vector<int, std::__1::allocator<int> >::pointer __swap_out_circular_buffer(__split_buffer<std::__1::vector<int, std::__1::allocator<int> >::value_type, std::__1::vector<int, std::__1::allocator<int> >::allocator_type &> &__v, std::__1::vector<int, std::__1::allocator<int> >::pointer __p);
            void __move_range(std::__1::vector<int, std::__1::allocator<int> >::pointer __from_s, std::__1::vector<int, std::__1::allocator<int> >::pointer __from_e, std::__1::vector<int, std::__1::allocator<int> >::pointer __to);
            void __move_assign(std::__1::vector<int, std::__1::allocator<int> > &__c, std::__1::true_type);
            void __move_assign(std::__1::vector<int, std::__1::allocator<int> > &__c, std::__1::false_type);
            void __destruct_at_end(std::__1::vector<int, std::__1::allocator<int> >::pointer __new_last) throw() __attribute__((internal_linkage));
            template <class _Up> inline void __push_back_slow_path(_Up &__x);
            void __annotate_contiguous_container(const void *, const void *, const void *, const void *) const throw() __attribute__((internal_linkage));
            void __annotate_new(std::__1::vector<int, std::__1::allocator<int> >::size_type __current_size) const throw() __attribute__((internal_linkage));
            void __annotate_delete() const throw() __attribute__((internal_linkage));
            void __annotate_increase(std::__1::vector<int, std::__1::allocator<int> >::size_type __n) const throw() __attribute__((internal_linkage));
            void __annotate_shrink(std::__1::vector<int, std::__1::allocator<int> >::size_type __old_size) const throw() __attribute__((internal_linkage));
            struct _ConstructTransaction;
            template <class ..._Args> void __construct_one_at_end(_Args &&...__args) __attribute__((internal_linkage));
        };
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> &__v)         {
            this->__annotate_delete();
            __alloc_traits::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
            std::__1::swap(this->__begin_, __v.__begin_);
            std::__1::swap(this->__end_, __v.__end_);
            std::__1::swap(this->__end_cap(), __v.__end_cap());
            __v.__first_ = __v.__begin_;
            this->__annotate_new(this->size());
            this->__invalidate_all_iterators();
        }
        template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::pointer vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> &__v, std::__1::vector::pointer __p)         {
            this->__annotate_delete();
            std::__1::vector::pointer __r = __v.__begin_;
            __alloc_traits::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, __p, __v.__begin_);
            __alloc_traits::__construct_forward_with_exception_guarantees(this->__alloc(), __p, this->__end_, __v.__end_);
            std::__1::swap(this->__begin_, __v.__begin_);
            std::__1::swap(this->__end_, __v.__end_);
            std::__1::swap(this->__end_cap(), __v.__end_cap());
            __v.__first_ = __v.__begin_;
            this->__annotate_new(this->size());
            this->__invalidate_all_iterators();
            return __r;
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__vallocate(std::__1::vector::size_type __n)         {
            if (__n > this->max_size())
                this->__throw_length_error();
            this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);
            this->__end_cap() = this->__begin_ + __n;
            this->__annotate_new(0);
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__vdeallocate() throw()         {
            if (this->__begin_ != std::__1::__get_nullptr_t()) {
                this->clear();
                __alloc_traits::deallocate(this->__alloc(), this->__begin_, this->capacity());
                this->__begin_ = this->__end_ = this->__end_cap() = std::__1::__get_nullptr_t();
            }
        }
        template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::size_type vector<_Tp, _Allocator>::max_size() const throw()         {
            return std::__1::min<std::__1::vector::size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<difference_type>::max());
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::size_type vector<_Tp, _Allocator>::__recommend(std::__1::vector::size_type __new_size) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            const std::__1::vector::size_type __ms = this->max_size();
            if (__new_size > __ms)
                this->__throw_length_error();
            const std::__1::vector::size_type __cap = this->capacity();
            if (__cap >= __ms / 2)
                return __ms;
            return std::__1::max<std::__1::vector::size_type>(2 * __cap, __new_size);
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__construct_at_end(std::__1::vector::size_type __n)         {
            std::__1::vector::_ConstructTransaction __tx(*this, __n);
            for (; __tx.__pos_ != __tx.__new_end_; ++__tx.__pos_) {
                __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_));
            }
        }
        template <class _Tp, class _Allocator> inline void vector<_Tp, _Allocator>::__construct_at_end(std::__1::vector::size_type __n, std::__1::vector::const_reference __x)         {
            std::__1::vector::_ConstructTransaction __tx(*this, __n);
            for (; __tx.__pos_ != __tx.__new_end_; ++__tx.__pos_) {
                __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_), __x);
            }
        }
        template <class _Tp, class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, std::__1::vector::size_type __n)         {
            std::__1::vector::_ConstructTransaction __tx(*this, __n);
            __alloc_traits::__construct_range_forward(this->__alloc(), __first, __last, __tx.__pos_);
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__append(std::__1::vector::size_type __n)         {
            if (static_cast<std::__1::vector::size_type>(this->__end_cap() - this->__end_) >= __n)
                this->__construct_at_end(__n);
            else {
                std::__1::vector::allocator_type &__a = this->__alloc();
                __split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> __v(this->__recommend(this->size() + __n), this->size(), __a);
                __v.__construct_at_end(__n);
                __swap_out_circular_buffer(__v);
            }
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__append(std::__1::vector::size_type __n, std::__1::vector::const_reference __x)         {
            if (static_cast<std::__1::vector::size_type>(this->__end_cap() - this->__end_) >= __n)
                this->__construct_at_end(__n, __x);
            else {
                std::__1::vector::allocator_type &__a = this->__alloc();
                __split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> __v(this->__recommend(this->size() + __n), this->size(), __a);
                __v.__construct_at_end(__n, __x);
                __swap_out_circular_buffer(__v);
            }
        }
        template <class _Tp, class _Allocator> explicit vector<_Tp, _Allocator>::vector<_Tp, _Alloc>(std::__1::vector::size_type __n)         {
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__n);
            }
        }
        template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector<_Tp, _Alloc>(std::__1::vector::size_type __n, const std::__1::vector::value_type &__x)         {
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__n, __x);
            }
        }
        template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector<_Tp, _Alloc>(std::__1::vector::size_type __n, const std::__1::vector::value_type &__x, const std::__1::vector::allocator_type &__a) : std::__1::vector::__base(__a)         {
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__n, __x);
            }
        }
        template <class _Tp, class _Allocator> template <class _InputIterator> vector<_Tp, _Allocator>::vector<_Tp, _Alloc>(_InputIterator __first, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value, _InputIterator>::type __last)         {
            for (; __first != __last; ++__first)
                this->__emplace_back(*__first);
        }
        template <class _Tp, class _Allocator> template <class _InputIterator> vector<_Tp, _Allocator>::vector<_Tp, _Alloc>(_InputIterator __first, _InputIterator __last, const std::__1::vector::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value>::type * = 0) : std::__1::vector::__base(__a)         {
            for (; __first != __last; ++__first)
                this->__emplace_back(*__first);
        }
        template <class _Tp, class _Allocator> template <class _ForwardIterator> vector<_Tp, _Allocator>::vector<_Tp, _Alloc>(_ForwardIterator __first, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value, _ForwardIterator>::type __last)         {
            std::__1::vector::size_type __n = static_cast<std::__1::vector::size_type>(std::__1::distance(__first, __last));
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__first, __last, __n);
            }
        }
        template <class _Tp, class _Allocator> template <class _ForwardIterator> vector<_Tp, _Allocator>::vector<_Tp, _Alloc>(_ForwardIterator __first, _ForwardIterator __last, const std::__1::vector::allocator_type &__a, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value>::type * = 0) : std::__1::vector::__base(__a)         {
            std::__1::vector::size_type __n = static_cast<std::__1::vector::size_type>(std::__1::distance(__first, __last));
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__first, __last, __n);
            }
        }
        template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector<_Tp, _Alloc>(const vector<_Tp, _Alloc> &__x) : std::__1::vector::__base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))         {
            std::__1::vector::size_type __n = __x.size();
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__x.__begin_, __x.__end_, __n);
            }
        }
        template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector<_Tp, _Alloc>(const vector<_Tp, _Alloc> &__x, const std::__1::vector::allocator_type &__a) : std::__1::vector::__base(__a)         {
            std::__1::vector::size_type __n = __x.size();
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__x.__begin_, __x.__end_, __n);
            }
        }
        template <class _Tp, class _Allocator> inline vector<_Tp, _Allocator> &vector<_Tp, _Allocator>::operator=(const vector<_Tp, _Alloc> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (this != &__x) {
                __base::__copy_assign_alloc(__x);
                assign(__x.__begin_, __x.__end_);
            }
            return *this;
        }
        template <class _Tp, class _Allocator> template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value, void>::type vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)         {
            this->clear();
            for (; __first != __last; ++__first)
                this->__emplace_back(*__first);
        }
        template <class _Tp, class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value, void>::type vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)         {
            std::__1::vector::size_type __new_size = static_cast<std::__1::vector::size_type>(std::__1::distance(__first, __last));
            if (__new_size <= this->capacity()) {
                _ForwardIterator __mid = __last;
                bool __growing = false;
                if (__new_size > this->size()) {
                    __growing = true;
                    __mid = __first;
                    std::__1::advance(__mid, this->size());
                }
                std::__1::vector::pointer __m = std::__1::copy(__first, __mid, this->__begin_);
                if (__growing)
                    __construct_at_end(__mid, __last, __new_size - this->size());
                else
                    this->__destruct_at_end(__m);
            } else {
                this->__vdeallocate();
                this->__vallocate(this->__recommend(__new_size));
                __construct_at_end(__first, __last, __new_size);
            }
            this->__invalidate_all_iterators();
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::assign(std::__1::vector::size_type __n, std::__1::vector::const_reference __u)         {
            if (__n <= this->capacity()) {
                std::__1::vector::size_type __s = this->size();
                std::__1::fill_n(this->__begin_, std::__1::min(__n, __s), __u);
                if (__n > __s)
                    __construct_at_end(__n - __s, __u);
                else
                    this->__destruct_at_end(this->__begin_ + __n);
            } else {
                this->__vdeallocate();
                this->__vallocate(this->__recommend(static_cast<std::__1::vector::size_type>(__n)));
                __construct_at_end(__n, __u);
            }
            this->__invalidate_all_iterators();
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::__make_iter(std::__1::vector::pointer __p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::vector::iterator(__p);
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::const_iterator vector<_Tp, _Allocator>::__make_iter(std::__1::vector::const_pointer __p) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::vector::const_iterator(__p);
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __make_iter(this->__begin_);
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::const_iterator vector<_Tp, _Allocator>::begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __make_iter(this->__begin_);
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __make_iter(this->__end_);
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::const_iterator vector<_Tp, _Allocator>::end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __make_iter(this->__end_);
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::reference vector<_Tp, _Allocator>::operator[](std::__1::vector::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ((void)0);
            return this->__begin_[__n];
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::const_reference vector<_Tp, _Allocator>::operator[](std::__1::vector::size_type __n) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ((void)0);
            return this->__begin_[__n];
        }
        template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::reference vector<_Tp, _Allocator>::at(std::__1::vector::size_type __n)         {
            if (__n >= this->size())
                this->__throw_out_of_range();
            return this->__begin_[__n];
        }
        template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::const_reference vector<_Tp, _Allocator>::at(std::__1::vector::size_type __n) const         {
            if (__n >= this->size())
                this->__throw_out_of_range();
            return this->__begin_[__n];
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::reserve(std::__1::vector::size_type __n)         {
            if (__n > this->capacity()) {
                std::__1::vector::allocator_type &__a = this->__alloc();
                __split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> __v(__n, this->size(), __a);
                __swap_out_circular_buffer(__v);
            }
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::shrink_to_fit() throw()         {
            if (this->capacity() > this->size()) {
                try {
                    std::__1::vector::allocator_type &__a = this->__alloc();
                    __split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> __v(this->size(), this->size(), __a);
                    __swap_out_circular_buffer(__v);
                } catch (...) {
                }
            }
        }
        template <class _Tp, class _Allocator> template <class _Up> void vector<_Tp, _Allocator>::__push_back_slow_path(_Up &__x)         {
            std::__1::vector::allocator_type &__a = this->__alloc();
            __split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> __v(this->__recommend(this->size() + 1), this->size(), __a);
            __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_), std::__1::forward<_Up>(__x));
            __v.__end_++;
            __swap_out_circular_buffer(__v);
        }
        template <class _Tp, class _Allocator> inline void vector<_Tp, _Allocator>::push_back(std::__1::vector::const_reference __x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (this->__end_ != this->__end_cap()) {
                __construct_one_at_end(__x);
            } else
                __push_back_slow_path(__x);
        }
        template <class _Tp, class _Allocator> inline void vector<_Tp, _Allocator>::pop_back()         {
            ((void)0);
            this->__destruct_at_end(this->__end_ - 1);
        }
        template <class _Tp, class _Allocator> inline typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::erase(std::__1::vector::const_iterator __position) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ((void)0);
            std::__1::vector::difference_type __ps = __position - this->cbegin();
            std::__1::vector::pointer __p = this->__begin_ + __ps;
            this->__destruct_at_end(std::__1::move(__p + 1, this->__end_, __p));
            this->__invalidate_iterators_past(__p - 1);
            std::__1::vector::iterator __r = __make_iter(__p);
            return __r;
        }
        template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::erase(std::__1::vector::const_iterator __first, std::__1::vector::const_iterator __last)         {
            ((void)0);
            std::__1::vector::pointer __p = this->__begin_ + (__first - begin());
            if (__first != __last) {
                this->__destruct_at_end(std::__1::move(__p + (__last - __first), this->__end_, __p));
                this->__invalidate_iterators_past(__p - 1);
            }
            std::__1::vector::iterator __r = __make_iter(__p);
            return __r;
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__move_range(std::__1::vector::pointer __from_s, std::__1::vector::pointer __from_e, std::__1::vector::pointer __to)         {
            std::__1::vector::pointer __old_last = this->__end_;
            std::__1::vector::difference_type __n = __old_last - __to;
            {
                std::__1::vector::pointer __i = __from_s + __n;
                std::__1::vector::_ConstructTransaction __tx(*this, __from_e - __i);
                for (; __i < __from_e; ++__i , ++__tx.__pos_) {
                    __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_), std::__1::move(*__i));
                }
            }
            std::__1::move_backward(__from_s, __from_s + __n, __old_last);
        }
        template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::insert(std::__1::vector::const_iterator __position, std::__1::vector::const_reference __x)         {
            std::__1::vector::pointer __p = this->__begin_ + (__position - begin());
            if (this->__end_ < this->__end_cap()) {
                if (__p == this->__end_) {
                    __construct_one_at_end(__x);
                } else {
                    this->__move_range(__p, this->__end_, __p + 1);
                    std::__1::vector::const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                    if (__p <= __xr && __xr < this->__end_)
                        ++__xr;
                    *__p = *__xr;
                }
            } else {
                std::__1::vector::allocator_type &__a = this->__alloc();
                __split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> __v(this->__recommend(this->size() + 1), __p - this->__begin_, __a);
                __v.push_back(__x);
                __p = __swap_out_circular_buffer(__v, __p);
            }
            return __make_iter(__p);
        }
        template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::insert(std::__1::vector::const_iterator __position, std::__1::vector::size_type __n, std::__1::vector::const_reference __x)         {
            std::__1::vector::pointer __p = this->__begin_ + (__position - begin());
            if (__n > 0) {
                if (__n <= static_cast<std::__1::vector::size_type>(this->__end_cap() - this->__end_)) {
                    std::__1::vector::size_type __old_n = __n;
                    std::__1::vector::pointer __old_last = this->__end_;
                    if (__n > static_cast<std::__1::vector::size_type>(this->__end_ - __p)) {
                        std::__1::vector::size_type __cx = __n - (this->__end_ - __p);
                        __construct_at_end(__cx, __x);
                        __n -= __cx;
                    }
                    if (__n > 0) {
                        this->__move_range(__p, __old_last, __p + __old_n);
                        std::__1::vector::const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                        if (__p <= __xr && __xr < this->__end_)
                            __xr += __old_n;
                        std::__1::fill_n(__p, __n, *__xr);
                    }
                } else {
                    std::__1::vector::allocator_type &__a = this->__alloc();
                    __split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> __v(this->__recommend(this->size() + __n), __p - this->__begin_, __a);
                    __v.__construct_at_end(__n, __x);
                    __p = __swap_out_circular_buffer(__v, __p);
                }
            }
            return __make_iter(__p);
        }
        template <class _Tp, class _Allocator> template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value && is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value, typename vector<_Tp, _Allocator>::iterator>::type vector<_Tp, _Allocator>::insert(std::__1::vector::const_iterator __position, _InputIterator __first, _InputIterator __last)         {
            std::__1::vector::difference_type __off = __position - begin();
            std::__1::vector::pointer __p = this->__begin_ + __off;
            std::__1::vector::allocator_type &__a = this->__alloc();
            std::__1::vector::pointer __old_last = this->__end_;
            for (; this->__end_ != this->__end_cap() && __first != __last; ++__first) {
                __construct_one_at_end(*__first);
            }
            __split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> __v(__a);
            if (__first != __last) {
                try {
                    __v.__construct_at_end(__first, __last);
                    std::__1::vector::difference_type __old_size = __old_last - this->__begin_;
                    std::__1::vector::difference_type __old_p = __p - this->__begin_;
                    this->reserve(this->__recommend(this->size() + __v.size()));
                    __p = this->__begin_ + __old_p;
                    __old_last = this->__begin_ + __old_size;
                } catch (...) {
                    erase(__make_iter(__old_last), end());
                    throw;
                }
            }
            __p = std::__1::rotate(__p, __old_last, this->__end_);
            insert(__make_iter(__p), make_move_iterator(__v.begin()), make_move_iterator(__v.end()));
            return begin() + __off;
        }
        template <class _Tp, class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value, typename vector<_Tp, _Allocator>::iterator>::type vector<_Tp, _Allocator>::insert(std::__1::vector::const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)         {
            std::__1::vector::pointer __p = this->__begin_ + (__position - begin());
            std::__1::vector::difference_type __n = std::__1::distance(__first, __last);
            if (__n > 0) {
                if (__n <= this->__end_cap() - this->__end_) {
                    std::__1::vector::size_type __old_n = __n;
                    std::__1::vector::pointer __old_last = this->__end_;
                    _ForwardIterator __m = __last;
                    std::__1::vector::difference_type __dx = this->__end_ - __p;
                    if (__n > __dx) {
                        __m = __first;
                        std::__1::vector::difference_type __diff = this->__end_ - __p;
                        std::__1::advance(__m, __diff);
                        __construct_at_end(__m, __last, __n - __diff);
                        __n = __dx;
                    }
                    if (__n > 0) {
                        this->__move_range(__p, __old_last, __p + __old_n);
                        std::__1::copy(__first, __m, __p);
                    }
                } else {
                    std::__1::vector::allocator_type &__a = this->__alloc();
                    __split_buffer<std::__1::vector::value_type, std::__1::vector::allocator_type &> __v(this->__recommend(this->size() + __n), __p - this->__begin_, __a);
                    __v.__construct_at_end(__first, __last);
                    __p = __swap_out_circular_buffer(__v, __p);
                }
            }
            return __make_iter(__p);
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::resize(std::__1::vector::size_type __sz)         {
            std::__1::vector::size_type __cs = this->size();
            if (__cs < __sz)
                this->__append(__sz - __cs);
            else if (__cs > __sz)
                this->__destruct_at_end(this->__begin_ + __sz);
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::resize(std::__1::vector::size_type __sz, std::__1::vector::const_reference __x)         {
            std::__1::vector::size_type __cs = this->size();
            if (__cs < __sz)
                this->__append(__sz - __cs, __x);
            else if (__cs > __sz)
                this->__destruct_at_end(this->__begin_ + __sz);
        }
        template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::swap(vector<_Tp, _Alloc> &__x)         {
            ((void)0);
            std::__1::swap(this->__begin_, __x.__begin_);
            std::__1::swap(this->__end_, __x.__end_);
            std::__1::swap(this->__end_cap(), __x.__end_cap());
            __swap_allocator(this->__alloc(), __x.__alloc(), integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
        }
        template <class _Tp, class _Allocator> bool vector<_Tp, _Allocator>::__invariants() const         {
            if (this->__begin_ == std::__1::__get_nullptr_t()) {
                if (this->__end_ != std::__1::__get_nullptr_t() || this->__end_cap() != std::__1::__get_nullptr_t())
                    return false;
            } else {
                if (this->__begin_ > this->__end_)
                    return false;
                if (this->__begin_ == this->__end_cap())
                    return false;
                if (this->__end_ > this->__end_cap())
                    return false;
            }
            return true;
        }
        template <class _Tp, class _Allocator> inline void vector<_Tp, _Allocator>::__invalidate_all_iterators() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        template <class _Tp, class _Allocator> inline void vector<_Tp, _Allocator>::__invalidate_iterators_past(std::__1::vector::pointer __new_last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ((void)__new_last);
        }
        template <class _Allocator> class vector<bool, _Allocator>;
        template <class _Allocator> struct hash<vector<bool, _Allocator>>;
        template <class _Allocator> struct __has_storage_type<vector<bool, _Allocator>> {
            static const bool value = true;
        };
        template <class _Allocator> class __attribute__((type_visibility("default"))) vector<bool, _Allocator> : private __vector_base_common<true> {
        public:
            typedef vector<bool, type-parameter-0-0> __self;
            typedef bool value_type;
            typedef _Allocator allocator_type;
            typedef allocator_traits<std::__1::vector<bool, type-parameter-0-0>::allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef std::__1::vector<bool, type-parameter-0-0>::size_type __storage_type;
            typedef __bit_iterator<vector<bool, type-parameter-0-0>, false> pointer;
            typedef __bit_iterator<vector<bool, type-parameter-0-0>, true> const_pointer;
            typedef std::__1::vector<bool, type-parameter-0-0>::pointer iterator;
            typedef std::__1::vector<bool, type-parameter-0-0>::const_pointer const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;
            typedef allocator_traits<std::__1::vector<bool, type-parameter-0-0>::__storage_allocator> __storage_traits;
            typedef typename __storage_traits::pointer __storage_pointer;
            typedef typename __storage_traits::const_pointer __const_storage_pointer;
            std::__1::vector<bool, type-parameter-0-0>::__storage_pointer __begin_;
            std::__1::vector<bool, type-parameter-0-0>::size_type __size_;
            __compressed_pair<std::__1::vector<bool, type-parameter-0-0>::size_type, std::__1::vector<bool, type-parameter-0-0>::__storage_allocator> __cap_alloc_;
        public:
            typedef __bit_reference<vector<bool, type-parameter-0-0> > reference;
            typedef __bit_const_reference<vector<bool, type-parameter-0-0> > const_reference;
        private:
            std::__1::vector<bool, type-parameter-0-0>::size_type &__cap() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cap_alloc_.first();
            }
            const std::__1::vector<bool, type-parameter-0-0>::size_type &__cap() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cap_alloc_.first();
            }
            std::__1::vector<bool, type-parameter-0-0>::__storage_allocator &__alloc() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cap_alloc_.second();
            }
            const std::__1::vector<bool, type-parameter-0-0>::__storage_allocator &__alloc() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cap_alloc_.second();
            }
            static const unsigned int __bits_per_word = static_cast<unsigned int>(sizeof(std::__1::vector<bool, type-parameter-0-0>::__storage_type) * 8);
            static std::__1::vector<bool, type-parameter-0-0>::size_type __internal_cap_to_external(std::__1::vector<bool, type-parameter-0-0>::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __n * __bits_per_word;
            }
            static std::__1::vector<bool, type-parameter-0-0>::size_type __external_cap_to_internal(std::__1::vector<bool, type-parameter-0-0>::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__n - 1) / __bits_per_word + 1;
            }
        public:
            vector<bool, type-parameter-0-0>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit vector<bool, type-parameter-0-0>(const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            ~vector<bool, type-parameter-0-0>();
            explicit vector<bool, type-parameter-0-0>(std::__1::vector<bool, type-parameter-0-0>::size_type __n);
            vector<bool, type-parameter-0-0>(std::__1::vector<bool, type-parameter-0-0>::size_type __n, const std::__1::vector<bool, type-parameter-0-0>::value_type &__v);
            vector<bool, type-parameter-0-0>(std::__1::vector<bool, type-parameter-0-0>::size_type __n, const std::__1::vector<bool, type-parameter-0-0>::value_type &__v, const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a);
            template <class _InputIterator> vector<bool, type-parameter-0-0>(_InputIterator __first, _InputIterator __last, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value>::type * = 0);
            template <class _InputIterator> vector<bool, type-parameter-0-0>(_InputIterator __first, _InputIterator __last, const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value>::type * = 0);
            template <class _ForwardIterator> vector<bool, type-parameter-0-0>(_ForwardIterator __first, _ForwardIterator __last, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type * = 0);
            template <class _ForwardIterator> vector<bool, type-parameter-0-0>(_ForwardIterator __first, _ForwardIterator __last, const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type * = 0);
            vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &__v);
            vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &__v, const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a);
            vector<bool, type-parameter-0-0> &operator=(const vector<bool, type-parameter-0-0> &__v);
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value, void>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            void assign(std::__1::vector<bool, type-parameter-0-0>::size_type __n, const std::__1::vector<bool, type-parameter-0-0>::value_type &__x);
            std::__1::vector<bool, type-parameter-0-0>::allocator_type get_allocator() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector<bool, type-parameter-0-0>::allocator_type(this->__alloc());
            }
            std::__1::vector<bool, type-parameter-0-0>::size_type max_size() const throw();
            std::__1::vector<bool, type-parameter-0-0>::size_type capacity() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __internal_cap_to_external(__cap());
            }
            std::__1::vector<bool, type-parameter-0-0>::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__size_;
            }
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__size_ == 0;
            }
            void reserve(std::__1::vector<bool, type-parameter-0-0>::size_type __n);
            void shrink_to_fit() throw();
            std::__1::vector<bool, type-parameter-0-0>::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_iter(0);
            }
            std::__1::vector<bool, type-parameter-0-0>::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_iter(0);
            }
            std::__1::vector<bool, type-parameter-0-0>::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_iter(this->__size_);
            }
            std::__1::vector<bool, type-parameter-0-0>::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_iter(this->__size_);
            }
            std::__1::vector<bool, type-parameter-0-0>::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector<bool, type-parameter-0-0>::reverse_iterator(end());
            }
            std::__1::vector<bool, type-parameter-0-0>::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector<bool, type-parameter-0-0>::const_reverse_iterator(end());
            }
            std::__1::vector<bool, type-parameter-0-0>::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector<bool, type-parameter-0-0>::reverse_iterator(begin());
            }
            std::__1::vector<bool, type-parameter-0-0>::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector<bool, type-parameter-0-0>::const_reverse_iterator(begin());
            }
            std::__1::vector<bool, type-parameter-0-0>::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_iter(0);
            }
            std::__1::vector<bool, type-parameter-0-0>::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_iter(this->__size_);
            }
            std::__1::vector<bool, type-parameter-0-0>::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rbegin();
            }
            std::__1::vector<bool, type-parameter-0-0>::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rend();
            }
            std::__1::vector<bool, type-parameter-0-0>::reference operator[](std::__1::vector<bool, type-parameter-0-0>::size_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_ref(__n);
            }
            std::__1::vector<bool, type-parameter-0-0>::const_reference operator[](std::__1::vector<bool, type-parameter-0-0>::size_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_ref(__n);
            }
            std::__1::vector<bool, type-parameter-0-0>::reference at(std::__1::vector<bool, type-parameter-0-0>::size_type __n);
            std::__1::vector<bool, type-parameter-0-0>::const_reference at(std::__1::vector<bool, type-parameter-0-0>::size_type __n) const;
            std::__1::vector<bool, type-parameter-0-0>::reference front() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_ref(0);
            }
            std::__1::vector<bool, type-parameter-0-0>::const_reference front() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_ref(0);
            }
            std::__1::vector<bool, type-parameter-0-0>::reference back() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_ref(this->__size_ - 1);
            }
            std::__1::vector<bool, type-parameter-0-0>::const_reference back() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __make_ref(this->__size_ - 1);
            }
            void push_back(const std::__1::vector<bool, type-parameter-0-0>::value_type &__x);
            void pop_back() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                --this->__size_;
            }
            std::__1::vector<bool, type-parameter-0-0>::iterator insert(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position, const std::__1::vector<bool, type-parameter-0-0>::value_type &__x);
            std::__1::vector<bool, type-parameter-0-0>::iterator insert(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position, std::__1::vector<bool, type-parameter-0-0>::size_type __n, const std::__1::vector<bool, type-parameter-0-0>::value_type &__x);
            std::__1::vector<bool, type-parameter-0-0>::iterator insert(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position, std::__1::vector<bool, type-parameter-0-0>::size_type __n, std::__1::vector<bool, type-parameter-0-0>::const_reference __x);
            template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value, iterator>::type insert(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, iterator>::type insert(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
            std::__1::vector<bool, type-parameter-0-0>::iterator erase(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::vector<bool, type-parameter-0-0>::iterator erase(std::__1::vector<bool, type-parameter-0-0>::const_iterator __first, std::__1::vector<bool, type-parameter-0-0>::const_iterator __last);
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__size_ = 0;
            }
            void swap(vector<bool, type-parameter-0-0> &);
            static void swap(std::__1::vector<bool, type-parameter-0-0>::reference __x, std::__1::vector<bool, type-parameter-0-0>::reference __y) throw()             {
                std::__1::swap(__x, __y);
            }
            void resize(std::__1::vector<bool, type-parameter-0-0>::size_type __sz, std::__1::vector<bool, type-parameter-0-0>::value_type __x = false);
            void flip() throw();
            bool __invariants() const;
        private:
            void __invalidate_all_iterators() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __vallocate(std::__1::vector<bool, type-parameter-0-0>::size_type __n);
            void __vdeallocate() throw();
            static std::__1::vector<bool, type-parameter-0-0>::size_type __align_it(std::__1::vector<bool, type-parameter-0-0>::size_type __new_size) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __new_size + (__bits_per_word - 1) & ~((std::__1::vector<bool, type-parameter-0-0>::size_type)__bits_per_word - 1);
            }
            std::__1::vector<bool, type-parameter-0-0>::size_type __recommend(std::__1::vector<bool, type-parameter-0-0>::size_type __new_size) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __construct_at_end(std::__1::vector<bool, type-parameter-0-0>::size_type __n, bool __x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
            void __append(std::__1::vector<bool, type-parameter-0-0>::size_type __n, std::__1::vector<bool, type-parameter-0-0>::const_reference __x);
            std::__1::vector<bool, type-parameter-0-0>::reference __make_ref(std::__1::vector<bool, type-parameter-0-0>::size_type __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector<bool, type-parameter-0-0>::reference(this->__begin_ + __pos / __bits_per_word, std::__1::vector<bool, type-parameter-0-0>::__storage_type(1) << __pos % __bits_per_word);
            }
            std::__1::vector<bool, type-parameter-0-0>::const_reference __make_ref(std::__1::vector<bool, type-parameter-0-0>::size_type __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector<bool, type-parameter-0-0>::const_reference(this->__begin_ + __pos / __bits_per_word, std::__1::vector<bool, type-parameter-0-0>::__storage_type(1) << __pos % __bits_per_word);
            }
            std::__1::vector<bool, type-parameter-0-0>::iterator __make_iter(std::__1::vector<bool, type-parameter-0-0>::size_type __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector<bool, type-parameter-0-0>::iterator(this->__begin_ + __pos / __bits_per_word, static_cast<unsigned int>(__pos % __bits_per_word));
            }
            std::__1::vector<bool, type-parameter-0-0>::const_iterator __make_iter(std::__1::vector<bool, type-parameter-0-0>::size_type __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::vector<bool, type-parameter-0-0>::const_iterator(this->__begin_ + __pos / __bits_per_word, static_cast<unsigned int>(__pos % __bits_per_word));
            }
            std::__1::vector<bool, type-parameter-0-0>::iterator __const_iterator_cast(std::__1::vector<bool, type-parameter-0-0>::const_iterator __p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return begin() + (__p - this->cbegin());
            }
            void __copy_assign_alloc(const vector<bool, type-parameter-0-0> &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __copy_assign_alloc(__v, integral_constant<bool, __storage_traits::propagate_on_container_copy_assignment::value>());
            }
            void __copy_assign_alloc(const vector<bool, type-parameter-0-0> &__c, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__alloc() != __c.__alloc())
                    this->__vdeallocate();
                __alloc() = __c.__alloc();
            }
            void __copy_assign_alloc(const vector<bool, type-parameter-0-0> &, std::__1::false_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __move_assign(vector<bool, type-parameter-0-0> &__c, std::__1::false_type);
            void __move_assign(vector<bool, type-parameter-0-0> &__c, std::__1::true_type);
            void __move_assign_alloc(vector<bool, type-parameter-0-0> &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __move_assign_alloc(__c, integral_constant<bool, __storage_traits::propagate_on_container_move_assignment::value>());
            }
            void __move_assign_alloc(vector<bool, type-parameter-0-0> &__c, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __alloc() = std::__1::move(__c.__alloc());
            }
            void __move_assign_alloc(vector<bool, type-parameter-0-0> &, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            size_t __hash_code() const throw();
            friend  class __bit_reference<vector<bool, type-parameter-0-0> >;
            friend  class __bit_const_reference<vector<bool, type-parameter-0-0> >;
            friend  class __bit_iterator<vector<bool, type-parameter-0-0>, false>;
            friend  class __bit_iterator<vector<bool, type-parameter-0-0>, true>;
            friend  struct __bit_array<vector<bool, type-parameter-0-0> >;
            friend  struct hash<vector<bool, type-parameter-0-0> >;
        };
        template <class _Allocator> inline void vector<bool, _Allocator>::__invalidate_all_iterators() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        template <class _Allocator> void vector<bool, _Allocator>::__vallocate(std::__1::vector<bool, type-parameter-0-0>::size_type __n)         {
            if (__n > this->max_size())
                this->__throw_length_error();
            __n = __external_cap_to_internal(__n);
            this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
            this->__size_ = 0;
            this->__cap() = __n;
        }
        template <class _Allocator> void vector<bool, _Allocator>::__vdeallocate() throw()         {
            if (this->__begin_ != std::__1::__get_nullptr_t()) {
                __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
                this->__invalidate_all_iterators();
                this->__begin_ = std::__1::__get_nullptr_t();
                this->__size_ = this->__cap() = 0;
            }
        }
        template <class _Allocator> typename vector<bool, _Allocator>::size_type vector<bool, _Allocator>::max_size() const throw()         {
            std::__1::vector<bool, type-parameter-0-0>::size_type __amax = __storage_traits::max_size(__alloc());
            std::__1::vector<bool, type-parameter-0-0>::size_type __nmax = numeric_limits<size_type>::max() / 2;
            if (__nmax / __bits_per_word <= __amax)
                return __nmax;
            return __internal_cap_to_external(__amax);
        }
        template <class _Allocator> inline typename vector<bool, _Allocator>::size_type vector<bool, _Allocator>::__recommend(std::__1::vector<bool, type-parameter-0-0>::size_type __new_size) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            const std::__1::vector<bool, type-parameter-0-0>::size_type __ms = this->max_size();
            if (__new_size > __ms)
                this->__throw_length_error();
            const std::__1::vector<bool, type-parameter-0-0>::size_type __cap = this->capacity();
            if (__cap >= __ms / 2)
                return __ms;
            return std::__1::max(2 * __cap, __align_it(__new_size));
        }
        template <class _Allocator> inline void vector<bool, _Allocator>::__construct_at_end(std::__1::vector<bool, type-parameter-0-0>::size_type __n, bool __x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::vector<bool, type-parameter-0-0>::size_type __old_size = this->__size_;
            this->__size_ += __n;
            if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word)) {
                if (this->__size_ <= __bits_per_word)
                    this->__begin_[0] = std::__1::vector<bool, type-parameter-0-0>::__storage_type(0);
                else
                    this->__begin_[(this->__size_ - 1) / __bits_per_word] = std::__1::vector<bool, type-parameter-0-0>::__storage_type(0);
            }
            std::__1::fill_n(__make_iter(__old_size), __n, __x);
        }
        template <class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)         {
            std::__1::vector<bool, type-parameter-0-0>::size_type __old_size = this->__size_;
            this->__size_ += std::__1::distance(__first, __last);
            if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word)) {
                if (this->__size_ <= __bits_per_word)
                    this->__begin_[0] = std::__1::vector<bool, type-parameter-0-0>::__storage_type(0);
                else
                    this->__begin_[(this->__size_ - 1) / __bits_per_word] = std::__1::vector<bool, type-parameter-0-0>::__storage_type(0);
            }
            std::__1::copy(__first, __last, __make_iter(__old_size));
        }
        template <class _Allocator> inline vector<bool, _Allocator>::vector<bool, type-parameter-0-0>() : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        template <class _Allocator> inline explicit vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, static_cast<std::__1::vector<bool, type-parameter-0-0>::__storage_allocator>(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
        }
        template <class _Allocator> explicit vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(std::__1::vector<bool, type-parameter-0-0>::size_type __n) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, std::__1::__default_init_tag())         {
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__n, false);
            }
        }
        template <class _Allocator> vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(std::__1::vector<bool, type-parameter-0-0>::size_type __n, const std::__1::vector<bool, type-parameter-0-0>::value_type &__x) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, std::__1::__default_init_tag())         {
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__n, __x);
            }
        }
        template <class _Allocator> vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(std::__1::vector<bool, type-parameter-0-0>::size_type __n, const std::__1::vector<bool, type-parameter-0-0>::value_type &__x, const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, static_cast<std::__1::vector<bool, type-parameter-0-0>::__storage_allocator>(__a))         {
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__n, __x);
            }
        }
        template <class _Allocator> template <class _InputIterator> vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(_InputIterator __first, _InputIterator __last, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value>::type * = 0) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, std::__1::__default_init_tag())         {
            try {
                for (; __first != __last; ++__first)
                    this->push_back(*__first);
            } catch (...) {
                if (this->__begin_ != std::__1::__get_nullptr_t())
                    __storage_traits::deallocate(__alloc(), this->__begin_, __cap());
                this->__invalidate_all_iterators();
                throw;
            }
        }
        template <class _Allocator> template <class _InputIterator> vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(_InputIterator __first, _InputIterator __last, const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value>::type * = 0) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, static_cast<std::__1::vector<bool, type-parameter-0-0>::__storage_allocator>(__a))         {
            try {
                for (; __first != __last; ++__first)
                    this->push_back(*__first);
            } catch (...) {
                if (this->__begin_ != std::__1::__get_nullptr_t())
                    __storage_traits::deallocate(__alloc(), this->__begin_, __cap());
                this->__invalidate_all_iterators();
                throw;
            }
        }
        template <class _Allocator> template <class _ForwardIterator> vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(_ForwardIterator __first, _ForwardIterator __last, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type * = 0) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, std::__1::__default_init_tag())         {
            std::__1::vector<bool, type-parameter-0-0>::size_type __n = static_cast<std::__1::vector<bool, type-parameter-0-0>::size_type>(std::__1::distance(__first, __last));
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__first, __last);
            }
        }
        template <class _Allocator> template <class _ForwardIterator> vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(_ForwardIterator __first, _ForwardIterator __last, const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type * = 0) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, static_cast<std::__1::vector<bool, type-parameter-0-0>::__storage_allocator>(__a))         {
            std::__1::vector<bool, type-parameter-0-0>::size_type __n = static_cast<std::__1::vector<bool, type-parameter-0-0>::size_type>(std::__1::distance(__first, __last));
            if (__n > 0) {
                this->__vallocate(__n);
                __construct_at_end(__first, __last);
            }
        }
        template <class _Allocator> vector<bool, _Allocator>::~vector<bool, type-parameter-0-0>()         {
            if (this->__begin_ != std::__1::__get_nullptr_t())
                __storage_traits::deallocate(__alloc(), this->__begin_, __cap());
            this->__invalidate_all_iterators();
        }
        template <class _Allocator> vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &__v) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))         {
            if (__v.size() > 0) {
                this->__vallocate(__v.size());
                __construct_at_end(__v.begin(), __v.end());
            }
        }
        template <class _Allocator> vector<bool, _Allocator>::vector<bool, type-parameter-0-0>(const vector<bool, type-parameter-0-0> &__v, const std::__1::vector<bool, type-parameter-0-0>::allocator_type &__a) : __begin_(std::__1::__get_nullptr_t()), __size_(0), __cap_alloc_(0, __a)         {
            if (__v.size() > 0) {
                this->__vallocate(__v.size());
                __construct_at_end(__v.begin(), __v.end());
            }
        }
        template <class _Allocator> vector<bool, _Allocator> &vector<bool, _Allocator>::operator=(const vector<bool, type-parameter-0-0> &__v)         {
            if (this != &__v) {
                __copy_assign_alloc(__v);
                if (__v.__size_) {
                    if (__v.__size_ > this->capacity()) {
                        this->__vdeallocate();
                        this->__vallocate(__v.__size_);
                    }
                    std::__1::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), this->__begin_);
                }
                this->__size_ = __v.__size_;
            }
            return *this;
        }
        template <class _Allocator> void vector<bool, _Allocator>::assign(std::__1::vector<bool, type-parameter-0-0>::size_type __n, const std::__1::vector<bool, type-parameter-0-0>::value_type &__x)         {
            this->__size_ = 0;
            if (__n > 0) {
                std::__1::vector<bool, type-parameter-0-0>::size_type __c = this->capacity();
                if (__n <= __c)
                    this->__size_ = __n;
                else {
                    vector<bool, type-parameter-0-0> __v(__alloc());
                    __v.reserve(this->__recommend(__n));
                    __v.__size_ = __n;
                    swap(__v);
                }
                std::__1::fill_n(begin(), __n, __x);
            }
            this->__invalidate_all_iterators();
        }
        template <class _Allocator> template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value, void>::type vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)         {
            this->clear();
            for (; __first != __last; ++__first)
                this->push_back(*__first);
        }
        template <class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)         {
            this->clear();
            std::__1::vector<bool, type-parameter-0-0>::difference_type __ns = std::__1::distance(__first, __last);
            ((void)0);
            const size_t __n = static_cast<std::__1::vector<bool, type-parameter-0-0>::size_type>(__ns);
            if (__n) {
                if (__n > this->capacity()) {
                    this->__vdeallocate();
                    this->__vallocate(__n);
                }
                __construct_at_end(__first, __last);
            }
        }
        template <class _Allocator> void vector<bool, _Allocator>::reserve(std::__1::vector<bool, type-parameter-0-0>::size_type __n)         {
            if (__n > this->capacity()) {
                vector<bool, type-parameter-0-0> __v(this->__alloc());
                __v.__vallocate(__n);
                __v.__construct_at_end(this->begin(), this->end());
                swap(__v);
                this->__invalidate_all_iterators();
            }
        }
        template <class _Allocator> void vector<bool, _Allocator>::shrink_to_fit() throw()         {
            if (__external_cap_to_internal(this->size()) > __cap()) {
                try {
                    vector<bool, type-parameter-0-0>(*this, std::__1::vector<bool, type-parameter-0-0>::allocator_type(__alloc())).swap(*this);
                } catch (...) {
                }
            }
        }
        template <class _Allocator> typename vector<bool, _Allocator>::reference vector<bool, _Allocator>::at(std::__1::vector<bool, type-parameter-0-0>::size_type __n)         {
            if (__n >= this->size())
                this->__throw_out_of_range();
            return (*this)[__n];
        }
        template <class _Allocator> typename vector<bool, _Allocator>::const_reference vector<bool, _Allocator>::at(std::__1::vector<bool, type-parameter-0-0>::size_type __n) const         {
            if (__n >= this->size())
                this->__throw_out_of_range();
            return (*this)[__n];
        }
        template <class _Allocator> void vector<bool, _Allocator>::push_back(const std::__1::vector<bool, type-parameter-0-0>::value_type &__x)         {
            if (this->__size_ == this->capacity())
                this->reserve(this->__recommend(this->__size_ + 1));
            ++this->__size_;
            back() = __x;
        }
        template <class _Allocator> typename vector<bool, _Allocator>::iterator vector<bool, _Allocator>::insert(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position, const std::__1::vector<bool, type-parameter-0-0>::value_type &__x)         {
            std::__1::vector<bool, type-parameter-0-0>::iterator __r;
            if (this->size() < this->capacity()) {
                std::__1::vector<bool, type-parameter-0-0>::const_iterator __old_end = end();
                ++this->__size_;
                std::__1::copy_backward(__position, __old_end, end());
                __r = this->__const_iterator_cast(__position);
            } else {
                vector<bool, type-parameter-0-0> __v(__alloc());
                __v.reserve(this->__recommend(this->__size_ + 1));
                __v.__size_ = this->__size_ + 1;
                __r = std::__1::copy(this->cbegin(), __position, __v.begin());
                std::__1::copy_backward(__position, this->cend(), __v.end());
                swap(__v);
            }
            *__r = __x;
            return __r;
        }
        template <class _Allocator> typename vector<bool, _Allocator>::iterator vector<bool, _Allocator>::insert(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position, std::__1::vector<bool, type-parameter-0-0>::size_type __n, const std::__1::vector<bool, type-parameter-0-0>::value_type &__x)         {
            std::__1::vector<bool, type-parameter-0-0>::iterator __r;
            std::__1::vector<bool, type-parameter-0-0>::size_type __c = this->capacity();
            if (__n <= __c && this->size() <= __c - __n) {
                std::__1::vector<bool, type-parameter-0-0>::const_iterator __old_end = end();
                this->__size_ += __n;
                std::__1::copy_backward(__position, __old_end, end());
                __r = this->__const_iterator_cast(__position);
            } else {
                vector<bool, type-parameter-0-0> __v(__alloc());
                __v.reserve(this->__recommend(this->__size_ + __n));
                __v.__size_ = this->__size_ + __n;
                __r = std::__1::copy(this->cbegin(), __position, __v.begin());
                std::__1::copy_backward(__position, this->cend(), __v.end());
                swap(__v);
            }
            std::__1::fill_n(__r, __n, __x);
            return __r;
        }
        template <class _Allocator> template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value && !__is_cpp17_forward_iterator<_InputIterator>::value, typename vector<bool, _Allocator>::iterator>::type vector<bool, _Allocator>::insert(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position, _InputIterator __first, _InputIterator __last)         {
            std::__1::vector<bool, type-parameter-0-0>::difference_type __off = __position - begin();
            std::__1::vector<bool, type-parameter-0-0>::iterator __p = this->__const_iterator_cast(__position);
            std::__1::vector<bool, type-parameter-0-0>::iterator __old_end = end();
            for (; this->size() != this->capacity() && __first != __last; ++__first) {
                ++this->__size_;
                back() = *__first;
            }
            vector<bool, type-parameter-0-0> __v(__alloc());
            if (__first != __last) {
                try {
                    __v.assign(__first, __last);
                    std::__1::vector<bool, type-parameter-0-0>::difference_type __old_size = static_cast<std::__1::vector<bool, type-parameter-0-0>::difference_type>(__old_end - begin());
                    std::__1::vector<bool, type-parameter-0-0>::difference_type __old_p = __p - begin();
                    this->reserve(this->__recommend(this->size() + __v.size()));
                    __p = begin() + __old_p;
                    __old_end = begin() + __old_size;
                } catch (...) {
                    erase(__old_end, end());
                    throw;
                }
            }
            __p = std::__1::rotate(__p, __old_end, end());
            insert(__p, __v.begin(), __v.end());
            return begin() + __off;
        }
        template <class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, typename vector<bool, _Allocator>::iterator>::type vector<bool, _Allocator>::insert(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)         {
            const std::__1::vector<bool, type-parameter-0-0>::difference_type __n_signed = std::__1::distance(__first, __last);
            ((void)0);
            const std::__1::vector<bool, type-parameter-0-0>::size_type __n = static_cast<std::__1::vector<bool, type-parameter-0-0>::size_type>(__n_signed);
            std::__1::vector<bool, type-parameter-0-0>::iterator __r;
            std::__1::vector<bool, type-parameter-0-0>::size_type __c = this->capacity();
            if (__n <= __c && this->size() <= __c - __n) {
                std::__1::vector<bool, type-parameter-0-0>::const_iterator __old_end = end();
                this->__size_ += __n;
                std::__1::copy_backward(__position, __old_end, end());
                __r = this->__const_iterator_cast(__position);
            } else {
                vector<bool, type-parameter-0-0> __v(__alloc());
                __v.reserve(this->__recommend(this->__size_ + __n));
                __v.__size_ = this->__size_ + __n;
                __r = std::__1::copy(this->cbegin(), __position, __v.begin());
                std::__1::copy_backward(__position, this->cend(), __v.end());
                swap(__v);
            }
            std::__1::copy(__first, __last, __r);
            return __r;
        }
        template <class _Allocator> inline typename vector<bool, _Allocator>::iterator vector<bool, _Allocator>::erase(std::__1::vector<bool, type-parameter-0-0>::const_iterator __position) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::vector<bool, type-parameter-0-0>::iterator __r = this->__const_iterator_cast(__position);
            std::__1::copy(__position + 1, this->cend(), __r);
            --this->__size_;
            return __r;
        }
        template <class _Allocator> typename vector<bool, _Allocator>::iterator vector<bool, _Allocator>::erase(std::__1::vector<bool, type-parameter-0-0>::const_iterator __first, std::__1::vector<bool, type-parameter-0-0>::const_iterator __last)         {
            std::__1::vector<bool, type-parameter-0-0>::iterator __r = this->__const_iterator_cast(__first);
            std::__1::vector<bool, type-parameter-0-0>::difference_type __d = __last - __first;
            std::__1::copy(__last, this->cend(), __r);
            this->__size_ -= __d;
            return __r;
        }
        template <class _Allocator> void vector<bool, _Allocator>::swap(vector<bool, type-parameter-0-0> &__x)         {
            std::__1::swap(this->__begin_, __x.__begin_);
            std::__1::swap(this->__size_, __x.__size_);
            std::__1::swap(this->__cap(), __x.__cap());
            __swap_allocator(this->__alloc(), __x.__alloc(), integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
        }
        template <class _Allocator> void vector<bool, _Allocator>::resize(std::__1::vector<bool, type-parameter-0-0>::size_type __sz, std::__1::vector<bool, type-parameter-0-0>::value_type __x = false)         {
            std::__1::vector<bool, type-parameter-0-0>::size_type __cs = this->size();
            if (__cs < __sz) {
                std::__1::vector<bool, type-parameter-0-0>::iterator __r;
                std::__1::vector<bool, type-parameter-0-0>::size_type __c = this->capacity();
                std::__1::vector<bool, type-parameter-0-0>::size_type __n = __sz - __cs;
                if (__n <= __c && __cs <= __c - __n) {
                    __r = end();
                    this->__size_ += __n;
                } else {
                    vector<bool, type-parameter-0-0> __v(__alloc());
                    __v.reserve(this->__recommend(this->__size_ + __n));
                    __v.__size_ = this->__size_ + __n;
                    __r = std::__1::copy(this->cbegin(), this->cend(), __v.begin());
                    swap(__v);
                }
                std::__1::fill_n(__r, __n, __x);
            } else
                this->__size_ = __sz;
        }
        template <class _Allocator> void vector<bool, _Allocator>::flip() throw()         {
            std::__1::vector<bool, type-parameter-0-0>::size_type __n = this->__size_;
            std::__1::vector<bool, type-parameter-0-0>::__storage_pointer __p = this->__begin_;
            for (; __n >= __bits_per_word; ++__p , __n -= __bits_per_word)
                *__p = ~*__p;
            if (__n > 0) {
                std::__1::vector<bool, type-parameter-0-0>::__storage_type __m = ~std::__1::vector<bool, type-parameter-0-0>::__storage_type(0) >> (__bits_per_word - __n);
                std::__1::vector<bool, type-parameter-0-0>::__storage_type __b = *__p & __m;
                *__p &= ~__m;
                *__p |= ~__b & __m;
            }
        }
        template <class _Allocator> bool vector<bool, _Allocator>::__invariants() const         {
            if (this->__begin_ == std::__1::__get_nullptr_t()) {
                if (this->__size_ != 0 || this->__cap() != 0)
                    return false;
            } else {
                if (this->__cap() == 0)
                    return false;
                if (this->__size_ > this->capacity())
                    return false;
            }
            return true;
        }
        template <class _Allocator> size_t vector<bool, _Allocator>::__hash_code() const throw()         {
            size_t __h = 0;
            std::__1::vector<bool, type-parameter-0-0>::size_type __n = this->__size_;
            std::__1::vector<bool, type-parameter-0-0>::__storage_pointer __p = this->__begin_;
            for (; __n >= __bits_per_word; ++__p , __n -= __bits_per_word)
                __h ^= *__p;
            if (__n > 0) {
                const std::__1::vector<bool, type-parameter-0-0>::__storage_type __m = ~std::__1::vector<bool, type-parameter-0-0>::__storage_type(0) >> (__bits_per_word - __n);
                __h ^= *__p & __m;
            }
            return __h;
        }
        template <class _Allocator> struct __attribute__((type_visibility("default"))) hash<vector<bool, _Allocator>> : public unary_function<vector<bool, _Allocator>, size_t> {
            size_t operator()(const vector<bool, _Allocator> &__vec) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __vec.__hash_code();
            }
        };
        template <class _Tp, class _Allocator> inline bool operator==(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
            return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
        }
        template<> inline bool operator==<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> >>(const vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__x, const vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > > &__y) __attribute__((internal_linkage))         {
            const typename vector<basic_string<char>, allocator<basic_string<char> > >::size_type __sz = __x.size();
            return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
        }
        template <class _Tp, class _Allocator> inline bool operator!=(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Tp, class _Allocator> inline bool operator<(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
        }
        template <class _Tp, class _Allocator> inline bool operator>(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Tp, class _Allocator> inline bool operator>=(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Tp, class _Allocator> inline bool operator<=(const vector<_Tp, _Allocator> &__x, const vector<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Tp, class _Allocator> inline void swap(vector<_Tp, _Allocator> &__x, vector<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
    }
}
namespace std {
    inline namespace __1 {
        template <class _Tp, class _Compare, class _Allocator> class __tree;
        template <class _Tp, class _NodePtr, class _DiffType> class __attribute__((type_visibility("default"))) __tree_iterator;
        template <class _Tp, class _ConstNodePtr, class _DiffType> class __attribute__((type_visibility("default"))) __tree_const_iterator;
        template <class _Pointer> class __tree_end_node;
        template <class _VoidPtr> class __tree_node_base;
        template <class _Tp, class _VoidPtr> class __tree_node;
        template <class _Key, class _Value> struct __value_type;
        template <class _Allocator> class __map_node_destructor;
        template <class _TreeIterator> class __attribute__((type_visibility("default"))) __map_iterator;
        template <class _TreeIterator> class __attribute__((type_visibility("default"))) __map_const_iterator;
        template <class _NodePtr> inline bool __tree_is_left_child(_NodePtr __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x == __x->__parent_->__left_;
        }
        template <class _NodePtr> unsigned int __tree_sub_invariant(_NodePtr __x)         {
            if (__x == std::__1::__get_nullptr_t())
                return 1;
            if (__x->__left_ != std::__1::__get_nullptr_t() && __x->__left_->__parent_ != __x)
                return 0;
            if (__x->__right_ != std::__1::__get_nullptr_t() && __x->__right_->__parent_ != __x)
                return 0;
            if (__x->__left_ == __x->__right_ && __x->__left_ != std::__1::__get_nullptr_t())
                return 0;
            if (!__x->__is_black_) {
                if (__x->__left_ && !__x->__left_->__is_black_)
                    return 0;
                if (__x->__right_ && !__x->__right_->__is_black_)
                    return 0;
            }
            unsigned int __h = __tree_sub_invariant(__x->__left_);
            if (__h == 0)
                return 0;
            if (__h != __tree_sub_invariant(__x->__right_))
                return 0;
            return __h + __x->__is_black_;
        }
        template <class _NodePtr> bool __tree_invariant(_NodePtr __root)         {
            if (__root == std::__1::__get_nullptr_t())
                return true;
            if (__root->__parent_ == std::__1::__get_nullptr_t())
                return false;
            if (!__tree_is_left_child(__root))
                return false;
            if (!__root->__is_black_)
                return false;
            return __tree_sub_invariant(__root) != 0;
        }
        template <class _NodePtr> inline _NodePtr __tree_min(_NodePtr __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            while (__x->__left_ != std::__1::__get_nullptr_t())
                __x = __x->__left_;
            return __x;
        }
        template <class _NodePtr> inline _NodePtr __tree_max(_NodePtr __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            while (__x->__right_ != std::__1::__get_nullptr_t())
                __x = __x->__right_;
            return __x;
        }
        template <class _NodePtr> _NodePtr __tree_next(_NodePtr __x) throw()         {
            if (__x->__right_ != std::__1::__get_nullptr_t())
                return __tree_min(__x->__right_);
            while (!__tree_is_left_child(__x))
                __x = __x->__parent_unsafe();
            return __x->__parent_unsafe();
        }
        template <class _EndNodePtr, class _NodePtr> inline _EndNodePtr __tree_next_iter(_NodePtr __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__x->__right_ != std::__1::__get_nullptr_t())
                return static_cast<_EndNodePtr>(__tree_min(__x->__right_));
            while (!__tree_is_left_child(__x))
                __x = __x->__parent_unsafe();
            return static_cast<_EndNodePtr>(__x->__parent_);
        }
        template <class _NodePtr, class _EndNodePtr> inline _NodePtr __tree_prev_iter(_EndNodePtr __x) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__x->__left_ != std::__1::__get_nullptr_t())
                return __tree_max(__x->__left_);
            _NodePtr __xx = static_cast<_NodePtr>(__x);
            while (__tree_is_left_child(__xx))
                __xx = __xx->__parent_unsafe();
            return __xx->__parent_unsafe();
        }
        template <class _NodePtr> _NodePtr __tree_leaf(_NodePtr __x) throw()         {
            while (true)
                {
                    if (__x->__left_ != std::__1::__get_nullptr_t()) {
                        __x = __x->__left_;
                        continue;
                    }
                    if (__x->__right_ != std::__1::__get_nullptr_t()) {
                        __x = __x->__right_;
                        continue;
                    }
                    break;
                }
            return __x;
        }
        template <class _NodePtr> void __tree_left_rotate(_NodePtr __x) throw()         {
            _NodePtr __y = __x->__right_;
            __x->__right_ = __y->__left_;
            if (__x->__right_ != std::__1::__get_nullptr_t())
                __x->__right_->__set_parent(__x);
            __y->__parent_ = __x->__parent_;
            if (__tree_is_left_child(__x))
                __x->__parent_->__left_ = __y;
            else
                __x->__parent_unsafe()->__right_ = __y;
            __y->__left_ = __x;
            __x->__set_parent(__y);
        }
        template <class _NodePtr> void __tree_right_rotate(_NodePtr __x) throw()         {
            _NodePtr __y = __x->__left_;
            __x->__left_ = __y->__right_;
            if (__x->__left_ != std::__1::__get_nullptr_t())
                __x->__left_->__set_parent(__x);
            __y->__parent_ = __x->__parent_;
            if (__tree_is_left_child(__x))
                __x->__parent_->__left_ = __y;
            else
                __x->__parent_unsafe()->__right_ = __y;
            __y->__right_ = __x;
            __x->__set_parent(__y);
        }
        template <class _NodePtr> void __tree_balance_after_insert(_NodePtr __root, _NodePtr __x) throw()         {
            __x->__is_black_ = __x == __root;
            while (__x != __root && !__x->__parent_unsafe()->__is_black_)
                {
                    if (__tree_is_left_child(__x->__parent_unsafe())) {
                        _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
                        if (__y != std::__1::__get_nullptr_t() && !__y->__is_black_) {
                            __x = __x->__parent_unsafe();
                            __x->__is_black_ = true;
                            __x = __x->__parent_unsafe();
                            __x->__is_black_ = __x == __root;
                            __y->__is_black_ = true;
                        } else {
                            if (!__tree_is_left_child(__x)) {
                                __x = __x->__parent_unsafe();
                                __tree_left_rotate(__x);
                            }
                            __x = __x->__parent_unsafe();
                            __x->__is_black_ = true;
                            __x = __x->__parent_unsafe();
                            __x->__is_black_ = false;
                            __tree_right_rotate(__x);
                            break;
                        }
                    } else {
                        _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
                        if (__y != std::__1::__get_nullptr_t() && !__y->__is_black_) {
                            __x = __x->__parent_unsafe();
                            __x->__is_black_ = true;
                            __x = __x->__parent_unsafe();
                            __x->__is_black_ = __x == __root;
                            __y->__is_black_ = true;
                        } else {
                            if (__tree_is_left_child(__x)) {
                                __x = __x->__parent_unsafe();
                                __tree_right_rotate(__x);
                            }
                            __x = __x->__parent_unsafe();
                            __x->__is_black_ = true;
                            __x = __x->__parent_unsafe();
                            __x->__is_black_ = false;
                            __tree_left_rotate(__x);
                            break;
                        }
                    }
                }
        }
        template <class _NodePtr> void __tree_remove(_NodePtr __root, _NodePtr __z) throw()         {
            _NodePtr __y = (__z->__left_ == std::__1::__get_nullptr_t() || __z->__right_ == std::__1::__get_nullptr_t()) ? __z : __tree_next(__z);
            _NodePtr __x = __y->__left_ != std::__1::__get_nullptr_t() ? __y->__left_ : __y->__right_;
            _NodePtr __w = std::__1::__get_nullptr_t();
            if (__x != std::__1::__get_nullptr_t())
                __x->__parent_ = __y->__parent_;
            if (__tree_is_left_child(__y)) {
                __y->__parent_->__left_ = __x;
                if (__y != __root)
                    __w = __y->__parent_unsafe()->__right_;
                else
                    __root = __x;
            } else {
                __y->__parent_unsafe()->__right_ = __x;
                __w = __y->__parent_->__left_;
            }
            bool __removed_black = __y->__is_black_;
            if (__y != __z) {
                __y->__parent_ = __z->__parent_;
                if (__tree_is_left_child(__z))
                    __y->__parent_->__left_ = __y;
                else
                    __y->__parent_unsafe()->__right_ = __y;
                __y->__left_ = __z->__left_;
                __y->__left_->__set_parent(__y);
                __y->__right_ = __z->__right_;
                if (__y->__right_ != std::__1::__get_nullptr_t())
                    __y->__right_->__set_parent(__y);
                __y->__is_black_ = __z->__is_black_;
                if (__root == __z)
                    __root = __y;
            }
            if (__removed_black && __root != std::__1::__get_nullptr_t()) {
                if (__x != std::__1::__get_nullptr_t())
                    __x->__is_black_ = true;
                else {
                    while (true)
                        {
                            if (!__tree_is_left_child(__w)) {
                                if (!__w->__is_black_) {
                                    __w->__is_black_ = true;
                                    __w->__parent_unsafe()->__is_black_ = false;
                                    __tree_left_rotate(__w->__parent_unsafe());
                                    if (__root == __w->__left_)
                                        __root = __w;
                                    __w = __w->__left_->__right_;
                                }
                                if ((__w->__left_ == std::__1::__get_nullptr_t() || __w->__left_->__is_black_) && (__w->__right_ == std::__1::__get_nullptr_t() || __w->__right_->__is_black_)) {
                                    __w->__is_black_ = false;
                                    __x = __w->__parent_unsafe();
                                    if (__x == __root || !__x->__is_black_) {
                                        __x->__is_black_ = true;
                                        break;
                                    }
                                    __w = __tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_ : __x->__parent_->__left_;
                                } else {
                                    if (__w->__right_ == std::__1::__get_nullptr_t() || __w->__right_->__is_black_) {
                                        __w->__left_->__is_black_ = true;
                                        __w->__is_black_ = false;
                                        __tree_right_rotate(__w);
                                        __w = __w->__parent_unsafe();
                                    }
                                    __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                                    __w->__parent_unsafe()->__is_black_ = true;
                                    __w->__right_->__is_black_ = true;
                                    __tree_left_rotate(__w->__parent_unsafe());
                                    break;
                                }
                            } else {
                                if (!__w->__is_black_) {
                                    __w->__is_black_ = true;
                                    __w->__parent_unsafe()->__is_black_ = false;
                                    __tree_right_rotate(__w->__parent_unsafe());
                                    if (__root == __w->__right_)
                                        __root = __w;
                                    __w = __w->__right_->__left_;
                                }
                                if ((__w->__left_ == std::__1::__get_nullptr_t() || __w->__left_->__is_black_) && (__w->__right_ == std::__1::__get_nullptr_t() || __w->__right_->__is_black_)) {
                                    __w->__is_black_ = false;
                                    __x = __w->__parent_unsafe();
                                    if (!__x->__is_black_ || __x == __root) {
                                        __x->__is_black_ = true;
                                        break;
                                    }
                                    __w = __tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_ : __x->__parent_->__left_;
                                } else {
                                    if (__w->__left_ == std::__1::__get_nullptr_t() || __w->__left_->__is_black_) {
                                        __w->__right_->__is_black_ = true;
                                        __w->__is_black_ = false;
                                        __tree_left_rotate(__w);
                                        __w = __w->__parent_unsafe();
                                    }
                                    __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                                    __w->__parent_unsafe()->__is_black_ = true;
                                    __w->__left_->__is_black_ = true;
                                    __tree_right_rotate(__w->__parent_unsafe());
                                    break;
                                }
                            }
                        }
                }
            }
        }
        template <class _Tp> struct __tree_key_value_types {
            typedef _Tp key_type;
            typedef _Tp __node_value_type;
            typedef _Tp __container_value_type;
            static const bool __is_map = false;
            static const std::__1::__tree_key_value_types::key_type &__get_key(const _Tp &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __v;
            }
            static const std::__1::__tree_key_value_types::__container_value_type &__get_value(const std::__1::__tree_key_value_types::__node_value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __v;
            }
            static std::__1::__tree_key_value_types::__container_value_type *__get_ptr(std::__1::__tree_key_value_types::__node_value_type &__n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::addressof(__n);
            }
        };
        template <class _Key, class _Tp> struct __tree_key_value_types<__value_type<_Key, _Tp>> {
            typedef _Key key_type;
            typedef _Tp mapped_type;
            typedef __value_type<_Key, _Tp> __node_value_type;
            typedef pair<const _Key, _Tp> __container_value_type;
            typedef std::__1::__tree_key_value_types<__value_type<type-parameter-0-0, type-parameter-0-1> >::__container_value_type __map_value_type;
            static const bool __is_map = true;
            static const std::__1::__tree_key_value_types<__value_type<type-parameter-0-0, type-parameter-0-1> >::key_type &__get_key(const std::__1::__tree_key_value_types<__value_type<type-parameter-0-0, type-parameter-0-1> >::__node_value_type &__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __t.__get_value().first;
            }
            template <class _Up> static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value, const key_type &>::type __get_key(_Up &__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __t.first;
            }
            static const std::__1::__tree_key_value_types<__value_type<type-parameter-0-0, type-parameter-0-1> >::__container_value_type &__get_value(const std::__1::__tree_key_value_types<__value_type<type-parameter-0-0, type-parameter-0-1> >::__node_value_type &__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __t.__get_value();
            }
            template <class _Up> static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value, const __container_value_type &>::type __get_value(_Up &__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __t;
            }
            static std::__1::__tree_key_value_types<__value_type<type-parameter-0-0, type-parameter-0-1> >::__container_value_type *__get_ptr(std::__1::__tree_key_value_types<__value_type<type-parameter-0-0, type-parameter-0-1> >::__node_value_type &__n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::addressof(__n.__get_value());
            }
        };
        template <class _VoidPtr> struct __tree_node_base_types {
            typedef _VoidPtr __void_pointer;
            typedef __tree_node_base<std::__1::__tree_node_base_types::__void_pointer> __node_base_type;
            typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type __node_base_pointer;
            typedef __tree_end_node<std::__1::__tree_node_base_types::__node_base_pointer> __end_node_type;
            typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type __end_node_pointer;
            typedef typename conditional<is_pointer<__end_node_pointer>::value, __end_node_pointer, __node_base_pointer>::type __parent_pointer;
        private:
            static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value), "_VoidPtr does not point to unqualified void type");
        };
        template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>, bool = _KVTypes::__is_map> struct __tree_map_pointer_types {
        };
        template <class _Tp, class _AllocPtr, class _KVTypes> struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
            typedef typename _KVTypes::__map_value_type _Mv;
            typedef typename __rebind_pointer<_AllocPtr, _Mv>::type __map_value_type_pointer;
            typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type __const_map_value_type_pointer;
        };
        template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type> struct __tree_node_types;
        template <class _NodePtr, class _Tp, class _VoidPtr> struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr>> : public __tree_node_base_types<_VoidPtr>, __tree_key_value_types<_Tp>, __tree_map_pointer_types<_Tp, _VoidPtr> {
            typedef __tree_node_base_types<_VoidPtr> __base;
            typedef __tree_key_value_types<_Tp> __key_base;
            typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;
        public:
            typedef typename pointer_traits<_NodePtr>::element_type __node_type;
            typedef _NodePtr __node_pointer;
            typedef _Tp __node_value_type;
            typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type __node_value_type_pointer;
            typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type __const_node_value_type_pointer;
            typedef typename conditional<is_pointer<__node_pointer>::value, typename __base::__end_node_pointer, __node_pointer>::type __iter_pointer;
        private:
            static_assert(!is_const<__node_type>::value, "_NodePtr should never be a pointer to const");
            static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type, _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
        };
        template <class _ValueTp, class _VoidPtr> struct __make_tree_node_types {
            typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type _NodePtr;
            typedef __tree_node_types<std::__1::__make_tree_node_types::_NodePtr> type;
        };
        template <class _Pointer> class __tree_end_node {
        public:
            typedef _Pointer pointer;
            std::__1::__tree_end_node::pointer __left_;
            __tree_end_node<_Pointer>() throw() : __left_() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
        template <class _VoidPtr> class __tree_node_base : public __tree_node_base_types<_VoidPtr>::__end_node_type {
            typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;
        public:
            typedef typename _NodeBaseTypes::__node_base_pointer pointer;
            typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;
            std::__1::__tree_node_base::pointer __right_;
            std::__1::__tree_node_base::__parent_pointer __parent_;
            bool __is_black_;
            std::__1::__tree_node_base::pointer __parent_unsafe() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__tree_node_base::pointer>(this->__parent_);
            }
            void __set_parent(std::__1::__tree_node_base::pointer __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__parent_ = static_cast<std::__1::__tree_node_base::__parent_pointer>(__p);
            }
        private:
            ~__tree_node_base<_VoidPtr>();
            __tree_node_base<_VoidPtr>(const __tree_node_base<_VoidPtr> &);
            __tree_node_base<_VoidPtr> &operator=(const __tree_node_base<_VoidPtr> &);
        };
        template <class _Tp, class _VoidPtr> class __tree_node : public __tree_node_base<_VoidPtr> {
        public:
            typedef _Tp __node_value_type;
            std::__1::__tree_node::__node_value_type __value_;
        private:
            ~__tree_node<_Tp, _VoidPtr>();
            __tree_node<_Tp, _VoidPtr>(const __tree_node<_Tp, _VoidPtr> &);
            __tree_node<_Tp, _VoidPtr> &operator=(const __tree_node<_Tp, _VoidPtr> &);
        };
        template <class _Allocator> class __tree_node_destructor {
            typedef _Allocator allocator_type;
            typedef allocator_traits<std::__1::__tree_node_destructor::allocator_type> __alloc_traits;
        public:
            typedef typename __alloc_traits::pointer pointer;
        private:
            typedef __tree_node_types<std::__1::__tree_node_destructor::pointer> _NodeTypes;
            std::__1::__tree_node_destructor::allocator_type &__na_;
        public:
            bool __value_constructed;
            __tree_node_destructor<_Allocator>(const __tree_node_destructor<_Allocator> &) = default
            __tree_node_destructor<_Allocator> &operator=(const __tree_node_destructor<_Allocator> &) = delete
            explicit __tree_node_destructor<_Allocator>(std::__1::__tree_node_destructor::allocator_type &__na, bool __val = false) throw() : __na_(__na), __value_constructed(__val) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void operator()(std::__1::__tree_node_destructor::pointer __p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__value_constructed)
                    __alloc_traits::destroy(this->__na_, _NodeTypes::__get_ptr(__p->__value_));
                if (__p)
                    __alloc_traits::deallocate(this->__na_, __p, 1);
            }
            friend template <class> class __map_node_destructor;
        };
        template <class _Tp, class _NodePtr, class _DiffType> class __attribute__((type_visibility("default"))) __tree_iterator {
            typedef __tree_node_types<_NodePtr> _NodeTypes;
            typedef _NodePtr __node_pointer;
            typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
            typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
            typedef typename _NodeTypes::__iter_pointer __iter_pointer;
            typedef pointer_traits<std::__1::__tree_iterator::__node_pointer> __pointer_traits;
            std::__1::__tree_iterator::__iter_pointer __ptr_;
        public:
            typedef std::__1::bidirectional_iterator_tag iterator_category;
            typedef _Tp value_type;
            typedef _DiffType difference_type;
            typedef std::__1::__tree_iterator::value_type &reference;
            typedef typename _NodeTypes::__node_value_type_pointer pointer;
            __tree_iterator<_Tp, _NodePtr, _DiffType>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__tree_iterator::reference operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__get_np()->__value_;
            }
            std::__1::__tree_iterator::pointer operator->() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return pointer_traits<pointer>::pointer_to(this->__get_np()->__value_);
            }
            __tree_iterator<_Tp, _NodePtr, _DiffType> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__ptr_ = static_cast<std::__1::__tree_iterator::__iter_pointer>(__tree_next_iter<std::__1::__tree_iterator::__end_node_pointer>(static_cast<std::__1::__tree_iterator::__node_base_pointer>(this->__ptr_)));
                return *this;
            }
            __tree_iterator<_Tp, _NodePtr, _DiffType> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __tree_iterator<_Tp, _NodePtr, _DiffType> __t(*this);
                ++(*this);
                return __t;
            }
            __tree_iterator<_Tp, _NodePtr, _DiffType> &operator--() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__ptr_ = static_cast<std::__1::__tree_iterator::__iter_pointer>(__tree_prev_iter<std::__1::__tree_iterator::__node_base_pointer>(static_cast<std::__1::__tree_iterator::__end_node_pointer>(this->__ptr_)));
                return *this;
            }
            __tree_iterator<_Tp, _NodePtr, _DiffType> operator--(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __tree_iterator<_Tp, _NodePtr, _DiffType> __t(*this);
                --(*this);
                return __t;
            }
            friend bool operator==(const __tree_iterator<_Tp, _NodePtr, _DiffType> &__x, const __tree_iterator<_Tp, _NodePtr, _DiffType> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__ptr_ == __y.__ptr_;
            }
;
            friend bool operator!=(const __tree_iterator<_Tp, _NodePtr, _DiffType> &__x, const __tree_iterator<_Tp, _NodePtr, _DiffType> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x == __y);
            }
;
        private:
            explicit __tree_iterator<_Tp, _NodePtr, _DiffType>(std::__1::__tree_iterator::__node_pointer __p) throw() : __ptr_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit __tree_iterator<_Tp, _NodePtr, _DiffType>(std::__1::__tree_iterator::__end_node_pointer __p) throw() : __ptr_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__tree_iterator::__node_pointer __get_np() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__tree_iterator::__node_pointer>(this->__ptr_);
            }
            friend template <class, class, class> class __tree;
            friend template <class, class, class> class __attribute__((type_visibility("default"))) __tree_const_iterator;
            friend template <class> class __attribute__((type_visibility("default"))) __map_iterator;
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) map;
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) multimap;
            friend template <class, class, class> class __attribute__((type_visibility("default"))) set;
            friend template <class, class, class> class __attribute__((type_visibility("default"))) multiset;
        };
        template <class _Tp, class _NodePtr, class _DiffType> class __attribute__((type_visibility("default"))) __tree_const_iterator {
            typedef __tree_node_types<_NodePtr> _NodeTypes;
            typedef typename _NodeTypes::__node_pointer __node_pointer;
            typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
            typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
            typedef typename _NodeTypes::__iter_pointer __iter_pointer;
            typedef pointer_traits<std::__1::__tree_const_iterator::__node_pointer> __pointer_traits;
            std::__1::__tree_const_iterator::__iter_pointer __ptr_;
        public:
            typedef std::__1::bidirectional_iterator_tag iterator_category;
            typedef _Tp value_type;
            typedef _DiffType difference_type;
            typedef const std::__1::__tree_const_iterator::value_type &reference;
            typedef typename _NodeTypes::__const_node_value_type_pointer pointer;
            __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        private:
            typedef __tree_iterator<std::__1::__tree_const_iterator::value_type, std::__1::__tree_const_iterator::__node_pointer, std::__1::__tree_const_iterator::difference_type> __non_const_iterator;
        public:
            __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType>(std::__1::__tree_const_iterator::__non_const_iterator __p) throw() : __ptr_(__p.__ptr_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__tree_const_iterator::reference operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__get_np()->__value_;
            }
            std::__1::__tree_const_iterator::pointer operator->() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return pointer_traits<pointer>::pointer_to(this->__get_np()->__value_);
            }
            __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__ptr_ = static_cast<std::__1::__tree_const_iterator::__iter_pointer>(__tree_next_iter<std::__1::__tree_const_iterator::__end_node_pointer>(static_cast<std::__1::__tree_const_iterator::__node_base_pointer>(this->__ptr_)));
                return *this;
            }
            __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> __t(*this);
                ++(*this);
                return __t;
            }
            __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> &operator--() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__ptr_ = static_cast<std::__1::__tree_const_iterator::__iter_pointer>(__tree_prev_iter<std::__1::__tree_const_iterator::__node_base_pointer>(static_cast<std::__1::__tree_const_iterator::__end_node_pointer>(this->__ptr_)));
                return *this;
            }
            __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> operator--(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> __t(*this);
                --(*this);
                return __t;
            }
            friend bool operator==(const __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> &__x, const __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__ptr_ == __y.__ptr_;
            }
;
            friend bool operator!=(const __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> &__x, const __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x == __y);
            }
;
        private:
            explicit __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType>(std::__1::__tree_const_iterator::__node_pointer __p) throw() : __ptr_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit __tree_const_iterator<_Tp, _ConstNodePtr, _DiffType>(std::__1::__tree_const_iterator::__end_node_pointer __p) throw() : __ptr_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__tree_const_iterator::__node_pointer __get_np() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__tree_const_iterator::__node_pointer>(this->__ptr_);
            }
            friend template <class, class, class> class __tree;
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) map;
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) multimap;
            friend template <class, class, class> class __attribute__((type_visibility("default"))) set;
            friend template <class, class, class> class __attribute__((type_visibility("default"))) multiset;
            friend template <class> class __attribute__((type_visibility("default"))) __map_const_iterator;
        };
        template <class _Tp, class _Compare> int __diagnose_non_const_comparator();
        template <class _Tp, class _Compare, class _Allocator> class __tree {
        public:
            typedef _Tp value_type;
            typedef _Compare value_compare;
            typedef _Allocator allocator_type;
        private:
            typedef allocator_traits<std::__1::__tree::allocator_type> __alloc_traits;
            typedef typename __make_tree_node_types<value_type, typename __alloc_traits::void_pointer>::type _NodeTypes;
            typedef typename _NodeTypes::key_type key_type;
        public:
            typedef typename _NodeTypes::__node_value_type __node_value_type;
            typedef typename _NodeTypes::__container_value_type __container_value_type;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
        public:
            typedef typename _NodeTypes::__void_pointer __void_pointer;
            typedef typename _NodeTypes::__node_type __node;
            typedef typename _NodeTypes::__node_pointer __node_pointer;
            typedef typename _NodeTypes::__node_base_type __node_base;
            typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
            typedef typename _NodeTypes::__end_node_type __end_node_t;
            typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;
            typedef typename _NodeTypes::__parent_pointer __parent_pointer;
            typedef typename _NodeTypes::__iter_pointer __iter_pointer;
            typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
            typedef allocator_traits<std::__1::__tree::__node_allocator> __node_traits;
        private:
            static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value), "Allocator does not rebind pointers in a sane manner.");
            typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type __node_base_allocator;
            typedef allocator_traits<std::__1::__tree::__node_base_allocator> __node_base_traits;
            static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value), "Allocator does not rebind pointers in a sane manner.");
        private:
            std::__1::__tree::__iter_pointer __begin_node_;
            __compressed_pair<std::__1::__tree::__end_node_t, std::__1::__tree::__node_allocator> __pair1_;
            __compressed_pair<std::__1::__tree::size_type, std::__1::__tree::value_compare> __pair3_;
        public:
            std::__1::__tree::__iter_pointer __end_node() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__tree::__iter_pointer>(pointer_traits<__end_node_ptr>::pointer_to(this->__pair1_.first()));
            }
            std::__1::__tree::__iter_pointer __end_node() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__tree::__iter_pointer>(pointer_traits<__end_node_ptr>::pointer_to(const_cast<std::__1::__tree::__end_node_t &>(this->__pair1_.first())));
            }
            std::__1::__tree::__node_allocator &__node_alloc() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__pair1_.second();
            }
        private:
            const std::__1::__tree::__node_allocator &__node_alloc() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__pair1_.second();
            }
            std::__1::__tree::__iter_pointer &__begin_node() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__begin_node_;
            }
            const std::__1::__tree::__iter_pointer &__begin_node() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__begin_node_;
            }
        public:
            std::__1::__tree::allocator_type __alloc() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__tree::allocator_type(__node_alloc());
            }
        private:
            std::__1::__tree::size_type &size() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__pair3_.first();
            }
        public:
            const std::__1::__tree::size_type &size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__pair3_.first();
            }
            std::__1::__tree::value_compare &value_comp() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__pair3_.second();
            }
            const std::__1::__tree::value_compare &value_comp() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__pair3_.second();
            }
        public:
            std::__1::__tree::__node_pointer __root() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<std::__1::__tree::__node_pointer>(__end_node()->__left_);
            }
            std::__1::__tree::__node_base_pointer *__root_ptr() const throw()             {
                return std::__1::addressof(__end_node()->__left_);
            }
            typedef __tree_iterator<std::__1::__tree::value_type, std::__1::__tree::__node_pointer, std::__1::__tree::difference_type> iterator;
            typedef __tree_const_iterator<std::__1::__tree::value_type, std::__1::__tree::__node_pointer, std::__1::__tree::difference_type> const_iterator;
            explicit __tree<_Tp, _Compare, _Allocator>(const std::__1::__tree::value_compare &__comp);
            explicit __tree<_Tp, _Compare, _Allocator>(const std::__1::__tree::allocator_type &__a);
            __tree<_Tp, _Compare, _Allocator>(const std::__1::__tree::value_compare &__comp, const std::__1::__tree::allocator_type &__a);
            __tree<_Tp, _Compare, _Allocator>(const __tree<_Tp, _Compare, _Allocator> &__t);
            __tree<_Tp, _Compare, _Allocator> &operator=(const __tree<_Tp, _Compare, _Allocator> &__t);
            template <class _ForwardIterator> void __assign_unique(_ForwardIterator __first, _ForwardIterator __last);
            template <class _InputIterator> void __assign_multi(_InputIterator __first, _InputIterator __last);
            ~__tree<_Tp, _Compare, _Allocator>();
            std::__1::__tree::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__tree::iterator(__begin_node());
            }
            std::__1::__tree::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__tree::const_iterator(__begin_node());
            }
            std::__1::__tree::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__tree::iterator(__end_node());
            }
            std::__1::__tree::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__tree::const_iterator(__end_node());
            }
            std::__1::__tree::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::min<std::__1::__tree::size_type>(__node_traits::max_size(__node_alloc()), numeric_limits<difference_type>::max());
            }
            void clear() throw();
            void swap(__tree<_Tp, _Compare, _Allocator> &__t);
            template <class _Key, class _Args> pair<std::__1::__tree::iterator, bool> __emplace_unique_key_args(const _Key &, _Args &__args) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Key, class _Args> std::__1::__tree::iterator __emplace_hint_unique_key_args(std::__1::__tree::const_iterator, const _Key &, _Args &) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            pair<std::__1::__tree::iterator, bool> __insert_unique(const std::__1::__tree::__container_value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
            }
            std::__1::__tree::iterator __insert_unique(std::__1::__tree::const_iterator __p, const std::__1::__tree::__container_value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);
            }
            std::__1::__tree::iterator __insert_multi(const std::__1::__tree::__container_value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::__tree::iterator __insert_multi(std::__1::__tree::const_iterator __p, const std::__1::__tree::__container_value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            pair<std::__1::__tree::iterator, bool> __node_assign_unique(const std::__1::__tree::__container_value_type &__v, std::__1::__tree::__node_pointer __dest) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::__tree::iterator __node_insert_multi(std::__1::__tree::__node_pointer __nd) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::__tree::iterator __node_insert_multi(std::__1::__tree::const_iterator __p, std::__1::__tree::__node_pointer __nd) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::__tree::iterator __remove_node_pointer(std::__1::__tree::__node_pointer) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::__tree::iterator erase(std::__1::__tree::const_iterator __p);
            std::__1::__tree::iterator erase(std::__1::__tree::const_iterator __f, std::__1::__tree::const_iterator __l);
            template <class _Key> std::__1::__tree::size_type __erase_unique(const _Key &__k);
            template <class _Key> std::__1::__tree::size_type __erase_multi(const _Key &__k);
            void __insert_node_at(std::__1::__tree::__parent_pointer __parent, std::__1::__tree::__node_base_pointer &__child, std::__1::__tree::__node_base_pointer __new_node) throw();
            template <class _Key> std::__1::__tree::iterator find(const _Key &__v);
            template <class _Key> std::__1::__tree::const_iterator find(const _Key &__v) const;
            template <class _Key> std::__1::__tree::size_type __count_unique(const _Key &__k) const;
            template <class _Key> std::__1::__tree::size_type __count_multi(const _Key &__k) const;
            template <class _Key> std::__1::__tree::iterator lower_bound(const _Key &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __lower_bound(__v, this->__root(), __end_node());
            }
            template <class _Key> std::__1::__tree::iterator __lower_bound(const _Key &__v, std::__1::__tree::__node_pointer __root, std::__1::__tree::__iter_pointer __result);
            template <class _Key> std::__1::__tree::const_iterator lower_bound(const _Key &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __lower_bound(__v, this->__root(), __end_node());
            }
            template <class _Key> std::__1::__tree::const_iterator __lower_bound(const _Key &__v, std::__1::__tree::__node_pointer __root, std::__1::__tree::__iter_pointer __result) const;
            template <class _Key> std::__1::__tree::iterator upper_bound(const _Key &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __upper_bound(__v, this->__root(), __end_node());
            }
            template <class _Key> std::__1::__tree::iterator __upper_bound(const _Key &__v, std::__1::__tree::__node_pointer __root, std::__1::__tree::__iter_pointer __result);
            template <class _Key> std::__1::__tree::const_iterator upper_bound(const _Key &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __upper_bound(__v, this->__root(), __end_node());
            }
            template <class _Key> std::__1::__tree::const_iterator __upper_bound(const _Key &__v, std::__1::__tree::__node_pointer __root, std::__1::__tree::__iter_pointer __result) const;
            template <class _Key> pair<std::__1::__tree::iterator, std::__1::__tree::iterator> __equal_range_unique(const _Key &__k);
            template <class _Key> pair<std::__1::__tree::const_iterator, std::__1::__tree::const_iterator> __equal_range_unique(const _Key &__k) const;
            template <class _Key> pair<std::__1::__tree::iterator, std::__1::__tree::iterator> __equal_range_multi(const _Key &__k);
            template <class _Key> pair<std::__1::__tree::const_iterator, std::__1::__tree::const_iterator> __equal_range_multi(const _Key &__k) const;
            typedef __tree_node_destructor<std::__1::__tree::__node_allocator> _Dp;
            typedef unique_ptr<std::__1::__tree::__node, std::__1::__tree::_Dp> __node_holder;
            std::__1::__tree::__node_holder remove(std::__1::__tree::const_iterator __p) throw();
        private:
            std::__1::__tree::__node_base_pointer &__find_leaf_low(std::__1::__tree::__parent_pointer &__parent, const std::__1::__tree::key_type &__v);
            std::__1::__tree::__node_base_pointer &__find_leaf_high(std::__1::__tree::__parent_pointer &__parent, const std::__1::__tree::key_type &__v);
            std::__1::__tree::__node_base_pointer &__find_leaf(std::__1::__tree::const_iterator __hint, std::__1::__tree::__parent_pointer &__parent, const std::__1::__tree::key_type &__v);
            template <class _Key> std::__1::__tree::__node_base_pointer &__find_equal(std::__1::__tree::__parent_pointer &__parent, const _Key &__v);
            template <class _Key> std::__1::__tree::__node_base_pointer &__find_equal(std::__1::__tree::__parent_pointer &__parent, const _Key &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return const_cast<__tree<_Tp, _Compare, _Allocator> *>(this)->__find_equal(__parent, __v);
            }
            template <class _Key> std::__1::__tree::__node_base_pointer &__find_equal(std::__1::__tree::const_iterator __hint, std::__1::__tree::__parent_pointer &__parent, std::__1::__tree::__node_base_pointer &__dummy, const _Key &__v);
            std::__1::__tree::__node_holder __construct_node(const std::__1::__tree::__container_value_type &__v);
            void destroy(std::__1::__tree::__node_pointer __nd) throw();
            void __copy_assign_alloc(const __tree<_Tp, _Compare, _Allocator> &__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __copy_assign_alloc(__t, integral_constant<bool, __node_traits::propagate_on_container_copy_assignment::value>());
            }
            void __copy_assign_alloc(const __tree<_Tp, _Compare, _Allocator> &__t, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__node_alloc() != __t.__node_alloc())
                    this->clear();
                __node_alloc() = __t.__node_alloc();
            }
            void __copy_assign_alloc(const __tree<_Tp, _Compare, _Allocator> &, std::__1::false_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __move_assign(__tree<_Tp, _Compare, _Allocator> &__t, std::__1::false_type);
            void __move_assign(__tree<_Tp, _Compare, _Allocator> &__t, std::__1::true_type);
            void __move_assign_alloc(__tree<_Tp, _Compare, _Allocator> &__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __move_assign_alloc(__t, integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
            }
            void __move_assign_alloc(__tree<_Tp, _Compare, _Allocator> &__t, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __node_alloc() = std::__1::move(__t.__node_alloc());
            }
            void __move_assign_alloc(__tree<_Tp, _Compare, _Allocator> &, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            struct _DetachedTreeCache {
                explicit _DetachedTreeCache(__tree<_Tp, _Compare, _Allocator> *__t) throw() : __t_(__t), __cache_root_(__detach_from_tree(__t)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__advance();
                }
                std::__1::__tree::__node_pointer __get() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return this->__cache_elem_;
                }
                void __advance() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__cache_elem_ = this->__cache_root_;
                    if (this->__cache_root_) {
                        this->__cache_root_ = __detach_next(this->__cache_root_);
                    }
                }
                ~_DetachedTreeCache() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__t_->destroy(this->__cache_elem_);
                    if (this->__cache_root_) {
                        while (this->__cache_root_->__parent_ != std::__1::__get_nullptr_t())
                            this->__cache_root_ = static_cast<std::__1::__tree::__node_pointer>(this->__cache_root_->__parent_);
                        this->__t_->destroy(this->__cache_root_);
                    }
                }
                _DetachedTreeCache(const std::__1::__tree::_DetachedTreeCache &) = delete
                std::__1::__tree::_DetachedTreeCache &operator=(const std::__1::__tree::_DetachedTreeCache &) = delete
            private:
                static std::__1::__tree::__node_pointer __detach_from_tree(__tree<_Tp, _Compare, _Allocator> *__t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
                static std::__1::__tree::__node_pointer __detach_next(std::__1::__tree::__node_pointer) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
                __tree<_Tp, _Compare, _Allocator> *__t_;
                std::__1::__tree::__node_pointer __cache_root_;
                std::__1::__tree::__node_pointer __cache_elem_;
            };
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) map;
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) multimap;
        };
        template <class _Tp, class _Compare, class _Allocator> explicit __tree<_Tp, _Compare, _Allocator>::__tree<_Tp, _Compare, _Allocator>(const std::__1::__tree::value_compare &__comp) : __pair3_(0, __comp)         {
            __begin_node() = __end_node();
        }
        template <class _Tp, class _Compare, class _Allocator> explicit __tree<_Tp, _Compare, _Allocator>::__tree<_Tp, _Compare, _Allocator>(const std::__1::__tree::allocator_type &__a) : __begin_node_(std::__1::__tree::__iter_pointer()), __pair1_(std::__1::__default_init_tag(), std::__1::__tree::__node_allocator(__a)), __pair3_(0, std::__1::__default_init_tag())         {
            __begin_node() = __end_node();
        }
        template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>::__tree<_Tp, _Compare, _Allocator>(const std::__1::__tree::value_compare &__comp, const std::__1::__tree::allocator_type &__a) : __begin_node_(std::__1::__tree::__iter_pointer()), __pair1_(std::__1::__default_init_tag(), std::__1::__tree::__node_allocator(__a)), __pair3_(0, __comp)         {
            __begin_node() = __end_node();
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_pointer __tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_from_tree(__tree<_Tp, _Compare, _Allocator> *__t) throw()         {
            std::__1::__tree::__node_pointer __cache = static_cast<std::__1::__tree::__node_pointer>(__t->__begin_node());
            __t->__begin_node() = __t->__end_node();
            __t->__end_node()->__left_->__parent_ = std::__1::__get_nullptr_t();
            __t->__end_node()->__left_ = std::__1::__get_nullptr_t();
            __t->size() = 0;
            if (__cache->__right_ != std::__1::__get_nullptr_t())
                __cache = static_cast<std::__1::__tree::__node_pointer>(__cache->__right_);
            return __cache;
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_pointer __tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_next(std::__1::__tree::__node_pointer __cache) throw()         {
            if (__cache->__parent_ == std::__1::__get_nullptr_t())
                return std::__1::__get_nullptr_t();
            if (__tree_is_left_child(static_cast<std::__1::__tree::__node_base_pointer>(__cache))) {
                __cache->__parent_->__left_ = std::__1::__get_nullptr_t();
                __cache = static_cast<std::__1::__tree::__node_pointer>(__cache->__parent_);
                if (__cache->__right_ == std::__1::__get_nullptr_t())
                    return __cache;
                return static_cast<std::__1::__tree::__node_pointer>(__tree_leaf(__cache->__right_));
            }
            __cache->__parent_unsafe()->__right_ = std::__1::__get_nullptr_t();
            __cache = static_cast<std::__1::__tree::__node_pointer>(__cache->__parent_);
            if (__cache->__left_ == std::__1::__get_nullptr_t())
                return __cache;
            return static_cast<std::__1::__tree::__node_pointer>(__tree_leaf(__cache->__left_));
        }
        template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator> &__tree<_Tp, _Compare, _Allocator>::operator=(const __tree<_Tp, _Compare, _Allocator> &__t)         {
            if (this != &__t) {
                value_comp() = __t.value_comp();
                __copy_assign_alloc(__t);
                __assign_multi(__t.begin(), __t.end());
            }
            return *this;
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _ForwardIterator> void __tree<_Tp, _Compare, _Allocator>::__assign_unique(_ForwardIterator __first, _ForwardIterator __last)         {
            typedef iterator_traits<_ForwardIterator> _ITraits;
            typedef typename _ITraits::value_type _ItValueType;
            static_assert((is_same<_ItValueType, __container_value_type>::value), "__assign_unique may only be called with the containers value type");
            static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value, "__assign_unique requires a forward iterator");
            if (size() != 0) {
                std::__1::__tree::_DetachedTreeCache __cache(this);
                for (; __cache.__get() != std::__1::__get_nullptr_t() && __first != __last; ++__first) {
                    if (this->__node_assign_unique(*__first, __cache.__get()).second)
                        __cache.__advance();
                }
            }
            for (; __first != __last; ++__first)
                __insert_unique(*__first);
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _InputIterator> void __tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)         {
            typedef iterator_traits<_InputIterator> _ITraits;
            typedef typename _ITraits::value_type _ItValueType;
            static_assert((is_same<_ItValueType, __container_value_type>::value || is_same<_ItValueType, __node_value_type>::value), "__assign_multi may only be called with the containers value type or the nodes value type");
            if (size() != 0) {
                std::__1::__tree::_DetachedTreeCache __cache(this);
                for (; __cache.__get() && __first != __last; ++__first) {
                    __cache.__get()->__value_ = *__first;
                    __node_insert_multi(__cache.__get());
                    __cache.__advance();
                }
            }
            for (; __first != __last; ++__first)
                __insert_multi(_NodeTypes::__get_value(*__first));
        }
        template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>::__tree<_Tp, _Compare, _Allocator>(const __tree<_Tp, _Compare, _Allocator> &__t) : __begin_node_(std::__1::__tree::__iter_pointer()), __pair1_(std::__1::__default_init_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())), __pair3_(0, __t.value_comp())         {
            __begin_node() = __end_node();
        }
        template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>::~__tree<_Tp, _Compare, _Allocator>()         {
            static_assert((is_copy_constructible<value_compare>::value), "Comparator must be copy-constructible.");
            this->destroy(this->__root());
        }
        template <class _Tp, class _Compare, class _Allocator> void __tree<_Tp, _Compare, _Allocator>::destroy(std::__1::__tree::__node_pointer __nd) throw()         {
            if (__nd != std::__1::__get_nullptr_t()) {
                this->destroy(static_cast<std::__1::__tree::__node_pointer>(__nd->__left_));
                this->destroy(static_cast<std::__1::__tree::__node_pointer>(__nd->__right_));
                std::__1::__tree::__node_allocator &__na = __node_alloc();
                __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
                __node_traits::deallocate(__na, __nd, 1);
            }
        }
        template <class _Tp, class _Compare, class _Allocator> void __tree<_Tp, _Compare, _Allocator>::swap(__tree<_Tp, _Compare, _Allocator> &__t)         {
            using std::__1::swap;
            swap(this->__begin_node_, __t.__begin_node_);
            swap(this->__pair1_.first(), __t.__pair1_.first());
            __swap_allocator(__node_alloc(), __t.__node_alloc());
            this->__pair3_.swap(__t.__pair3_);
            if (size() == 0)
                __begin_node() = __end_node();
            else
                __end_node()->__left_->__parent_ = static_cast<std::__1::__tree::__parent_pointer>(__end_node());
            if (__t.size() == 0)
                __t.__begin_node() = __t.__end_node();
            else
                __t.__end_node()->__left_->__parent_ = static_cast<std::__1::__tree::__parent_pointer>(__t.__end_node());
        }
        template <class _Tp, class _Compare, class _Allocator> void __tree<_Tp, _Compare, _Allocator>::clear() throw()         {
            this->destroy(this->__root());
            size() = 0;
            __begin_node() = __end_node();
            __end_node()->__left_ = std::__1::__get_nullptr_t();
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(std::__1::__tree::__parent_pointer &__parent, const std::__1::__tree::key_type &__v)         {
            std::__1::__tree::__node_pointer __nd = this->__root();
            if (__nd != std::__1::__get_nullptr_t()) {
                while (true)
                    {
                        if (value_comp()(__nd->__value_, __v)) {
                            if (__nd->__right_ != std::__1::__get_nullptr_t())
                                __nd = static_cast<std::__1::__tree::__node_pointer>(__nd->__right_);
                            else {
                                __parent = static_cast<std::__1::__tree::__parent_pointer>(__nd);
                                return __nd->__right_;
                            }
                        } else {
                            if (__nd->__left_ != std::__1::__get_nullptr_t())
                                __nd = static_cast<std::__1::__tree::__node_pointer>(__nd->__left_);
                            else {
                                __parent = static_cast<std::__1::__tree::__parent_pointer>(__nd);
                                return __parent->__left_;
                            }
                        }
                    }
            }
            __parent = static_cast<std::__1::__tree::__parent_pointer>(__end_node());
            return __parent->__left_;
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(std::__1::__tree::__parent_pointer &__parent, const std::__1::__tree::key_type &__v)         {
            std::__1::__tree::__node_pointer __nd = this->__root();
            if (__nd != std::__1::__get_nullptr_t()) {
                while (true)
                    {
                        if (value_comp()(__v, __nd->__value_)) {
                            if (__nd->__left_ != std::__1::__get_nullptr_t())
                                __nd = static_cast<std::__1::__tree::__node_pointer>(__nd->__left_);
                            else {
                                __parent = static_cast<std::__1::__tree::__parent_pointer>(__nd);
                                return __parent->__left_;
                            }
                        } else {
                            if (__nd->__right_ != std::__1::__get_nullptr_t())
                                __nd = static_cast<std::__1::__tree::__node_pointer>(__nd->__right_);
                            else {
                                __parent = static_cast<std::__1::__tree::__parent_pointer>(__nd);
                                return __nd->__right_;
                            }
                        }
                    }
            }
            __parent = static_cast<std::__1::__tree::__parent_pointer>(__end_node());
            return __parent->__left_;
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &__tree<_Tp, _Compare, _Allocator>::__find_leaf(std::__1::__tree::const_iterator __hint, std::__1::__tree::__parent_pointer &__parent, const std::__1::__tree::key_type &__v)         {
            if (__hint == end() || !value_comp()(*__hint, __v)) {
                std::__1::__tree::const_iterator __prior = __hint;
                if (__prior == begin() || !value_comp()(__v, *--__prior)) {
                    if (__hint.__ptr_->__left_ == std::__1::__get_nullptr_t()) {
                        __parent = static_cast<std::__1::__tree::__parent_pointer>(__hint.__ptr_);
                        return __parent->__left_;
                    } else {
                        __parent = static_cast<std::__1::__tree::__parent_pointer>(__prior.__ptr_);
                        return static_cast<std::__1::__tree::__node_base_pointer>(__prior.__ptr_)->__right_;
                    }
                }
                return this->__find_leaf_high(__parent, __v);
            }
            return this->__find_leaf_low(__parent, __v);
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &__tree<_Tp, _Compare, _Allocator>::__find_equal(std::__1::__tree::__parent_pointer &__parent, const _Key &__v)         {
            std::__1::__tree::__node_pointer __nd = this->__root();
            std::__1::__tree::__node_base_pointer *__nd_ptr = this->__root_ptr();
            if (__nd != std::__1::__get_nullptr_t()) {
                while (true)
                    {
                        if (value_comp()(__v, __nd->__value_)) {
                            if (__nd->__left_ != std::__1::__get_nullptr_t()) {
                                __nd_ptr = std::__1::addressof(__nd->__left_);
                                __nd = static_cast<std::__1::__tree::__node_pointer>(__nd->__left_);
                            } else {
                                __parent = static_cast<std::__1::__tree::__parent_pointer>(__nd);
                                return __parent->__left_;
                            }
                        } else if (value_comp()(__nd->__value_, __v)) {
                            if (__nd->__right_ != std::__1::__get_nullptr_t()) {
                                __nd_ptr = std::__1::addressof(__nd->__right_);
                                __nd = static_cast<std::__1::__tree::__node_pointer>(__nd->__right_);
                            } else {
                                __parent = static_cast<std::__1::__tree::__parent_pointer>(__nd);
                                return __nd->__right_;
                            }
                        } else {
                            __parent = static_cast<std::__1::__tree::__parent_pointer>(__nd);
                            return *__nd_ptr;
                        }
                    }
            }
            __parent = static_cast<std::__1::__tree::__parent_pointer>(__end_node());
            return __parent->__left_;
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &__tree<_Tp, _Compare, _Allocator>::__find_equal(std::__1::__tree::const_iterator __hint, std::__1::__tree::__parent_pointer &__parent, std::__1::__tree::__node_base_pointer &__dummy, const _Key &__v)         {
            if (__hint == end() || value_comp()(__v, *__hint)) {
                std::__1::__tree::const_iterator __prior = __hint;
                if (__prior == begin() || value_comp()(*--__prior, __v)) {
                    if (__hint.__ptr_->__left_ == std::__1::__get_nullptr_t()) {
                        __parent = static_cast<std::__1::__tree::__parent_pointer>(__hint.__ptr_);
                        return __parent->__left_;
                    } else {
                        __parent = static_cast<std::__1::__tree::__parent_pointer>(__prior.__ptr_);
                        return static_cast<std::__1::__tree::__node_base_pointer>(__prior.__ptr_)->__right_;
                    }
                }
                return __find_equal(__parent, __v);
            } else if (value_comp()(*__hint, __v)) {
                std::__1::__tree::const_iterator __next = std::__1::next(__hint);
                if (__next == end() || value_comp()(__v, *__next)) {
                    if (__hint.__get_np()->__right_ == std::__1::__get_nullptr_t()) {
                        __parent = static_cast<std::__1::__tree::__parent_pointer>(__hint.__ptr_);
                        return static_cast<std::__1::__tree::__node_base_pointer>(__hint.__ptr_)->__right_;
                    } else {
                        __parent = static_cast<std::__1::__tree::__parent_pointer>(__next.__ptr_);
                        return __parent->__left_;
                    }
                }
                return __find_equal(__parent, __v);
            }
            __parent = static_cast<std::__1::__tree::__parent_pointer>(__hint.__ptr_);
            __dummy = static_cast<std::__1::__tree::__node_base_pointer>(__hint.__ptr_);
            return __dummy;
        }
        template <class _Tp, class _Compare, class _Allocator> void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(std::__1::__tree::__parent_pointer __parent, std::__1::__tree::__node_base_pointer &__child, std::__1::__tree::__node_base_pointer __new_node) throw()         {
            __new_node->__left_ = std::__1::__get_nullptr_t();
            __new_node->__right_ = std::__1::__get_nullptr_t();
            __new_node->__parent_ = __parent;
            __child = __new_node;
            if (__begin_node()->__left_ != std::__1::__get_nullptr_t())
                __begin_node() = static_cast<std::__1::__tree::__iter_pointer>(__begin_node()->__left_);
            __tree_balance_after_insert(__end_node()->__left_, __child);
            ++size();
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key, class _Args> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool> __tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(const _Key &__k, _Args &__args)         {
            std::__1::__tree::__parent_pointer __parent;
            std::__1::__tree::__node_base_pointer &__child = __find_equal(__parent, __k);
            std::__1::__tree::__node_pointer __r = static_cast<std::__1::__tree::__node_pointer>(__child);
            bool __inserted = false;
            if (__child == std::__1::__get_nullptr_t()) {
                std::__1::__tree::__node_holder __h = this->__construct_node(__args);
                this->__insert_node_at(__parent, __child, static_cast<std::__1::__tree::__node_base_pointer>(__h.get()));
                __r = __h.release();
                __inserted = true;
            }
            return pair<std::__1::__tree::iterator, bool>(std::__1::__tree::iterator(__r), __inserted);
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key, class _Args> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(std::__1::__tree::const_iterator __p, const _Key &__k, _Args &__args)         {
            std::__1::__tree::__parent_pointer __parent;
            std::__1::__tree::__node_base_pointer __dummy;
            std::__1::__tree::__node_base_pointer &__child = __find_equal(__p, __parent, __dummy, __k);
            std::__1::__tree::__node_pointer __r = static_cast<std::__1::__tree::__node_pointer>(__child);
            if (__child == std::__1::__get_nullptr_t()) {
                std::__1::__tree::__node_holder __h = this->__construct_node(__args);
                this->__insert_node_at(__parent, __child, static_cast<std::__1::__tree::__node_base_pointer>(__h.get()));
                __r = __h.release();
            }
            return std::__1::__tree::iterator(__r);
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_holder __tree<_Tp, _Compare, _Allocator>::__construct_node(const std::__1::__tree::__container_value_type &__v)         {
            std::__1::__tree::__node_allocator &__na = __node_alloc();
            std::__1::__tree::__node_holder __h(__node_traits::allocate(__na, 1), std::__1::__tree::_Dp(__na));
            __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);
            __h.get_deleter().__value_constructed = true;
            return std::__1::move(__h);
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__insert_multi(const std::__1::__tree::__container_value_type &__v)         {
            std::__1::__tree::__parent_pointer __parent;
            std::__1::__tree::__node_base_pointer &__child = this->__find_leaf_high(__parent, _NodeTypes::__get_key(__v));
            std::__1::__tree::__node_holder __h = this->__construct_node(__v);
            this->__insert_node_at(__parent, __child, static_cast<std::__1::__tree::__node_base_pointer>(__h.get()));
            return std::__1::__tree::iterator(__h.release());
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__insert_multi(std::__1::__tree::const_iterator __p, const std::__1::__tree::__container_value_type &__v)         {
            std::__1::__tree::__parent_pointer __parent;
            std::__1::__tree::__node_base_pointer &__child = this->__find_leaf(__p, __parent, _NodeTypes::__get_key(__v));
            std::__1::__tree::__node_holder __h = this->__construct_node(__v);
            this->__insert_node_at(__parent, __child, static_cast<std::__1::__tree::__node_base_pointer>(__h.get()));
            return std::__1::__tree::iterator(__h.release());
        }
        template <class _Tp, class _Compare, class _Allocator> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool> __tree<_Tp, _Compare, _Allocator>::__node_assign_unique(const std::__1::__tree::__container_value_type &__v, std::__1::__tree::__node_pointer __nd)         {
            std::__1::__tree::__parent_pointer __parent;
            std::__1::__tree::__node_base_pointer &__child = __find_equal(__parent, _NodeTypes::__get_key(__v));
            std::__1::__tree::__node_pointer __r = static_cast<std::__1::__tree::__node_pointer>(__child);
            bool __inserted = false;
            if (__child == std::__1::__get_nullptr_t()) {
                __nd->__value_ = __v;
                this->__insert_node_at(__parent, __child, static_cast<std::__1::__tree::__node_base_pointer>(__nd));
                __r = __nd;
                __inserted = true;
            }
            return pair<std::__1::__tree::iterator, bool>(std::__1::__tree::iterator(__r), __inserted);
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__node_insert_multi(std::__1::__tree::__node_pointer __nd)         {
            std::__1::__tree::__parent_pointer __parent;
            std::__1::__tree::__node_base_pointer &__child = this->__find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
            this->__insert_node_at(__parent, __child, static_cast<std::__1::__tree::__node_base_pointer>(__nd));
            return std::__1::__tree::iterator(__nd);
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__node_insert_multi(std::__1::__tree::const_iterator __p, std::__1::__tree::__node_pointer __nd)         {
            std::__1::__tree::__parent_pointer __parent;
            std::__1::__tree::__node_base_pointer &__child = this->__find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
            this->__insert_node_at(__parent, __child, static_cast<std::__1::__tree::__node_base_pointer>(__nd));
            return std::__1::__tree::iterator(__nd);
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(std::__1::__tree::__node_pointer __ptr) throw()         {
            std::__1::__tree::iterator __r(__ptr);
            ++__r;
            if (__begin_node() == __ptr)
                __begin_node() = __r.__ptr_;
            --size();
            __tree_remove(__end_node()->__left_, static_cast<std::__1::__tree::__node_base_pointer>(__ptr));
            return __r;
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::erase(std::__1::__tree::const_iterator __p)         {
            std::__1::__tree::__node_pointer __np = __p.__get_np();
            std::__1::__tree::iterator __r = this->__remove_node_pointer(__np);
            std::__1::__tree::__node_allocator &__na = __node_alloc();
            __node_traits::destroy(__na, _NodeTypes::__get_ptr(const_cast<std::__1::__tree::__node_value_type &>(*__p)));
            __node_traits::deallocate(__na, __np, 1);
            return __r;
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::erase(std::__1::__tree::const_iterator __f, std::__1::__tree::const_iterator __l)         {
            while (__f != __l)
                __f = erase(__f);
            return std::__1::__tree::iterator(__l.__ptr_);
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::size_type __tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key &__k)         {
            std::__1::__tree::iterator __i = find(__k);
            if (__i == end())
                return 0;
            erase(__i);
            return 1;
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::size_type __tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key &__k)         {
            pair<std::__1::__tree::iterator, std::__1::__tree::iterator> __p = __equal_range_multi(__k);
            std::__1::__tree::size_type __r = 0;
            for (; __p.first != __p.second; ++__r)
                __p.first = erase(__p.first);
            return __r;
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::find(const _Key &__v)         {
            std::__1::__tree::iterator __p = __lower_bound(__v, this->__root(), __end_node());
            if (__p != end() && !value_comp()(__v, *__p))
                return __p;
            return end();
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::find(const _Key &__v) const         {
            std::__1::__tree::const_iterator __p = __lower_bound(__v, this->__root(), __end_node());
            if (__p != end() && !value_comp()(__v, *__p))
                return __p;
            return end();
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::size_type __tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key &__k) const         {
            std::__1::__tree::__node_pointer __rt = this->__root();
            while (__rt != std::__1::__get_nullptr_t())
                {
                    if (value_comp()(__k, __rt->__value_)) {
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__left_);
                    } else if (value_comp()(__rt->__value_, __k))
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__right_);
                    else
                        return 1;
                }
            return 0;
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::size_type __tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key &__k) const         {
            std::__1::__tree::__iter_pointer __result = __end_node();
            std::__1::__tree::__node_pointer __rt = this->__root();
            while (__rt != std::__1::__get_nullptr_t())
                {
                    if (value_comp()(__k, __rt->__value_)) {
                        __result = static_cast<std::__1::__tree::__iter_pointer>(__rt);
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__left_);
                    } else if (value_comp()(__rt->__value_, __k))
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__right_);
                    else
                        return std::__1::distance(__lower_bound(__k, static_cast<std::__1::__tree::__node_pointer>(__rt->__left_), static_cast<std::__1::__tree::__iter_pointer>(__rt)), __upper_bound(__k, static_cast<std::__1::__tree::__node_pointer>(__rt->__right_), __result));
                }
            return 0;
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key &__v, std::__1::__tree::__node_pointer __root, std::__1::__tree::__iter_pointer __result)         {
            while (__root != std::__1::__get_nullptr_t())
                {
                    if (!value_comp()(__root->__value_, __v)) {
                        __result = static_cast<std::__1::__tree::__iter_pointer>(__root);
                        __root = static_cast<std::__1::__tree::__node_pointer>(__root->__left_);
                    } else
                        __root = static_cast<std::__1::__tree::__node_pointer>(__root->__right_);
                }
            return std::__1::__tree::iterator(__result);
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key &__v, std::__1::__tree::__node_pointer __root, std::__1::__tree::__iter_pointer __result) const         {
            while (__root != std::__1::__get_nullptr_t())
                {
                    if (!value_comp()(__root->__value_, __v)) {
                        __result = static_cast<std::__1::__tree::__iter_pointer>(__root);
                        __root = static_cast<std::__1::__tree::__node_pointer>(__root->__left_);
                    } else
                        __root = static_cast<std::__1::__tree::__node_pointer>(__root->__right_);
                }
            return std::__1::__tree::const_iterator(__result);
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key &__v, std::__1::__tree::__node_pointer __root, std::__1::__tree::__iter_pointer __result)         {
            while (__root != std::__1::__get_nullptr_t())
                {
                    if (value_comp()(__v, __root->__value_)) {
                        __result = static_cast<std::__1::__tree::__iter_pointer>(__root);
                        __root = static_cast<std::__1::__tree::__node_pointer>(__root->__left_);
                    } else
                        __root = static_cast<std::__1::__tree::__node_pointer>(__root->__right_);
                }
            return std::__1::__tree::iterator(__result);
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key &__v, std::__1::__tree::__node_pointer __root, std::__1::__tree::__iter_pointer __result) const         {
            while (__root != std::__1::__get_nullptr_t())
                {
                    if (value_comp()(__v, __root->__value_)) {
                        __result = static_cast<std::__1::__tree::__iter_pointer>(__root);
                        __root = static_cast<std::__1::__tree::__node_pointer>(__root->__left_);
                    } else
                        __root = static_cast<std::__1::__tree::__node_pointer>(__root->__right_);
                }
            return std::__1::__tree::const_iterator(__result);
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, typename __tree<_Tp, _Compare, _Allocator>::iterator> __tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key &__k)         {
            typedef pair<std::__1::__tree::iterator, std::__1::__tree::iterator> _Pp;
            std::__1::__tree::__iter_pointer __result = __end_node();
            std::__1::__tree::__node_pointer __rt = this->__root();
            while (__rt != std::__1::__get_nullptr_t())
                {
                    if (value_comp()(__k, __rt->__value_)) {
                        __result = static_cast<std::__1::__tree::__iter_pointer>(__rt);
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__left_);
                    } else if (value_comp()(__rt->__value_, __k))
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__right_);
                    else
                        return _Pp(std::__1::__tree::iterator(__rt), std::__1::__tree::iterator(__rt->__right_ != std::__1::__get_nullptr_t() ? static_cast<std::__1::__tree::__iter_pointer>(__tree_min(__rt->__right_)) : __result));
                }
            return _Pp(std::__1::__tree::iterator(__result), std::__1::__tree::iterator(__result));
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator, typename __tree<_Tp, _Compare, _Allocator>::const_iterator> __tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key &__k) const         {
            typedef pair<std::__1::__tree::const_iterator, std::__1::__tree::const_iterator> _Pp;
            std::__1::__tree::__iter_pointer __result = __end_node();
            std::__1::__tree::__node_pointer __rt = this->__root();
            while (__rt != std::__1::__get_nullptr_t())
                {
                    if (value_comp()(__k, __rt->__value_)) {
                        __result = static_cast<std::__1::__tree::__iter_pointer>(__rt);
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__left_);
                    } else if (value_comp()(__rt->__value_, __k))
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__right_);
                    else
                        return _Pp(std::__1::__tree::const_iterator(__rt), std::__1::__tree::const_iterator(__rt->__right_ != std::__1::__get_nullptr_t() ? static_cast<std::__1::__tree::__iter_pointer>(__tree_min(__rt->__right_)) : __result));
                }
            return _Pp(std::__1::__tree::const_iterator(__result), std::__1::__tree::const_iterator(__result));
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, typename __tree<_Tp, _Compare, _Allocator>::iterator> __tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key &__k)         {
            typedef pair<std::__1::__tree::iterator, std::__1::__tree::iterator> _Pp;
            std::__1::__tree::__iter_pointer __result = __end_node();
            std::__1::__tree::__node_pointer __rt = this->__root();
            while (__rt != std::__1::__get_nullptr_t())
                {
                    if (value_comp()(__k, __rt->__value_)) {
                        __result = static_cast<std::__1::__tree::__iter_pointer>(__rt);
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__left_);
                    } else if (value_comp()(__rt->__value_, __k))
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__right_);
                    else
                        return _Pp(__lower_bound(__k, static_cast<std::__1::__tree::__node_pointer>(__rt->__left_), static_cast<std::__1::__tree::__iter_pointer>(__rt)), __upper_bound(__k, static_cast<std::__1::__tree::__node_pointer>(__rt->__right_), __result));
                }
            return _Pp(std::__1::__tree::iterator(__result), std::__1::__tree::iterator(__result));
        }
        template <class _Tp, class _Compare, class _Allocator> template <class _Key> pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator, typename __tree<_Tp, _Compare, _Allocator>::const_iterator> __tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key &__k) const         {
            typedef pair<std::__1::__tree::const_iterator, std::__1::__tree::const_iterator> _Pp;
            std::__1::__tree::__iter_pointer __result = __end_node();
            std::__1::__tree::__node_pointer __rt = this->__root();
            while (__rt != std::__1::__get_nullptr_t())
                {
                    if (value_comp()(__k, __rt->__value_)) {
                        __result = static_cast<std::__1::__tree::__iter_pointer>(__rt);
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__left_);
                    } else if (value_comp()(__rt->__value_, __k))
                        __rt = static_cast<std::__1::__tree::__node_pointer>(__rt->__right_);
                    else
                        return _Pp(__lower_bound(__k, static_cast<std::__1::__tree::__node_pointer>(__rt->__left_), static_cast<std::__1::__tree::__iter_pointer>(__rt)), __upper_bound(__k, static_cast<std::__1::__tree::__node_pointer>(__rt->__right_), __result));
                }
            return _Pp(std::__1::__tree::const_iterator(__result), std::__1::__tree::const_iterator(__result));
        }
        template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_holder __tree<_Tp, _Compare, _Allocator>::remove(std::__1::__tree::const_iterator __p) throw()         {
            std::__1::__tree::__node_pointer __np = __p.__get_np();
            if (__begin_node() == __p.__ptr_) {
                if (__np->__right_ != std::__1::__get_nullptr_t())
                    __begin_node() = static_cast<std::__1::__tree::__iter_pointer>(__np->__right_);
                else
                    __begin_node() = static_cast<std::__1::__tree::__iter_pointer>(__np->__parent_);
            }
            --size();
            __tree_remove(__end_node()->__left_, static_cast<std::__1::__tree::__node_base_pointer>(__np));
            return std::__1::__tree::__node_holder(__np, std::__1::__tree::_Dp(__node_alloc(), true));
        }
        template <class _Tp, class _Compare, class _Allocator> inline void swap(__tree<_Tp, _Compare, _Allocator> &__x, __tree<_Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
    }
}
namespace std {
    class __attribute__((visibility("default"))) __attribute__((availability(macos, strict, introduced=10.14))) __attribute__((availability(ios, strict, introduced=12.0))) __attribute__((availability(tvos, strict, introduced=12.0))) __attribute__((availability(watchos, strict, introduced=5.0))) bad_optional_access : public std::exception {
    public:
        virtual ~bad_optional_access() throw();
        virtual const char *what() const throw();
    };
}
namespace std {
    inline namespace __1 {
    }
}
namespace std {
    inline namespace __1 {
        template <class _Key, class _CP, class _Compare, bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value> class __map_value_compare : private _Compare {
        public:
            __map_value_compare<_Key, _CP, _Compare, >() : _Compare() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __map_value_compare<_Key, _CP, _Compare, >(_Compare c) : _Compare(c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            const _Compare &key_comp() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this;
            }
            bool operator()(const _CP &__x, const _CP &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<const _Compare &>(*this)(__x.__get_value().first, __y.__get_value().first);
            }
            bool operator()(const _CP &__x, const _Key &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<const _Compare &>(*this)(__x.__get_value().first, __y);
            }
            bool operator()(const _Key &__x, const _CP &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<const _Compare &>(*this)(__x, __y.__get_value().first);
            }
            void swap(__map_value_compare<_Key, _CP, _Compare, > &__y)             {
                using std::__1::swap;
                swap(static_cast<_Compare &>(*this), static_cast<_Compare &>(__y));
            }
        };
        template <class _Key, class _CP, class _Compare> class __map_value_compare<_Key, _CP, _Compare, false> {
            _Compare comp;
        public:
            __map_value_compare<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, false>() : comp() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __map_value_compare<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, false>(_Compare c) : comp(c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            const _Compare &key_comp() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->comp;
            }
            bool operator()(const _CP &__x, const _CP &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->comp(__x.__get_value().first, __y.__get_value().first);
            }
            bool operator()(const _CP &__x, const _Key &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->comp(__x.__get_value().first, __y);
            }
            bool operator()(const _Key &__x, const _CP &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->comp(__x, __y.__get_value().first);
            }
            void swap(__map_value_compare<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, false> &__y)             {
                using std::__1::swap;
                swap(this->comp, __y.comp);
            }
        };
        template <class _Key, class _CP, class _Compare, bool __b> inline void swap(__map_value_compare<_Key, _CP, _Compare, __b> &__x, __map_value_compare<_Key, _CP, _Compare, __b> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _Allocator> class __map_node_destructor {
            typedef _Allocator allocator_type;
            typedef allocator_traits<std::__1::__map_node_destructor::allocator_type> __alloc_traits;
        public:
            typedef typename __alloc_traits::pointer pointer;
        private:
            std::__1::__map_node_destructor::allocator_type &__na_;
            __map_node_destructor<_Allocator> &operator=(const __map_node_destructor<_Allocator> &);
        public:
            bool __first_constructed;
            bool __second_constructed;
            explicit __map_node_destructor<_Allocator>(std::__1::__map_node_destructor::allocator_type &__na) throw() : __na_(__na), __first_constructed(false), __second_constructed(false) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void operator()(std::__1::__map_node_destructor::pointer __p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__second_constructed)
                    __alloc_traits::destroy(this->__na_, std::__1::addressof(__p->__value_.__get_value().second));
                if (this->__first_constructed)
                    __alloc_traits::destroy(this->__na_, std::__1::addressof(__p->__value_.__get_value().first));
                if (__p)
                    __alloc_traits::deallocate(this->__na_, __p, 1);
            }
        };
        template <class _Key, class _Tp, class _Compare, class _Allocator> class map;
        template <class _Key, class _Tp, class _Compare, class _Allocator> class multimap;
        template <class _TreeIterator> class __map_const_iterator;
        template <class _Key, class _Tp> struct __value_type {
            typedef _Key key_type;
            typedef _Tp mapped_type;
            typedef pair<const std::__1::__value_type::key_type, std::__1::__value_type::mapped_type> value_type;
        private:
            std::__1::__value_type::value_type __cc;
        public:
            std::__1::__value_type::value_type &__get_value() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cc;
            }
            const std::__1::__value_type::value_type &__get_value() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cc;
            }
        private:
            __value_type<_Key, _Value>();
            __value_type<_Key, _Value>(const __value_type<_Key, _Value> &);
            __value_type<_Key, _Value> &operator=(const __value_type<_Key, _Value> &);
            ~__value_type<_Key, _Value>();
        };
        template <class _Tp> struct __extract_key_value_types;
        template <class _Key, class _Tp> struct __extract_key_value_types<__value_type<_Key, _Tp>> {
            typedef const _Key __key_type;
            typedef _Tp __mapped_type;
        };
        template <class _TreeIterator> class __attribute__((type_visibility("default"))) __map_iterator {
            typedef typename _TreeIterator::_NodeTypes _NodeTypes;
            typedef typename _TreeIterator::__pointer_traits __pointer_traits;
            _TreeIterator __i_;
        public:
            typedef std::__1::bidirectional_iterator_tag iterator_category;
            typedef typename _NodeTypes::__map_value_type value_type;
            typedef typename _TreeIterator::difference_type difference_type;
            typedef std::__1::__map_iterator::value_type &reference;
            typedef typename _NodeTypes::__map_value_type_pointer pointer;
            __map_iterator<_TreeIterator>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __map_iterator<_TreeIterator>(_TreeIterator __i) throw() : __i_(__i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__map_iterator::reference operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__i_->__get_value();
            }
            std::__1::__map_iterator::pointer operator->() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return pointer_traits<pointer>::pointer_to(this->__i_->__get_value());
            }
            __map_iterator<_TreeIterator> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ++this->__i_;
                return *this;
            }
            __map_iterator<_TreeIterator> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __map_iterator<_TreeIterator> __t(*this);
                ++(*this);
                return __t;
            }
            __map_iterator<_TreeIterator> &operator--() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                --this->__i_;
                return *this;
            }
            __map_iterator<_TreeIterator> operator--(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __map_iterator<_TreeIterator> __t(*this);
                --(*this);
                return __t;
            }
            friend bool operator==(const __map_iterator<_TreeIterator> &__x, const __map_iterator<_TreeIterator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__i_ == __y.__i_;
            }
;
            friend bool operator!=(const __map_iterator<_TreeIterator> &__x, const __map_iterator<_TreeIterator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__i_ != __y.__i_;
            }
;
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) map;
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) multimap;
            friend template <class> class __attribute__((type_visibility("default"))) __map_const_iterator;
        };
        template <class _TreeIterator> class __attribute__((type_visibility("default"))) __map_const_iterator {
            typedef typename _TreeIterator::_NodeTypes _NodeTypes;
            typedef typename _TreeIterator::__pointer_traits __pointer_traits;
            _TreeIterator __i_;
        public:
            typedef std::__1::bidirectional_iterator_tag iterator_category;
            typedef typename _NodeTypes::__map_value_type value_type;
            typedef typename _TreeIterator::difference_type difference_type;
            typedef const std::__1::__map_const_iterator::value_type &reference;
            typedef typename _NodeTypes::__const_map_value_type_pointer pointer;
            __map_const_iterator<_TreeIterator>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __map_const_iterator<_TreeIterator>(_TreeIterator __i) throw() : __i_(__i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __map_const_iterator<_TreeIterator>(__map_iterator<typename _TreeIterator::__non_const_iterator> __i) throw() : __i_(__i.__i_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__map_const_iterator::reference operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__i_->__get_value();
            }
            std::__1::__map_const_iterator::pointer operator->() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return pointer_traits<pointer>::pointer_to(this->__i_->__get_value());
            }
            __map_const_iterator<_TreeIterator> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ++this->__i_;
                return *this;
            }
            __map_const_iterator<_TreeIterator> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __map_const_iterator<_TreeIterator> __t(*this);
                ++(*this);
                return __t;
            }
            __map_const_iterator<_TreeIterator> &operator--() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                --this->__i_;
                return *this;
            }
            __map_const_iterator<_TreeIterator> operator--(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __map_const_iterator<_TreeIterator> __t(*this);
                --(*this);
                return __t;
            }
            friend bool operator==(const __map_const_iterator<_TreeIterator> &__x, const __map_const_iterator<_TreeIterator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__i_ == __y.__i_;
            }
;
            friend bool operator!=(const __map_const_iterator<_TreeIterator> &__x, const __map_const_iterator<_TreeIterator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__i_ != __y.__i_;
            }
;
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) map;
            friend template <class, class, class, class> class __attribute__((type_visibility("default"))) multimap;
            friend template <class, class, class> class __attribute__((type_visibility("default"))) __tree_const_iterator;
        };
        template <class _Key, class _Tp, class _Compare = less<_Key>, class _Allocator = allocator<pair<const _Key, _Tp> >> class __attribute__((type_visibility("default"))) map {
        public:
            typedef _Key key_type;
            typedef _Tp mapped_type;
            typedef pair<const std::__1::map::key_type, std::__1::map::mapped_type> value_type;
            typedef typename __identity<_Compare>::type key_compare;
            typedef typename __identity<_Allocator>::type allocator_type;
            typedef std::__1::map::value_type &reference;
            typedef const std::__1::map::value_type &const_reference;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            class __attribute__((type_visibility("default"))) value_compare : public binary_function<std::__1::map::value_type, std::__1::map::value_type, bool> {
                friend  class map<_Key, _Tp, _Compare, _Allocator>;
            protected:
                std::__1::map::key_compare comp;
                value_compare(std::__1::map::key_compare c) : comp(c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
            public:
                bool operator()(const std::__1::map::value_type &__x, const std::__1::map::value_type &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return this->comp(__x.first, __y.first);
                }
            };
        private:
            typedef std::__1::__value_type<key_type, mapped_type> __value_type;
            typedef __map_value_compare<std::__1::map::key_type, std::__1::map::__value_type, std::__1::map::key_compare> __vc;
            typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>, __value_type>::type __allocator_type;
            typedef __tree<std::__1::map::__value_type, std::__1::map::__vc, std::__1::map::__allocator_type> __base;
            typedef typename __base::__node_traits __node_traits;
            typedef allocator_traits<std::__1::map::allocator_type> __alloc_traits;
            std::__1::map::__base __tree_;
        public:
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef __map_iterator<typename __base::iterator> iterator;
            typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            friend template <class _Key2, class _Value2, class _Comp2, class _Alloc2> class __attribute__((type_visibility("default"))) map;
            friend template <class _Key2, class _Value2, class _Comp2, class _Alloc2> class __attribute__((type_visibility("default"))) multimap;
            map<_Key, _Tp, _Compare, _Allocator>() : __tree_(std::__1::map::__vc(std::__1::map::key_compare())) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit map<_Key, _Tp, _Compare, _Allocator>(const std::__1::map::key_compare &__comp) : __tree_(std::__1::map::__vc(__comp)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit map<_Key, _Tp, _Compare, _Allocator>(const std::__1::map::key_compare &__comp, const std::__1::map::allocator_type &__a) : __tree_(std::__1::map::__vc(__comp), typename __base::allocator_type(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _InputIterator> map<_Key, _Tp, _Compare, _Allocator>(_InputIterator __f, _InputIterator __l, const std::__1::map::key_compare &__comp = std::__1::map::key_compare()) : __tree_(std::__1::map::__vc(__comp)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__f, __l);
            }
            template <class _InputIterator> map<_Key, _Tp, _Compare, _Allocator>(_InputIterator __f, _InputIterator __l, const std::__1::map::key_compare &__comp, const std::__1::map::allocator_type &__a) : __tree_(std::__1::map::__vc(__comp), typename __base::allocator_type(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__f, __l);
            }
            map<_Key, _Tp, _Compare, _Allocator>(const map<_Key, _Tp, _Compare, _Allocator> &__m) : __tree_(__m.__tree_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__m.begin(), __m.end());
            }
            map<_Key, _Tp, _Compare, _Allocator> &operator=(const map<_Key, _Tp, _Compare, _Allocator> &__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this != &__m) {
                    this->__tree_.clear();
                    this->__tree_.value_comp() = __m.__tree_.value_comp();
                    this->__tree_.__copy_assign_alloc(__m.__tree_);
                    insert(__m.begin(), __m.end());
                }
                return *this;
            }
            explicit map<_Key, _Tp, _Compare, _Allocator>(const std::__1::map::allocator_type &__a) : __tree_(typename __base::allocator_type(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            map<_Key, _Tp, _Compare, _Allocator>(const map<_Key, _Tp, _Compare, _Allocator> &__m, const std::__1::map::allocator_type &__a) : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__m.begin(), __m.end());
            }
            ~map<_Key, _Tp, _Compare, _Allocator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(sizeof (__diagnose_non_const_comparator<_Key, _Compare>()), "");
            }
            std::__1::map::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.begin();
            }
            std::__1::map::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.begin();
            }
            std::__1::map::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.end();
            }
            std::__1::map::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.end();
            }
            std::__1::map::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::map::reverse_iterator(end());
            }
            std::__1::map::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::map::const_reverse_iterator(end());
            }
            std::__1::map::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::map::reverse_iterator(begin());
            }
            std::__1::map::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::map::const_reverse_iterator(begin());
            }
            std::__1::map::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return begin();
            }
            std::__1::map::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return end();
            }
            std::__1::map::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rbegin();
            }
            std::__1::map::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rend();
            }
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.size() == 0;
            }
            std::__1::map::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.size();
            }
            std::__1::map::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.max_size();
            }
            std::__1::map::mapped_type &operator[](const std::__1::map::key_type &__k);
            std::__1::map::mapped_type &at(const std::__1::map::key_type &__k);
            const std::__1::map::mapped_type &at(const std::__1::map::key_type &__k) const;
            std::__1::map::allocator_type get_allocator() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::map::allocator_type(this->__tree_.__alloc());
            }
            std::__1::map::key_compare key_comp() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.value_comp().key_comp();
            }
            std::__1::map::value_compare value_comp() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::map::value_compare(this->__tree_.value_comp().key_comp());
            }
            pair<std::__1::map::iterator, bool> insert(const std::__1::map::value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__insert_unique(__v);
            }
            std::__1::map::iterator insert(std::__1::map::const_iterator __p, const std::__1::map::value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__insert_unique(__p.__i_, __v);
            }
            template <class _InputIterator> void insert(_InputIterator __f, _InputIterator __l) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (std::__1::map::const_iterator __e = this->cend(); __f != __l; ++__f)
                    insert(__e.__i_, *__f);
            }
            std::__1::map::iterator erase(std::__1::map::const_iterator __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__p.__i_);
            }
            std::__1::map::iterator erase(std::__1::map::iterator __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__p.__i_);
            }
            std::__1::map::size_type erase(const std::__1::map::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__erase_unique(__k);
            }
            std::__1::map::iterator erase(std::__1::map::const_iterator __f, std::__1::map::const_iterator __l) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__f.__i_, __l.__i_);
            }
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_.clear();
            }
            void swap(map<_Key, _Tp, _Compare, _Allocator> &__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_.swap(__m.__tree_);
            }
            std::__1::map::iterator find(const std::__1::map::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.find(__k);
            }
            std::__1::map::const_iterator find(const std::__1::map::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.find(__k);
            }
            std::__1::map::size_type count(const std::__1::map::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__count_unique(__k);
            }
            std::__1::map::iterator lower_bound(const std::__1::map::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.lower_bound(__k);
            }
            std::__1::map::const_iterator lower_bound(const std::__1::map::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.lower_bound(__k);
            }
            std::__1::map::iterator upper_bound(const std::__1::map::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.upper_bound(__k);
            }
            std::__1::map::const_iterator upper_bound(const std::__1::map::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.upper_bound(__k);
            }
            pair<std::__1::map::iterator, std::__1::map::iterator> equal_range(const std::__1::map::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__equal_range_unique(__k);
            }
            pair<std::__1::map::const_iterator, std::__1::map::const_iterator> equal_range(const std::__1::map::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__equal_range_unique(__k);
            }
        private:
            typedef typename __base::__node __node;
            typedef typename __base::__node_allocator __node_allocator;
            typedef typename __base::__node_pointer __node_pointer;
            typedef typename __base::__node_base_pointer __node_base_pointer;
            typedef typename __base::__parent_pointer __parent_pointer;
            typedef __map_node_destructor<std::__1::map::__node_allocator> _Dp;
            typedef unique_ptr<std::__1::map::__node, std::__1::map::_Dp> __node_holder;
            std::__1::map::__node_holder __construct_node_with_key(const std::__1::map::key_type &__k);
        };
        template <class _Key, class _Tp, class _Compare, class _Allocator> typename map<_Key, _Tp, _Compare, _Allocator>::__node_holder map<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const std::__1::map::key_type &__k)         {
            std::__1::map::__node_allocator &__na = this->__tree_.__node_alloc();
            std::__1::map::__node_holder __h(__node_traits::allocate(__na, 1), std::__1::map::_Dp(__na));
            __node_traits::construct(__na, std::__1::addressof(__h->__value_.__get_value().first), __k);
            __h.get_deleter().__first_constructed = true;
            __node_traits::construct(__na, std::__1::addressof(__h->__value_.__get_value().second));
            __h.get_deleter().__second_constructed = true;
            return std::__1::move(__h);
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> _Tp &map<_Key, _Tp, _Compare, _Allocator>::operator[](const std::__1::map::key_type &__k)         {
            std::__1::map::__parent_pointer __parent;
            std::__1::map::__node_base_pointer &__child = this->__tree_.__find_equal(__parent, __k);
            std::__1::map::__node_pointer __r = static_cast<std::__1::map::__node_pointer>(__child);
            if (__child == std::__1::__get_nullptr_t()) {
                std::__1::map::__node_holder __h = this->__construct_node_with_key(__k);
                this->__tree_.__insert_node_at(__parent, __child, static_cast<std::__1::map::__node_base_pointer>(__h.get()));
                __r = __h.release();
            }
            return __r->__value_.__get_value().second;
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> _Tp &map<_Key, _Tp, _Compare, _Allocator>::at(const std::__1::map::key_type &__k)         {
            std::__1::map::__parent_pointer __parent;
            std::__1::map::__node_base_pointer &__child = this->__tree_.__find_equal(__parent, __k);
            if (__child == std::__1::__get_nullptr_t())
                __throw_out_of_range("map::at:  key not found");
            return static_cast<std::__1::map::__node_pointer>(__child)->__value_.__get_value().second;
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> const _Tp &map<_Key, _Tp, _Compare, _Allocator>::at(const std::__1::map::key_type &__k) const         {
            std::__1::map::__parent_pointer __parent;
            std::__1::map::__node_base_pointer __child = this->__tree_.__find_equal(__parent, __k);
            if (__child == std::__1::__get_nullptr_t())
                __throw_out_of_range("map::at:  key not found");
            return static_cast<std::__1::map::__node_pointer>(__child)->__value_.__get_value().second;
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator==(const map<_Key, _Tp, _Compare, _Allocator> &__x, const map<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator<(const map<_Key, _Tp, _Compare, _Allocator> &__x, const map<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator!=(const map<_Key, _Tp, _Compare, _Allocator> &__x, const map<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator>(const map<_Key, _Tp, _Compare, _Allocator> &__x, const map<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator>=(const map<_Key, _Tp, _Compare, _Allocator> &__x, const map<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator<=(const map<_Key, _Tp, _Compare, _Allocator> &__x, const map<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline void swap(map<_Key, _Tp, _Compare, _Allocator> &__x, map<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _Key, class _Tp, class _Compare = less<_Key>, class _Allocator = allocator<pair<const _Key, _Tp> >> class __attribute__((type_visibility("default"))) multimap {
        public:
            typedef _Key key_type;
            typedef _Tp mapped_type;
            typedef pair<const std::__1::multimap::key_type, std::__1::multimap::mapped_type> value_type;
            typedef typename __identity<_Compare>::type key_compare;
            typedef typename __identity<_Allocator>::type allocator_type;
            typedef std::__1::multimap::value_type &reference;
            typedef const std::__1::multimap::value_type &const_reference;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            class __attribute__((type_visibility("default"))) value_compare : public binary_function<std::__1::multimap::value_type, std::__1::multimap::value_type, bool> {
                friend  class multimap<_Key, _Tp, _Compare, _Allocator>;
            protected:
                std::__1::multimap::key_compare comp;
                value_compare(std::__1::multimap::key_compare c) : comp(c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
            public:
                bool operator()(const std::__1::multimap::value_type &__x, const std::__1::multimap::value_type &__y) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return this->comp(__x.first, __y.first);
                }
            };
        private:
            typedef std::__1::__value_type<key_type, mapped_type> __value_type;
            typedef __map_value_compare<std::__1::multimap::key_type, std::__1::multimap::__value_type, std::__1::multimap::key_compare> __vc;
            typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>, __value_type>::type __allocator_type;
            typedef __tree<std::__1::multimap::__value_type, std::__1::multimap::__vc, std::__1::multimap::__allocator_type> __base;
            typedef typename __base::__node_traits __node_traits;
            typedef allocator_traits<std::__1::multimap::allocator_type> __alloc_traits;
            std::__1::multimap::__base __tree_;
        public:
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef __map_iterator<typename __base::iterator> iterator;
            typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            friend template <class _Key2, class _Value2, class _Comp2, class _Alloc2> class __attribute__((type_visibility("default"))) map;
            friend template <class _Key2, class _Value2, class _Comp2, class _Alloc2> class __attribute__((type_visibility("default"))) multimap;
            multimap<_Key, _Tp, _Compare, _Allocator>() : __tree_(std::__1::multimap::__vc(std::__1::multimap::key_compare())) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit multimap<_Key, _Tp, _Compare, _Allocator>(const std::__1::multimap::key_compare &__comp) : __tree_(std::__1::multimap::__vc(__comp)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit multimap<_Key, _Tp, _Compare, _Allocator>(const std::__1::multimap::key_compare &__comp, const std::__1::multimap::allocator_type &__a) : __tree_(std::__1::multimap::__vc(__comp), typename __base::allocator_type(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _InputIterator> multimap<_Key, _Tp, _Compare, _Allocator>(_InputIterator __f, _InputIterator __l, const std::__1::multimap::key_compare &__comp = std::__1::multimap::key_compare()) : __tree_(std::__1::multimap::__vc(__comp)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__f, __l);
            }
            template <class _InputIterator> multimap<_Key, _Tp, _Compare, _Allocator>(_InputIterator __f, _InputIterator __l, const std::__1::multimap::key_compare &__comp, const std::__1::multimap::allocator_type &__a) : __tree_(std::__1::multimap::__vc(__comp), typename __base::allocator_type(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__f, __l);
            }
            multimap<_Key, _Tp, _Compare, _Allocator>(const multimap<_Key, _Tp, _Compare, _Allocator> &__m) : __tree_(__m.__tree_.value_comp(), __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc())) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__m.begin(), __m.end());
            }
            multimap<_Key, _Tp, _Compare, _Allocator> &operator=(const multimap<_Key, _Tp, _Compare, _Allocator> &__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this != &__m) {
                    this->__tree_.clear();
                    this->__tree_.value_comp() = __m.__tree_.value_comp();
                    this->__tree_.__copy_assign_alloc(__m.__tree_);
                    insert(__m.begin(), __m.end());
                }
                return *this;
            }
            explicit multimap<_Key, _Tp, _Compare, _Allocator>(const std::__1::multimap::allocator_type &__a) : __tree_(typename __base::allocator_type(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            multimap<_Key, _Tp, _Compare, _Allocator>(const multimap<_Key, _Tp, _Compare, _Allocator> &__m, const std::__1::multimap::allocator_type &__a) : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__m.begin(), __m.end());
            }
            ~multimap<_Key, _Tp, _Compare, _Allocator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(sizeof (__diagnose_non_const_comparator<_Key, _Compare>()), "");
            }
            std::__1::multimap::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.begin();
            }
            std::__1::multimap::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.begin();
            }
            std::__1::multimap::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.end();
            }
            std::__1::multimap::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.end();
            }
            std::__1::multimap::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multimap::reverse_iterator(end());
            }
            std::__1::multimap::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multimap::const_reverse_iterator(end());
            }
            std::__1::multimap::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multimap::reverse_iterator(begin());
            }
            std::__1::multimap::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multimap::const_reverse_iterator(begin());
            }
            std::__1::multimap::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return begin();
            }
            std::__1::multimap::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return end();
            }
            std::__1::multimap::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rbegin();
            }
            std::__1::multimap::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rend();
            }
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.size() == 0;
            }
            std::__1::multimap::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.size();
            }
            std::__1::multimap::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.max_size();
            }
            std::__1::multimap::allocator_type get_allocator() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multimap::allocator_type(this->__tree_.__alloc());
            }
            std::__1::multimap::key_compare key_comp() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.value_comp().key_comp();
            }
            std::__1::multimap::value_compare value_comp() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multimap::value_compare(this->__tree_.value_comp().key_comp());
            }
            std::__1::multimap::iterator insert(const std::__1::multimap::value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__insert_multi(__v);
            }
            std::__1::multimap::iterator insert(std::__1::multimap::const_iterator __p, const std::__1::multimap::value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__insert_multi(__p.__i_, __v);
            }
            template <class _InputIterator> void insert(_InputIterator __f, _InputIterator __l) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (std::__1::multimap::const_iterator __e = this->cend(); __f != __l; ++__f)
                    this->__tree_.__insert_multi(__e.__i_, *__f);
            }
            std::__1::multimap::iterator erase(std::__1::multimap::const_iterator __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__p.__i_);
            }
            std::__1::multimap::iterator erase(std::__1::multimap::iterator __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__p.__i_);
            }
            std::__1::multimap::size_type erase(const std::__1::multimap::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__erase_multi(__k);
            }
            std::__1::multimap::iterator erase(std::__1::multimap::const_iterator __f, std::__1::multimap::const_iterator __l) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__f.__i_, __l.__i_);
            }
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_.clear();
            }
            void swap(multimap<_Key, _Tp, _Compare, _Allocator> &__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_.swap(__m.__tree_);
            }
            std::__1::multimap::iterator find(const std::__1::multimap::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.find(__k);
            }
            std::__1::multimap::const_iterator find(const std::__1::multimap::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.find(__k);
            }
            std::__1::multimap::size_type count(const std::__1::multimap::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__count_multi(__k);
            }
            std::__1::multimap::iterator lower_bound(const std::__1::multimap::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.lower_bound(__k);
            }
            std::__1::multimap::const_iterator lower_bound(const std::__1::multimap::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.lower_bound(__k);
            }
            std::__1::multimap::iterator upper_bound(const std::__1::multimap::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.upper_bound(__k);
            }
            std::__1::multimap::const_iterator upper_bound(const std::__1::multimap::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.upper_bound(__k);
            }
            pair<std::__1::multimap::iterator, std::__1::multimap::iterator> equal_range(const std::__1::multimap::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__equal_range_multi(__k);
            }
            pair<std::__1::multimap::const_iterator, std::__1::multimap::const_iterator> equal_range(const std::__1::multimap::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__equal_range_multi(__k);
            }
        private:
            typedef typename __base::__node __node;
            typedef typename __base::__node_allocator __node_allocator;
            typedef typename __base::__node_pointer __node_pointer;
            typedef __map_node_destructor<std::__1::multimap::__node_allocator> _Dp;
            typedef unique_ptr<std::__1::multimap::__node, std::__1::multimap::_Dp> __node_holder;
        };
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator==(const multimap<_Key, _Tp, _Compare, _Allocator> &__x, const multimap<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator<(const multimap<_Key, _Tp, _Compare, _Allocator> &__x, const multimap<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator!=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x, const multimap<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator>(const multimap<_Key, _Tp, _Compare, _Allocator> &__x, const multimap<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator>=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x, const multimap<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline bool operator<=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x, const multimap<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Key, class _Tp, class _Compare, class _Allocator> inline void swap(multimap<_Key, _Tp, _Compare, _Allocator> &__x, multimap<_Key, _Tp, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
    }
}
namespace std {
    inline namespace __1 {
        template <class _Key, class _Compare, class _Allocator> class multiset;
        template <class _Key, class _Compare = less<_Key>, class _Allocator = allocator<_Key>> class __attribute__((type_visibility("default"))) set {
        public:
            typedef _Key key_type;
            typedef std::__1::set::key_type value_type;
            typedef _Compare key_compare;
            typedef std::__1::set::key_compare value_compare;
            typedef typename __identity<_Allocator>::type allocator_type;
            typedef std::__1::set::value_type &reference;
            typedef const std::__1::set::value_type &const_reference;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
        private:
            typedef __tree<std::__1::set::value_type, std::__1::set::value_compare, std::__1::set::allocator_type> __base;
            typedef allocator_traits<std::__1::set::allocator_type> __alloc_traits;
            typedef typename __base::__node_holder __node_holder;
            std::__1::set::__base __tree_;
        public:
            typedef typename __base::pointer pointer;
            typedef typename __base::const_pointer const_pointer;
            typedef typename __base::size_type size_type;
            typedef typename __base::difference_type difference_type;
            typedef typename __base::const_iterator iterator;
            typedef typename __base::const_iterator const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            friend template <class _Key2, class _Compare2, class _Alloc2> class __attribute__((type_visibility("default"))) set;
            friend template <class _Key2, class _Compare2, class _Alloc2> class __attribute__((type_visibility("default"))) multiset;
            set<_Key, _Compare, _Allocator>() : __tree_(std::__1::set::value_compare()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit set<_Key, _Compare, _Allocator>(const std::__1::set::value_compare &__comp) : __tree_(__comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit set<_Key, _Compare, _Allocator>(const std::__1::set::value_compare &__comp, const std::__1::set::allocator_type &__a) : __tree_(__comp, __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _InputIterator> set<_Key, _Compare, _Allocator>(_InputIterator __f, _InputIterator __l, const std::__1::set::value_compare &__comp = std::__1::set::value_compare()) : __tree_(__comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__f, __l);
            }
            template <class _InputIterator> set<_Key, _Compare, _Allocator>(_InputIterator __f, _InputIterator __l, const std::__1::set::value_compare &__comp, const std::__1::set::allocator_type &__a) : __tree_(__comp, __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__f, __l);
            }
            set<_Key, _Compare, _Allocator>(const set<_Key, _Compare, _Allocator> &__s) : __tree_(__s.__tree_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__s.begin(), __s.end());
            }
            set<_Key, _Compare, _Allocator> &operator=(const set<_Key, _Compare, _Allocator> &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_ = __s.__tree_;
                return *this;
            }
            explicit set<_Key, _Compare, _Allocator>(const std::__1::set::allocator_type &__a) : __tree_(__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            set<_Key, _Compare, _Allocator>(const set<_Key, _Compare, _Allocator> &__s, const std::__1::set::allocator_type &__a) : __tree_(__s.__tree_.value_comp(), __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__s.begin(), __s.end());
            }
            ~set<_Key, _Compare, _Allocator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(sizeof (__diagnose_non_const_comparator<_Key, _Compare>()), "");
            }
            std::__1::set::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.begin();
            }
            std::__1::set::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.begin();
            }
            std::__1::set::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.end();
            }
            std::__1::set::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.end();
            }
            std::__1::set::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::set::reverse_iterator(end());
            }
            std::__1::set::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::set::const_reverse_iterator(end());
            }
            std::__1::set::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::set::reverse_iterator(begin());
            }
            std::__1::set::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::set::const_reverse_iterator(begin());
            }
            std::__1::set::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return begin();
            }
            std::__1::set::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return end();
            }
            std::__1::set::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rbegin();
            }
            std::__1::set::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rend();
            }
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.size() == 0;
            }
            std::__1::set::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.size();
            }
            std::__1::set::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.max_size();
            }
            pair<std::__1::set::iterator, bool> insert(const std::__1::set::value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__insert_unique(__v);
            }
            std::__1::set::iterator insert(std::__1::set::const_iterator __p, const std::__1::set::value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__insert_unique(__p, __v);
            }
            template <class _InputIterator> void insert(_InputIterator __f, _InputIterator __l) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (std::__1::set::const_iterator __e = this->cend(); __f != __l; ++__f)
                    this->__tree_.__insert_unique(__e, *__f);
            }
            std::__1::set::iterator erase(std::__1::set::const_iterator __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__p);
            }
            std::__1::set::size_type erase(const std::__1::set::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__erase_unique(__k);
            }
            std::__1::set::iterator erase(std::__1::set::const_iterator __f, std::__1::set::const_iterator __l) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__f, __l);
            }
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_.clear();
            }
            void swap(set<_Key, _Compare, _Allocator> &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_.swap(__s.__tree_);
            }
            std::__1::set::allocator_type get_allocator() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__alloc();
            }
            std::__1::set::key_compare key_comp() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.value_comp();
            }
            std::__1::set::value_compare value_comp() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.value_comp();
            }
            std::__1::set::iterator find(const std::__1::set::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.find(__k);
            }
            std::__1::set::const_iterator find(const std::__1::set::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.find(__k);
            }
            std::__1::set::size_type count(const std::__1::set::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__count_unique(__k);
            }
            std::__1::set::iterator lower_bound(const std::__1::set::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.lower_bound(__k);
            }
            std::__1::set::const_iterator lower_bound(const std::__1::set::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.lower_bound(__k);
            }
            std::__1::set::iterator upper_bound(const std::__1::set::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.upper_bound(__k);
            }
            std::__1::set::const_iterator upper_bound(const std::__1::set::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.upper_bound(__k);
            }
            pair<std::__1::set::iterator, std::__1::set::iterator> equal_range(const std::__1::set::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__equal_range_unique(__k);
            }
            pair<std::__1::set::const_iterator, std::__1::set::const_iterator> equal_range(const std::__1::set::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__equal_range_unique(__k);
            }
        };
        template <class _Key, class _Compare, class _Allocator> inline bool operator==(const set<_Key, _Compare, _Allocator> &__x, const set<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator<(const set<_Key, _Compare, _Allocator> &__x, const set<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator!=(const set<_Key, _Compare, _Allocator> &__x, const set<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator>(const set<_Key, _Compare, _Allocator> &__x, const set<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator>=(const set<_Key, _Compare, _Allocator> &__x, const set<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator<=(const set<_Key, _Compare, _Allocator> &__x, const set<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Key, class _Compare, class _Allocator> inline void swap(set<_Key, _Compare, _Allocator> &__x, set<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _Key, class _Compare = less<_Key>, class _Allocator = allocator<_Key>> class __attribute__((type_visibility("default"))) multiset {
        public:
            typedef _Key key_type;
            typedef std::__1::multiset::key_type value_type;
            typedef _Compare key_compare;
            typedef std::__1::multiset::key_compare value_compare;
            typedef typename __identity<_Allocator>::type allocator_type;
            typedef std::__1::multiset::value_type &reference;
            typedef const std::__1::multiset::value_type &const_reference;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
        private:
            typedef __tree<std::__1::multiset::value_type, std::__1::multiset::value_compare, std::__1::multiset::allocator_type> __base;
            typedef allocator_traits<std::__1::multiset::allocator_type> __alloc_traits;
            typedef typename __base::__node_holder __node_holder;
            std::__1::multiset::__base __tree_;
        public:
            typedef typename __base::pointer pointer;
            typedef typename __base::const_pointer const_pointer;
            typedef typename __base::size_type size_type;
            typedef typename __base::difference_type difference_type;
            typedef typename __base::const_iterator iterator;
            typedef typename __base::const_iterator const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            friend template <class _Key2, class _Compare2, class _Alloc2> class __attribute__((type_visibility("default"))) set;
            friend template <class _Key2, class _Compare2, class _Alloc2> class __attribute__((type_visibility("default"))) multiset;
            multiset<_Key, _Compare, _Allocator>() : __tree_(std::__1::multiset::value_compare()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit multiset<_Key, _Compare, _Allocator>(const std::__1::multiset::value_compare &__comp) : __tree_(__comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit multiset<_Key, _Compare, _Allocator>(const std::__1::multiset::value_compare &__comp, const std::__1::multiset::allocator_type &__a) : __tree_(__comp, __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _InputIterator> multiset<_Key, _Compare, _Allocator>(_InputIterator __f, _InputIterator __l, const std::__1::multiset::value_compare &__comp = std::__1::multiset::value_compare()) : __tree_(__comp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__f, __l);
            }
            template <class _InputIterator> multiset<_Key, _Compare, _Allocator>(_InputIterator __f, _InputIterator __l, const std::__1::multiset::value_compare &__comp, const std::__1::multiset::allocator_type &__a) : __tree_(__comp, __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__f, __l);
            }
            multiset<_Key, _Compare, _Allocator>(const multiset<_Key, _Compare, _Allocator> &__s) : __tree_(__s.__tree_.value_comp(), __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc())) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__s.begin(), __s.end());
            }
            multiset<_Key, _Compare, _Allocator> &operator=(const multiset<_Key, _Compare, _Allocator> &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_ = __s.__tree_;
                return *this;
            }
            explicit multiset<_Key, _Compare, _Allocator>(const std::__1::multiset::allocator_type &__a) : __tree_(__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            multiset<_Key, _Compare, _Allocator>(const multiset<_Key, _Compare, _Allocator> &__s, const std::__1::multiset::allocator_type &__a) : __tree_(__s.__tree_.value_comp(), __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                insert(__s.begin(), __s.end());
            }
            ~multiset<_Key, _Compare, _Allocator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                static_assert(sizeof (__diagnose_non_const_comparator<_Key, _Compare>()), "");
            }
            std::__1::multiset::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.begin();
            }
            std::__1::multiset::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.begin();
            }
            std::__1::multiset::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.end();
            }
            std::__1::multiset::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.end();
            }
            std::__1::multiset::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multiset::reverse_iterator(end());
            }
            std::__1::multiset::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multiset::const_reverse_iterator(end());
            }
            std::__1::multiset::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multiset::reverse_iterator(begin());
            }
            std::__1::multiset::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::multiset::const_reverse_iterator(begin());
            }
            std::__1::multiset::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return begin();
            }
            std::__1::multiset::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return end();
            }
            std::__1::multiset::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rbegin();
            }
            std::__1::multiset::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rend();
            }
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.size() == 0;
            }
            std::__1::multiset::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.size();
            }
            std::__1::multiset::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.max_size();
            }
            std::__1::multiset::iterator insert(const std::__1::multiset::value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__insert_multi(__v);
            }
            std::__1::multiset::iterator insert(std::__1::multiset::const_iterator __p, const std::__1::multiset::value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__insert_multi(__p, __v);
            }
            template <class _InputIterator> void insert(_InputIterator __f, _InputIterator __l) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (std::__1::multiset::const_iterator __e = this->cend(); __f != __l; ++__f)
                    this->__tree_.__insert_multi(__e, *__f);
            }
            std::__1::multiset::iterator erase(std::__1::multiset::const_iterator __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__p);
            }
            std::__1::multiset::size_type erase(const std::__1::multiset::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__erase_multi(__k);
            }
            std::__1::multiset::iterator erase(std::__1::multiset::const_iterator __f, std::__1::multiset::const_iterator __l) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.erase(__f, __l);
            }
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_.clear();
            }
            void swap(multiset<_Key, _Compare, _Allocator> &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__tree_.swap(__s.__tree_);
            }
            std::__1::multiset::allocator_type get_allocator() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__alloc();
            }
            std::__1::multiset::key_compare key_comp() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.value_comp();
            }
            std::__1::multiset::value_compare value_comp() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.value_comp();
            }
            std::__1::multiset::iterator find(const std::__1::multiset::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.find(__k);
            }
            std::__1::multiset::const_iterator find(const std::__1::multiset::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.find(__k);
            }
            std::__1::multiset::size_type count(const std::__1::multiset::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__count_multi(__k);
            }
            std::__1::multiset::iterator lower_bound(const std::__1::multiset::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.lower_bound(__k);
            }
            std::__1::multiset::const_iterator lower_bound(const std::__1::multiset::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.lower_bound(__k);
            }
            std::__1::multiset::iterator upper_bound(const std::__1::multiset::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.upper_bound(__k);
            }
            std::__1::multiset::const_iterator upper_bound(const std::__1::multiset::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.upper_bound(__k);
            }
            pair<std::__1::multiset::iterator, std::__1::multiset::iterator> equal_range(const std::__1::multiset::key_type &__k) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__equal_range_multi(__k);
            }
            pair<std::__1::multiset::const_iterator, std::__1::multiset::const_iterator> equal_range(const std::__1::multiset::key_type &__k) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tree_.__equal_range_multi(__k);
            }
        };
        template <class _Key, class _Compare, class _Allocator> inline bool operator==(const multiset<_Key, _Compare, _Allocator> &__x, const multiset<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator<(const multiset<_Key, _Compare, _Allocator> &__x, const multiset<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator!=(const multiset<_Key, _Compare, _Allocator> &__x, const multiset<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator>(const multiset<_Key, _Compare, _Allocator> &__x, const multiset<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator>=(const multiset<_Key, _Compare, _Allocator> &__x, const multiset<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Key, class _Compare, class _Allocator> inline bool operator<=(const multiset<_Key, _Compare, _Allocator> &__x, const multiset<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Key, class _Compare, class _Allocator> inline void swap(multiset<_Key, _Compare, _Allocator> &__x, multiset<_Key, _Compare, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
    }
}
namespace std {
    inline namespace __1 {
        template <class _Tp, class _Allocator> class __deque_base;
        template <class _Tp, class _Allocator = allocator<_Tp>> class __attribute__((type_visibility("default"))) deque;
        template <class _ValueType, class _Pointer, class _Reference, class _MapPointer, class _DiffType, _DiffType _BlockSize> class __attribute__((type_visibility("default"))) __deque_iterator;
        template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy_backward(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        template <class _ValueType, class _DiffType> struct __deque_block_size {
            static const _DiffType value = sizeof(_ValueType) < 256 ? 4096 / sizeof(_ValueType) : 16;
        };
        template <class _ValueType, class _Pointer, class _Reference, class _MapPointer, class _DiffType, _DiffType _BS = __deque_block_size<_ValueType, _DiffType>::value> class __attribute__((type_visibility("default"))) __deque_iterator {
            typedef _MapPointer __map_iterator;
        public:
            typedef _Pointer pointer;
            typedef _DiffType difference_type;
        private:
            std::__1::__deque_iterator::__map_iterator __m_iter_;
            std::__1::__deque_iterator::pointer __ptr_;
            static const std::__1::__deque_iterator::difference_type __block_size;
        public:
            typedef _ValueType value_type;
            typedef std::__1::random_access_iterator_tag iterator_category;
            typedef _Reference reference;
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Pp, class _Rp, class _MP> __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize>(const __deque_iterator<std::__1::__deque_iterator::value_type, _Pp, _Rp, _MP, std::__1::__deque_iterator::difference_type, _BS> &__it, typename enable_if<is_convertible<_Pp, pointer>::value>::type * = 0) throw() : __m_iter_(__it.__m_iter_), __ptr_(__it.__ptr_) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::__deque_iterator::reference operator*() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__ptr_;
            }
            std::__1::__deque_iterator::pointer operator->() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ptr_;
            }
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (++this->__ptr_ - *this->__m_iter_ == __block_size) {
                    ++this->__m_iter_;
                    this->__ptr_ = *this->__m_iter_;
                }
                return *this;
            }
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> __tmp = *this;
                ++(*this);
                return __tmp;
            }
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &operator--() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__ptr_ == *this->__m_iter_) {
                    --this->__m_iter_;
                    this->__ptr_ = *this->__m_iter_ + __block_size;
                }
                --this->__ptr_;
                return *this;
            }
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> operator--(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> __tmp = *this;
                --(*this);
                return __tmp;
            }
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &operator+=(std::__1::__deque_iterator::difference_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__n != 0) {
                    __n += this->__ptr_ - *this->__m_iter_;
                    if (__n > 0) {
                        this->__m_iter_ += __n / __block_size;
                        this->__ptr_ = *this->__m_iter_ + __n % __block_size;
                    } else {
                        std::__1::__deque_iterator::difference_type __z = __block_size - 1 - __n;
                        this->__m_iter_ -= __z / __block_size;
                        this->__ptr_ = *this->__m_iter_ + (__block_size - 1 - __z % __block_size);
                    }
                }
                return *this;
            }
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &operator-=(std::__1::__deque_iterator::difference_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this += - __n;
            }
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> operator+(std::__1::__deque_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> __t(*this);
                __t += __n;
                return __t;
            }
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> operator-(std::__1::__deque_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> __t(*this);
                __t -= __n;
                return __t;
            }
            friend __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> operator+(std::__1::__deque_iterator::difference_type __n, const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__it) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __it + __n;
            }
;
            friend std::__1::__deque_iterator::difference_type operator-(const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__x, const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__x != __y)
                    return (__x.__m_iter_ - __y.__m_iter_) * __block_size + (__x.__ptr_ - *__x.__m_iter_) - (__y.__ptr_ - *__y.__m_iter_);
                return 0;
            }
;
            std::__1::__deque_iterator::reference operator[](std::__1::__deque_iterator::difference_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *(*this + __n);
            }
            friend bool operator==(const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__x, const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__ptr_ == __y.__ptr_;
            }
;
            friend bool operator!=(const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__x, const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x == __y);
            }
;
            friend bool operator<(const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__x, const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __x.__m_iter_ < __y.__m_iter_ || (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);
            }
;
            friend bool operator>(const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__x, const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __y < __x;
            }
;
            friend bool operator<=(const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__x, const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__y < __x);
            }
;
            friend bool operator>=(const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__x, const __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x < __y);
            }
;
        private:
            __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize>(std::__1::__deque_iterator::__map_iterator __m, std::__1::__deque_iterator::pointer __p) throw() : __m_iter_(__m), __ptr_(__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _Tp, class _Ap> class __deque_base;
            friend template <class _Tp, class _Ap> class __attribute__((type_visibility("default"))) deque;
            friend template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp> class __attribute__((type_visibility("default"))) __deque_iterator;
            friend template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *);
            friend template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);
            friend template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
            friend template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy_backward(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *);
            friend template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);
            friend template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
            friend template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *);
            friend template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);
            friend template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
            friend template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type *);
            friend template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);
            friend template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        };
        const _DiffType __block_size = __deque_block_size<_ValueType, _DiffType>::value;
        template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0)         {
            typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
            typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
            const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
            while (__f != __l)
                {
                    pointer __rb = __r.__ptr_;
                    pointer __re = *__r.__m_iter_ + __block_size;
                    difference_type __bs = __re - __rb;
                    difference_type __n = __l - __f;
                    _RAIter __m = __l;
                    if (__n > __bs) {
                        __n = __bs;
                        __m = __f + __n;
                    }
                    std::__1::copy(__f, __m, __rb);
                    __f = __m;
                    __r += __n;
                }
            return __r;
        }
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r)         {
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
            const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
            difference_type __n = __l - __f;
            while (__n > 0)
                {
                    pointer __fb = __f.__ptr_;
                    pointer __fe = *__f.__m_iter_ + __block_size;
                    difference_type __bs = __fe - __fb;
                    if (__bs > __n) {
                        __bs = __n;
                        __fe = __fb + __bs;
                    }
                    __r = std::__1::copy(__fb, __fe, __r);
                    __n -= __bs;
                    __f += __bs;
                }
            return __r;
        }
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)         {
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
            const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
            difference_type __n = __l - __f;
            while (__n > 0)
                {
                    pointer __fb = __f.__ptr_;
                    pointer __fe = *__f.__m_iter_ + __block_size;
                    difference_type __bs = __fe - __fb;
                    if (__bs > __n) {
                        __bs = __n;
                        __fe = __fb + __bs;
                    }
                    __r = std::__1::copy(__fb, __fe, __r);
                    __n -= __bs;
                    __f += __bs;
                }
            return __r;
        }
        template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy_backward(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0)         {
            typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
            typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
            while (__f != __l)
                {
                    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
                    pointer __rb = *__rp.__m_iter_;
                    pointer __re = __rp.__ptr_ + 1;
                    difference_type __bs = __re - __rb;
                    difference_type __n = __l - __f;
                    _RAIter __m = __f;
                    if (__n > __bs) {
                        __n = __bs;
                        __m = __l - __n;
                    }
                    std::__1::copy_backward(__m, __l, __re);
                    __l = __m;
                    __r -= __n;
                }
            return __r;
        }
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r)         {
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
            difference_type __n = __l - __f;
            while (__n > 0)
                {
                    --__l;
                    pointer __lb = *__l.__m_iter_;
                    pointer __le = __l.__ptr_ + 1;
                    difference_type __bs = __le - __lb;
                    if (__bs > __n) {
                        __bs = __n;
                        __lb = __le - __bs;
                    }
                    __r = std::__1::copy_backward(__lb, __le, __r);
                    __n -= __bs;
                    __l -= __bs - 1;
                }
            return __r;
        }
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)         {
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
            difference_type __n = __l - __f;
            while (__n > 0)
                {
                    --__l;
                    pointer __lb = *__l.__m_iter_;
                    pointer __le = __l.__ptr_ + 1;
                    difference_type __bs = __le - __lb;
                    if (__bs > __n) {
                        __bs = __n;
                        __lb = __le - __bs;
                    }
                    __r = std::__1::copy_backward(__lb, __le, __r);
                    __n -= __bs;
                    __l -= __bs - 1;
                }
            return __r;
        }
        template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0)         {
            typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
            typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
            const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
            while (__f != __l)
                {
                    pointer __rb = __r.__ptr_;
                    pointer __re = *__r.__m_iter_ + __block_size;
                    difference_type __bs = __re - __rb;
                    difference_type __n = __l - __f;
                    _RAIter __m = __l;
                    if (__n > __bs) {
                        __n = __bs;
                        __m = __f + __n;
                    }
                    std::__1::move(__f, __m, __rb);
                    __f = __m;
                    __r += __n;
                }
            return __r;
        }
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r)         {
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
            const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
            difference_type __n = __l - __f;
            while (__n > 0)
                {
                    pointer __fb = __f.__ptr_;
                    pointer __fe = *__f.__m_iter_ + __block_size;
                    difference_type __bs = __fe - __fb;
                    if (__bs > __n) {
                        __bs = __n;
                        __fe = __fb + __bs;
                    }
                    __r = std::__1::move(__fb, __fe, __r);
                    __n -= __bs;
                    __f += __bs;
                }
            return __r;
        }
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)         {
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
            const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
            difference_type __n = __l - __f;
            while (__n > 0)
                {
                    pointer __fb = __f.__ptr_;
                    pointer __fe = *__f.__m_iter_ + __block_size;
                    difference_type __bs = __fe - __fb;
                    if (__bs > __n) {
                        __bs = __n;
                        __fe = __fb + __bs;
                    }
                    __r = std::__1::move(__fb, __fe, __r);
                    __n -= __bs;
                    __f += __bs;
                }
            return __r;
        }
        template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(_RAIter __f, _RAIter __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0)         {
            typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
            typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
            while (__f != __l)
                {
                    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
                    pointer __rb = *__rp.__m_iter_;
                    pointer __re = __rp.__ptr_ + 1;
                    difference_type __bs = __re - __rb;
                    difference_type __n = __l - __f;
                    _RAIter __m = __f;
                    if (__n > __bs) {
                        __n = __bs;
                        __m = __l - __n;
                    }
                    std::__1::move_backward(__m, __l, __re);
                    __l = __m;
                    __r -= __n;
                }
            return __r;
        }
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _OutputIterator> _OutputIterator move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r)         {
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
            difference_type __n = __l - __f;
            while (__n > 0)
                {
                    --__l;
                    pointer __lb = *__l.__m_iter_;
                    pointer __le = __l.__ptr_ + 1;
                    difference_type __bs = __le - __lb;
                    if (__bs > __n) {
                        __bs = __n;
                        __lb = __le - __bs;
                    }
                    __r = std::__1::move_backward(__lb, __le, __r);
                    __n -= __bs;
                    __l -= __bs - 1;
                }
            return __r;
        }
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1, class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f, __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)         {
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
            typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
            difference_type __n = __l - __f;
            while (__n > 0)
                {
                    --__l;
                    pointer __lb = *__l.__m_iter_;
                    pointer __le = __l.__ptr_ + 1;
                    difference_type __bs = __le - __lb;
                    if (__bs > __n) {
                        __bs = __n;
                        __lb = __le - __bs;
                    }
                    __r = std::__1::move_backward(__lb, __le, __r);
                    __n -= __bs;
                    __l -= __bs - 1;
                }
            return __r;
        }
        template <bool> class __deque_base_common {
        protected:
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
template<> class __deque_base_common<true> {
        protected:
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
        template <bool __b> void __deque_base_common<__b>::__throw_length_error() const         {
            std::__1::__throw_length_error("deque");
        }
        template <bool __b> void __deque_base_common<__b>::__throw_out_of_range() const         {
            std::__1::__throw_out_of_range("deque");
        }
        template <class _Tp, class _Allocator> class __deque_base : protected __deque_base_common<true> {
            __deque_base<_Tp, _Allocator>(const __deque_base<_Tp, _Allocator> &__c);
            __deque_base<_Tp, _Allocator> &operator=(const __deque_base<_Tp, _Allocator> &__c);
        public:
            typedef _Allocator allocator_type;
            typedef allocator_traits<std::__1::__deque_base::allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef _Tp value_type;
            typedef std::__1::__deque_base::value_type &reference;
            typedef const std::__1::__deque_base::value_type &const_reference;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static const std::__1::__deque_base::difference_type __block_size;
            typedef typename __rebind_alloc_helper<__alloc_traits, pointer>::type __pointer_allocator;
            typedef allocator_traits<std::__1::__deque_base::__pointer_allocator> __map_traits;
            typedef typename __map_traits::pointer __map_pointer;
            typedef typename __rebind_alloc_helper<__alloc_traits, const_pointer>::type __const_pointer_allocator;
            typedef typename allocator_traits<__const_pointer_allocator>::const_pointer __map_const_pointer;
            typedef __split_buffer<std::__1::__deque_base::pointer, std::__1::__deque_base::__pointer_allocator> __map;
            typedef __deque_iterator<std::__1::__deque_base::value_type, std::__1::__deque_base::pointer, std::__1::__deque_base::reference, std::__1::__deque_base::__map_pointer, std::__1::__deque_base::difference_type> iterator;
            typedef __deque_iterator<std::__1::__deque_base::value_type, std::__1::__deque_base::const_pointer, std::__1::__deque_base::const_reference, std::__1::__deque_base::__map_const_pointer, std::__1::__deque_base::difference_type> const_iterator;
            struct __deque_block_range {
                explicit __deque_block_range(std::__1::__deque_base::pointer __b, std::__1::__deque_base::pointer __e) throw() : __begin_(__b), __end_(__e)                 {
                }
                const std::__1::__deque_base::pointer __begin_;
                const std::__1::__deque_base::pointer __end_;
            };
            struct __deque_range {
                std::__1::__deque_base::iterator __pos_;
                const std::__1::__deque_base::iterator __end_;
                __deque_range(std::__1::__deque_base::iterator __pos, std::__1::__deque_base::iterator __e) throw() : __pos_(__pos), __end_(__e)                 {
                }
                explicit operator bool() const throw()                 {
                    return this->__pos_ != this->__end_;
                }
                std::__1::__deque_base::__deque_range begin() const                 {
                    return *this;
                }
                std::__1::__deque_base::__deque_range end() const                 {
                    return std::__1::__deque_base::__deque_range(this->__end_, this->__end_);
                }
                std::__1::__deque_base::__deque_block_range operator*() const throw()                 {
                    if (this->__pos_.__m_iter_ == this->__end_.__m_iter_) {
                        return std::__1::__deque_base::__deque_block_range(this->__pos_.__ptr_, this->__end_.__ptr_);
                    }
                    return std::__1::__deque_base::__deque_block_range(this->__pos_.__ptr_, *this->__pos_.__m_iter_ + __block_size);
                }
                std::__1::__deque_base::__deque_range &operator++() throw()                 {
                    if (this->__pos_.__m_iter_ == this->__end_.__m_iter_) {
                        this->__pos_ = this->__end_;
                    } else {
                        ++this->__pos_.__m_iter_;
                        this->__pos_.__ptr_ = *this->__pos_.__m_iter_;
                    }
                    return *this;
                }
                friend bool operator==(const std::__1::__deque_base::__deque_range &__lhs, const std::__1::__deque_base::__deque_range &__rhs)                 {
                    return __lhs.__pos_ == __rhs.__pos_;
                }
;
                friend bool operator!=(const std::__1::__deque_base::__deque_range &__lhs, const std::__1::__deque_base::__deque_range &__rhs)                 {
                    return !(__lhs == __rhs);
                }
;
            };
            struct _ConstructTransaction {
                _ConstructTransaction(__deque_base<_Tp, _Allocator> *__db, std::__1::__deque_base::__deque_block_range &__r) : __pos_(__r.__begin_), __end_(__r.__end_), __begin_(__r.__begin_), __base_(__db)                 {
                }
                ~_ConstructTransaction()                 {
                    this->__base_->size() += (this->__pos_ - this->__begin_);
                }
                std::__1::__deque_base::pointer __pos_;
                const std::__1::__deque_base::pointer __end_;
            private:
                const std::__1::__deque_base::pointer __begin_;
                __deque_base<_Tp, _Allocator> *const __base_;
            };
        protected:
            std::__1::__deque_base::__map __map_;
            std::__1::__deque_base::size_type __start_;
            __compressed_pair<std::__1::__deque_base::size_type, std::__1::__deque_base::allocator_type> __size_;
            std::__1::__deque_base::iterator begin() throw();
            std::__1::__deque_base::const_iterator begin() const throw();
            std::__1::__deque_base::iterator end() throw();
            std::__1::__deque_base::const_iterator end() const throw();
            std::__1::__deque_base::size_type &size() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__size_.first();
            }
            const std::__1::__deque_base::size_type &size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__size_.first();
            }
            std::__1::__deque_base::allocator_type &__alloc() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__size_.second();
            }
            const std::__1::__deque_base::allocator_type &__alloc() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__size_.second();
            }
            __deque_base<_Tp, _Allocator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit __deque_base<_Tp, _Allocator>(const std::__1::__deque_base::allocator_type &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        public:
            ~__deque_base<_Tp, _Allocator>();
            void swap(__deque_base<_Tp, _Allocator> &__c);
        protected:
            void clear() throw();
            bool __invariants() const;
            void __move_assign(__deque_base<_Tp, _Allocator> &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__map_ = std::__1::move(__c.__map_);
                this->__start_ = __c.__start_;
                size() = __c.size();
                __move_assign_alloc(__c);
                __c.__start_ = __c.size() = 0;
            }
            void __move_assign_alloc(__deque_base<_Tp, _Allocator> &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __move_assign_alloc(__c, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
            }
        private:
            void __move_assign_alloc(__deque_base<_Tp, _Allocator> &__c, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __alloc() = std::__1::move(__c.__alloc());
            }
            void __move_assign_alloc(__deque_base<_Tp, _Allocator> &, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
        const typename __deque_base<_Tp, _Allocator>::difference_type __block_size = __deque_block_size<value_type, difference_type>::value;
        template <class _Tp, class _Allocator> bool __deque_base<_Tp, _Allocator>::__invariants() const         {
            if (!this->__map_.__invariants())
                return false;
            if (this->__map_.size() >= std::__1::__deque_base::size_type(-1) / __block_size)
                return false;
            for (typename __map::const_iterator __i = this->__map_.begin(), __e = this->__map_.end(); __i != __e; ++__i)
                if (*__i == std::__1::__get_nullptr_t())
                    return false;
            if (this->__map_.size() != 0) {
                if (size() >= this->__map_.size() * __block_size)
                    return false;
                if (this->__start_ >= this->__map_.size() * __block_size - size())
                    return false;
            } else {
                if (size() != 0)
                    return false;
                if (this->__start_ != 0)
                    return false;
            }
            return true;
        }
        template <class _Tp, class _Allocator> typename __deque_base<_Tp, _Allocator>::iterator __deque_base<_Tp, _Allocator>::begin() throw()         {
            std::__1::__deque_base::__map_pointer __mp = this->__map_.begin() + this->__start_ / __block_size;
            return std::__1::__deque_base::iterator(__mp, this->__map_.empty() ? 0 : *__mp + this->__start_ % __block_size);
        }
        template <class _Tp, class _Allocator> typename __deque_base<_Tp, _Allocator>::const_iterator __deque_base<_Tp, _Allocator>::begin() const throw()         {
            std::__1::__deque_base::__map_const_pointer __mp = static_cast<std::__1::__deque_base::__map_const_pointer>(this->__map_.begin() + this->__start_ / __block_size);
            return std::__1::__deque_base::const_iterator(__mp, this->__map_.empty() ? 0 : *__mp + this->__start_ % __block_size);
        }
        template <class _Tp, class _Allocator> typename __deque_base<_Tp, _Allocator>::iterator __deque_base<_Tp, _Allocator>::end() throw()         {
            std::__1::__deque_base::size_type __p = size() + this->__start_;
            std::__1::__deque_base::__map_pointer __mp = this->__map_.begin() + __p / __block_size;
            return std::__1::__deque_base::iterator(__mp, this->__map_.empty() ? 0 : *__mp + __p % __block_size);
        }
        template <class _Tp, class _Allocator> typename __deque_base<_Tp, _Allocator>::const_iterator __deque_base<_Tp, _Allocator>::end() const throw()         {
            std::__1::__deque_base::size_type __p = size() + this->__start_;
            std::__1::__deque_base::__map_const_pointer __mp = static_cast<std::__1::__deque_base::__map_const_pointer>(this->__map_.begin() + __p / __block_size);
            return std::__1::__deque_base::const_iterator(__mp, this->__map_.empty() ? 0 : *__mp + __p % __block_size);
        }
        template <class _Tp, class _Allocator> inline __deque_base<_Tp, _Allocator>::__deque_base<_Tp, _Allocator>() : __start_(0), __size_(0, std::__1::__default_init_tag())         {
        }
        template <class _Tp, class _Allocator> inline explicit __deque_base<_Tp, _Allocator>::__deque_base<_Tp, _Allocator>(const std::__1::__deque_base::allocator_type &__a) : __map_(std::__1::__deque_base::__pointer_allocator(__a)), __start_(0), __size_(0, __a)         {
        }
        template <class _Tp, class _Allocator> __deque_base<_Tp, _Allocator>::~__deque_base<_Tp, _Allocator>()         {
            this->clear();
            typename __map::iterator __i = this->__map_.begin();
            typename __map::iterator __e = this->__map_.end();
            for (; __i != __e; ++__i)
                __alloc_traits::deallocate(__alloc(), *__i, __block_size);
        }
        template <class _Tp, class _Allocator> void __deque_base<_Tp, _Allocator>::swap(__deque_base<_Tp, _Allocator> &__c)         {
            this->__map_.swap(__c.__map_);
            std::__1::swap(this->__start_, __c.__start_);
            std::__1::swap(size(), __c.size());
            __swap_allocator(__alloc(), __c.__alloc());
        }
        template <class _Tp, class _Allocator> void __deque_base<_Tp, _Allocator>::clear() throw()         {
            std::__1::__deque_base::allocator_type &__a = __alloc();
            for (std::__1::__deque_base::iterator __i = begin(), __e = end(); __i != __e; ++__i)
                __alloc_traits::destroy(__a, std::__1::addressof(*__i));
            size() = 0;
            while (this->__map_.size() > 2)
                {
                    __alloc_traits::deallocate(__a, this->__map_.front(), __block_size);
                    this->__map_.pop_front();
                }
            switch (this->__map_.size()) {
              case 1:
                this->__start_ = __block_size / 2;
                break;
              case 2:
                this->__start_ = __block_size;
                break;
            }
        }
        template <class _Tp, class _Allocator = allocator<_Tp>> class __attribute__((type_visibility("default"))) deque : private __deque_base<_Tp, _Allocator> {
        public:
            typedef _Tp value_type;
            typedef _Allocator allocator_type;
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __deque_base<std::__1::deque::value_type, std::__1::deque::allocator_type> __base;
            typedef typename __base::__alloc_traits __alloc_traits;
            typedef typename __base::reference reference;
            typedef typename __base::const_reference const_reference;
            typedef typename __base::iterator iterator;
            typedef typename __base::const_iterator const_iterator;
            typedef typename __base::size_type size_type;
            typedef typename __base::difference_type difference_type;
            typedef typename __base::pointer pointer;
            typedef typename __base::const_pointer const_pointer;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            using typename __base::__deque_range;
            using typename __base::__deque_block_range;
            using typename __base::_ConstructTransaction;
            deque<_Tp, _Allocator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit deque<_Tp, _Allocator>(const std::__1::deque::allocator_type &__a) : std::__1::deque::__base(__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit deque<_Tp, _Allocator>(std::__1::deque::size_type __n);
            deque<_Tp, _Allocator>(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v);
            deque<_Tp, _Allocator>(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v, const std::__1::deque::allocator_type &__a);
            template <class _InputIter> deque<_Tp, _Allocator>(_InputIter __f, _InputIter __l, typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type * = 0);
            template <class _InputIter> deque<_Tp, _Allocator>(_InputIter __f, _InputIter __l, const std::__1::deque::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type * = 0);
            deque<_Tp, _Allocator>(const deque<_Tp, _Allocator> &__c);
            deque<_Tp, _Allocator>(const deque<_Tp, _Allocator> &__c, const std::__1::deque::allocator_type &__a);
            deque<_Tp, _Allocator> &operator=(const deque<_Tp, _Allocator> &__c);
            template <class _InputIter> void assign(_InputIter __f, _InputIter __l, typename enable_if<__is_cpp17_input_iterator<_InputIter>::value && !__is_cpp17_random_access_iterator<_InputIter>::value>::type * = 0);
            template <class _RAIter> void assign(_RAIter __f, _RAIter __l, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0);
            void assign(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v);
            std::__1::deque::allocator_type get_allocator() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::deque::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::begin();
            }
            std::__1::deque::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::begin();
            }
            std::__1::deque::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::end();
            }
            std::__1::deque::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::end();
            }
            std::__1::deque::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::deque::reverse_iterator(__base::end());
            }
            std::__1::deque::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::deque::const_reverse_iterator(__base::end());
            }
            std::__1::deque::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::deque::reverse_iterator(__base::begin());
            }
            std::__1::deque::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::deque::const_reverse_iterator(__base::begin());
            }
            std::__1::deque::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::begin();
            }
            std::__1::deque::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::end();
            }
            std::__1::deque::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::deque::const_reverse_iterator(__base::end());
            }
            std::__1::deque::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::deque::const_reverse_iterator(__base::begin());
            }
            std::__1::deque::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::size();
            }
            std::__1::deque::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::min<std::__1::deque::size_type>(__alloc_traits::max_size(__base::__alloc()), numeric_limits<difference_type>::max());
            }
            void resize(std::__1::deque::size_type __n);
            void resize(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v);
            void shrink_to_fit() throw();
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::size() == 0;
            }
            std::__1::deque::reference operator[](std::__1::deque::size_type __i) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::deque::const_reference operator[](std::__1::deque::size_type __i) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::deque::reference at(std::__1::deque::size_type __i) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::deque::const_reference at(std::__1::deque::size_type __i) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::deque::reference front() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::deque::const_reference front() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::deque::reference back() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::deque::const_reference back() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void push_front(const std::__1::deque::value_type &__v);
            void push_back(const std::__1::deque::value_type &__v);
            std::__1::deque::iterator insert(std::__1::deque::const_iterator __p, const std::__1::deque::value_type &__v);
            std::__1::deque::iterator insert(std::__1::deque::const_iterator __p, std::__1::deque::size_type __n, const std::__1::deque::value_type &__v);
            template <class _InputIter> std::__1::deque::iterator insert(std::__1::deque::const_iterator __p, _InputIter __f, _InputIter __l, typename enable_if<__is_cpp17_input_iterator<_InputIter>::value && !__is_cpp17_forward_iterator<_InputIter>::value>::type * = 0);
            template <class _ForwardIterator> std::__1::deque::iterator insert(std::__1::deque::const_iterator __p, _ForwardIterator __f, _ForwardIterator __l, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && !__is_cpp17_bidirectional_iterator<_ForwardIterator>::value>::type * = 0);
            template <class _BiIter> std::__1::deque::iterator insert(std::__1::deque::const_iterator __p, _BiIter __f, _BiIter __l, typename enable_if<__is_cpp17_bidirectional_iterator<_BiIter>::value>::type * = 0);
            void pop_front();
            void pop_back();
            std::__1::deque::iterator erase(std::__1::deque::const_iterator __p);
            std::__1::deque::iterator erase(std::__1::deque::const_iterator __f, std::__1::deque::const_iterator __l);
            void swap(deque<_Tp, _Allocator> &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool __invariants() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::__invariants();
            }
            typedef typename __base::__map_const_pointer __map_const_pointer;
            static std::__1::deque::size_type __recommend_blocks(std::__1::deque::size_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __n / __base::__block_size + (__n % __base::__block_size != 0);
            }
            std::__1::deque::size_type __capacity() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::__map_.size() == 0 ? 0 : __base::__map_.size() * __base::__block_size - 1;
            }
            std::__1::deque::size_type __block_count() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::__map_.size();
            }
            std::__1::deque::size_type __front_spare() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __base::__start_;
            }
            std::__1::deque::size_type __front_spare_blocks() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__front_spare() / __base::__block_size;
            }
            std::__1::deque::size_type __back_spare() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__capacity() - (__base::__start_ + __base::size());
            }
            std::__1::deque::size_type __back_spare_blocks() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__back_spare() / __base::__block_size;
            }
        private:
            bool __maybe_remove_front_spare(bool __keep_one = true) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__front_spare_blocks() >= 2 || (!__keep_one && this->__front_spare_blocks())) {
                    __alloc_traits::deallocate(__base::__alloc(), __base::__map_.front(), __base::__block_size);
                    __base::__map_.pop_front();
                    __base::__start_ -= __base::__block_size;
                    return true;
                }
                return false;
            }
            bool __maybe_remove_back_spare(bool __keep_one = true) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__back_spare_blocks() >= 2 || (!__keep_one && this->__back_spare_blocks())) {
                    __alloc_traits::deallocate(__base::__alloc(), __base::__map_.back(), __base::__block_size);
                    __base::__map_.pop_back();
                    return true;
                }
                return false;
            }
            template <class _InpIter> void __append(_InpIter __f, _InpIter __l, typename enable_if<__is_cpp17_input_iterator<_InpIter>::value && !__is_cpp17_forward_iterator<_InpIter>::value>::type * = 0);
            template <class _ForIter> void __append(_ForIter __f, _ForIter __l, typename enable_if<__is_cpp17_forward_iterator<_ForIter>::value>::type * = 0);
            void __append(std::__1::deque::size_type __n);
            void __append(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v);
            void __erase_to_end(std::__1::deque::const_iterator __f);
            void __add_front_capacity();
            void __add_front_capacity(std::__1::deque::size_type __n);
            void __add_back_capacity();
            void __add_back_capacity(std::__1::deque::size_type __n);
            std::__1::deque::iterator __move_and_check(std::__1::deque::iterator __f, std::__1::deque::iterator __l, std::__1::deque::iterator __r, std::__1::deque::const_pointer &__vt);
            std::__1::deque::iterator __move_backward_and_check(std::__1::deque::iterator __f, std::__1::deque::iterator __l, std::__1::deque::iterator __r, std::__1::deque::const_pointer &__vt);
            void __move_construct_and_check(std::__1::deque::iterator __f, std::__1::deque::iterator __l, std::__1::deque::iterator __r, std::__1::deque::const_pointer &__vt);
            void __move_construct_backward_and_check(std::__1::deque::iterator __f, std::__1::deque::iterator __l, std::__1::deque::iterator __r, std::__1::deque::const_pointer &__vt);
            void __copy_assign_alloc(const deque<_Tp, _Allocator> &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __copy_assign_alloc(__c, integral_constant<bool, __alloc_traits::propagate_on_container_copy_assignment::value>());
            }
            void __copy_assign_alloc(const deque<_Tp, _Allocator> &__c, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__base::__alloc() != __c.__alloc()) {
                    this->clear();
                    this->shrink_to_fit();
                }
                __base::__alloc() = __c.__alloc();
                __base::__map_.__alloc() = __c.__map_.__alloc();
            }
            void __copy_assign_alloc(const deque<_Tp, _Allocator> &, std::__1::false_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __move_assign(deque<_Tp, _Allocator> &__c, std::__1::true_type);
            void __move_assign(deque<_Tp, _Allocator> &__c, std::__1::false_type);
        };
        template <class _Tp, class _Allocator> explicit deque<_Tp, _Allocator>::deque<_Tp, _Allocator>(std::__1::deque::size_type __n)         {
            if (__n > 0)
                __append(__n);
        }
        template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque<_Tp, _Allocator>(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v)         {
            if (__n > 0)
                __append(__n, __v);
        }
        template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque<_Tp, _Allocator>(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v, const std::__1::deque::allocator_type &__a) : std::__1::deque::__base(__a)         {
            if (__n > 0)
                __append(__n, __v);
        }
        template <class _Tp, class _Allocator> template <class _InputIter> deque<_Tp, _Allocator>::deque<_Tp, _Allocator>(_InputIter __f, _InputIter __l, typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type * = 0)         {
            __append(__f, __l);
        }
        template <class _Tp, class _Allocator> template <class _InputIter> deque<_Tp, _Allocator>::deque<_Tp, _Allocator>(_InputIter __f, _InputIter __l, const std::__1::deque::allocator_type &__a, typename enable_if<__is_cpp17_input_iterator<_InputIter>::value>::type * = 0) : std::__1::deque::__base(__a)         {
            __append(__f, __l);
        }
        template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque<_Tp, _Allocator>(const deque<_Tp, _Allocator> &__c) : std::__1::deque::__base(__alloc_traits::select_on_container_copy_construction(__c.__alloc()))         {
            __append(__c.begin(), __c.end());
        }
        template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque<_Tp, _Allocator>(const deque<_Tp, _Allocator> &__c, const std::__1::deque::allocator_type &__a) : std::__1::deque::__base(__a)         {
            __append(__c.begin(), __c.end());
        }
        template <class _Tp, class _Allocator> deque<_Tp, _Allocator> &deque<_Tp, _Allocator>::operator=(const deque<_Tp, _Allocator> &__c)         {
            if (this != &__c) {
                __copy_assign_alloc(__c);
                assign(__c.begin(), __c.end());
            }
            return *this;
        }
        template <class _Tp, class _Allocator> template <class _InputIter> void deque<_Tp, _Allocator>::assign(_InputIter __f, _InputIter __l, typename enable_if<__is_cpp17_input_iterator<_InputIter>::value && !__is_cpp17_random_access_iterator<_InputIter>::value>::type * = 0)         {
            std::__1::deque::iterator __i = __base::begin();
            std::__1::deque::iterator __e = __base::end();
            for (; __f != __l && __i != __e; ++__f , (void)++__i)
                *__i = *__f;
            if (__f != __l)
                __append(__f, __l);
            else
                this->__erase_to_end(__i);
        }
        template <class _Tp, class _Allocator> template <class _RAIter> void deque<_Tp, _Allocator>::assign(_RAIter __f, _RAIter __l, typename enable_if<__is_cpp17_random_access_iterator<_RAIter>::value>::type * = 0)         {
            if (static_cast<std::__1::deque::size_type>(__l - __f) > __base::size()) {
                _RAIter __m = __f + __base::size();
                std::__1::copy(__f, __m, __base::begin());
                __append(__m, __l);
            } else
                this->__erase_to_end(std::__1::copy(__f, __l, __base::begin()));
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::assign(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v)         {
            if (__n > __base::size()) {
                std::__1::fill_n(__base::begin(), __base::size(), __v);
                __n -= __base::size();
                __append(__n, __v);
            } else
                this->__erase_to_end(std::__1::fill_n(__base::begin(), __n, __v));
        }
        template <class _Tp, class _Allocator> inline _Allocator deque<_Tp, _Allocator>::get_allocator() const throw()         {
            return __base::__alloc();
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::resize(std::__1::deque::size_type __n)         {
            if (__n > __base::size())
                __append(__n - __base::size());
            else if (__n < __base::size())
                this->__erase_to_end(__base::begin() + __n);
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::resize(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v)         {
            if (__n > __base::size())
                __append(__n - __base::size(), __v);
            else if (__n < __base::size())
                this->__erase_to_end(__base::begin() + __n);
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::shrink_to_fit() throw()         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            if (this->empty()) {
                while (__base::__map_.size() > 0)
                    {
                        __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
                        __base::__map_.pop_back();
                    }
                __base::__start_ = 0;
            } else {
                this->__maybe_remove_front_spare(false);
                this->__maybe_remove_back_spare(false);
            }
            __base::__map_.shrink_to_fit();
        }
        template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::operator[](std::__1::deque::size_type __i) throw()         {
            std::__1::deque::size_type __p = __base::__start_ + __i;
            return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
        }
        template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::operator[](std::__1::deque::size_type __i) const throw()         {
            std::__1::deque::size_type __p = __base::__start_ + __i;
            return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
        }
        template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::at(std::__1::deque::size_type __i)         {
            if (__i >= __base::size())
                __base::__throw_out_of_range();
            std::__1::deque::size_type __p = __base::__start_ + __i;
            return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
        }
        template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::at(std::__1::deque::size_type __i) const         {
            if (__i >= __base::size())
                __base::__throw_out_of_range();
            std::__1::deque::size_type __p = __base::__start_ + __i;
            return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
        }
        template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::front() throw()         {
            return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size) + __base::__start_ % __base::__block_size);
        }
        template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::front() const throw()         {
            return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size) + __base::__start_ % __base::__block_size);
        }
        template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::back() throw()         {
            std::__1::deque::size_type __p = __base::size() + __base::__start_ - 1;
            return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
        }
        template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::back() const throw()         {
            std::__1::deque::size_type __p = __base::size() + __base::__start_ - 1;
            return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::push_back(const std::__1::deque::value_type &__v)         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            if (this->__back_spare() == 0)
                __add_back_capacity();
            __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
            ++__base::size();
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::push_front(const std::__1::deque::value_type &__v)         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            if (this->__front_spare() == 0)
                __add_front_capacity();
            __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
            --__base::__start_;
            ++__base::size();
        }
        template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(std::__1::deque::const_iterator __p, const std::__1::deque::value_type &__v)         {
            std::__1::deque::size_type __pos = __p - __base::begin();
            std::__1::deque::size_type __to_end = __base::size() - __pos;
            std::__1::deque::allocator_type &__a = __base::__alloc();
            if (__pos < __to_end) {
                if (this->__front_spare() == 0)
                    __add_front_capacity();
                if (__pos == 0) {
                    __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
                    --__base::__start_;
                    ++__base::size();
                } else {
                    std::__1::deque::const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
                    std::__1::deque::iterator __b = __base::begin();
                    std::__1::deque::iterator __bm1 = std::__1::prev(__b);
                    if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))
                        __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);
                    __alloc_traits::construct(__a, std::__1::addressof(*__bm1), std::__1::move(*__b));
                    --__base::__start_;
                    ++__base::size();
                    if (__pos > 1)
                        __b = this->__move_and_check(std::__1::next(__b), __b + __pos, __b, __vt);
                    *__b = *__vt;
                }
            } else {
                if (this->__back_spare() == 0)
                    __add_back_capacity();
                std::__1::deque::size_type __de = __base::size() - __pos;
                if (__de == 0) {
                    __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
                    ++__base::size();
                } else {
                    std::__1::deque::const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
                    std::__1::deque::iterator __e = __base::end();
                    std::__1::deque::iterator __em1 = std::__1::prev(__e);
                    if (__vt == pointer_traits<const_pointer>::pointer_to(*__em1))
                        __vt = pointer_traits<const_pointer>::pointer_to(*__e);
                    __alloc_traits::construct(__a, std::__1::addressof(*__e), std::__1::move(*__em1));
                    ++__base::size();
                    if (__de > 1)
                        __e = this->__move_backward_and_check(__e - __de, __em1, __e, __vt);
                    *--__e = *__vt;
                }
            }
            return __base::begin() + __pos;
        }
        template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(std::__1::deque::const_iterator __p, std::__1::deque::size_type __n, const std::__1::deque::value_type &__v)         {
            std::__1::deque::size_type __pos = __p - __base::begin();
            std::__1::deque::size_type __to_end = __base::size() - __pos;
            std::__1::deque::allocator_type &__a = __base::__alloc();
            if (__pos < __to_end) {
                if (__n > this->__front_spare())
                    __add_front_capacity(__n - this->__front_spare());
                std::__1::deque::iterator __old_begin = __base::begin();
                std::__1::deque::iterator __i = __old_begin;
                if (__n > __pos) {
                    for (std::__1::deque::size_type __m = __n - __pos; __m; --__m , --__base::__start_ , ++__base::size())
                        __alloc_traits::construct(__a, std::__1::addressof(*--__i), __v);
                    __n = __pos;
                }
                if (__n > 0) {
                    std::__1::deque::const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
                    std::__1::deque::iterator __obn = __old_begin + __n;
                    this->__move_construct_backward_and_check(__old_begin, __obn, __i, __vt);
                    if (__n < __pos)
                        __old_begin = this->__move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);
                    std::__1::fill_n(__old_begin, __n, *__vt);
                }
            } else {
                std::__1::deque::size_type __back_capacity = this->__back_spare();
                if (__n > __back_capacity)
                    __add_back_capacity(__n - __back_capacity);
                std::__1::deque::iterator __old_end = __base::end();
                std::__1::deque::iterator __i = __old_end;
                std::__1::deque::size_type __de = __base::size() - __pos;
                if (__n > __de) {
                    for (std::__1::deque::size_type __m = __n - __de; __m; --__m , ++__i , ++__base::size())
                        __alloc_traits::construct(__a, std::__1::addressof(*__i), __v);
                    __n = __de;
                }
                if (__n > 0) {
                    std::__1::deque::const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
                    std::__1::deque::iterator __oen = __old_end - __n;
                    this->__move_construct_and_check(__oen, __old_end, __i, __vt);
                    if (__n < __de)
                        __old_end = this->__move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);
                    std::__1::fill_n(__old_end - __n, __n, *__vt);
                }
            }
            return __base::begin() + __pos;
        }
        template <class _Tp, class _Allocator> template <class _InputIter> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(std::__1::deque::const_iterator __p, _InputIter __f, _InputIter __l, typename enable_if<__is_cpp17_input_iterator<_InputIter>::value && !__is_cpp17_forward_iterator<_InputIter>::value>::type * = 0)         {
            __split_buffer<std::__1::deque::value_type, std::__1::deque::allocator_type &> __buf(__base::__alloc());
            __buf.__construct_at_end(__f, __l);
            typedef typename __split_buffer<value_type, allocator_type &>::iterator __bi;
            return insert(__p, move_iterator<__bi>(__buf.begin()), move_iterator<__bi>(__buf.end()));
        }
        template <class _Tp, class _Allocator> template <class _ForwardIterator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(std::__1::deque::const_iterator __p, _ForwardIterator __f, _ForwardIterator __l, typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && !__is_cpp17_bidirectional_iterator<_ForwardIterator>::value>::type * = 0)         {
            std::__1::deque::size_type __n = std::__1::distance(__f, __l);
            __split_buffer<std::__1::deque::value_type, std::__1::deque::allocator_type &> __buf(__n, 0, __base::__alloc());
            __buf.__construct_at_end(__f, __l);
            typedef typename __split_buffer<value_type, allocator_type &>::iterator __fwd;
            return insert(__p, move_iterator<__fwd>(__buf.begin()), move_iterator<__fwd>(__buf.end()));
        }
        template <class _Tp, class _Allocator> template <class _BiIter> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(std::__1::deque::const_iterator __p, _BiIter __f, _BiIter __l, typename enable_if<__is_cpp17_bidirectional_iterator<_BiIter>::value>::type * = 0)         {
            std::__1::deque::size_type __n = std::__1::distance(__f, __l);
            std::__1::deque::size_type __pos = __p - __base::begin();
            std::__1::deque::size_type __to_end = __base::size() - __pos;
            std::__1::deque::allocator_type &__a = __base::__alloc();
            if (__pos < __to_end) {
                if (__n > this->__front_spare())
                    __add_front_capacity(__n - this->__front_spare());
                std::__1::deque::iterator __old_begin = __base::begin();
                std::__1::deque::iterator __i = __old_begin;
                _BiIter __m = __f;
                if (__n > __pos) {
                    __m = __pos < __n / 2 ? std::__1::prev(__l, __pos) : std::__1::next(__f, __n - __pos);
                    for (_BiIter __j = __m; __j != __f; --__base::__start_ , ++__base::size())
                        __alloc_traits::construct(__a, std::__1::addressof(*--__i), *--__j);
                    __n = __pos;
                }
                if (__n > 0) {
                    std::__1::deque::iterator __obn = __old_begin + __n;
                    for (std::__1::deque::iterator __j = __obn; __j != __old_begin;) {
                        __alloc_traits::construct(__a, std::__1::addressof(*--__i), std::__1::move(*--__j));
                        --__base::__start_;
                        ++__base::size();
                    }
                    if (__n < __pos)
                        __old_begin = std::__1::move(__obn, __old_begin + __pos, __old_begin);
                    std::__1::copy(__m, __l, __old_begin);
                }
            } else {
                std::__1::deque::size_type __back_capacity = this->__back_spare();
                if (__n > __back_capacity)
                    __add_back_capacity(__n - __back_capacity);
                std::__1::deque::iterator __old_end = __base::end();
                std::__1::deque::iterator __i = __old_end;
                _BiIter __m = __l;
                std::__1::deque::size_type __de = __base::size() - __pos;
                if (__n > __de) {
                    __m = __de < __n / 2 ? std::__1::next(__f, __de) : std::__1::prev(__l, __n - __de);
                    for (_BiIter __j = __m; __j != __l; ++__i , (void)++__j , ++__base::size())
                        __alloc_traits::construct(__a, std::__1::addressof(*__i), *__j);
                    __n = __de;
                }
                if (__n > 0) {
                    std::__1::deque::iterator __oen = __old_end - __n;
                    for (std::__1::deque::iterator __j = __oen; __j != __old_end; ++__i , ++__j , ++__base::size())
                        __alloc_traits::construct(__a, std::__1::addressof(*__i), std::__1::move(*__j));
                    if (__n < __de)
                        __old_end = std::__1::move_backward(__old_end - __de, __oen, __old_end);
                    std::__1::copy_backward(__f, __m, __old_end);
                }
            }
            return __base::begin() + __pos;
        }
        template <class _Tp, class _Allocator> template <class _InpIter> void deque<_Tp, _Allocator>::__append(_InpIter __f, _InpIter __l, typename enable_if<__is_cpp17_input_iterator<_InpIter>::value && !__is_cpp17_forward_iterator<_InpIter>::value>::type * = 0)         {
            for (; __f != __l; ++__f)
                this->push_back(*__f);
        }
        template <class _Tp, class _Allocator> template <class _ForIter> void deque<_Tp, _Allocator>::__append(_ForIter __f, _ForIter __l, typename enable_if<__is_cpp17_forward_iterator<_ForIter>::value>::type * = 0)         {
            std::__1::deque::size_type __n = std::__1::distance(__f, __l);
            std::__1::deque::allocator_type &__a = __base::__alloc();
            std::__1::deque::size_type __back_capacity = this->__back_spare();
            if (__n > __back_capacity)
                __add_back_capacity(__n - __back_capacity);
            for (std::__1::deque::__deque_block_range __br : std::__1::deque::__deque_range(__base::end(), __base::end() + __n)) {
                std::__1::deque::_ConstructTransaction __tx(this, __br);
                for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_ , (void)++__f) {
                    __alloc_traits::construct(__a, std::__to_address(__tx.__pos_), *__f);
                }
            }
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__append(std::__1::deque::size_type __n)         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            std::__1::deque::size_type __back_capacity = this->__back_spare();
            if (__n > __back_capacity)
                __add_back_capacity(__n - __back_capacity);
            for (std::__1::deque::__deque_block_range __br : std::__1::deque::__deque_range(__base::end(), __base::end() + __n)) {
                std::__1::deque::_ConstructTransaction __tx(this, __br);
                for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
                    __alloc_traits::construct(__a, std::__to_address(__tx.__pos_));
                }
            }
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__append(std::__1::deque::size_type __n, const std::__1::deque::value_type &__v)         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            std::__1::deque::size_type __back_capacity = this->__back_spare();
            if (__n > __back_capacity)
                __add_back_capacity(__n - __back_capacity);
            for (std::__1::deque::__deque_block_range __br : std::__1::deque::__deque_range(__base::end(), __base::end() + __n)) {
                std::__1::deque::_ConstructTransaction __tx(this, __br);
                for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
                    __alloc_traits::construct(__a, std::__to_address(__tx.__pos_), __v);
                }
            }
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__add_front_capacity()         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            if (this->__back_spare() >= __base::__block_size) {
                __base::__start_ += __base::__block_size;
                std::__1::deque::pointer __pt = __base::__map_.back();
                __base::__map_.pop_back();
                __base::__map_.push_front(__pt);
            } else if (__base::__map_.size() < __base::__map_.capacity()) {
                if (__base::__map_.__front_spare() > 0)
                    __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
                else {
                    __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
                    std::__1::deque::pointer __pt = __base::__map_.back();
                    __base::__map_.pop_back();
                    __base::__map_.push_front(__pt);
                }
                __base::__start_ = __base::__map_.size() == 1 ? __base::__block_size / 2 : __base::__start_ + __base::__block_size;
            } else {
                __split_buffer<std::__1::deque::pointer, typename __base::__pointer_allocator &> __buf(max<std::__1::deque::size_type>(2 * __base::__map_.capacity(), 1), 0, __base::__map_.__alloc());
                typedef __allocator_destructor<_Allocator> _Dp;
                unique_ptr<std::__1::deque::pointer, _Dp> __hold(__alloc_traits::allocate(__a, __base::__block_size), _Dp(__a, __base::__block_size));
                __buf.push_back(__hold.get());
                __hold.release();
                for (typename __base::__map_pointer __i = __base::__map_.begin(); __i != __base::__map_.end(); ++__i)
                    __buf.push_back(*__i);
                std::__1::swap(__base::__map_.__first_, __buf.__first_);
                std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
                std::__1::swap(__base::__map_.__end_, __buf.__end_);
                std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
                __base::__start_ = __base::__map_.size() == 1 ? __base::__block_size / 2 : __base::__start_ + __base::__block_size;
            }
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__add_front_capacity(std::__1::deque::size_type __n)         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            std::__1::deque::size_type __nb = __recommend_blocks(__n + __base::__map_.empty());
            std::__1::deque::size_type __back_capacity = this->__back_spare() / __base::__block_size;
            __back_capacity = std::__1::min(__back_capacity, __nb);
            __nb -= __back_capacity;
            if (__nb == 0) {
                __base::__start_ += __base::__block_size * __back_capacity;
                for (; __back_capacity > 0; --__back_capacity) {
                    std::__1::deque::pointer __pt = __base::__map_.back();
                    __base::__map_.pop_back();
                    __base::__map_.push_front(__pt);
                }
            } else if (__nb <= __base::__map_.capacity() - __base::__map_.size()) {
                for (; __nb > 0; --__nb , __base::__start_ += __base::__block_size - (__base::__map_.size() == 1)) {
                    if (__base::__map_.__front_spare() == 0)
                        break;
                    __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
                }
                for (; __nb > 0; --__nb , ++__back_capacity)
                    __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
                __base::__start_ += __back_capacity * __base::__block_size;
                for (; __back_capacity > 0; --__back_capacity) {
                    std::__1::deque::pointer __pt = __base::__map_.back();
                    __base::__map_.pop_back();
                    __base::__map_.push_front(__pt);
                }
            } else {
                std::__1::deque::size_type __ds = (__nb + __back_capacity) * __base::__block_size - __base::__map_.empty();
                __split_buffer<std::__1::deque::pointer, typename __base::__pointer_allocator &> __buf(max<std::__1::deque::size_type>(2 * __base::__map_.capacity(), __nb + __base::__map_.size()), 0, __base::__map_.__alloc());
                try {
                    for (; __nb > 0; --__nb)
                        __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
                } catch (...) {
                    for (typename __base::__map_pointer __i = __buf.begin(); __i != __buf.end(); ++__i)
                        __alloc_traits::deallocate(__a, *__i, __base::__block_size);
                    throw;
                }
                for (; __back_capacity > 0; --__back_capacity) {
                    __buf.push_back(__base::__map_.back());
                    __base::__map_.pop_back();
                }
                for (typename __base::__map_pointer __i = __base::__map_.begin(); __i != __base::__map_.end(); ++__i)
                    __buf.push_back(*__i);
                std::__1::swap(__base::__map_.__first_, __buf.__first_);
                std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
                std::__1::swap(__base::__map_.__end_, __buf.__end_);
                std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
                __base::__start_ += __ds;
            }
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__add_back_capacity()         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            if (this->__front_spare() >= __base::__block_size) {
                __base::__start_ -= __base::__block_size;
                std::__1::deque::pointer __pt = __base::__map_.front();
                __base::__map_.pop_front();
                __base::__map_.push_back(__pt);
            } else if (__base::__map_.size() < __base::__map_.capacity()) {
                if (__base::__map_.__back_spare() != 0)
                    __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
                else {
                    __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
                    std::__1::deque::pointer __pt = __base::__map_.front();
                    __base::__map_.pop_front();
                    __base::__map_.push_back(__pt);
                }
            } else {
                __split_buffer<std::__1::deque::pointer, typename __base::__pointer_allocator &> __buf(max<std::__1::deque::size_type>(2 * __base::__map_.capacity(), 1), __base::__map_.size(), __base::__map_.__alloc());
                typedef __allocator_destructor<_Allocator> _Dp;
                unique_ptr<std::__1::deque::pointer, _Dp> __hold(__alloc_traits::allocate(__a, __base::__block_size), _Dp(__a, __base::__block_size));
                __buf.push_back(__hold.get());
                __hold.release();
                for (typename __base::__map_pointer __i = __base::__map_.end(); __i != __base::__map_.begin();)
                    __buf.push_front(*--__i);
                std::__1::swap(__base::__map_.__first_, __buf.__first_);
                std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
                std::__1::swap(__base::__map_.__end_, __buf.__end_);
                std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
            }
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__add_back_capacity(std::__1::deque::size_type __n)         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            std::__1::deque::size_type __nb = __recommend_blocks(__n + __base::__map_.empty());
            std::__1::deque::size_type __front_capacity = this->__front_spare() / __base::__block_size;
            __front_capacity = std::__1::min(__front_capacity, __nb);
            __nb -= __front_capacity;
            if (__nb == 0) {
                __base::__start_ -= __base::__block_size * __front_capacity;
                for (; __front_capacity > 0; --__front_capacity) {
                    std::__1::deque::pointer __pt = __base::__map_.front();
                    __base::__map_.pop_front();
                    __base::__map_.push_back(__pt);
                }
            } else if (__nb <= __base::__map_.capacity() - __base::__map_.size()) {
                for (; __nb > 0; --__nb) {
                    if (__base::__map_.__back_spare() == 0)
                        break;
                    __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
                }
                for (; __nb > 0; --__nb , ++__front_capacity , __base::__start_ += __base::__block_size - (__base::__map_.size() == 1))
                    __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
                __base::__start_ -= __base::__block_size * __front_capacity;
                for (; __front_capacity > 0; --__front_capacity) {
                    std::__1::deque::pointer __pt = __base::__map_.front();
                    __base::__map_.pop_front();
                    __base::__map_.push_back(__pt);
                }
            } else {
                std::__1::deque::size_type __ds = __front_capacity * __base::__block_size;
                __split_buffer<std::__1::deque::pointer, typename __base::__pointer_allocator &> __buf(max<std::__1::deque::size_type>(2 * __base::__map_.capacity(), __nb + __base::__map_.size()), __base::__map_.size() - __front_capacity, __base::__map_.__alloc());
                try {
                    for (; __nb > 0; --__nb)
                        __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
                } catch (...) {
                    for (typename __base::__map_pointer __i = __buf.begin(); __i != __buf.end(); ++__i)
                        __alloc_traits::deallocate(__a, *__i, __base::__block_size);
                    throw;
                }
                for (; __front_capacity > 0; --__front_capacity) {
                    __buf.push_back(__base::__map_.front());
                    __base::__map_.pop_front();
                }
                for (typename __base::__map_pointer __i = __base::__map_.end(); __i != __base::__map_.begin();)
                    __buf.push_front(*--__i);
                std::__1::swap(__base::__map_.__first_, __buf.__first_);
                std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
                std::__1::swap(__base::__map_.__end_, __buf.__end_);
                std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
                __base::__start_ -= __ds;
            }
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::pop_front()         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            __alloc_traits::destroy(__a, __to_address(*(__base::__map_.begin() + __base::__start_ / __base::__block_size) + __base::__start_ % __base::__block_size));
            --__base::size();
            ++__base::__start_;
            this->__maybe_remove_front_spare();
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::pop_back()         {
            ((void)0);
            std::__1::deque::allocator_type &__a = __base::__alloc();
            std::__1::deque::size_type __p = __base::size() + __base::__start_ - 1;
            __alloc_traits::destroy(__a, __to_address(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size));
            --__base::size();
            this->__maybe_remove_back_spare();
        }
        template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::__move_and_check(std::__1::deque::iterator __f, std::__1::deque::iterator __l, std::__1::deque::iterator __r, std::__1::deque::const_pointer &__vt)         {
            std::__1::deque::difference_type __n = __l - __f;
            while (__n > 0)
                {
                    std::__1::deque::pointer __fb = __f.__ptr_;
                    std::__1::deque::pointer __fe = *__f.__m_iter_ + __base::__block_size;
                    std::__1::deque::difference_type __bs = __fe - __fb;
                    if (__bs > __n) {
                        __bs = __n;
                        __fe = __fb + __bs;
                    }
                    if (__fb <= __vt && __vt < __fe)
                        __vt = (std::__1::deque::const_iterator(static_cast<std::__1::deque::__map_const_pointer>(__f.__m_iter_), __vt) -= __f - __r).__ptr_;
                    __r = std::__1::move(__fb, __fe, __r);
                    __n -= __bs;
                    __f += __bs;
                }
            return __r;
        }
        template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::__move_backward_and_check(std::__1::deque::iterator __f, std::__1::deque::iterator __l, std::__1::deque::iterator __r, std::__1::deque::const_pointer &__vt)         {
            std::__1::deque::difference_type __n = __l - __f;
            while (__n > 0)
                {
                    --__l;
                    std::__1::deque::pointer __lb = *__l.__m_iter_;
                    std::__1::deque::pointer __le = __l.__ptr_ + 1;
                    std::__1::deque::difference_type __bs = __le - __lb;
                    if (__bs > __n) {
                        __bs = __n;
                        __lb = __le - __bs;
                    }
                    if (__lb <= __vt && __vt < __le)
                        __vt = (std::__1::deque::const_iterator(static_cast<std::__1::deque::__map_const_pointer>(__l.__m_iter_), __vt) += __r - __l - 1).__ptr_;
                    __r = std::__1::move_backward(__lb, __le, __r);
                    __n -= __bs;
                    __l -= __bs - 1;
                }
            return __r;
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__move_construct_and_check(std::__1::deque::iterator __f, std::__1::deque::iterator __l, std::__1::deque::iterator __r, std::__1::deque::const_pointer &__vt)         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            std::__1::deque::difference_type __n = __l - __f;
            while (__n > 0)
                {
                    std::__1::deque::pointer __fb = __f.__ptr_;
                    std::__1::deque::pointer __fe = *__f.__m_iter_ + __base::__block_size;
                    std::__1::deque::difference_type __bs = __fe - __fb;
                    if (__bs > __n) {
                        __bs = __n;
                        __fe = __fb + __bs;
                    }
                    if (__fb <= __vt && __vt < __fe)
                        __vt = (std::__1::deque::const_iterator(static_cast<std::__1::deque::__map_const_pointer>(__f.__m_iter_), __vt) += __r - __f).__ptr_;
                    for (; __fb != __fe; ++__fb , ++__r , ++__base::size())
                        __alloc_traits::construct(__a, std::__1::addressof(*__r), std::__1::move(*__fb));
                    __n -= __bs;
                    __f += __bs;
                }
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__move_construct_backward_and_check(std::__1::deque::iterator __f, std::__1::deque::iterator __l, std::__1::deque::iterator __r, std::__1::deque::const_pointer &__vt)         {
            std::__1::deque::allocator_type &__a = __base::__alloc();
            std::__1::deque::difference_type __n = __l - __f;
            while (__n > 0)
                {
                    --__l;
                    std::__1::deque::pointer __lb = *__l.__m_iter_;
                    std::__1::deque::pointer __le = __l.__ptr_ + 1;
                    std::__1::deque::difference_type __bs = __le - __lb;
                    if (__bs > __n) {
                        __bs = __n;
                        __lb = __le - __bs;
                    }
                    if (__lb <= __vt && __vt < __le)
                        __vt = (std::__1::deque::const_iterator(static_cast<std::__1::deque::__map_const_pointer>(__l.__m_iter_), __vt) -= __l - __r + 1).__ptr_;
                    while (__le != __lb)
                        {
                            __alloc_traits::construct(__a, std::__1::addressof(*--__r), std::__1::move(*--__le));
                            --__base::__start_;
                            ++__base::size();
                        }
                    __n -= __bs;
                    __l -= __bs - 1;
                }
        }
        template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::erase(std::__1::deque::const_iterator __f)         {
            std::__1::deque::iterator __b = __base::begin();
            std::__1::deque::difference_type __pos = __f - __b;
            std::__1::deque::iterator __p = __b + __pos;
            std::__1::deque::allocator_type &__a = __base::__alloc();
            if (static_cast<size_t>(__pos) <= (__base::size() - 1) / 2) {
                std::__1::move_backward(__b, __p, std::__1::next(__p));
                __alloc_traits::destroy(__a, std::__1::addressof(*__b));
                --__base::size();
                ++__base::__start_;
                this->__maybe_remove_front_spare();
            } else {
                std::__1::deque::iterator __i = std::__1::move(std::__1::next(__p), __base::end(), __p);
                __alloc_traits::destroy(__a, std::__1::addressof(*__i));
                --__base::size();
                this->__maybe_remove_back_spare();
            }
            return __base::begin() + __pos;
        }
        template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::erase(std::__1::deque::const_iterator __f, std::__1::deque::const_iterator __l)         {
            std::__1::deque::difference_type __n = __l - __f;
            std::__1::deque::iterator __b = __base::begin();
            std::__1::deque::difference_type __pos = __f - __b;
            std::__1::deque::iterator __p = __b + __pos;
            if (__n > 0) {
                std::__1::deque::allocator_type &__a = __base::__alloc();
                if (static_cast<size_t>(__pos) <= (__base::size() - __n) / 2) {
                    std::__1::deque::iterator __i = std::__1::move_backward(__b, __p, __p + __n);
                    for (; __b != __i; ++__b)
                        __alloc_traits::destroy(__a, std::__1::addressof(*__b));
                    __base::size() -= __n;
                    __base::__start_ += __n;
                    while (this->__maybe_remove_front_spare())
                        {
                        }
                } else {
                    std::__1::deque::iterator __i = std::__1::move(__p + __n, __base::end(), __p);
                    for (std::__1::deque::iterator __e = __base::end(); __i != __e; ++__i)
                        __alloc_traits::destroy(__a, std::__1::addressof(*__i));
                    __base::size() -= __n;
                    while (this->__maybe_remove_back_spare())
                        {
                        }
                }
            }
            return __base::begin() + __pos;
        }
        template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__erase_to_end(std::__1::deque::const_iterator __f)         {
            std::__1::deque::iterator __e = __base::end();
            std::__1::deque::difference_type __n = __e - __f;
            if (__n > 0) {
                std::__1::deque::allocator_type &__a = __base::__alloc();
                std::__1::deque::iterator __b = __base::begin();
                std::__1::deque::difference_type __pos = __f - __b;
                for (std::__1::deque::iterator __p = __b + __pos; __p != __e; ++__p)
                    __alloc_traits::destroy(__a, std::__1::addressof(*__p));
                __base::size() -= __n;
                while (this->__maybe_remove_back_spare())
                    {
                    }
            }
        }
        template <class _Tp, class _Allocator> inline void deque<_Tp, _Allocator>::swap(deque<_Tp, _Allocator> &__c)         {
            __base::swap(__c);
        }
        template <class _Tp, class _Allocator> inline void deque<_Tp, _Allocator>::clear() throw()         {
            __base::clear();
        }
        template <class _Tp, class _Allocator> inline bool operator==(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();
            return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
        }
        template <class _Tp, class _Allocator> inline bool operator!=(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Tp, class _Allocator> inline bool operator<(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
        }
        template <class _Tp, class _Allocator> inline bool operator>(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Tp, class _Allocator> inline bool operator>=(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Tp, class _Allocator> inline bool operator<=(const deque<_Tp, _Allocator> &__x, const deque<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Tp, class _Allocator> inline void swap(deque<_Tp, _Allocator> &__x, deque<_Tp, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
    }
}
namespace std {
    inline namespace __1 {
        template <class _Tp, class _Container = deque<_Tp>> class __attribute__((type_visibility("default"))) stack;
        template <class _Tp, class _Container> bool operator==(const stack<_Tp, _Container> &__x, const stack<_Tp, _Container> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Tp, class _Container> bool operator<(const stack<_Tp, _Container> &__x, const stack<_Tp, _Container> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Tp, class _Container = deque<_Tp>> class __attribute__((type_visibility("default"))) stack {
        public:
            typedef _Container container_type;
            typedef typename container_type::value_type value_type;
            typedef typename container_type::reference reference;
            typedef typename container_type::const_reference const_reference;
            typedef typename container_type::size_type size_type;
            static_assert((is_same<_Tp, value_type>::value), "");
        protected:
            std::__1::stack::container_type c;
        public:
            stack<_Tp, _Container>() : c() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            stack<_Tp, _Container>(const stack<_Tp, _Container> &__q) : c(__q.c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            stack<_Tp, _Container> &operator=(const stack<_Tp, _Container> &__q) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->c = __q.c;
                return *this;
            }
            explicit stack<_Tp, _Container>(const std::__1::stack::container_type &__c) : c(__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> explicit stack<_Tp, _Container>(const _Alloc &__a, typename enable_if<uses_allocator<container_type, _Alloc>::value>::type * = 0) : c(__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> stack<_Tp, _Container>(const std::__1::stack::container_type &__c, const _Alloc &__a, typename enable_if<uses_allocator<container_type, _Alloc>::value>::type * = 0) : c(__c, __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Alloc> stack<_Tp, _Container>(const stack<_Tp, _Container> &__s, const _Alloc &__a, typename enable_if<uses_allocator<container_type, _Alloc>::value>::type * = 0) : c(__s.c, __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            bool empty() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->c.empty();
            }
            std::__1::stack::size_type size() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->c.size();
            }
            std::__1::stack::reference top() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->c.back();
            }
            std::__1::stack::const_reference top() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->c.back();
            }
            void push(const std::__1::stack::value_type &__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->c.push_back(__v);
            }
            void pop() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->c.pop_back();
            }
            void swap(stack<_Tp, _Container> &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                using std::__1::swap;
                swap(this->c, __s.c);
            }
            friend template <class T1, class _C1> bool operator==(const stack<T1, _C1> &__x, const stack<T1, _C1> &__y);
            friend template <class T1, class _C1> bool operator<(const stack<T1, _C1> &__x, const stack<T1, _C1> &__y);
        };
        template <class _Tp, class _Container> inline bool operator==(const stack<_Tp, _Container> &__x, const stack<_Tp, _Container> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.c == __y.c;
        }
        template <class _Tp, class _Container> inline bool operator<(const stack<_Tp, _Container> &__x, const stack<_Tp, _Container> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.c < __y.c;
        }
        template <class _Tp, class _Container> inline bool operator!=(const stack<_Tp, _Container> &__x, const stack<_Tp, _Container> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template <class _Tp, class _Container> inline bool operator>(const stack<_Tp, _Container> &__x, const stack<_Tp, _Container> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y < __x;
        }
        template <class _Tp, class _Container> inline bool operator>=(const stack<_Tp, _Container> &__x, const stack<_Tp, _Container> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x < __y);
        }
        template <class _Tp, class _Container> inline bool operator<=(const stack<_Tp, _Container> &__x, const stack<_Tp, _Container> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__y < __x);
        }
        template <class _Tp, class _Container> inline typename enable_if<__is_swappable<_Container>::value, void>::type swap(stack<_Tp, _Container> &__x, stack<_Tp, _Container> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _Tp, class _Container, class _Alloc> struct __attribute__((type_visibility("default"))) uses_allocator<stack<_Tp, _Container>, _Alloc> : public uses_allocator<_Container, _Alloc> {
        };
    }
}
namespace std {
    inline namespace __1 {
        using ::FILE;
        using ::fpos_t;
        using ::size_t;
        using ::fclose;
        using ::fflush;
        using ::setbuf;
        using ::setvbuf;
        using ::fprintf;
        using ::fscanf;
        using ::snprintf;
        using ::sprintf;
        using ::sscanf;
        using ::vfprintf;
        using ::vfscanf;
        using ::vsscanf;
        using ::vsnprintf;
        using ::vsprintf;
        using ::fgetc;
        using ::fgets;
        using ::fputc;
        using ::fputs;
        using ::getc;
        using ::putc;
        using ::ungetc;
        using ::fread;
        using ::fwrite;
        using ::fgetpos;
        using ::fseek;
        using ::fsetpos;
        using ::ftell;
        using ::rewind;
        using ::clearerr;
        using ::feof;
        using ::ferror;
        using ::perror;
        using ::fopen;
        using ::freopen;
        using ::remove;
        using ::rename;
        using ::tmpfile;
        using ::tmpnam;
        using ::getchar;
        using ::gets;
        using ::scanf;
        using ::vscanf;
        using ::printf;
        using ::putchar;
        using ::puts;
        using ::vprintf;
    }
}
namespace std {
    inline namespace __1 {
        template <class _CharT> struct __attribute__((type_visibility("default"))) char_traits {
            typedef _CharT char_type;
            typedef int int_type;
            typedef std::__1::streamoff off_type;
            typedef std::__1::streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(std::__1::char_traits::char_type &__c1, const std::__1::char_traits::char_type &__c2) throw()             {
                __c1 = __c2;
            }
            static inline bool eq(std::__1::char_traits::char_type __c1, std::__1::char_traits::char_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline bool lt(std::__1::char_traits::char_type __c1, std::__1::char_traits::char_type __c2) throw()             {
                return __c1 < __c2;
            }
            static int compare(const std::__1::char_traits::char_type *__s1, const std::__1::char_traits::char_type *__s2, size_t __n);
            static size_t length(const std::__1::char_traits::char_type *__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static const std::__1::char_traits::char_type *find(const std::__1::char_traits::char_type *__s, size_t __n, const std::__1::char_traits::char_type &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static std::__1::char_traits::char_type *move(std::__1::char_traits::char_type *__s1, const std::__1::char_traits::char_type *__s2, size_t __n);
            static std::__1::char_traits::char_type *copy(std::__1::char_traits::char_type *__s1, const std::__1::char_traits::char_type *__s2, size_t __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static std::__1::char_traits::char_type *assign(std::__1::char_traits::char_type *__s, size_t __n, std::__1::char_traits::char_type __a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static inline std::__1::char_traits::int_type not_eof(std::__1::char_traits::int_type __c) throw()             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }
            static inline std::__1::char_traits::char_type to_char_type(std::__1::char_traits::int_type __c) throw()             {
                return std::__1::char_traits::char_type(__c);
            }
            static inline std::__1::char_traits::int_type to_int_type(std::__1::char_traits::char_type __c) throw()             {
                return std::__1::char_traits::int_type(__c);
            }
            static inline bool eq_int_type(std::__1::char_traits::int_type __c1, std::__1::char_traits::int_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline std::__1::char_traits::int_type eof() throw()             {
                return std::__1::char_traits::int_type((-1));
            }
        };
        template <class _CharT> int char_traits<_CharT>::compare(const std::__1::char_traits::char_type *__s1, const std::__1::char_traits::char_type *__s2, size_t __n)         {
            for (; __n; --__n , ++__s1 , ++__s2) {
                if (lt(*__s1, *__s2))
                    return -1;
                if (lt(*__s2, *__s1))
                    return 1;
            }
            return 0;
        }
        template <class _CharT> inline size_t char_traits<_CharT>::length(const std::__1::char_traits::char_type *__s)         {
            size_t __len = 0;
            for (; !eq(*__s, std::__1::char_traits::char_type(0)); ++__s)
                ++__len;
            return __len;
        }
        template <class _CharT> inline const _CharT *char_traits<_CharT>::find(const std::__1::char_traits::char_type *__s, size_t __n, const std::__1::char_traits::char_type &__a)         {
            for (; __n; --__n) {
                if (eq(*__s, __a))
                    return __s;
                ++__s;
            }
            return 0;
        }
        template <class _CharT> _CharT *char_traits<_CharT>::move(std::__1::char_traits::char_type *__s1, const std::__1::char_traits::char_type *__s2, size_t __n)         {
            if (__n == 0)
                return __s1;
            std::__1::char_traits::char_type *__r = __s1;
            if (__s1 < __s2) {
                for (; __n; --__n , ++__s1 , ++__s2)
                    assign(*__s1, *__s2);
            } else if (__s2 < __s1) {
                __s1 += __n;
                __s2 += __n;
                for (; __n; --__n)
                    assign(*--__s1, *--__s2);
            }
            return __r;
        }
        template <class _CharT> inline _CharT *char_traits<_CharT>::copy(std::__1::char_traits::char_type *__s1, const std::__1::char_traits::char_type *__s2, size_t __n)         {
            ((void)0);
            std::__1::char_traits::char_type *__r = __s1;
            for (; __n; --__n , ++__s1 , ++__s2)
                assign(*__s1, *__s2);
            return __r;
        }
        template <class _CharT> inline _CharT *char_traits<_CharT>::assign(std::__1::char_traits::char_type *__s, size_t __n, std::__1::char_traits::char_type __a)         {
            std::__1::char_traits::char_type *__r = __s;
            for (; __n; --__n , ++__s)
                assign(*__s, __a);
            return __r;
        }
        template <class _CharT> static inline _CharT *__move_constexpr(_CharT *__s1, const _CharT *__s2, size_t __n) throw()         {
            if (__n == 0)
                return __s1;
            if (__s1 < __s2) {
                std::__1::copy(__s2, __s2 + __n, __s1);
            } else if (__s2 < __s1) {
                std::__1::copy_backward(__s2, __s2 + __n, __s1 + __n);
            }
            return __s1;
        }
        template<> static inline char *__move_constexpr<char>(char *__s1, const char *__s2, size_t __n) throw()         {
            if (__n == 0)
                return __s1;
            if (__s1 < __s2) {
                std::__1::copy(__s2, __s2 + __n, __s1);
            } else if (__s2 < __s1) {
                std::__1::copy_backward(__s2, __s2 + __n, __s1 + __n);
            }
            return __s1;
        }
        template<> static inline wchar_t *__move_constexpr<wchar_t>(wchar_t *__s1, const wchar_t *__s2, size_t __n) throw()         {
            if (__n == 0)
                return __s1;
            if (__s1 < __s2) {
                std::__1::copy(__s2, __s2 + __n, __s1);
            } else if (__s2 < __s1) {
                std::__1::copy_backward(__s2, __s2 + __n, __s1 + __n);
            }
            return __s1;
        }
        template <class _CharT> static inline _CharT *__copy_constexpr(_CharT *__s1, const _CharT *__s2, size_t __n) throw()         {
            std::__1::copy_n(__s2, __n, __s1);
            return __s1;
        }
        template<> static inline char *__copy_constexpr<char>(char *__s1, const char *__s2, size_t __n) throw()         {
            std::__1::copy_n(__s2, __n, __s1);
            return __s1;
        }
        template<> static inline wchar_t *__copy_constexpr<wchar_t>(wchar_t *__s1, const wchar_t *__s2, size_t __n) throw()         {
            std::__1::copy_n(__s2, __n, __s1);
            return __s1;
        }
        template <class _CharT> static inline _CharT *__assign_constexpr(_CharT *__s, size_t __n, _CharT __a) throw()         {
            std::__1::fill_n(__s, __n, __a);
            return __s;
        }
        template<> static inline char *__assign_constexpr<char>(char *__s, size_t __n, char __a) throw()         {
            std::__1::fill_n(__s, __n, __a);
            return __s;
        }
        template<> static inline wchar_t *__assign_constexpr<wchar_t>(wchar_t *__s, size_t __n, wchar_t __a) throw()         {
            std::__1::fill_n(__s, __n, __a);
            return __s;
        }
        template<> struct __attribute__((type_visibility("default"))) char_traits<char> {
            typedef char char_type;
            typedef int int_type;
            typedef std::__1::streamoff off_type;
            typedef std::__1::streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(std::__1::char_traits<char>::char_type &__c1, const std::__1::char_traits<char>::char_type &__c2) throw()             {
                __c1 = __c2;
            }
            static inline bool eq(std::__1::char_traits<char>::char_type __c1, std::__1::char_traits<char>::char_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline bool lt(std::__1::char_traits<char>::char_type __c1, std::__1::char_traits<char>::char_type __c2) throw()             {
                return (unsigned char)__c1 < (unsigned char)__c2;
            }
            static int compare(const std::__1::char_traits<char>::char_type *__s1, const std::__1::char_traits<char>::char_type *__s2, size_t __n) throw();
            static inline size_t length(const std::__1::char_traits<char>::char_type *__s) throw()             {
                return __builtin_strlen(__s);
            }
            static const std::__1::char_traits<char>::char_type *find(const std::__1::char_traits<char>::char_type *__s, size_t __n, const std::__1::char_traits<char>::char_type &__a) throw();
            static inline std::__1::char_traits<char>::char_type *move(std::__1::char_traits<char>::char_type *__s1, const std::__1::char_traits<char>::char_type *__s2, size_t __n) throw()             {
                return __libcpp_is_constant_evaluated() ? __move_constexpr(__s1, __s2, __n) : __n == 0 ? __s1 : (std::__1::char_traits<char>::char_type *)memmove(__s1, __s2, __n);
            }
            static inline std::__1::char_traits<char>::char_type *copy(std::__1::char_traits<char>::char_type *__s1, const std::__1::char_traits<char>::char_type *__s2, size_t __n) throw()             {
                ((void)0);
                return __libcpp_is_constant_evaluated() ? __copy_constexpr(__s1, __s2, __n) : __n == 0 ? __s1 : (std::__1::char_traits<char>::char_type *)memcpy(__s1, __s2, __n);
            }
            static inline std::__1::char_traits<char>::char_type *assign(std::__1::char_traits<char>::char_type *__s, size_t __n, std::__1::char_traits<char>::char_type __a) throw()             {
                return __libcpp_is_constant_evaluated() ? __assign_constexpr(__s, __n, __a) : __n == 0 ? __s : (std::__1::char_traits<char>::char_type *)memset(__s, to_int_type(__a), __n);
            }
            static inline std::__1::char_traits<char>::int_type not_eof(std::__1::char_traits<char>::int_type __c) throw()             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }
            static inline std::__1::char_traits<char>::char_type to_char_type(std::__1::char_traits<char>::int_type __c) throw()             {
                return std::__1::char_traits<char>::char_type(__c);
            }
            static inline std::__1::char_traits<char>::int_type to_int_type(std::__1::char_traits<char>::char_type __c) throw()             {
                return std::__1::char_traits<char>::int_type((unsigned char)__c);
            }
            static inline bool eq_int_type(std::__1::char_traits<char>::int_type __c1, std::__1::char_traits<char>::int_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline std::__1::char_traits<char>::int_type eof() throw()             {
                return std::__1::char_traits<char>::int_type((-1));
            }
        };
        inline int char_traits<char>::compare(const std::__1::char_traits<char>::char_type *__s1, const std::__1::char_traits<char>::char_type *__s2, size_t __n) throw()         {
            if (__n == 0)
                return 0;
            return memcmp(__s1, __s2, __n);
        }
        inline const char *char_traits<char>::find(const std::__1::char_traits<char>::char_type *__s, size_t __n, const std::__1::char_traits<char>::char_type &__a) throw()         {
            if (__n == 0)
                return std::__1::__get_nullptr_t();
            return (const std::__1::char_traits<char>::char_type *)memchr(__s, to_int_type(__a), __n);
        }
        template<> struct __attribute__((type_visibility("default"))) char_traits<wchar_t> {
            typedef wchar_t char_type;
            typedef wint_t int_type;
            typedef std::__1::streamoff off_type;
            typedef std::__1::streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(std::__1::char_traits<wchar_t>::char_type &__c1, const std::__1::char_traits<wchar_t>::char_type &__c2) throw()             {
                __c1 = __c2;
            }
            static inline bool eq(std::__1::char_traits<wchar_t>::char_type __c1, std::__1::char_traits<wchar_t>::char_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline bool lt(std::__1::char_traits<wchar_t>::char_type __c1, std::__1::char_traits<wchar_t>::char_type __c2) throw()             {
                return __c1 < __c2;
            }
            static int compare(const std::__1::char_traits<wchar_t>::char_type *__s1, const std::__1::char_traits<wchar_t>::char_type *__s2, size_t __n) throw();
            static size_t length(const std::__1::char_traits<wchar_t>::char_type *__s) throw();
            static const std::__1::char_traits<wchar_t>::char_type *find(const std::__1::char_traits<wchar_t>::char_type *__s, size_t __n, const std::__1::char_traits<wchar_t>::char_type &__a) throw();
            static inline std::__1::char_traits<wchar_t>::char_type *move(std::__1::char_traits<wchar_t>::char_type *__s1, const std::__1::char_traits<wchar_t>::char_type *__s2, size_t __n) throw()             {
                return __libcpp_is_constant_evaluated() ? __move_constexpr(__s1, __s2, __n) : __n == 0 ? __s1 : wmemmove(__s1, __s2, __n);
            }
            static inline std::__1::char_traits<wchar_t>::char_type *copy(std::__1::char_traits<wchar_t>::char_type *__s1, const std::__1::char_traits<wchar_t>::char_type *__s2, size_t __n) throw()             {
                ((void)0);
                return __libcpp_is_constant_evaluated() ? __copy_constexpr(__s1, __s2, __n) : __n == 0 ? __s1 : wmemcpy(__s1, __s2, __n);
            }
            static inline std::__1::char_traits<wchar_t>::char_type *assign(std::__1::char_traits<wchar_t>::char_type *__s, size_t __n, std::__1::char_traits<wchar_t>::char_type __a) throw()             {
                return __libcpp_is_constant_evaluated() ? __assign_constexpr(__s, __n, __a) : __n == 0 ? __s : wmemset(__s, __a, __n);
            }
            static inline std::__1::char_traits<wchar_t>::int_type not_eof(std::__1::char_traits<wchar_t>::int_type __c) throw()             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }
            static inline std::__1::char_traits<wchar_t>::char_type to_char_type(std::__1::char_traits<wchar_t>::int_type __c) throw()             {
                return std::__1::char_traits<wchar_t>::char_type(__c);
            }
            static inline std::__1::char_traits<wchar_t>::int_type to_int_type(std::__1::char_traits<wchar_t>::char_type __c) throw()             {
                return std::__1::char_traits<wchar_t>::int_type(__c);
            }
            static inline bool eq_int_type(std::__1::char_traits<wchar_t>::int_type __c1, std::__1::char_traits<wchar_t>::int_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline std::__1::char_traits<wchar_t>::int_type eof() throw()             {
                return std::__1::char_traits<wchar_t>::int_type(((__darwin_wint_t)-1));
            }
        };
        inline int char_traits<wchar_t>::compare(const std::__1::char_traits<wchar_t>::char_type *__s1, const std::__1::char_traits<wchar_t>::char_type *__s2, size_t __n) throw()         {
            if (__n == 0)
                return 0;
            return wmemcmp(__s1, __s2, __n);
        }
        template <class _Traits> inline size_t __char_traits_length_checked(const typename _Traits::char_type *__s) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return _Traits::length(__s);
        }
        inline size_t char_traits<wchar_t>::length(const std::__1::char_traits<wchar_t>::char_type *__s) throw()         {
            return wcslen(__s);
        }
        inline const wchar_t *char_traits<wchar_t>::find(const std::__1::char_traits<wchar_t>::char_type *__s, size_t __n, const std::__1::char_traits<wchar_t>::char_type &__a) throw()         {
            if (__n == 0)
                return std::__1::__get_nullptr_t();
            return wmemchr(__s, __a, __n);
        }
        template<> struct __attribute__((type_visibility("default"))) char_traits<char16_t> {
            typedef char16_t char_type;
            typedef uint_least16_t int_type;
            typedef std::__1::streamoff off_type;
            typedef std::__1::u16streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(std::__1::char_traits<char16_t>::char_type &__c1, const std::__1::char_traits<char16_t>::char_type &__c2) throw()             {
                __c1 = __c2;
            }
            static inline bool eq(std::__1::char_traits<char16_t>::char_type __c1, std::__1::char_traits<char16_t>::char_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline bool lt(std::__1::char_traits<char16_t>::char_type __c1, std::__1::char_traits<char16_t>::char_type __c2) throw()             {
                return __c1 < __c2;
            }
            static int compare(const std::__1::char_traits<char16_t>::char_type *__s1, const std::__1::char_traits<char16_t>::char_type *__s2, size_t __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static size_t length(const std::__1::char_traits<char16_t>::char_type *__s) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static const std::__1::char_traits<char16_t>::char_type *find(const std::__1::char_traits<char16_t>::char_type *__s, size_t __n, const std::__1::char_traits<char16_t>::char_type &__a) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static std::__1::char_traits<char16_t>::char_type *move(std::__1::char_traits<char16_t>::char_type *__s1, const std::__1::char_traits<char16_t>::char_type *__s2, size_t __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static std::__1::char_traits<char16_t>::char_type *copy(std::__1::char_traits<char16_t>::char_type *__s1, const std::__1::char_traits<char16_t>::char_type *__s2, size_t __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static std::__1::char_traits<char16_t>::char_type *assign(std::__1::char_traits<char16_t>::char_type *__s, size_t __n, std::__1::char_traits<char16_t>::char_type __a) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static inline std::__1::char_traits<char16_t>::int_type not_eof(std::__1::char_traits<char16_t>::int_type __c) throw()             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }
            static inline std::__1::char_traits<char16_t>::char_type to_char_type(std::__1::char_traits<char16_t>::int_type __c) throw()             {
                return std::__1::char_traits<char16_t>::char_type(__c);
            }
            static inline std::__1::char_traits<char16_t>::int_type to_int_type(std::__1::char_traits<char16_t>::char_type __c) throw()             {
                return std::__1::char_traits<char16_t>::int_type(__c);
            }
            static inline bool eq_int_type(std::__1::char_traits<char16_t>::int_type __c1, std::__1::char_traits<char16_t>::int_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline std::__1::char_traits<char16_t>::int_type eof() throw()             {
                return std::__1::char_traits<char16_t>::int_type(65535);
            }
        };
        inline int char_traits<char16_t>::compare(const std::__1::char_traits<char16_t>::char_type *__s1, const std::__1::char_traits<char16_t>::char_type *__s2, size_t __n) throw()         {
            for (; __n; --__n , ++__s1 , ++__s2) {
                if (lt(*__s1, *__s2))
                    return -1;
                if (lt(*__s2, *__s1))
                    return 1;
            }
            return 0;
        }
        inline size_t char_traits<char16_t>::length(const std::__1::char_traits<char16_t>::char_type *__s) throw()         {
            size_t __len = 0;
            for (; !eq(*__s, std::__1::char_traits<char16_t>::char_type(0)); ++__s)
                ++__len;
            return __len;
        }
        inline const char16_t *char_traits<char16_t>::find(const std::__1::char_traits<char16_t>::char_type *__s, size_t __n, const std::__1::char_traits<char16_t>::char_type &__a) throw()         {
            for (; __n; --__n) {
                if (eq(*__s, __a))
                    return __s;
                ++__s;
            }
            return 0;
        }
        inline char16_t *char_traits<char16_t>::move(std::__1::char_traits<char16_t>::char_type *__s1, const std::__1::char_traits<char16_t>::char_type *__s2, size_t __n) throw()         {
            if (__n == 0)
                return __s1;
            std::__1::char_traits<char16_t>::char_type *__r = __s1;
            if (__s1 < __s2) {
                for (; __n; --__n , ++__s1 , ++__s2)
                    assign(*__s1, *__s2);
            } else if (__s2 < __s1) {
                __s1 += __n;
                __s2 += __n;
                for (; __n; --__n)
                    assign(*--__s1, *--__s2);
            }
            return __r;
        }
        inline char16_t *char_traits<char16_t>::copy(std::__1::char_traits<char16_t>::char_type *__s1, const std::__1::char_traits<char16_t>::char_type *__s2, size_t __n) throw()         {
            ((void)0);
            std::__1::char_traits<char16_t>::char_type *__r = __s1;
            for (; __n; --__n , ++__s1 , ++__s2)
                assign(*__s1, *__s2);
            return __r;
        }
        inline char16_t *char_traits<char16_t>::assign(std::__1::char_traits<char16_t>::char_type *__s, size_t __n, std::__1::char_traits<char16_t>::char_type __a) throw()         {
            std::__1::char_traits<char16_t>::char_type *__r = __s;
            for (; __n; --__n , ++__s)
                assign(*__s, __a);
            return __r;
        }
        template<> struct __attribute__((type_visibility("default"))) char_traits<char32_t> {
            typedef char32_t char_type;
            typedef uint_least32_t int_type;
            typedef std::__1::streamoff off_type;
            typedef std::__1::u32streampos pos_type;
            typedef mbstate_t state_type;
            static inline void assign(std::__1::char_traits<char32_t>::char_type &__c1, const std::__1::char_traits<char32_t>::char_type &__c2) throw()             {
                __c1 = __c2;
            }
            static inline bool eq(std::__1::char_traits<char32_t>::char_type __c1, std::__1::char_traits<char32_t>::char_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline bool lt(std::__1::char_traits<char32_t>::char_type __c1, std::__1::char_traits<char32_t>::char_type __c2) throw()             {
                return __c1 < __c2;
            }
            static int compare(const std::__1::char_traits<char32_t>::char_type *__s1, const std::__1::char_traits<char32_t>::char_type *__s2, size_t __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static size_t length(const std::__1::char_traits<char32_t>::char_type *__s) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static const std::__1::char_traits<char32_t>::char_type *find(const std::__1::char_traits<char32_t>::char_type *__s, size_t __n, const std::__1::char_traits<char32_t>::char_type &__a) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static std::__1::char_traits<char32_t>::char_type *move(std::__1::char_traits<char32_t>::char_type *__s1, const std::__1::char_traits<char32_t>::char_type *__s2, size_t __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static std::__1::char_traits<char32_t>::char_type *copy(std::__1::char_traits<char32_t>::char_type *__s1, const std::__1::char_traits<char32_t>::char_type *__s2, size_t __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static std::__1::char_traits<char32_t>::char_type *assign(std::__1::char_traits<char32_t>::char_type *__s, size_t __n, std::__1::char_traits<char32_t>::char_type __a) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            static inline std::__1::char_traits<char32_t>::int_type not_eof(std::__1::char_traits<char32_t>::int_type __c) throw()             {
                return eq_int_type(__c, eof()) ? ~eof() : __c;
            }
            static inline std::__1::char_traits<char32_t>::char_type to_char_type(std::__1::char_traits<char32_t>::int_type __c) throw()             {
                return std::__1::char_traits<char32_t>::char_type(__c);
            }
            static inline std::__1::char_traits<char32_t>::int_type to_int_type(std::__1::char_traits<char32_t>::char_type __c) throw()             {
                return std::__1::char_traits<char32_t>::int_type(__c);
            }
            static inline bool eq_int_type(std::__1::char_traits<char32_t>::int_type __c1, std::__1::char_traits<char32_t>::int_type __c2) throw()             {
                return __c1 == __c2;
            }
            static inline std::__1::char_traits<char32_t>::int_type eof() throw()             {
                return std::__1::char_traits<char32_t>::int_type(4294967295U);
            }
        };
        inline int char_traits<char32_t>::compare(const std::__1::char_traits<char32_t>::char_type *__s1, const std::__1::char_traits<char32_t>::char_type *__s2, size_t __n) throw()         {
            for (; __n; --__n , ++__s1 , ++__s2) {
                if (lt(*__s1, *__s2))
                    return -1;
                if (lt(*__s2, *__s1))
                    return 1;
            }
            return 0;
        }
        inline size_t char_traits<char32_t>::length(const std::__1::char_traits<char32_t>::char_type *__s) throw()         {
            size_t __len = 0;
            for (; !eq(*__s, std::__1::char_traits<char32_t>::char_type(0)); ++__s)
                ++__len;
            return __len;
        }
        inline const char32_t *char_traits<char32_t>::find(const std::__1::char_traits<char32_t>::char_type *__s, size_t __n, const std::__1::char_traits<char32_t>::char_type &__a) throw()         {
            for (; __n; --__n) {
                if (eq(*__s, __a))
                    return __s;
                ++__s;
            }
            return 0;
        }
        inline char32_t *char_traits<char32_t>::move(std::__1::char_traits<char32_t>::char_type *__s1, const std::__1::char_traits<char32_t>::char_type *__s2, size_t __n) throw()         {
            if (__n == 0)
                return __s1;
            std::__1::char_traits<char32_t>::char_type *__r = __s1;
            if (__s1 < __s2) {
                for (; __n; --__n , ++__s1 , ++__s2)
                    assign(*__s1, *__s2);
            } else if (__s2 < __s1) {
                __s1 += __n;
                __s2 += __n;
                for (; __n; --__n)
                    assign(*--__s1, *--__s2);
            }
            return __r;
        }
        inline char32_t *char_traits<char32_t>::copy(std::__1::char_traits<char32_t>::char_type *__s1, const std::__1::char_traits<char32_t>::char_type *__s2, size_t __n) throw()         {
            ((void)0);
            std::__1::char_traits<char32_t>::char_type *__r = __s1;
            for (; __n; --__n , ++__s1 , ++__s2)
                assign(*__s1, *__s2);
            return __r;
        }
        inline char32_t *char_traits<char32_t>::assign(std::__1::char_traits<char32_t>::char_type *__s, size_t __n, std::__1::char_traits<char32_t>::char_type __a) throw()         {
            std::__1::char_traits<char32_t>::char_type *__r = __s;
            for (; __n; --__n , ++__s)
                assign(*__s, __a);
            return __r;
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_find(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__pos >= __sz)
                return __npos;
            const _CharT *__r = _Traits::find(__p + __pos, __sz - __pos, __c);
            if (__r == 0)
                return __npos;
            return static_cast<_SizeT>(__r - __p);
        }
        template <class _CharT, class _Traits> inline const _CharT *__search_substring(const _CharT *__first1, const _CharT *__last1, const _CharT *__first2, const _CharT *__last2)         {
            const ptrdiff_t __len2 = __last2 - __first2;
            if (__len2 == 0)
                return __first1;
            ptrdiff_t __len1 = __last1 - __first1;
            if (__len1 < __len2)
                return __last1;
            _CharT __f2 = *__first2;
            while (true)
                {
                    __len1 = __last1 - __first1;
                    if (__len1 < __len2)
                        return __last1;
                    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
                    if (__first1 == 0)
                        return __last1;
                    if (_Traits::compare(__first1, __first2, __len2) == 0)
                        return __first1;
                    ++__first1;
                }
        }
        template<> inline const char *__search_substring<char, std::__1::char_traits<char>>(const char *__first1, const char *__last1, const char *__first2, const char *__last2)         {
            const ptrdiff_t __len2 = __last2 - __first2;
            if (__len2 == 0)
                return __first1;
            ptrdiff_t __len1 = __last1 - __first1;
            if (__len1 < __len2)
                return __last1;
            char __f2 = *__first2;
            while (true)
                {
                    __len1 = __last1 - __first1;
                    if (__len1 < __len2)
                        return __last1;
                    __first1 = char_traits<char>::find(__first1, __len1 - __len2 + 1, __f2);
                    if (__first1 == 0)
                        return __last1;
                    if (char_traits<char>::compare(__first1, __first2, __len2) == 0)
                        return __first1;
                    ++__first1;
                }
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_find(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__pos > __sz)
                return __npos;
            if (__n == 0)
                return __pos;
            const _CharT *__r = __search_substring<_CharT, _Traits>(__p + __pos, __p + __sz, __s, __s + __n);
            if (__r == __p + __sz)
                return __npos;
            return static_cast<_SizeT>(__r - __p);
        }
        template<> inline unsigned long __str_find<char, unsigned long, std::__1::char_traits<char>, 18446744073709551615>(const char *__p, unsigned long __sz, const char *__s, unsigned long __pos, unsigned long __n) throw() __attribute__((internal_linkage))         {
            if (__pos > __sz)
                return 18446744073709551615UL;
            if (__n == 0)
                return __pos;
            const char *__r = __search_substring<char, std::__1::char_traits<char> >(__p + __pos, __p + __sz, __s, __s + __n);
            if (__r == __p + __sz)
                return 18446744073709551615UL;
            return static_cast<unsigned long>(__r - __p);
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_rfind(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__sz < 1)
                return __npos;
            if (__pos < __sz)
                ++__pos;
            else
                __pos = __sz;
            for (const _CharT *__ps = __p + __pos; __ps != __p;) {
                if (_Traits::eq(*--__ps, __c))
                    return static_cast<_SizeT>(__ps - __p);
            }
            return __npos;
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_rfind(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __pos = std::__1::min(__pos, __sz);
            if (__n < __sz - __pos)
                __pos += __n;
            else
                __pos = __sz;
            const _CharT *__r = std::__1::__find_end(__p, __p + __pos, __s, __s + __n, _Traits::eq, std::__1::random_access_iterator_tag(), std::__1::random_access_iterator_tag());
            if (__n > 0 && __r == __p + __pos)
                return __npos;
            return static_cast<_SizeT>(__r - __p);
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_find_first_of(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__pos >= __sz || __n == 0)
                return __npos;
            const _CharT *__r = std::__1::__find_first_of_ce(__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq);
            if (__r == __p + __sz)
                return __npos;
            return static_cast<_SizeT>(__r - __p);
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_find_last_of(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__n != 0) {
                if (__pos < __sz)
                    ++__pos;
                else
                    __pos = __sz;
                for (const _CharT *__ps = __p + __pos; __ps != __p;) {
                    const _CharT *__r = _Traits::find(__s, __n, *--__ps);
                    if (__r)
                        return static_cast<_SizeT>(__ps - __p);
                }
            }
            return __npos;
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_find_first_not_of(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__pos < __sz) {
                const _CharT *__pe = __p + __sz;
                for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps)
                    if (_Traits::find(__s, __n, *__ps) == 0)
                        return static_cast<_SizeT>(__ps - __p);
            }
            return __npos;
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_find_first_not_of(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__pos < __sz) {
                const _CharT *__pe = __p + __sz;
                for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps)
                    if (!_Traits::eq(*__ps, __c))
                        return static_cast<_SizeT>(__ps - __p);
            }
            return __npos;
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_find_last_not_of(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos, _SizeT __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__pos < __sz)
                ++__pos;
            else
                __pos = __sz;
            for (const _CharT *__ps = __p + __pos; __ps != __p;)
                if (_Traits::find(__s, __n, *--__ps) == 0)
                    return static_cast<_SizeT>(__ps - __p);
            return __npos;
        }
        template <class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT __str_find_last_not_of(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__pos < __sz)
                ++__pos;
            else
                __pos = __sz;
            for (const _CharT *__ps = __p + __pos; __ps != __p;)
                if (!_Traits::eq(*--__ps, __c))
                    return static_cast<_SizeT>(__ps - __p);
            return __npos;
        }
        template <class _Ptr> inline size_t __do_string_hash(_Ptr __p, _Ptr __e) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef typename iterator_traits<_Ptr>::value_type value_type;
            return __murmur2_or_cityhash<size_t>()(__p, (__e - __p) * sizeof(value_type));
        }
        template <class _CharT, class _Iter, class _Traits = char_traits<_CharT>> struct __quoted_output_proxy {
            _Iter __first;
            _Iter __last;
            _CharT __delim;
            _CharT __escape;
            __quoted_output_proxy<_CharT, _Iter, _Traits>(_Iter __f, _Iter __l, _CharT __d, _CharT __e) : __first(__f), __last(__l), __delim(__d), __escape(__e)             {
            }
        };
    }
}
namespace std {
    inline namespace __1 {
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_string_view {
        public:
            typedef _Traits traits_type;
            typedef _CharT value_type;
            typedef _CharT *pointer;
            typedef const _CharT *const_pointer;
            typedef _CharT &reference;
            typedef const _CharT &const_reference;
            typedef std::__1::basic_string_view::const_pointer const_iterator;
            typedef std::__1::basic_string_view::const_iterator iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::__1::basic_string_view::const_reverse_iterator reverse_iterator;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            static const std::__1::basic_string_view::size_type npos = -1;
            static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
            static_assert((is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
            static_assert((is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
            static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            basic_string_view<_CharT, _Traits>() throw() : __data(std::__1::__get_nullptr_t()), __size(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            basic_string_view<_CharT, _Traits>(const basic_string_view<_CharT, _Traits> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = default
            basic_string_view<_CharT, _Traits> &operator=(const basic_string_view<_CharT, _Traits> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = default
            basic_string_view<_CharT, _Traits>(const _CharT *__s, std::__1::basic_string_view::size_type __len) throw() : __data(__s), __size(__len) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            basic_string_view<_CharT, _Traits>(const _CharT *__s) : __data(__s), __size(std::__char_traits_length_checked<_Traits>(__s)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::basic_string_view::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->cbegin();
            }
            std::__1::basic_string_view::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->cend();
            }
            std::__1::basic_string_view::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__data;
            }
            std::__1::basic_string_view::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__data + this->__size;
            }
            std::__1::basic_string_view::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string_view::const_reverse_iterator(this->cend());
            }
            std::__1::basic_string_view::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string_view::const_reverse_iterator(this->cbegin());
            }
            std::__1::basic_string_view::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string_view::const_reverse_iterator(this->cend());
            }
            std::__1::basic_string_view::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string_view::const_reverse_iterator(this->cbegin());
            }
            std::__1::basic_string_view::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__size;
            }
            std::__1::basic_string_view::size_type length() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__size;
            }
            std::__1::basic_string_view::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return numeric_limits<size_type>::max();
            }
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__size == 0;
            }
            std::__1::basic_string_view::const_reference operator[](std::__1::basic_string_view::size_type __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__data[__pos];
            }
            std::__1::basic_string_view::const_reference at(std::__1::basic_string_view::size_type __pos) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __pos >= this->size() ? (__throw_out_of_range("string_view::at") , this->__data[0]) : this->__data[__pos];
            }
            std::__1::basic_string_view::const_reference front() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return ((void)0) , this->__data[0];
            }
            std::__1::basic_string_view::const_reference back() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return ((void)0) , this->__data[this->__size - 1];
            }
            std::__1::basic_string_view::const_pointer data() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__data;
            }
            void remove_prefix(std::__1::basic_string_view::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                this->__data += __n;
                this->__size -= __n;
            }
            void remove_suffix(std::__1::basic_string_view::size_type __n) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                this->__size -= __n;
            }
            void swap(basic_string_view<_CharT, _Traits> &__other) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                const std::__1::basic_string_view::value_type *__p = this->__data;
                this->__data = __other.__data;
                __other.__data = __p;
                std::__1::basic_string_view::size_type __sz = this->__size;
                this->__size = __other.__size;
                __other.__size = __sz;
            }
            std::__1::basic_string_view::size_type copy(_CharT *__s, std::__1::basic_string_view::size_type __n, std::__1::basic_string_view::size_type __pos = 0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__pos > this->size())
                    __throw_out_of_range("string_view::copy");
                std::__1::basic_string_view::size_type __rlen = std::__1::min(__n, this->size() - __pos);
                _Traits::copy(__s, this->data() + __pos, __rlen);
                return __rlen;
            }
            basic_string_view<_CharT, _Traits> substr(std::__1::basic_string_view::size_type __pos = 0, std::__1::basic_string_view::size_type __n = npos) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __pos > this->size() ? (__throw_out_of_range("string_view::substr") , basic_string_view<_CharT, _Traits>()) : basic_string_view<_CharT, _Traits>(this->data() + __pos, std::__1::min(__n, this->size() - __pos));
            }
            int compare(basic_string_view<_CharT, _Traits> __sv) const throw()             {
                std::__1::basic_string_view::size_type __rlen = std::__1::min(this->size(), __sv.size());
                int __retval = _Traits::compare(this->data(), __sv.data(), __rlen);
                if (__retval == 0)
                    __retval = this->size() == __sv.size() ? 0 : (this->size() < __sv.size() ? -1 : 1);
                return __retval;
            }
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, basic_string_view<_CharT, _Traits> __sv) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->substr(__pos1, __n1).compare(__sv);
            }
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, basic_string_view<_CharT, _Traits> __sv, std::__1::basic_string_view::size_type __pos2, std::__1::basic_string_view::size_type __n2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
            }
            int compare(const _CharT *__s) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return compare(basic_string_view<_CharT, _Traits>(__s));
            }
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, const _CharT *__s) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>(__s));
            }
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, const _CharT *__s, std::__1::basic_string_view::size_type __n2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->substr(__pos1, __n1).compare(basic_string_view<_CharT, _Traits>(__s, __n2));
            }
            std::__1::basic_string_view::size_type find(basic_string_view<_CharT, _Traits> __s, std::__1::basic_string_view::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s.data(), __pos, __s.size());
            }
            std::__1::basic_string_view::size_type find(_CharT __c, std::__1::basic_string_view::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __str_find<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __c, __pos);
            }
            std::__1::basic_string_view::size_type find(const _CharT *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
            }
            std::__1::basic_string_view::size_type find(const _CharT *__s, std::__1::basic_string_view::size_type __pos = 0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
            }
            std::__1::basic_string_view::size_type rfind(basic_string_view<_CharT, _Traits> __s, std::__1::basic_string_view::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_rfind<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s.data(), __pos, __s.size());
            }
            std::__1::basic_string_view::size_type rfind(_CharT __c, std::__1::basic_string_view::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __str_rfind<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __c, __pos);
            }
            std::__1::basic_string_view::size_type rfind(const _CharT *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_rfind<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
            }
            std::__1::basic_string_view::size_type rfind(const _CharT *__s, std::__1::basic_string_view::size_type __pos = npos) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_rfind<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
            }
            std::__1::basic_string_view::size_type find_first_of(basic_string_view<_CharT, _Traits> __s, std::__1::basic_string_view::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_first_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s.data(), __pos, __s.size());
            }
            std::__1::basic_string_view::size_type find_first_of(_CharT __c, std::__1::basic_string_view::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return find(__c, __pos);
            }
            std::__1::basic_string_view::size_type find_first_of(const _CharT *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_first_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
            }
            std::__1::basic_string_view::size_type find_first_of(const _CharT *__s, std::__1::basic_string_view::size_type __pos = 0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_first_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
            }
            std::__1::basic_string_view::size_type find_last_of(basic_string_view<_CharT, _Traits> __s, std::__1::basic_string_view::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_last_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s.data(), __pos, __s.size());
            }
            std::__1::basic_string_view::size_type find_last_of(_CharT __c, std::__1::basic_string_view::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rfind(__c, __pos);
            }
            std::__1::basic_string_view::size_type find_last_of(const _CharT *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_last_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
            }
            std::__1::basic_string_view::size_type find_last_of(const _CharT *__s, std::__1::basic_string_view::size_type __pos = npos) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_last_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
            }
            std::__1::basic_string_view::size_type find_first_not_of(basic_string_view<_CharT, _Traits> __s, std::__1::basic_string_view::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_first_not_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s.data(), __pos, __s.size());
            }
            std::__1::basic_string_view::size_type find_first_not_of(_CharT __c, std::__1::basic_string_view::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __str_find_first_not_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __c, __pos);
            }
            std::__1::basic_string_view::size_type find_first_not_of(const _CharT *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_first_not_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
            }
            std::__1::basic_string_view::size_type find_first_not_of(const _CharT *__s, std::__1::basic_string_view::size_type __pos = 0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_first_not_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
            }
            std::__1::basic_string_view::size_type find_last_not_of(basic_string_view<_CharT, _Traits> __s, std::__1::basic_string_view::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_last_not_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s.data(), __pos, __s.size());
            }
            std::__1::basic_string_view::size_type find_last_not_of(_CharT __c, std::__1::basic_string_view::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __str_find_last_not_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __c, __pos);
            }
            std::__1::basic_string_view::size_type find_last_not_of(const _CharT *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_last_not_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
            }
            std::__1::basic_string_view::size_type find_last_not_of(const _CharT *__s, std::__1::basic_string_view::size_type __pos = npos) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                return __str_find_last_not_of<std::__1::basic_string_view::value_type, std::__1::basic_string_view::size_type, std::__1::basic_string_view::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
            }
        private:
            const std::__1::basic_string_view::value_type *__data;
            std::__1::basic_string_view::size_type __size;
        };
template<> class basic_string_view<char, std::__1::char_traits<char>> {
        public:
            typedef std::__1::char_traits<char> traits_type;
            typedef char value_type;
            typedef char *pointer;
            typedef const char *const_pointer;
            typedef char &reference;
            typedef const char &const_reference;
            typedef std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_pointer const_iterator;
            typedef std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_iterator iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_reverse_iterator reverse_iterator;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            static const std::__1::basic_string_view::size_type npos = -1;
            static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
            static_assert((is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
            static_assert((is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
            static_assert((is_same<char, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            basic_string_view() throw() __attribute__((internal_linkage));
            basic_string_view(const std::__1::basic_string_view<char, std::__1::char_traits<char> > &) throw() __attribute__((internal_linkage)) = default
            std::__1::basic_string_view<char, std::__1::char_traits<char> > &operator=(const std::__1::basic_string_view<char, std::__1::char_traits<char> > &) throw() __attribute__((internal_linkage)) = default
            basic_string_view(const char *__s, std::__1::basic_string_view::size_type __len) throw() __attribute__((internal_linkage));
            basic_string_view(const char *__s) __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_iterator begin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_iterator end() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_iterator cbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_iterator cend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_reverse_iterator rbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_reverse_iterator rend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_reverse_iterator crbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_reverse_iterator crend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view::size_type size() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view::size_type length() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view::size_type max_size() const throw() __attribute__((internal_linkage));
            bool empty() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_reference operator[](std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_reference at(std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_reference front() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_reference back() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::const_pointer data() const throw() __attribute__((internal_linkage));
            void remove_prefix(std::__1::basic_string_view::size_type __n) throw() __attribute__((internal_linkage));
            void remove_suffix(std::__1::basic_string_view::size_type __n) throw() __attribute__((internal_linkage));
            void swap(std::__1::basic_string_view<char, std::__1::char_traits<char> > &__other) throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type copy(char *__s, std::__1::basic_string_view::size_type __n, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> > substr(std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            int compare(std::__1::basic_string_view<char, std::__1::char_traits<char> > __sv) const throw();
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, std::__1::basic_string_view<char, std::__1::char_traits<char> > __sv) const __attribute__((internal_linkage));
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, std::__1::basic_string_view<char, std::__1::char_traits<char> > __sv, std::__1::basic_string_view::size_type __pos2, std::__1::basic_string_view::size_type __n2) const __attribute__((internal_linkage));
            int compare(const char *__s) const throw() __attribute__((internal_linkage));
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, const char *__s) const __attribute__((internal_linkage));
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, const char *__s, std::__1::basic_string_view::size_type __n2) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find(std::__1::basic_string_view<char, std::__1::char_traits<char> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find(char __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find(const char *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find(const char *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type rfind(std::__1::basic_string_view<char, std::__1::char_traits<char> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type rfind(char __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type rfind(const char *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type rfind(const char *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_first_of(std::__1::basic_string_view<char, std::__1::char_traits<char> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_first_of(char __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_first_of(const char *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_first_of(const char *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_last_of(std::__1::basic_string_view<char, std::__1::char_traits<char> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_last_of(char __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_last_of(const char *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_last_of(const char *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_first_not_of(std::__1::basic_string_view<char, std::__1::char_traits<char> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_first_not_of(char __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_first_not_of(const char *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_first_not_of(const char *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_last_not_of(std::__1::basic_string_view<char, std::__1::char_traits<char> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_last_not_of(char __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_last_not_of(const char *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<char, std::__1::char_traits<char> >::size_type find_last_not_of(const char *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
        private:
            const std::__1::basic_string_view<char, std::__1::char_traits<char> >::value_type *__data;
            std::__1::basic_string_view::size_type __size;
        };
template<> class basic_string_view<wchar_t, std::__1::char_traits<wchar_t>> {
        public:
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef wchar_t value_type;
            typedef wchar_t *pointer;
            typedef const wchar_t *const_pointer;
            typedef wchar_t &reference;
            typedef const wchar_t &const_reference;
            typedef std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_pointer const_iterator;
            typedef std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_iterator iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_reverse_iterator reverse_iterator;
            typedef size_t size_type;
            typedef ptrdiff_t difference_type;
            static const std::__1::basic_string_view::size_type npos = -1;
            static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
            static_assert((is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
            static_assert((is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
            static_assert((is_same<wchar_t, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            basic_string_view() throw() __attribute__((internal_linkage));
            basic_string_view(const std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > &) throw() __attribute__((internal_linkage)) = default
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > &operator=(const std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > &) throw() __attribute__((internal_linkage)) = default
            basic_string_view(const wchar_t *__s, std::__1::basic_string_view::size_type __len) throw() __attribute__((internal_linkage));
            basic_string_view(const wchar_t *__s) __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_iterator begin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_iterator end() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_iterator cbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_iterator cend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_reverse_iterator rbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_reverse_iterator rend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_reverse_iterator crbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_reverse_iterator crend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view::size_type size() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view::size_type length() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view::size_type max_size() const throw() __attribute__((internal_linkage));
            bool empty() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_reference operator[](std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_reference at(std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_reference front() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_reference back() const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::const_pointer data() const throw() __attribute__((internal_linkage));
            void remove_prefix(std::__1::basic_string_view::size_type __n) throw() __attribute__((internal_linkage));
            void remove_suffix(std::__1::basic_string_view::size_type __n) throw() __attribute__((internal_linkage));
            void swap(std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > &__other) throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type copy(wchar_t *__s, std::__1::basic_string_view::size_type __n, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > substr(std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            int compare(std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __sv) const throw();
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __sv) const __attribute__((internal_linkage));
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __sv, std::__1::basic_string_view::size_type __pos2, std::__1::basic_string_view::size_type __n2) const __attribute__((internal_linkage));
            int compare(const wchar_t *__s) const throw() __attribute__((internal_linkage));
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, const wchar_t *__s) const __attribute__((internal_linkage));
            int compare(std::__1::basic_string_view::size_type __pos1, std::__1::basic_string_view::size_type __n1, const wchar_t *__s, std::__1::basic_string_view::size_type __n2) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find(std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find(wchar_t __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find(const wchar_t *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find(const wchar_t *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type rfind(std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type rfind(wchar_t __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type rfind(const wchar_t *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type rfind(const wchar_t *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_first_of(std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_first_of(wchar_t __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_first_of(const wchar_t *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_first_of(const wchar_t *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_last_of(std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_last_of(wchar_t __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_last_of(const wchar_t *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_last_of(const wchar_t *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_first_not_of(std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_first_not_of(wchar_t __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_first_not_of(const wchar_t *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_first_not_of(const wchar_t *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_last_not_of(std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __s, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_last_not_of(wchar_t __c, std::__1::basic_string_view::size_type __pos) const throw() __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_last_not_of(const wchar_t *__s, std::__1::basic_string_view::size_type __pos, std::__1::basic_string_view::size_type __n) const __attribute__((internal_linkage));
            std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::size_type find_last_not_of(const wchar_t *__s, std::__1::basic_string_view::size_type __pos) const __attribute__((internal_linkage));
        private:
            const std::__1::basic_string_view<wchar_t, std::__1::char_traits<wchar_t> >::value_type *__data;
            std::__1::basic_string_view::size_type __size;
        };
        template <class _CharT, class _Traits> bool operator==(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__lhs.size() != __rhs.size())
                return false;
            return __lhs.compare(__rhs) == 0;
        }
        template <class _CharT, class _Traits> bool operator==(basic_string_view<_CharT, _Traits> __lhs, typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__lhs.size() != __rhs.size())
                return false;
            return __lhs.compare(__rhs) == 0;
        }
        template <class _CharT, class _Traits> bool operator==(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__lhs.size() != __rhs.size())
                return false;
            return __lhs.compare(__rhs) == 0;
        }
        template <class _CharT, class _Traits> bool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__lhs.size() != __rhs.size())
                return true;
            return __lhs.compare(__rhs) != 0;
        }
        template <class _CharT, class _Traits> bool operator!=(basic_string_view<_CharT, _Traits> __lhs, typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__lhs.size() != __rhs.size())
                return true;
            return __lhs.compare(__rhs) != 0;
        }
        template <class _CharT, class _Traits> bool operator!=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__lhs.size() != __rhs.size())
                return true;
            return __lhs.compare(__rhs) != 0;
        }
        template <class _CharT, class _Traits> bool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) < 0;
        }
        template <class _CharT, class _Traits> bool operator<(basic_string_view<_CharT, _Traits> __lhs, typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) < 0;
        }
        template <class _CharT, class _Traits> bool operator<(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) < 0;
        }
        template <class _CharT, class _Traits> bool operator>(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) > 0;
        }
        template <class _CharT, class _Traits> bool operator>(basic_string_view<_CharT, _Traits> __lhs, typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) > 0;
        }
        template <class _CharT, class _Traits> bool operator>(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) > 0;
        }
        template <class _CharT, class _Traits> bool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) <= 0;
        }
        template <class _CharT, class _Traits> bool operator<=(basic_string_view<_CharT, _Traits> __lhs, typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) <= 0;
        }
        template <class _CharT, class _Traits> bool operator<=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) <= 0;
        }
        template <class _CharT, class _Traits> bool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) >= 0;
        }
        template <class _CharT, class _Traits> bool operator>=(basic_string_view<_CharT, _Traits> __lhs, typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) >= 0;
        }
        template <class _CharT, class _Traits> bool operator>=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) >= 0;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, basic_string_view<_CharT, _Traits> __str);
        typedef basic_string_view<char> string_view;
        typedef basic_string_view<char16_t> u16string_view;
        typedef basic_string_view<char32_t> u32string_view;
        typedef basic_string_view<wchar_t> wstring_view;
        template <class _CharT> struct __attribute__((type_visibility("default"))) hash<basic_string_view<_CharT, char_traits<_CharT> >> : public unary_function<basic_string_view<_CharT, char_traits<_CharT> >, size_t> {
            size_t operator()(const basic_string_view<_CharT, char_traits<_CharT> > __val) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __do_string_hash(__val.data(), __val.data() + __val.size());
            }
        };
    }
}
namespace std {
    inline namespace __1 {
        using ::isalnum;
        using ::isalpha;
        using ::isblank;
        using ::iscntrl;
        using ::isdigit;
        using ::isgraph;
        using ::islower;
        using ::isprint;
        using ::ispunct;
        using ::isspace;
        using ::isupper;
        using ::isxdigit;
        using ::tolower;
        using ::toupper;
    }
}
typedef __darwin_wctrans_t wctrans_t;
inline int iswblank(wint_t _wc) {
    return (__istype(_wc, 131072L));
}
inline int iswascii(wint_t _wc) {
    return ((_wc & ~127) == 0);
}
inline int iswhexnumber(wint_t _wc) {
    return (__istype(_wc, 65536L));
}
inline int iswideogram(wint_t _wc) {
    return (__istype(_wc, 524288L));
}
inline int iswnumber(wint_t _wc) {
    return (__istype(_wc, 1024L));
}
inline int iswphonogram(wint_t _wc) {
    return (__istype(_wc, 2097152L));
}
inline int iswrune(wint_t _wc) {
    return (__istype(_wc, 4294967280L));
}
inline int iswspecial(wint_t _wc) {
    return (__istype(_wc, 1048576L));
}
extern "C" {
    wint_t nextwctype(wint_t, wctype_t);
    wint_t towctrans(wint_t, wctrans_t);
    wctrans_t wctrans(const char *);
}
namespace std {
    inline namespace __1 {
        using ::wint_t;
        using ::wctrans_t;
        using ::wctype_t;
        using ::iswalnum;
        using ::iswalpha;
        using ::iswblank;
        using ::iswcntrl;
        using ::iswdigit;
        using ::iswgraph;
        using ::iswlower;
        using ::iswprint;
        using ::iswpunct;
        using ::iswspace;
        using ::iswupper;
        using ::iswxdigit;
        using ::iswctype;
        using ::wctype;
        using ::towlower;
        using ::towupper;
        using ::towctrans;
        using ::wctrans;
    }
}
namespace std {
    inline namespace __1 {
        using ::mbstate_t;
        using ::size_t;
        using ::tm;
        using ::wint_t;
        using ::FILE;
        using ::fwprintf;
        using ::fwscanf;
        using ::swprintf;
        using ::vfwprintf;
        using ::vswprintf;
        using ::swscanf;
        using ::vfwscanf;
        using ::vswscanf;
        using ::fgetwc;
        using ::fgetws;
        using ::fputwc;
        using ::fputws;
        using ::fwide;
        using ::getwc;
        using ::putwc;
        using ::ungetwc;
        using ::wcstod;
        using ::wcstof;
        using ::wcstold;
        using ::wcstol;
        using ::wcstoll;
        using ::wcstoul;
        using ::wcstoull;
        using ::wcscpy;
        using ::wcsncpy;
        using ::wcscat;
        using ::wcsncat;
        using ::wcscmp;
        using ::wcscoll;
        using ::wcsncmp;
        using ::wcsxfrm;
        using ::wcschr;
        using ::wcspbrk;
        using ::wcsrchr;
        using ::wcsstr;
        using ::wmemchr;
        using ::wcscspn;
        using ::wcslen;
        using ::wcsspn;
        using ::wcstok;
        using ::wmemcmp;
        using ::wmemcpy;
        using ::wmemmove;
        using ::wmemset;
        using ::wcsftime;
        using ::btowc;
        using ::wctob;
        using ::mbsinit;
        using ::mbrlen;
        using ::mbrtowc;
        using ::wcrtomb;
        using ::mbsrtowcs;
        using ::wcsrtombs;
        using ::getwchar;
        using ::vwscanf;
        using ::wscanf;
        using ::putwchar;
        using ::vwprintf;
        using ::wprintf;
    }
}
namespace std {
    inline namespace __1 {
        template <class _StateT> class __attribute__((type_visibility("default"))) fpos {
        private:
            _StateT __st_;
            std::__1::streamoff __off_;
        public:
            fpos<_State>(std::__1::streamoff __off = std::__1::streamoff()) : __st_(), __off_(__off) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            operator streamoff() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__off_;
            }
            _StateT state() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__st_;
            }
            void state(_StateT __st) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__st_ = __st;
            }
            fpos<_State> &operator+=(std::__1::streamoff __off) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__off_ += __off;
                return *this;
            }
            fpos<_State> operator+(std::__1::streamoff __off) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                fpos<_State> __t(*this);
                __t += __off;
                return __t;
            }
            fpos<_State> &operator-=(std::__1::streamoff __off) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__off_ -= __off;
                return *this;
            }
            fpos<_State> operator-(std::__1::streamoff __off) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                fpos<_State> __t(*this);
                __t -= __off;
                return __t;
            }
        };
        template <class _StateT> inline std::__1::streamoff operator-(const fpos<_StateT> &__x, const fpos<_StateT> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::streamoff(__x) - std::__1::streamoff(__y);
        }
        template <class _StateT> inline bool operator==(const fpos<_StateT> &__x, const fpos<_StateT> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::streamoff(__x) == std::__1::streamoff(__y);
        }
        template <class _StateT> inline bool operator!=(const fpos<_StateT> &__x, const fpos<_StateT> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::streamoff(__x) != std::__1::streamoff(__y);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, const basic_string<_CharT, _Traits, _Allocator> &__y);
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const _CharT *__x, const basic_string<_CharT, _Traits, _Allocator> &__y);
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(_CharT __x, const basic_string<_CharT, _Traits, _Allocator> &__y);
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, const _CharT *__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, _CharT __y);
        template <bool> class __attribute__((type_visibility("default"))) __basic_string_common {
        protected:
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
        template <bool __b> void __basic_string_common<__b>::__throw_length_error() const         {
            std::__1::__throw_length_error("basic_string");
        }
        template <bool __b> void __basic_string_common<__b>::__throw_out_of_range() const         {
            std::__1::__throw_out_of_range("basic_string");
        }
        template<> class __attribute__((visibility("default"))) __basic_string_common<true> {
        protected:
            void __throw_length_error() const;
            void __throw_out_of_range() const;
        };
        template <class _Iter> struct __libcpp_string_gets_noexcept_iterator_impl : public std::__1::false_type {
        };
        template <class _Iter> struct __libcpp_string_gets_noexcept_iterator : public integral_constant<bool, (__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value)> {
        };
        template <class _CharT, class _Traits, class _Tp> struct __can_be_converted_to_string_view : public integral_constant<bool, ((is_convertible<const _Tp &, basic_string_view<_CharT, _Traits> >::value && !is_convertible<const _Tp &, const _CharT *>::value))> {
        };
template<> struct __can_be_converted_to_string_view<char, std::__1::char_traits<char>, std::__1::basic_string<char>> : public integral_constant<bool, ((is_convertible<const basic_string<char> &, basic_string_view<char, char_traits<char> > >::value && !is_convertible<const basic_string<char> &, const char *>::value))> {
        };
template<> struct __can_be_converted_to_string_view<wchar_t, std::__1::char_traits<wchar_t>, std::__1::basic_string<wchar_t>> : public integral_constant<bool, ((is_convertible<const basic_string<wchar_t> &, basic_string_view<wchar_t, char_traits<wchar_t> > >::value && !is_convertible<const basic_string<wchar_t> &, const wchar_t *>::value))> {
        };
template<> struct __can_be_converted_to_string_view<char, std::__1::char_traits<char>, char [128]> : public integral_constant<bool, ((is_convertible<char const &[128], basic_string_view<char, char_traits<char> > >::value && !is_convertible<char const &[128], const char *>::value))> {
        };
template<> struct __can_be_converted_to_string_view<char, std::__1::char_traits<char>, char [19]> : public integral_constant<bool, ((is_convertible<char const &[19], basic_string_view<char, char_traits<char> > >::value && !is_convertible<char const &[19], const char *>::value))> {
        };
template<> struct __can_be_converted_to_string_view<char, std::__1::char_traits<char>, char [33]> : public integral_constant<bool, ((is_convertible<char const &[33], basic_string_view<char, char_traits<char> > >::value && !is_convertible<char const &[33], const char *>::value))> {
        };
template<> struct __can_be_converted_to_string_view<char, std::__1::char_traits<char>, const char *> : public integral_constant<bool, ((is_convertible<const char *const &, basic_string_view<char, char_traits<char> > >::value && !is_convertible<const char *const &, const char *>::value))> {
        };
template<> struct __can_be_converted_to_string_view<char, std::__1::char_traits<char>, std::__1::allocator<char>> : public integral_constant<bool, ((is_convertible<const allocator<char> &, basic_string_view<char, char_traits<char> > >::value && !is_convertible<const allocator<char> &, const char *>::value))> {
        };
template<> struct __can_be_converted_to_string_view<char, std::__1::char_traits<char>, long> : public integral_constant<bool, ((is_convertible<const long &, basic_string_view<char, char_traits<char> > >::value && !is_convertible<const long &, const char *>::value))> {
        };
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_string : private __basic_string_common<true> {
        public:
            typedef basic_string<_CharT, _Traits, _Allocator> __self;
            typedef basic_string_view<_CharT, _Traits> __self_view;
            typedef _Traits traits_type;
            typedef _CharT value_type;
            typedef _Allocator allocator_type;
            typedef allocator_traits<std::__1::basic_string::allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef std::__1::basic_string::value_type &reference;
            typedef const std::__1::basic_string::value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
            static_assert((is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
            static_assert((is_trivial<value_type>::value), "Character type of basic_string must be trivial");
            static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<std::__1::basic_string::pointer> iterator;
            typedef __wrap_iter<std::__1::basic_string::const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                std::__1::basic_string::size_type __cap_;
                std::__1::basic_string::size_type __size_;
                std::__1::basic_string::pointer __data_;
            };
            static const std::__1::basic_string::size_type __short_mask = 1;
            static const std::__1::basic_string::size_type __long_mask = 1UL;
            enum  {
                __min_cap = (sizeof(std::__1::basic_string::__long) - 1) / sizeof(std::__1::basic_string::value_type) > 2 ? (sizeof(std::__1::basic_string::__long) - 1) / sizeof(std::__1::basic_string::value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    std::__1::basic_string::value_type __lx;
                };
                std::__1::basic_string::value_type __data_[__min_cap];
            };
            union __ulx {
                std::__1::basic_string::__long __lx;
                std::__1::basic_string::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string::__ulx) / sizeof(std::__1::basic_string::size_type)
            };
            struct __raw {
                std::__1::basic_string::size_type __words[__n_words];
            };
            struct __rep {
                union {
                    std::__1::basic_string::__long __l;
                    std::__1::basic_string::__short __s;
                    std::__1::basic_string::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string::__rep, std::__1::basic_string::allocator_type> __r_;
        public:
            static const std::__1::basic_string::size_type npos = -1;
            basic_string<_CharT, _Traits, _Allocator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit basic_string<_CharT, _Traits, _Allocator>(const std::__1::basic_string::allocator_type &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str);
            basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, const std::__1::basic_string::allocator_type &__a);
            template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type> basic_string<_CharT, _Traits, _Allocator>(const _CharT *__s) : __r_(std::__1::__default_init_tag(), std::__1::__default_init_tag()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ((void)0);
                __init(__s, traits_type::length(__s));
            }
            template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type> basic_string<_CharT, _Traits, _Allocator>(const _CharT *__s, const _Allocator &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_string<_CharT, _Traits, _Allocator>(const _CharT *__s, std::__1::basic_string::size_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_string<_CharT, _Traits, _Allocator>(const _CharT *__s, std::__1::basic_string::size_type __n, const _Allocator &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_string<_CharT, _Traits, _Allocator>(std::__1::basic_string::size_type __n, _CharT __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type> basic_string<_CharT, _Traits, _Allocator>(std::__1::basic_string::size_type __n, _CharT __c, const _Allocator &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n, const _Allocator &__a = _Allocator());
            basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos, const _Allocator &__a = _Allocator()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type> inline basic_string<_CharT, _Traits, _Allocator>(const _Tp &__t, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n, const std::__1::basic_string::allocator_type &__a = std::__1::basic_string::allocator_type()) __attribute__((visibility("hidden")));
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type> inline explicit basic_string<_CharT, _Traits, _Allocator>(const _Tp &__t) __attribute__((visibility("hidden")));
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type> inline explicit basic_string<_CharT, _Traits, _Allocator>(const _Tp &__t, const std::__1::basic_string::allocator_type &__a) __attribute__((visibility("hidden")));
            template <class _InputIterator, class = typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value>::type> basic_string<_CharT, _Traits, _Allocator>(_InputIterator __first, _InputIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _InputIterator, class = typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value>::type> basic_string<_CharT, _Traits, _Allocator>(_InputIterator __first, _InputIterator __last, const std::__1::basic_string::allocator_type &__a) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline ~basic_string<_CharT, _Traits, _Allocator>();
            operator __self_view() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string::__self_view(this->data(), this->size());
            }
            basic_string<_CharT, _Traits, _Allocator> &operator=(const basic_string<_CharT, _Traits, _Allocator> &__str);
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type> basic_string<_CharT, _Traits, _Allocator> &operator=(const _Tp &__t)             {
                std::__1::basic_string::__self_view __sv = __t;
                return assign(__sv);
            }
            basic_string<_CharT, _Traits, _Allocator> &operator=(const std::__1::basic_string::value_type *__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return assign(__s);
            }
            basic_string<_CharT, _Traits, _Allocator> &operator=(std::__1::basic_string::value_type __c);
            std::__1::basic_string::iterator begin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string::iterator(__get_pointer());
            }
            std::__1::basic_string::const_iterator begin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string::const_iterator(__get_pointer());
            }
            std::__1::basic_string::iterator end() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string::iterator(__get_pointer() + this->size());
            }
            std::__1::basic_string::const_iterator end() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string::const_iterator(__get_pointer() + this->size());
            }
            std::__1::basic_string::reverse_iterator rbegin() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string::reverse_iterator(end());
            }
            std::__1::basic_string::const_reverse_iterator rbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string::const_reverse_iterator(end());
            }
            std::__1::basic_string::reverse_iterator rend() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string::reverse_iterator(begin());
            }
            std::__1::basic_string::const_reverse_iterator rend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::basic_string::const_reverse_iterator(begin());
            }
            std::__1::basic_string::const_iterator cbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return begin();
            }
            std::__1::basic_string::const_iterator cend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return end();
            }
            std::__1::basic_string::const_reverse_iterator crbegin() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rbegin();
            }
            std::__1::basic_string::const_reverse_iterator crend() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return rend();
            }
            std::__1::basic_string::size_type size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__is_long() ? this->__get_long_size() : this->__get_short_size();
            }
            std::__1::basic_string::size_type length() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->size();
            }
            std::__1::basic_string::size_type max_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type capacity() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (this->__is_long() ? this->__get_long_cap() : static_cast<std::__1::basic_string::size_type>(__min_cap)) - 1;
            }
            void resize(std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c);
            void resize(std::__1::basic_string::size_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                resize(__n, std::__1::basic_string::value_type());
            }
            void reserve(std::__1::basic_string::size_type __res_arg);
            void __resize_default_init(std::__1::basic_string::size_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void reserve() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                reserve(0);
            }
            void shrink_to_fit() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                reserve();
            }
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool empty() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->size() == 0;
            }
            std::__1::basic_string::const_reference operator[](std::__1::basic_string::size_type __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::reference operator[](std::__1::basic_string::size_type __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::const_reference at(std::__1::basic_string::size_type __n) const;
            std::__1::basic_string::reference at(std::__1::basic_string::size_type __n);
            basic_string<_CharT, _Traits, _Allocator> &operator+=(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return append(__str);
            }
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type operator+=(const _Tp &__t) __attribute__((visibility("hidden")))             {
                std::__1::basic_string::__self_view __sv = __t;
                return append(__sv);
            }
            basic_string<_CharT, _Traits, _Allocator> &operator+=(const std::__1::basic_string::value_type *__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return append(__s);
            }
            basic_string<_CharT, _Traits, _Allocator> &operator+=(std::__1::basic_string::value_type __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->push_back(__c);
                return *this;
            }
            basic_string<_CharT, _Traits, _Allocator> &append(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type append(const _Tp &__t) __attribute__((visibility("hidden")))             {
                std::__1::basic_string::__self_view __sv = __t;
                return append(__sv.data(), __sv.size());
            }
            basic_string<_CharT, _Traits, _Allocator> &append(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n = npos);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type append(const _Tp &__t, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n = npos) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &append(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n);
            basic_string<_CharT, _Traits, _Allocator> &append(const std::__1::basic_string::value_type *__s);
            basic_string<_CharT, _Traits, _Allocator> &append(std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c);
            void __append_default_init(std::__1::basic_string::size_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _ForwardIterator> inline basic_string<_CharT, _Traits, _Allocator> &__append_forward_unsafe(_ForwardIterator, _ForwardIterator) __attribute__((visibility("hidden")));
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type append(_InputIterator __first, _InputIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                const basic_string<_CharT, _Traits, _Allocator> __temp(__first, __last, __alloc());
                append(__temp.data(), __temp.size());
                return *this;
            }
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type append(_ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __append_forward_unsafe(__first, __last);
            }
            void push_back(std::__1::basic_string::value_type __c);
            void pop_back() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::reference front() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::const_reference front() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::reference back() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::const_reference back() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type assign(const _Tp &__t) __attribute__((visibility("hidden")))             {
                std::__1::basic_string::__self_view __sv = __t;
                return assign(__sv.data(), __sv.size());
            }
            basic_string<_CharT, _Traits, _Allocator> &assign(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this = __str;
            }
            basic_string<_CharT, _Traits, _Allocator> &assign(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n = npos);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type assign(const _Tp &__t, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n = npos) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &assign(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n);
            basic_string<_CharT, _Traits, _Allocator> &assign(const std::__1::basic_string::value_type *__s);
            basic_string<_CharT, _Traits, _Allocator> &assign(std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c);
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type assign(_InputIterator __first, _InputIterator __last) __attribute__((visibility("hidden")));
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type assign(_ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &insert(std::__1::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type insert(std::__1::basic_string::size_type __pos1, const _Tp &__t) __attribute__((visibility("hidden")))             {
                std::__1::basic_string::__self_view __sv = __t;
                return insert(__pos1, __sv.data(), __sv.size());
            }
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type insert(std::__1::basic_string::size_type __pos1, const _Tp &__t, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n = npos) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &insert(std::__1::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n = npos);
            basic_string<_CharT, _Traits, _Allocator> &insert(std::__1::basic_string::size_type __pos, const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n);
            basic_string<_CharT, _Traits, _Allocator> &insert(std::__1::basic_string::size_type __pos, const std::__1::basic_string::value_type *__s);
            basic_string<_CharT, _Traits, _Allocator> &insert(std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c);
            std::__1::basic_string::iterator insert(std::__1::basic_string::const_iterator __pos, std::__1::basic_string::value_type __c);
            std::__1::basic_string::iterator insert(std::__1::basic_string::const_iterator __pos, std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, iterator>::type insert(std::__1::basic_string::const_iterator __pos, _InputIterator __first, _InputIterator __last) __attribute__((visibility("hidden")));
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, iterator>::type insert(std::__1::basic_string::const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &erase(std::__1::basic_string::size_type __pos = 0, std::__1::basic_string::size_type __n = npos);
            std::__1::basic_string::iterator erase(std::__1::basic_string::const_iterator __pos) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::iterator erase(std::__1::basic_string::const_iterator __first, std::__1::basic_string::const_iterator __last) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_string<_CharT, _Traits, _Allocator> &replace(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type replace(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const _Tp &__t) __attribute__((visibility("hidden")))             {
                std::__1::basic_string::__self_view __sv = __t;
                return replace(__pos1, __n1, __sv.data(), __sv.size());
            }
            basic_string<_CharT, _Traits, _Allocator> &replace(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n2 = npos);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type replace(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const _Tp &__t, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n2 = npos) __attribute__((visibility("hidden")));
            basic_string<_CharT, _Traits, _Allocator> &replace(std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n1, const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n2);
            basic_string<_CharT, _Traits, _Allocator> &replace(std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n1, const std::__1::basic_string::value_type *__s);
            basic_string<_CharT, _Traits, _Allocator> &replace(std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n1, std::__1::basic_string::size_type __n2, std::__1::basic_string::value_type __c);
            basic_string<_CharT, _Traits, _Allocator> &replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, const _Tp &__t) __attribute__((visibility("hidden")))             {
                std::__1::basic_string::__self_view __sv = __t;
                return replace(__i1 - begin(), __i2 - __i1, __sv);
            }
            basic_string<_CharT, _Traits, _Allocator> &replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_string<_CharT, _Traits, _Allocator> &replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, const std::__1::basic_string::value_type *__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_string<_CharT, _Traits, _Allocator> &replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _InputIterator> inline typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, _InputIterator __j1, _InputIterator __j2) __attribute__((visibility("hidden")));
            std::__1::basic_string::size_type copy(std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n, std::__1::basic_string::size_type __pos = 0) const;
            basic_string<_CharT, _Traits, _Allocator> substr(std::__1::basic_string::size_type __pos = 0, std::__1::basic_string::size_type __n = npos) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void swap(basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            const std::__1::basic_string::value_type *c_str() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->data();
            }
            const std::__1::basic_string::value_type *data() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__to_address(__get_pointer());
            }
            std::__1::basic_string::allocator_type get_allocator() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __alloc();
            }
            std::__1::basic_string::size_type find(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, size_type>::type find(const _Tp &__t, std::__1::basic_string::size_type __pos = 0) const __attribute__((visibility("hidden")));
            std::__1::basic_string::size_type find(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw();
            std::__1::basic_string::size_type find(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type find(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = 0) const throw();
            std::__1::basic_string::size_type rfind(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, size_type>::type rfind(const _Tp &__t, std::__1::basic_string::size_type __pos = npos) const __attribute__((visibility("hidden")));
            std::__1::basic_string::size_type rfind(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw();
            std::__1::basic_string::size_type rfind(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type rfind(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = npos) const throw();
            std::__1::basic_string::size_type find_first_of(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, size_type>::type find_first_of(const _Tp &__t, std::__1::basic_string::size_type __pos = 0) const __attribute__((visibility("hidden")));
            std::__1::basic_string::size_type find_first_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw();
            std::__1::basic_string::size_type find_first_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type find_first_of(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type find_last_of(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, size_type>::type find_last_of(const _Tp &__t, std::__1::basic_string::size_type __pos = npos) const __attribute__((visibility("hidden")));
            std::__1::basic_string::size_type find_last_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw();
            std::__1::basic_string::size_type find_last_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type find_last_of(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type find_first_not_of(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, size_type>::type find_first_not_of(const _Tp &__t, std::__1::basic_string::size_type __pos = 0) const __attribute__((visibility("hidden")));
            std::__1::basic_string::size_type find_first_not_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw();
            std::__1::basic_string::size_type find_first_not_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type find_first_not_of(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = 0) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type find_last_not_of(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, size_type>::type find_last_not_of(const _Tp &__t, std::__1::basic_string::size_type __pos = npos) const __attribute__((visibility("hidden")));
            std::__1::basic_string::size_type find_last_not_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw();
            std::__1::basic_string::size_type find_last_not_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_string::size_type find_last_not_of(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = npos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            int compare(const basic_string<_CharT, _Traits, _Allocator> &__str) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type compare(const _Tp &__t) const __attribute__((visibility("hidden")));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const _Tp &__t) const __attribute__((visibility("hidden")));
            int compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            int compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n2 = npos) const;
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const _Tp &__t, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n2 = npos) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            int compare(const std::__1::basic_string::value_type *__s) const throw();
            int compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const std::__1::basic_string::value_type *__s) const;
            int compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n2) const;
            bool __invariants() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __clear_and_shrink() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool __is_long() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return bool(this->__r_.first().__s.__size_ & __short_mask);
            }
        private:
            std::__1::basic_string::allocator_type &__alloc() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__r_.second();
            }
            const std::__1::basic_string::allocator_type &__alloc() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__r_.second();
            }
            void __set_short_size(std::__1::basic_string::size_type __s) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__r_.first().__s.__size_ = (unsigned char)(__s << 1);
            }
            std::__1::basic_string::size_type __get_short_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__r_.first().__s.__size_ >> 1;
            }
            void __set_long_size(std::__1::basic_string::size_type __s) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__r_.first().__l.__size_ = __s;
            }
            std::__1::basic_string::size_type __get_long_size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__size_;
            }
            void __set_size(std::__1::basic_string::size_type __s) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__is_long())
                    this->__set_long_size(__s);
                else
                    this->__set_short_size(__s);
            }
            void __set_long_cap(std::__1::basic_string::size_type __s) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__r_.first().__l.__cap_ = __long_mask | __s;
            }
            std::__1::basic_string::size_type __get_long_cap() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__cap_ & std::__1::basic_string::size_type(~__long_mask);
            }
            void __set_long_pointer(std::__1::basic_string::pointer __p) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__r_.first().__l.__data_ = __p;
            }
            std::__1::basic_string::pointer __get_long_pointer() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__data_;
            }
            std::__1::basic_string::const_pointer __get_long_pointer() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__data_;
            }
            std::__1::basic_string::pointer __get_short_pointer() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return pointer_traits<pointer>::pointer_to(this->__r_.first().__s.__data_[0]);
            }
            std::__1::basic_string::const_pointer __get_short_pointer() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return pointer_traits<const_pointer>::pointer_to(this->__r_.first().__s.__data_[0]);
            }
            std::__1::basic_string::pointer __get_pointer() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__is_long() ? __get_long_pointer() : __get_short_pointer();
            }
            std::__1::basic_string::const_pointer __get_pointer() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__is_long() ? __get_long_pointer() : __get_short_pointer();
            }
            void __zero() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::basic_string::size_type (&__a)[__n_words] = this->__r_.first().__r.__words;
                for (unsigned int __i = 0; __i < __n_words; ++__i)
                    __a[__i] = 0;
            }
            template <std::__1::basic_string::size_type __a> static std::__1::basic_string::size_type __align_it(std::__1::basic_string::size_type __s) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return (__s + (__a - 1)) & ~(__a - 1);
            }
            enum  {
                __alignment = 16
            };
            static std::__1::basic_string::size_type __recommend(std::__1::basic_string::size_type __s) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__s < __min_cap)
                    return static_cast<std::__1::basic_string::size_type>(__min_cap) - 1;
                std::__1::basic_string::size_type __guess = __align_it<sizeof(std::__1::basic_string::value_type) < __alignment ? __alignment / sizeof(std::__1::basic_string::value_type) : 1>(__s + 1) - 1;
                if (__guess == __min_cap)
                    ++__guess;
                return __guess;
            }
            inline void __init(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __sz, std::__1::basic_string::size_type __reserve);
            inline void __init(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __sz);
            inline void __init(std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c);
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(std::__1::basic_string::size_type __old_cap, std::__1::basic_string::size_type __delta_cap, std::__1::basic_string::size_type __old_sz, std::__1::basic_string::size_type __n_copy, std::__1::basic_string::size_type __n_del, std::__1::basic_string::size_type __n_add = 0);
            void __grow_by_and_replace(std::__1::basic_string::size_type __old_cap, std::__1::basic_string::size_type __delta_cap, std::__1::basic_string::size_type __old_sz, std::__1::basic_string::size_type __n_copy, std::__1::basic_string::size_type __n_del, std::__1::basic_string::size_type __n_add, const std::__1::basic_string::value_type *__p_new_stuff);
            void __erase_to_end(std::__1::basic_string::size_type __pos) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __copy_assign_alloc(const basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __copy_assign_alloc(__str, integral_constant<bool, __alloc_traits::propagate_on_container_copy_assignment::value>());
            }
            void __copy_assign_alloc(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__alloc() == __str.__alloc())
                    __alloc() = __str.__alloc();
                else {
                    if (!__str.__is_long()) {
                        this->__clear_and_shrink();
                        __alloc() = __str.__alloc();
                    } else {
                        std::__1::basic_string::allocator_type __a = __str.__alloc();
                        std::__1::basic_string::pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());
                        this->__clear_and_shrink();
                        __alloc() = std::__1::move(__a);
                        this->__set_long_pointer(__p);
                        this->__set_long_cap(__str.__get_long_cap());
                        this->__set_long_size(__str.size());
                    }
                }
            }
            void __copy_assign_alloc(const basic_string<_CharT, _Traits, _Allocator> &, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __move_assign_alloc(basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __move_assign_alloc(__str, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
            }
            void __move_assign_alloc(basic_string<_CharT, _Traits, _Allocator> &__c, std::__1::true_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __alloc() = std::__1::move(__c.__alloc());
            }
            void __move_assign_alloc(basic_string<_CharT, _Traits, _Allocator> &, std::__1::false_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void __invalidate_all_iterators() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __invalidate_iterators_past(std::__1::basic_string::size_type) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            friend basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &, const basic_string<_CharT, _Traits, _Allocator> &);
            friend basic_string<_CharT, _Traits, _Allocator> operator+(const std::__1::basic_string::value_type *, const basic_string<_CharT, _Traits, _Allocator> &);
            friend basic_string<_CharT, _Traits, _Allocator> operator+(std::__1::basic_string::value_type, const basic_string<_CharT, _Traits, _Allocator> &);
            friend basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &, const std::__1::basic_string::value_type *);
            friend basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &, std::__1::basic_string::value_type);
        };
        template <class _CharT, class _Traits, class _Allocator> inline void basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()         {
        }
        template <class _CharT, class _Traits, class _Allocator> inline void basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(std::__1::basic_string::size_type)         {
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>() : __r_(std::__1::__default_init_tag(), std::__1::__default_init_tag())         {
            this->__zero();
        }
        template <class _CharT, class _Traits, class _Allocator> inline explicit basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const std::__1::basic_string::allocator_type &__a) : __r_(std::__1::__default_init_tag(), __a)         {
            this->__zero();
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::__init(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __sz, std::__1::basic_string::size_type __reserve)         {
            if (__reserve > this->max_size())
                this->__throw_length_error();
            std::__1::basic_string::pointer __p;
            if (__reserve < __min_cap) {
                this->__set_short_size(__sz);
                __p = __get_short_pointer();
            } else {
                std::__1::basic_string::size_type __cap = __recommend(__reserve);
                __p = __alloc_traits::allocate(__alloc(), __cap + 1);
                this->__set_long_pointer(__p);
                this->__set_long_cap(__cap + 1);
                this->__set_long_size(__sz);
            }
            traits_type::copy(std::__1::__to_address(__p), __s, __sz);
            traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::__init(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __sz)         {
            if (__sz > this->max_size())
                this->__throw_length_error();
            std::__1::basic_string::pointer __p;
            if (__sz < __min_cap) {
                this->__set_short_size(__sz);
                __p = __get_short_pointer();
            } else {
                std::__1::basic_string::size_type __cap = __recommend(__sz);
                __p = __alloc_traits::allocate(__alloc(), __cap + 1);
                this->__set_long_pointer(__p);
                this->__set_long_cap(__cap + 1);
                this->__set_long_size(__sz);
            }
            traits_type::copy(std::__1::__to_address(__p), __s, __sz);
            traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type> basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const _CharT *__s, const _Allocator &__a) : __r_(std::__1::__default_init_tag(), __a)         {
            ((void)0);
            __init(__s, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const _CharT *__s, std::__1::basic_string::size_type __n) : __r_(std::__1::__default_init_tag(), std::__1::__default_init_tag())         {
            ((void)0);
            __init(__s, __n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const _CharT *__s, std::__1::basic_string::size_type __n, const _Allocator &__a) : __r_(std::__1::__default_init_tag(), __a)         {
            ((void)0);
            __init(__s, __n);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str) : __r_(std::__1::__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc()))         {
            if (!__str.__is_long())
                this->__r_.first().__r = __str.__r_.first().__r;
            else
                __init(std::__1::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, const std::__1::basic_string::allocator_type &__a) : __r_(std::__1::__default_init_tag(), __a)         {
            if (!__str.__is_long())
                this->__r_.first().__r = __str.__r_.first().__r;
            else
                __init(std::__1::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::__init(std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c)         {
            if (__n > this->max_size())
                this->__throw_length_error();
            std::__1::basic_string::pointer __p;
            if (__n < __min_cap) {
                this->__set_short_size(__n);
                __p = __get_short_pointer();
            } else {
                std::__1::basic_string::size_type __cap = __recommend(__n);
                __p = __alloc_traits::allocate(__alloc(), __cap + 1);
                this->__set_long_pointer(__p);
                this->__set_long_cap(__cap + 1);
                this->__set_long_size(__n);
            }
            traits_type::assign(std::__1::__to_address(__p), __n, __c);
            traits_type::assign(__p[__n], std::__1::basic_string::value_type());
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(std::__1::basic_string::size_type __n, _CharT __c) : __r_(std::__1::__default_init_tag(), std::__1::__default_init_tag())         {
            __init(__n, __c);
        }
        template <class _CharT, class _Traits, class _Allocator> template <class = typename enable_if<__is_allocator<_Allocator>::value, nullptr_t>::type> basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(std::__1::basic_string::size_type __n, _CharT __c, const _Allocator &__a) : __r_(std::__1::__default_init_tag(), __a)         {
            __init(__n, __c);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n, const _Allocator &__a = _Allocator()) : __r_(std::__1::__default_init_tag(), __a)         {
            std::__1::basic_string::size_type __str_sz = __str.size();
            if (__pos > __str_sz)
                this->__throw_out_of_range();
            __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos, const _Allocator &__a = _Allocator()) : __r_(std::__1::__default_init_tag(), __a)         {
            std::__1::basic_string::size_type __str_sz = __str.size();
            if (__pos > __str_sz)
                this->__throw_out_of_range();
            __init(__str.data() + __pos, __str_sz - __pos);
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type> basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const _Tp &__t, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n, const std::__1::basic_string::allocator_type &__a = std::__1::basic_string::allocator_type()) : __r_(std::__1::__default_init_tag(), __a)         {
            std::__1::basic_string::__self_view __sv0 = __t;
            std::__1::basic_string::__self_view __sv = __sv0.substr(__pos, __n);
            __init(__sv.data(), __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type> explicit basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const _Tp &__t) : __r_(std::__1::__default_init_tag(), std::__1::__default_init_tag())         {
            std::__1::basic_string::__self_view __sv = __t;
            __init(__sv.data(), __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type> explicit basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(const _Tp &__t, const _Allocator &__a) : __r_(std::__1::__default_init_tag(), __a)         {
            std::__1::basic_string::__self_view __sv = __t;
            __init(__sv.data(), __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _InputIterator> typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value, void>::type basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)         {
            this->__zero();
            try {
                for (; __first != __last; ++__first)
                    this->push_back(*__first);
            } catch (...) {
                if (this->__is_long())
                    __alloc_traits::deallocate(__alloc(), __get_long_pointer(), this->__get_long_cap());
                throw;
            }
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)         {
            std::__1::basic_string::size_type __sz = static_cast<std::__1::basic_string::size_type>(std::__1::distance(__first, __last));
            if (__sz > this->max_size())
                this->__throw_length_error();
            std::__1::basic_string::pointer __p;
            if (__sz < __min_cap) {
                this->__set_short_size(__sz);
                __p = __get_short_pointer();
            } else {
                std::__1::basic_string::size_type __cap = __recommend(__sz);
                __p = __alloc_traits::allocate(__alloc(), __cap + 1);
                this->__set_long_pointer(__p);
                this->__set_long_cap(__cap + 1);
                this->__set_long_size(__sz);
            }
            for (; __first != __last; ++__first , (void)++__p)
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, std::__1::basic_string::value_type());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _InputIterator, class = typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value>::type> inline basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(_InputIterator __first, _InputIterator __last) : __r_(std::__1::__default_init_tag(), std::__1::__default_init_tag())         {
            __init(__first, __last);
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _InputIterator, class = typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value>::type> inline basic_string<_CharT, _Traits, _Allocator>::basic_string<_CharT, _Traits, _Allocator>(_InputIterator __first, _InputIterator __last, const std::__1::basic_string::allocator_type &__a) : __r_(std::__1::__default_init_tag(), __a)         {
            __init(__first, __last);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>::~basic_string<_CharT, _Traits, _Allocator>()         {
            if (this->__is_long())
                __alloc_traits::deallocate(__alloc(), __get_long_pointer(), this->__get_long_cap());
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace(std::__1::basic_string::size_type __old_cap, std::__1::basic_string::size_type __delta_cap, std::__1::basic_string::size_type __old_sz, std::__1::basic_string::size_type __n_copy, std::__1::basic_string::size_type __n_del, std::__1::basic_string::size_type __n_add, const std::__1::basic_string::value_type *__p_new_stuff)         {
            std::__1::basic_string::size_type __ms = this->max_size();
            if (__delta_cap > __ms - __old_cap - 1)
                this->__throw_length_error();
            std::__1::basic_string::pointer __old_p = __get_pointer();
            std::__1::basic_string::size_type __cap = __old_cap < __ms / 2 - __alignment ? __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
            std::__1::basic_string::pointer __p = __alloc_traits::allocate(__alloc(), __cap + 1);
            this->__invalidate_all_iterators();
            if (__n_copy != 0)
                traits_type::copy(std::__1::__to_address(__p), std::__1::__to_address(__old_p), __n_copy);
            if (__n_add != 0)
                traits_type::copy(std::__1::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
            std::__1::basic_string::size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
            if (__sec_cp_sz != 0)
                traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add, std::__1::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
            if (__old_cap + 1 != __min_cap)
                __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
            this->__set_long_pointer(__p);
            this->__set_long_cap(__cap + 1);
            __old_sz = __n_copy + __n_add + __sec_cp_sz;
            this->__set_long_size(__old_sz);
            traits_type::assign(__p[__old_sz], std::__1::basic_string::value_type());
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::__grow_by(std::__1::basic_string::size_type __old_cap, std::__1::basic_string::size_type __delta_cap, std::__1::basic_string::size_type __old_sz, std::__1::basic_string::size_type __n_copy, std::__1::basic_string::size_type __n_del, std::__1::basic_string::size_type __n_add = 0)         {
            std::__1::basic_string::size_type __ms = this->max_size();
            if (__delta_cap > __ms - __old_cap)
                this->__throw_length_error();
            std::__1::basic_string::pointer __old_p = __get_pointer();
            std::__1::basic_string::size_type __cap = __old_cap < __ms / 2 - __alignment ? __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
            std::__1::basic_string::pointer __p = __alloc_traits::allocate(__alloc(), __cap + 1);
            this->__invalidate_all_iterators();
            if (__n_copy != 0)
                traits_type::copy(std::__1::__to_address(__p), std::__1::__to_address(__old_p), __n_copy);
            std::__1::basic_string::size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
            if (__sec_cp_sz != 0)
                traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add, std::__1::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
            if (__old_cap + 1 != __min_cap)
                __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
            this->__set_long_pointer(__p);
            this->__set_long_cap(__cap + 1);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::assign(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n)         {
            ((void)0);
            std::__1::basic_string::size_type __cap = this->capacity();
            if (__cap >= __n) {
                std::__1::basic_string::value_type *__p = std::__1::__to_address(__get_pointer());
                traits_type::move(__p, __s, __n);
                traits_type::assign(__p[__n], std::__1::basic_string::value_type());
                this->__set_size(__n);
                this->__invalidate_iterators_past(__n);
            } else {
                std::__1::basic_string::size_type __sz = this->size();
                this->__grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
            }
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::assign(std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c)         {
            std::__1::basic_string::size_type __cap = this->capacity();
            if (__cap < __n) {
                std::__1::basic_string::size_type __sz = this->size();
                this->__grow_by(__cap, __n - __cap, __sz, 0, __sz);
            } else
                this->__invalidate_iterators_past(__n);
            std::__1::basic_string::value_type *__p = std::__1::__to_address(__get_pointer());
            traits_type::assign(__p, __n, __c);
            traits_type::assign(__p[__n], std::__1::basic_string::value_type());
            this->__set_size(__n);
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::operator=(std::__1::basic_string::value_type __c)         {
            std::__1::basic_string::pointer __p;
            if (this->__is_long()) {
                __p = __get_long_pointer();
                this->__set_long_size(1);
            } else {
                __p = __get_short_pointer();
                this->__set_short_size(1);
            }
            traits_type::assign(*__p, __c);
            traits_type::assign(*++__p, std::__1::basic_string::value_type());
            this->__invalidate_iterators_past(1);
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string<_CharT, _Traits, _Allocator> &__str)         {
            if (this != &__str) {
                __copy_assign_alloc(__str);
                return assign(__str.data(), __str.size());
            }
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _InputIterator> typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)         {
            const basic_string<_CharT, _Traits, _Allocator> __temp(__first, __last, __alloc());
            assign(__temp.data(), __temp.size());
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)         {
            std::__1::basic_string::size_type __n = static_cast<std::__1::basic_string::size_type>(std::__1::distance(__first, __last));
            std::__1::basic_string::size_type __cap = this->capacity();
            if (__cap < __n) {
                std::__1::basic_string::size_type __sz = this->size();
                this->__grow_by(__cap, __n - __cap, __sz, 0, __sz);
            } else
                this->__invalidate_iterators_past(__n);
            std::__1::basic_string::pointer __p = __get_pointer();
            for (; __first != __last; ++__first , ++__p)
                traits_type::assign(*__p, *__first);
            traits_type::assign(*__p, std::__1::basic_string::value_type());
            this->__set_size(__n);
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n = npos)         {
            std::__1::basic_string::size_type __sz = __str.size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp &__t, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n = npos)         {
            std::__1::basic_string::__self_view __sv = __t;
            std::__1::basic_string::size_type __sz = __sv.size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            return assign(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::assign(const std::__1::basic_string::value_type *__s)         {
            ((void)0);
            return assign(__s, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::append(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n)         {
            ((void)0);
            std::__1::basic_string::size_type __cap = this->capacity();
            std::__1::basic_string::size_type __sz = this->size();
            if (__cap - __sz >= __n) {
                if (__n) {
                    std::__1::basic_string::value_type *__p = std::__1::__to_address(__get_pointer());
                    traits_type::copy(__p + __sz, __s, __n);
                    __sz += __n;
                    this->__set_size(__sz);
                    traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
                }
            } else
                this->__grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::append(std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c)         {
            if (__n) {
                std::__1::basic_string::size_type __cap = this->capacity();
                std::__1::basic_string::size_type __sz = this->size();
                if (__cap - __sz < __n)
                    this->__grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
                std::__1::basic_string::pointer __p = __get_pointer();
                traits_type::assign(std::__1::__to_address(__p) + __sz, __n, __c);
                __sz += __n;
                this->__set_size(__sz);
                traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
            }
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> inline void basic_string<_CharT, _Traits, _Allocator>::__append_default_init(std::__1::basic_string::size_type __n)         {
            if (__n) {
                std::__1::basic_string::size_type __cap = this->capacity();
                std::__1::basic_string::size_type __sz = this->size();
                if (__cap - __sz < __n)
                    this->__grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
                std::__1::basic_string::pointer __p = __get_pointer();
                __sz += __n;
                this->__set_size(__sz);
                traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
            }
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::push_back(std::__1::basic_string::value_type __c)         {
            bool __is_short = !this->__is_long();
            std::__1::basic_string::size_type __cap;
            std::__1::basic_string::size_type __sz;
            if (__is_short) {
                __cap = __min_cap - 1;
                __sz = this->__get_short_size();
            } else {
                __cap = this->__get_long_cap() - 1;
                __sz = this->__get_long_size();
            }
            if (__sz == __cap) {
                this->__grow_by(__cap, 1, __sz, __sz, 0);
                __is_short = !this->__is_long();
            }
            std::__1::basic_string::pointer __p;
            if (__is_short) {
                __p = __get_short_pointer() + __sz;
                this->__set_short_size(__sz + 1);
            } else {
                __p = __get_long_pointer() + __sz;
                this->__set_long_size(__sz + 1);
            }
            traits_type::assign(*__p, __c);
            traits_type::assign(*++__p, std::__1::basic_string::value_type());
        }
        template <class _Tp> bool __ptr_in_range(const _Tp *__p, const _Tp *__first, const _Tp *__last)         {
            return __first <= __p && __p < __last;
        }
        template <class _Tp1, class _Tp2> bool __ptr_in_range(const _Tp1 *, const _Tp2 *, const _Tp2 *)         {
            return false;
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _ForwardIterator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(_ForwardIterator __first, _ForwardIterator __last)         {
            static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value, "function requires a ForwardIterator");
            std::__1::basic_string::size_type __sz = this->size();
            std::__1::basic_string::size_type __cap = this->capacity();
            std::__1::basic_string::size_type __n = static_cast<std::__1::basic_string::size_type>(std::__1::distance(__first, __last));
            if (__n) {
                typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
                _CharRef __tmp_ref = *__first;
                if (__ptr_in_range(std::__1::addressof(__tmp_ref), this->data(), this->data() + this->size())) {
                    const basic_string<_CharT, _Traits, _Allocator> __temp(__first, __last, __alloc());
                    append(__temp.data(), __temp.size());
                } else {
                    if (__cap - __sz < __n)
                        this->__grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
                    std::__1::basic_string::pointer __p = __get_pointer() + __sz;
                    for (; __first != __last; ++__p , ++__first)
                        traits_type::assign(*__p, *__first);
                    traits_type::assign(*__p, std::__1::basic_string::value_type());
                    this->__set_size(__sz + __n);
                }
            }
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::append(const basic_string<_CharT, _Traits, _Allocator> &__str)         {
            return append(__str.data(), __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::append(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n = npos)         {
            std::__1::basic_string::size_type __sz = __str.size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type basic_string<_CharT, _Traits, _Allocator>::append(const _Tp &__t, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n = npos)         {
            std::__1::basic_string::__self_view __sv = __t;
            std::__1::basic_string::size_type __sz = __sv.size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            return append(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::append(const std::__1::basic_string::value_type *__s)         {
            ((void)0);
            return append(__s, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::size_type __pos, const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n)         {
            ((void)0);
            std::__1::basic_string::size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            std::__1::basic_string::size_type __cap = this->capacity();
            if (__cap - __sz >= __n) {
                if (__n) {
                    std::__1::basic_string::value_type *__p = std::__1::__to_address(__get_pointer());
                    std::__1::basic_string::size_type __n_move = __sz - __pos;
                    if (__n_move != 0) {
                        if (__p + __pos <= __s && __s < __p + __sz)
                            __s += __n;
                        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
                    }
                    traits_type::move(__p + __pos, __s, __n);
                    __sz += __n;
                    this->__set_size(__sz);
                    traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
                }
            } else
                this->__grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c)         {
            std::__1::basic_string::size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            if (__n) {
                std::__1::basic_string::size_type __cap = this->capacity();
                std::__1::basic_string::value_type *__p;
                if (__cap - __sz >= __n) {
                    __p = std::__1::__to_address(__get_pointer());
                    std::__1::basic_string::size_type __n_move = __sz - __pos;
                    if (__n_move != 0)
                        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
                } else {
                    this->__grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
                    __p = std::__1::__to_address(__get_long_pointer());
                }
                traits_type::assign(__p + __pos, __n, __c);
                __sz += __n;
                this->__set_size(__sz);
                traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
            }
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _InputIterator> typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, typename basic_string<_CharT, _Traits, _Allocator>::iterator>::type basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::const_iterator __pos, _InputIterator __first, _InputIterator __last)         {
            const basic_string<_CharT, _Traits, _Allocator> __temp(__first, __last, __alloc());
            return insert(__pos, __temp.data(), __temp.data() + __temp.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _ForwardIterator> typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, typename basic_string<_CharT, _Traits, _Allocator>::iterator>::type basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)         {
            std::__1::basic_string::size_type __ip = static_cast<std::__1::basic_string::size_type>(__pos - begin());
            std::__1::basic_string::size_type __n = static_cast<std::__1::basic_string::size_type>(std::__1::distance(__first, __last));
            if (__n) {
                typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
                _CharRef __tmp_char = *__first;
                if (__ptr_in_range(std::__1::addressof(__tmp_char), this->data(), this->data() + this->size())) {
                    const basic_string<_CharT, _Traits, _Allocator> __temp(__first, __last, __alloc());
                    return insert(__pos, __temp.data(), __temp.data() + __temp.size());
                }
                std::__1::basic_string::size_type __sz = this->size();
                std::__1::basic_string::size_type __cap = this->capacity();
                std::__1::basic_string::value_type *__p;
                if (__cap - __sz >= __n) {
                    __p = std::__1::__to_address(__get_pointer());
                    std::__1::basic_string::size_type __n_move = __sz - __ip;
                    if (__n_move != 0)
                        traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
                } else {
                    this->__grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
                    __p = std::__1::__to_address(__get_long_pointer());
                }
                __sz += __n;
                this->__set_size(__sz);
                traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
                for (__p += __ip; __first != __last; ++__p , ++__first)
                    traits_type::assign(*__p, *__first);
            }
            return begin() + __ip;
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Allocator> &__str)         {
            return insert(__pos1, __str.data(), __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n = npos)         {
            std::__1::basic_string::size_type __str_sz = __str.size();
            if (__pos2 > __str_sz)
                this->__throw_out_of_range();
            return insert(__pos1, __str.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::size_type __pos1, const _Tp &__t, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n = npos)         {
            std::__1::basic_string::__self_view __sv = __t;
            std::__1::basic_string::size_type __str_sz = __sv.size();
            if (__pos2 > __str_sz)
                this->__throw_out_of_range();
            return insert(__pos1, __sv.data() + __pos2, std::__1::min(__n, __str_sz - __pos2));
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::size_type __pos, const std::__1::basic_string::value_type *__s)         {
            ((void)0);
            return insert(__pos, __s, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::iterator basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::const_iterator __pos, std::__1::basic_string::value_type __c)         {
            std::__1::basic_string::size_type __ip = static_cast<std::__1::basic_string::size_type>(__pos - begin());
            std::__1::basic_string::size_type __sz = this->size();
            std::__1::basic_string::size_type __cap = this->capacity();
            std::__1::basic_string::value_type *__p;
            if (__cap == __sz) {
                this->__grow_by(__cap, 1, __sz, __ip, 0, 1);
                __p = std::__1::__to_address(__get_long_pointer());
            } else {
                __p = std::__1::__to_address(__get_pointer());
                std::__1::basic_string::size_type __n_move = __sz - __ip;
                if (__n_move != 0)
                    traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
            }
            traits_type::assign(__p[__ip], __c);
            traits_type::assign(__p[++__sz], std::__1::basic_string::value_type());
            this->__set_size(__sz);
            return begin() + static_cast<std::__1::basic_string::difference_type>(__ip);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::iterator basic_string<_CharT, _Traits, _Allocator>::insert(std::__1::basic_string::const_iterator __pos, std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c)         {
            std::__1::basic_string::difference_type __p = __pos - begin();
            insert(static_cast<std::__1::basic_string::size_type>(__p), __n, __c);
            return begin() + __p;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n1, const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n2) __attribute__((no_sanitize("unsigned-integer-overflow")))         {
            ((void)0);
            std::__1::basic_string::size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            __n1 = std::__1::min(__n1, __sz - __pos);
            std::__1::basic_string::size_type __cap = this->capacity();
            if (__cap - __sz + __n1 >= __n2) {
                std::__1::basic_string::value_type *__p = std::__1::__to_address(__get_pointer());
                if (__n1 != __n2) {
                    std::__1::basic_string::size_type __n_move = __sz - __pos - __n1;
                    if (__n_move != 0) {
                        if (__n1 > __n2) {
                            traits_type::move(__p + __pos, __s, __n2);
                            traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                            goto __finish;
                        }
                        if (__p + __pos < __s && __s < __p + __sz) {
                            if (__p + __pos + __n1 <= __s)
                                __s += __n2 - __n1;
                            else {
                                traits_type::move(__p + __pos, __s, __n1);
                                __pos += __n1;
                                __s += __n2;
                                __n2 -= __n1;
                                __n1 = 0;
                            }
                        }
                        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                    }
                }
                traits_type::move(__p + __pos, __s, __n2);
              __finish:
                __sz += __n2 - __n1;
                this->__set_size(__sz);
                this->__invalidate_iterators_past(__sz);
                traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
            } else
                this->__grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n1, std::__1::basic_string::size_type __n2, std::__1::basic_string::value_type __c) __attribute__((no_sanitize("unsigned-integer-overflow")))         {
            std::__1::basic_string::size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            __n1 = std::__1::min(__n1, __sz - __pos);
            std::__1::basic_string::size_type __cap = this->capacity();
            std::__1::basic_string::value_type *__p;
            if (__cap - __sz + __n1 >= __n2) {
                __p = std::__1::__to_address(__get_pointer());
                if (__n1 != __n2) {
                    std::__1::basic_string::size_type __n_move = __sz - __pos - __n1;
                    if (__n_move != 0)
                        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
                }
            } else {
                this->__grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
                __p = std::__1::__to_address(__get_long_pointer());
            }
            traits_type::assign(__p + __pos, __n2, __c);
            __sz += __n2 - __n1;
            this->__set_size(__sz);
            this->__invalidate_iterators_past(__sz);
            traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _InputIterator> typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value, basic_string<_CharT, _Traits, _Allocator> &>::type basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, _InputIterator __j1, _InputIterator __j2)         {
            const basic_string<_CharT, _Traits, _Allocator> __temp(__j1, __j2, __alloc());
            return this->replace(__i1, __i2, __temp);
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str)         {
            return replace(__pos1, __n1, __str.data(), __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n2 = npos)         {
            std::__1::basic_string::size_type __str_sz = __str.size();
            if (__pos2 > __str_sz)
                this->__throw_out_of_range();
            return replace(__pos1, __n1, __str.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, basic_string<_CharT, _Traits, _Allocator> &>::type basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const _Tp &__t, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n2 = npos)         {
            std::__1::basic_string::__self_view __sv = __t;
            std::__1::basic_string::size_type __str_sz = __sv.size();
            if (__pos2 > __str_sz)
                this->__throw_out_of_range();
            return replace(__pos1, __n1, __sv.data() + __pos2, std::__1::min(__n2, __str_sz - __pos2));
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n1, const std::__1::basic_string::value_type *__s)         {
            ((void)0);
            return replace(__pos, __n1, __s, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, const basic_string<_CharT, _Traits, _Allocator> &__str)         {
            return replace(static_cast<std::__1::basic_string::size_type>(__i1 - begin()), static_cast<std::__1::basic_string::size_type>(__i2 - __i1), __str.data(), __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n)         {
            return replace(static_cast<std::__1::basic_string::size_type>(__i1 - begin()), static_cast<std::__1::basic_string::size_type>(__i2 - __i1), __s, __n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, const std::__1::basic_string::value_type *__s)         {
            return replace(static_cast<std::__1::basic_string::size_type>(__i1 - begin()), static_cast<std::__1::basic_string::size_type>(__i2 - __i1), __s);
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::replace(std::__1::basic_string::const_iterator __i1, std::__1::basic_string::const_iterator __i2, std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c)         {
            return replace(static_cast<std::__1::basic_string::size_type>(__i1 - begin()), static_cast<std::__1::basic_string::size_type>(__i2 - __i1), __n, __c);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> &basic_string<_CharT, _Traits, _Allocator>::erase(std::__1::basic_string::size_type __pos = 0, std::__1::basic_string::size_type __n = npos)         {
            std::__1::basic_string::size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            if (__n) {
                std::__1::basic_string::value_type *__p = std::__1::__to_address(__get_pointer());
                __n = std::__1::min(__n, __sz - __pos);
                std::__1::basic_string::size_type __n_move = __sz - __pos - __n;
                if (__n_move != 0)
                    traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
                __sz -= __n;
                this->__set_size(__sz);
                this->__invalidate_iterators_past(__sz);
                traits_type::assign(__p[__sz], std::__1::basic_string::value_type());
            }
            return *this;
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::iterator basic_string<_CharT, _Traits, _Allocator>::erase(std::__1::basic_string::const_iterator __pos)         {
            ((void)0);
            std::__1::basic_string::iterator __b = begin();
            std::__1::basic_string::size_type __r = static_cast<std::__1::basic_string::size_type>(__pos - __b);
            erase(__r, 1);
            return __b + static_cast<std::__1::basic_string::difference_type>(__r);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::iterator basic_string<_CharT, _Traits, _Allocator>::erase(std::__1::basic_string::const_iterator __first, std::__1::basic_string::const_iterator __last)         {
            ((void)0);
            std::__1::basic_string::iterator __b = begin();
            std::__1::basic_string::size_type __r = static_cast<std::__1::basic_string::size_type>(__first - __b);
            erase(__r, static_cast<std::__1::basic_string::size_type>(__last - __first));
            return __b + static_cast<std::__1::basic_string::difference_type>(__r);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void basic_string<_CharT, _Traits, _Allocator>::pop_back()         {
            ((void)0);
            std::__1::basic_string::size_type __sz;
            if (this->__is_long()) {
                __sz = this->__get_long_size() - 1;
                this->__set_long_size(__sz);
                traits_type::assign(*(__get_long_pointer() + __sz), std::__1::basic_string::value_type());
            } else {
                __sz = this->__get_short_size() - 1;
                this->__set_short_size(__sz);
                traits_type::assign(*(__get_short_pointer() + __sz), std::__1::basic_string::value_type());
            }
            this->__invalidate_iterators_past(__sz);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void basic_string<_CharT, _Traits, _Allocator>::clear() throw()         {
            this->__invalidate_all_iterators();
            if (this->__is_long()) {
                traits_type::assign(*__get_long_pointer(), std::__1::basic_string::value_type());
                this->__set_long_size(0);
            } else {
                traits_type::assign(*__get_short_pointer(), std::__1::basic_string::value_type());
                this->__set_short_size(0);
            }
        }
        template <class _CharT, class _Traits, class _Allocator> inline void basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(std::__1::basic_string::size_type __pos)         {
            if (this->__is_long()) {
                traits_type::assign(*(__get_long_pointer() + __pos), std::__1::basic_string::value_type());
                this->__set_long_size(__pos);
            } else {
                traits_type::assign(*(__get_short_pointer() + __pos), std::__1::basic_string::value_type());
                this->__set_short_size(__pos);
            }
            this->__invalidate_iterators_past(__pos);
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::resize(std::__1::basic_string::size_type __n, std::__1::basic_string::value_type __c)         {
            std::__1::basic_string::size_type __sz = this->size();
            if (__n > __sz)
                append(__n - __sz, __c);
            else
                this->__erase_to_end(__n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(std::__1::basic_string::size_type __n)         {
            std::__1::basic_string::size_type __sz = this->size();
            if (__n > __sz) {
                this->__append_default_init(__n - __sz);
            } else
                this->__erase_to_end(__n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::max_size() const throw()         {
            std::__1::basic_string::size_type __m = __alloc_traits::max_size(__alloc());
            return __m - __alignment;
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::reserve(std::__1::basic_string::size_type __res_arg)         {
            if (__res_arg > this->max_size())
                this->__throw_length_error();
            std::__1::basic_string::size_type __cap = this->capacity();
            std::__1::basic_string::size_type __sz = this->size();
            __res_arg = std::__1::max(__res_arg, __sz);
            __res_arg = __recommend(__res_arg);
            if (__res_arg != __cap) {
                std::__1::basic_string::pointer __new_data, __p;
                bool __was_long, __now_long;
                if (__res_arg == __min_cap - 1) {
                    __was_long = true;
                    __now_long = false;
                    __new_data = __get_short_pointer();
                    __p = __get_long_pointer();
                } else {
                    if (__res_arg > __cap)
                        __new_data = __alloc_traits::allocate(__alloc(), __res_arg + 1);
                    else {
                        try {
                            __new_data = __alloc_traits::allocate(__alloc(), __res_arg + 1);
                        } catch (...) {
                            return;
                        }
                    }
                    __now_long = true;
                    __was_long = this->__is_long();
                    __p = __get_pointer();
                }
                traits_type::copy(std::__1::__to_address(__new_data), std::__1::__to_address(__p), this->size() + 1);
                if (__was_long)
                    __alloc_traits::deallocate(__alloc(), __p, __cap + 1);
                if (__now_long) {
                    this->__set_long_cap(__res_arg + 1);
                    this->__set_long_size(__sz);
                    this->__set_long_pointer(__new_data);
                } else
                    this->__set_short_size(__sz);
                this->__invalidate_all_iterators();
            }
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference basic_string<_CharT, _Traits, _Allocator>::operator[](std::__1::basic_string::size_type __pos) const throw()         {
            ((void)0);
            return *(this->data() + __pos);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::reference basic_string<_CharT, _Traits, _Allocator>::operator[](std::__1::basic_string::size_type __pos) throw()         {
            ((void)0);
            return *(__get_pointer() + __pos);
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::const_reference basic_string<_CharT, _Traits, _Allocator>::at(std::__1::basic_string::size_type __n) const         {
            if (__n >= this->size())
                this->__throw_out_of_range();
            return (*this)[__n];
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::reference basic_string<_CharT, _Traits, _Allocator>::at(std::__1::basic_string::size_type __n)         {
            if (__n >= this->size())
                this->__throw_out_of_range();
            return (*this)[__n];
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::reference basic_string<_CharT, _Traits, _Allocator>::front() throw()         {
            ((void)0);
            return *__get_pointer();
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference basic_string<_CharT, _Traits, _Allocator>::front() const throw()         {
            ((void)0);
            return *this->data();
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::reference basic_string<_CharT, _Traits, _Allocator>::back() throw()         {
            ((void)0);
            return *(__get_pointer() + this->size() - 1);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference basic_string<_CharT, _Traits, _Allocator>::back() const throw()         {
            ((void)0);
            return *(this->data() + this->size() - 1);
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::copy(std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n, std::__1::basic_string::size_type __pos = 0) const         {
            std::__1::basic_string::size_type __sz = this->size();
            if (__pos > __sz)
                this->__throw_out_of_range();
            std::__1::basic_string::size_type __rlen = std::__1::min(__n, __sz - __pos);
            traits_type::copy(__s, this->data() + __pos, __rlen);
            return __rlen;
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> basic_string<_CharT, _Traits, _Allocator>::substr(std::__1::basic_string::size_type __pos = 0, std::__1::basic_string::size_type __n = npos) const         {
            return basic_string<_CharT, _Traits, _Allocator>(*this, __pos, __n, __alloc());
        }
        template <class _CharT, class _Traits, class _Allocator> inline void basic_string<_CharT, _Traits, _Allocator>::swap(basic_string<_CharT, _Traits, _Allocator> &__str)         {
            ((void)0);
            std::__1::swap(this->__r_.first(), __str.__r_.first());
            __swap_allocator(__alloc(), __str.__alloc());
        }
        template <class _Traits> struct __attribute__((visibility("hidden"))) __traits_eq {
            typedef typename _Traits::char_type char_type;
            bool operator()(const std::__1::__traits_eq::char_type &__x, const std::__1::__traits_eq::char_type &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return _Traits::eq(__x, __y);
            }
        };
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw()         {
            ((void)0);
            return __str_find<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = 0) const throw()         {
            return __str_find<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type basic_string<_CharT, _Traits, _Allocator>::find(const _Tp &__t, std::__1::basic_string::size_type __pos = 0) const         {
            std::__1::basic_string::__self_view __sv = __t;
            return __str_find<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __sv.data(), __pos, __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = 0) const throw()         {
            ((void)0);
            return __str_find<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = 0) const throw()         {
            return __str_find<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __c, __pos);
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::rfind(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw()         {
            ((void)0);
            return __str_rfind<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = npos) const throw()         {
            return __str_rfind<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp &__t, std::__1::basic_string::size_type __pos = npos) const         {
            std::__1::basic_string::__self_view __sv = __t;
            return __str_rfind<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __sv.data(), __pos, __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::rfind(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = npos) const throw()         {
            ((void)0);
            return __str_rfind<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::rfind(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = npos) const throw()         {
            return __str_rfind<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __c, __pos);
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_first_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw()         {
            ((void)0);
            return __str_find_first_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = 0) const throw()         {
            return __str_find_first_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type basic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp &__t, std::__1::basic_string::size_type __pos = 0) const         {
            std::__1::basic_string::__self_view __sv = __t;
            return __str_find_first_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __sv.data(), __pos, __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_first_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = 0) const throw()         {
            ((void)0);
            return __str_find_first_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_first_of(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = 0) const throw()         {
            return find(__c, __pos);
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_last_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw()         {
            ((void)0);
            return __str_find_last_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = npos) const throw()         {
            return __str_find_last_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp &__t, std::__1::basic_string::size_type __pos = npos) const         {
            std::__1::basic_string::__self_view __sv = __t;
            return __str_find_last_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __sv.data(), __pos, __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_last_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = npos) const throw()         {
            ((void)0);
            return __str_find_last_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_last_of(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = npos) const throw()         {
            return rfind(__c, __pos);
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw()         {
            ((void)0);
            return __str_find_first_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = 0) const throw()         {
            return __str_find_first_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp &__t, std::__1::basic_string::size_type __pos = 0) const         {
            std::__1::basic_string::__self_view __sv = __t;
            return __str_find_first_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __sv.data(), __pos, __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = 0) const throw()         {
            ((void)0);
            return __str_find_first_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = 0) const throw()         {
            return __str_find_first_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __c, __pos);
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos, std::__1::basic_string::size_type __n) const throw()         {
            ((void)0);
            return __str_find_last_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, __n);
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos = npos) const throw()         {
            return __str_find_last_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __str.data(), __pos, __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp &__t, std::__1::basic_string::size_type __pos = npos) const         {
            std::__1::basic_string::__self_view __sv = __t;
            return __str_find_last_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __sv.data(), __pos, __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __pos = npos) const throw()         {
            ((void)0);
            return __str_find_last_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> inline typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(std::__1::basic_string::value_type __c, std::__1::basic_string::size_type __pos = npos) const throw()         {
            return __str_find_last_not_of<std::__1::basic_string::value_type, std::__1::basic_string::size_type, std::__1::basic_string::traits_type, npos>(this->data(), this->size(), __c, __pos);
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp &__t) const         {
            std::__1::basic_string::__self_view __sv = __t;
            size_t __lhs_sz = this->size();
            size_t __rhs_sz = __sv.size();
            int __result = traits_type::compare(this->data(), __sv.data(), std::__1::min(__lhs_sz, __rhs_sz));
            if (__result != 0)
                return __result;
            if (__lhs_sz < __rhs_sz)
                return -1;
            if (__lhs_sz > __rhs_sz)
                return 1;
            return 0;
        }
        template <class _CharT, class _Traits, class _Allocator> inline int basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string<_CharT, _Traits, _Allocator> &__str) const throw()         {
            return compare(std::__1::basic_string::__self_view(__str));
        }
        template <class _CharT, class _Traits, class _Allocator> int basic_string<_CharT, _Traits, _Allocator>::compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const std::__1::basic_string::value_type *__s, std::__1::basic_string::size_type __n2) const         {
            ((void)0);
            std::__1::basic_string::size_type __sz = this->size();
            if (__pos1 > __sz || __n2 == npos)
                this->__throw_out_of_range();
            std::__1::basic_string::size_type __rlen = std::__1::min(__n1, __sz - __pos1);
            int __r = traits_type::compare(this->data() + __pos1, __s, std::__1::min(__rlen, __n2));
            if (__r == 0) {
                if (__rlen < __n2)
                    __r = -1;
                else if (__rlen > __n2)
                    __r = 1;
            }
            return __r;
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type basic_string<_CharT, _Traits, _Allocator>::compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const _Tp &__t) const         {
            std::__1::basic_string::__self_view __sv = __t;
            return compare(__pos1, __n1, __sv.data(), __sv.size());
        }
        template <class _CharT, class _Traits, class _Allocator> inline int basic_string<_CharT, _Traits, _Allocator>::compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str) const         {
            return compare(__pos1, __n1, __str.data(), __str.size());
        }
        template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type basic_string<_CharT, _Traits, _Allocator>::compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const _Tp &__t, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n2 = npos) const         {
            std::__1::basic_string::__self_view __sv = __t;
            return std::__1::basic_string::__self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
        }
        template <class _CharT, class _Traits, class _Allocator> int basic_string<_CharT, _Traits, _Allocator>::compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Allocator> &__str, std::__1::basic_string::size_type __pos2, std::__1::basic_string::size_type __n2 = npos) const         {
            return compare(__pos1, __n1, std::__1::basic_string::__self_view(__str), __pos2, __n2);
        }
        template <class _CharT, class _Traits, class _Allocator> int basic_string<_CharT, _Traits, _Allocator>::compare(const std::__1::basic_string::value_type *__s) const throw()         {
            ((void)0);
            return compare(0, npos, __s, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> int basic_string<_CharT, _Traits, _Allocator>::compare(std::__1::basic_string::size_type __pos1, std::__1::basic_string::size_type __n1, const std::__1::basic_string::value_type *__s) const         {
            ((void)0);
            return compare(__pos1, __n1, __s, traits_type::length(__s));
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool basic_string<_CharT, _Traits, _Allocator>::__invariants() const         {
            if (this->size() > this->capacity())
                return false;
            if (this->capacity() < __min_cap - 1)
                return false;
            if (this->data() == 0)
                return false;
            if (this->data()[this->size()] != std::__1::basic_string::value_type(0))
                return false;
            return true;
        }
        template <class _CharT, class _Traits, class _Allocator> inline void basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() throw()         {
            this->clear();
            if (this->__is_long()) {
                __alloc_traits::deallocate(__alloc(), __get_long_pointer(), this->capacity() + 1);
                this->__set_long_cap(0);
                this->__set_short_size(0);
            }
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            size_t __lhs_sz = __lhs.size();
            return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(), __rhs.data(), __lhs_sz) == 0;
        }
        template<> inline bool operator==<char, std::__1::char_traits<char>, std::__1::allocator<char>>(const basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > &__lhs, const basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > &__rhs) throw() __attribute__((internal_linkage))        template <class _Allocator> inline bool operator==(const basic_string<char, char_traits<char>, _Allocator> &__lhs, const basic_string<char, char_traits<char>, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            size_t __lhs_sz = __lhs.size();
            if (__lhs_sz != __rhs.size())
                return false;
            const char *__lp = __lhs.data();
            const char *__rp = __rhs.data();
            if (__lhs.__is_long())
                return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
            for (; __lhs_sz != 0; --__lhs_sz , ++__lp , ++__rp)
                if (*__lp != *__rp)
                    return false;
            return true;
        }
        template<> inline bool operator==<std::__1::allocator<char>>(const basic_string<char, char_traits<char>, std::__1::allocator<char> > &__lhs, const basic_string<char, char_traits<char>, std::__1::allocator<char> > &__rhs) throw() __attribute__((internal_linkage))         {
            size_t __lhs_sz = __lhs.size();
            if (__lhs_sz != __rhs.size())
                return false;
            const char *__lp = __lhs.data();
            const char *__rp = __rhs.data();
            if (__lhs.__is_long())
                return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
            for (; __lhs_sz != 0; --__lhs_sz , ++__lp , ++__rp)
                if (*__lp != *__rp)
                    return false;
            return true;
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator==(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef basic_string<_CharT, _Traits, _Allocator> _String;
            ((void)0);
            size_t __lhs_len = _Traits::length(__lhs);
            if (__lhs_len != __rhs.size())
                return false;
            return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            typedef basic_string<_CharT, _Traits, _Allocator> _String;
            ((void)0);
            size_t __rhs_len = _Traits::length(__rhs);
            if (__rhs_len != __lhs.size())
                return false;
            return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
        }
        template<> inline bool operator==<char, std::__1::char_traits<char>, std::__1::allocator<char>>(const basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > &__lhs, const char *__rhs) throw() __attribute__((internal_linkage))         {
            typedef basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > _String;
            ((void)0);
            size_t __rhs_len = char_traits<char>::length(__rhs);
            if (__rhs_len != __lhs.size())
                return false;
            return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__lhs == __rhs);
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator!=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__lhs == __rhs);
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__lhs == __rhs);
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) < 0;
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __lhs.compare(__rhs) < 0;
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __rhs.compare(__lhs) > 0;
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __rhs < __lhs;
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __rhs < __lhs;
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __rhs < __lhs;
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__rhs < __lhs);
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__rhs < __lhs);
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator<=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__rhs < __lhs);
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__lhs < __rhs);
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__lhs < __rhs);
        }
        template <class _CharT, class _Traits, class _Allocator> inline bool operator>=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__lhs < __rhs);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
            __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
            __r.append(__rhs.data(), __rhs_sz);
            return __r;
        }
        template<> std::__1::basic_string<char> operator+<>(const std::__1::basic_string<char> &__lhs, const std::__1::basic_string<char> &__rhs)         {
            basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > __r(__lhs.get_allocator());
            typename basic_string<char, char_traits<char>, allocator<char> >::size_type __lhs_sz = __lhs.size();
            typename basic_string<char, char_traits<char>, allocator<char> >::size_type __rhs_sz = __rhs.size();
            __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
            __r.append(__rhs.data(), __rhs_sz);
            return __r;
        }
        template<> std::__1::basic_string<wchar_t> operator+<>(const std::__1::basic_string<wchar_t> &, const std::__1::basic_string<wchar_t> &)        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
            __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
            __r.append(__rhs.data(), __rhs_sz);
            return __r;
        }
        template<> std::__1::basic_string<wchar_t> operator+<>(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *, const std::__1::basic_string<wchar_t> &)        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Allocator> &__rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();
            __r.__init(&__lhs, 1, 1 + __rhs_sz);
            __r.append(__rhs.data(), __rhs_sz);
            return __r;
        }
        template<> std::__1::basic_string<char> operator+<>(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type, const std::__1::basic_string<char> &)        template<> std::__1::basic_string<wchar_t> operator+<>(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type, const std::__1::basic_string<wchar_t> &)        template <class _CharT, class _Traits, class _Allocator> inline basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs, const _CharT *__rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);
            __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
            __r.append(__rhs, __rhs_sz);
            return __r;
        }
        template<> std::__1::basic_string<char> operator+<>(const std::__1::basic_string<char> &__lhs, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__rhs)         {
            basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > __r(__lhs.get_allocator());
            typename basic_string<char, char_traits<char>, allocator<char> >::size_type __lhs_sz = __lhs.size();
            typename basic_string<char, char_traits<char>, allocator<char> >::size_type __rhs_sz = char_traits<char>::length(__rhs);
            __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
            __r.append(__rhs, __rhs_sz);
            return __r;
        }
        template<> std::__1::basic_string<wchar_t> operator+<>(const std::__1::basic_string<wchar_t> &, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *)        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs, _CharT __rhs)         {
            basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
            typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();
            __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
            __r.push_back(__rhs);
            return __r;
        }
        template<> std::__1::basic_string<char> operator+<>(const std::__1::basic_string<char> &, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type)        template<> std::__1::basic_string<wchar_t> operator+<>(const std::__1::basic_string<wchar_t> &, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type)        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_string<_CharT, _Traits, _Allocator> &__lhs, basic_string<_CharT, _Traits, _Allocator> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __lhs.swap(__rhs);
        }
        typedef basic_string<char16_t> u16string;
        typedef basic_string<char32_t> u32string;
        int stoi(const std::__1::string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        long stol(const std::__1::string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        unsigned long stoul(const std::__1::string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        long long stoll(const std::__1::string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        unsigned long long stoull(const std::__1::string &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        float stof(const std::__1::string &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        double stod(const std::__1::string &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        long double stold(const std::__1::string &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        std::__1::string to_string(int __val) __attribute__((visibility("default")));
        std::__1::string to_string(unsigned int __val) __attribute__((visibility("default")));
        std::__1::string to_string(long __val) __attribute__((visibility("default")));
        std::__1::string to_string(unsigned long __val) __attribute__((visibility("default")));
        std::__1::string to_string(long long __val) __attribute__((visibility("default")));
        std::__1::string to_string(unsigned long long __val) __attribute__((visibility("default")));
        std::__1::string to_string(float __val) __attribute__((visibility("default")));
        std::__1::string to_string(double __val) __attribute__((visibility("default")));
        std::__1::string to_string(long double __val) __attribute__((visibility("default")));
        int stoi(const std::__1::wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        long stol(const std::__1::wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        unsigned long stoul(const std::__1::wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        long long stoll(const std::__1::wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        unsigned long long stoull(const std::__1::wstring &__str, size_t *__idx = 0, int __base = 10) __attribute__((visibility("default")));
        float stof(const std::__1::wstring &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        double stod(const std::__1::wstring &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        long double stold(const std::__1::wstring &__str, size_t *__idx = 0) __attribute__((visibility("default")));
        std::__1::wstring to_wstring(int __val) __attribute__((visibility("default")));
        std::__1::wstring to_wstring(unsigned int __val) __attribute__((visibility("default")));
        std::__1::wstring to_wstring(long __val) __attribute__((visibility("default")));
        std::__1::wstring to_wstring(unsigned long __val) __attribute__((visibility("default")));
        std::__1::wstring to_wstring(long long __val) __attribute__((visibility("default")));
        std::__1::wstring to_wstring(unsigned long long __val) __attribute__((visibility("default")));
        std::__1::wstring to_wstring(float __val) __attribute__((visibility("default")));
        std::__1::wstring to_wstring(double __val) __attribute__((visibility("default")));
        std::__1::wstring to_wstring(long double __val) __attribute__((visibility("default")));
        const typename basic_string<_CharT, _Traits, _Allocator>::size_type npos;
        template <class _CharT, class _Allocator> struct __attribute__((type_visibility("default"))) hash<basic_string<_CharT, char_traits<_CharT>, _Allocator>> : public unary_function<basic_string<_CharT, char_traits<_CharT>, _Allocator>, size_t> {
            size_t operator()(const basic_string<_CharT, char_traits<_CharT>, _Allocator> &__val) const throw()             {
                return __do_string_hash(__val.data(), __val.data() + __val.size());
            }
        };
        template <class _CharT, class _Traits, class _Allocator> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Allocator> &__str);
        template <class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str);
        template <class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm);
        template <class _CharT, class _Traits, class _Allocator> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template<> class __attribute__((visibility("default"))) basic_string<char> : private __basic_string_common<true> {
        public:
            typedef std::__1::basic_string<char> __self;
            typedef basic_string_view<char, std::__1::char_traits<char> > __self_view;
            typedef std::__1::char_traits<char> traits_type;
            typedef char value_type;
            typedef std::__1::allocator<char> allocator_type;
            typedef allocator_traits<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type &reference;
            typedef const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
            static_assert((is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
            static_assert((is_trivial<value_type>::value), "Character type of basic_string must be trivial");
            static_assert((is_same<char, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::pointer> iterator;
            typedef __wrap_iter<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __cap_;
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __size_;
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::pointer __data_;
            };
            static const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __short_mask = 1;
            static const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __long_mask = 1UL;
            enum  {
                __min_cap = (sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long) - 1) / sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type) > 2 ? (sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long) - 1) / sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __lx;
                };
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __data_[23];
            };
            union __ulx {
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long __lx;
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__ulx) / sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type)
            };
            struct __raw {
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __words[3];
            };
            struct __rep {
                union {
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long __l;
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__short __s;
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type> __r_;
        public:
            static const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type npos = -1;
            basic_string<char, char_traits<char>, allocator<char> >::basic_string() : __basic_string_common<true>(), __r_(std::__1::__default_init_tag(), std::__1::__default_init_tag())             {
                this->__zero();
            }
            explicit basic_string<char, char_traits<char>, allocator<char> >::basic_string(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type &__a) : __basic_string_common<true>(), __r_(std::__1::__default_init_tag(), __a)             {
                this->__zero();
            }
            basic_string(const std::__1::basic_string<char> &__str);
            basic_string(const std::__1::basic_string<char> &__str, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type &__a);
            template <class = typename enable_if<__is_allocator<allocator<char> >::value, nullptr_t>::type> basic_string(const char *__s) __attribute__((internal_linkage));
            template<> basic_string<std::__1::nullptr_t>(const char *__s) : __basic_string_common<true>(), __r_(std::__1::__default_init_tag(), std::__1::__default_init_tag()) __attribute__((internal_linkage))             {
                ((void)0);
                this->__init(__s, traits_type::length(__s));
            }
;
            template <class = typename enable_if<__is_allocator<allocator<char> >::value, nullptr_t>::type> basic_string(const char *__s, const std::__1::allocator<char> &__a);
            basic_string(const char *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            basic_string(const char *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, const std::__1::allocator<char> &__a);
            basic_string<char, char_traits<char>, allocator<char> >::basic_string(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, char __c) : __basic_string_common<true>(), __r_(std::__1::__default_init_tag(), std::__1::__default_init_tag())             {
                this->__init(__n, __c);
            }
            template <class = typename enable_if<__is_allocator<allocator<char> >::value, nullptr_t>::type> basic_string(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, char __c, const std::__1::allocator<char> &__a);
            basic_string(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, const std::__1::allocator<char> &__a);
            basic_string(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, const std::__1::allocator<char> &__a);
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, void>::type> inline basic_string(const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type &__a);
            template<> inline basic_string<std::__1::basic_string<char>, void>(const std::__1::basic_string<char> &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type &__a);
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, void>::type> inline explicit basic_string(const _Tp &__t);
            template<> inline explicit basic_string<std::__1::basic_string<char>, void>(const std::__1::basic_string<char> &__t);
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, void>::type> inline explicit basic_string(const _Tp &__t, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type &__a);
            template <class _InputIterator, class = typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value>::type> basic_string(_InputIterator __first, _InputIterator __last);
            template <class _InputIterator, class = typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value>::type> basic_string(_InputIterator __first, _InputIterator __last, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type &__a);
            inline basic_string<char, char_traits<char>, allocator<char> >::~basic_string<char>()             {
                if (this->__is_long())
                    __alloc_traits::deallocate(this->__alloc(), this->__get_long_pointer(), this->__get_long_cap());
            }
            operator __self_view() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char> &operator=(const std::__1::basic_string<char> &__str);
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, void>::type> std::__1::basic_string<char> &operator=(const _Tp &__t);
            template<> std::__1::basic_string<char> &operator=<std::__1::basic_string<char>, void>(const std::__1::basic_string<char> &__t);
            std::__1::basic_string<char> &operator=(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s) __attribute__((internal_linkage));
            std::__1::basic_string<char> &operator=(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c);
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::iterator begin() throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator begin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::iterator end() throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator end() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::reverse_iterator rbegin() throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_reverse_iterator rbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::reverse_iterator rend() throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_reverse_iterator rend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator cbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator cend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_reverse_iterator crbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_reverse_iterator crend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type size() const throw() __attribute__((internal_linkage))             {
                return this->__is_long() ? this->__get_long_size() : this->__get_short_size();
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type length() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type basic_string<char, char_traits<char>, allocator<char> >::max_size() const throw()             {
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __m = __alloc_traits::max_size(this->__alloc());
                return __m - __alignment;
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type capacity() const throw() __attribute__((internal_linkage));
            void resize(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c);
            void resize(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n) __attribute__((internal_linkage));
            void reserve(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __res_arg);
            void __resize_default_init(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            void reserve() throw() __attribute__((internal_linkage));
            void shrink_to_fit() throw() __attribute__((internal_linkage));
            void clear() throw();
            bool empty() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_reference operator[](std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::reference basic_string<char, char_traits<char>, allocator<char> >::operator[](std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) throw()             {
                ((void)0);
                return *(this->__get_pointer() + __pos);
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_reference at(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n) const;
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::reference at(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char> &operator+=(const std::__1::basic_string<char> &__str) __attribute__((internal_linkage))             {
                return this->append(__str);
            }
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type operator+=(const _Tp &__t);
            template<> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, basic_string<char> >::value, basic_string<char> &>::type operator+=<std::__1::basic_string<char>>(const std::__1::basic_string<char> &__t);
            std::__1::basic_string<char> &operator+=(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s) __attribute__((internal_linkage))             {
                return this->append(__s);
            }
            std::__1::basic_string<char> &operator+=(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c) __attribute__((internal_linkage));
            std::__1::basic_string<char> &basic_string<char, char_traits<char>, allocator<char> >::append(const std::__1::basic_string<char> &__str)             {
                return this->append(__str.data(), __str.size());
            }
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type append(const _Tp &__t);
            template<> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, basic_string<char> >::value, basic_string<char> &>::type append<std::__1::basic_string<char>>(const std::__1::basic_string<char> &__t);
            std::__1::basic_string<char> &append(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type append(const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char> &append(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char> &append(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s);
            std::__1::basic_string<char> &append(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c);
            void __append_default_init(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            template <class _ForwardIterator> inline std::__1::basic_string<char> &__append_forward_unsafe(_ForwardIterator, _ForwardIterator);
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, basic_string<char> &>::type append(_InputIterator __first, _InputIterator __last) __attribute__((internal_linkage));
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, basic_string<char> &>::type append(_ForwardIterator __first, _ForwardIterator __last) __attribute__((internal_linkage));
            void push_back(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c);
            void pop_back();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::reference front() throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_reference front() const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::reference back() throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_reference back() const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type assign(const _Tp &__t);
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char> &__str) __attribute__((internal_linkage));
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type assign(const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char> &assign(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s);
            std::__1::basic_string<char> &assign(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c);
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, basic_string<char> &>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, basic_string<char> &>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<char> &insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, const std::__1::basic_string<char> &__str);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, const _Tp &__t);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos2, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char> &insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos2, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char> &insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char> &insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s);
            std::__1::basic_string<char> &insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c);
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::iterator insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c);
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::iterator insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c);
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, iterator>::type insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __pos, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, iterator>::type insert(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<char> &erase(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::iterator erase(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __pos);
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::iterator erase(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __first, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __last);
            std::__1::basic_string<char> &replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const std::__1::basic_string<char> &__str);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const _Tp &__t);
            std::__1::basic_string<char> &replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos2, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n2);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos2, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n2);
            std::__1::basic_string<char> &replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n2) __attribute__((no_sanitize("unsigned-integer-overflow")));
            std::__1::basic_string<char> &replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s);
            std::__1::basic_string<char> &replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n2, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c) __attribute__((no_sanitize("unsigned-integer-overflow")));
            std::__1::basic_string<char> &replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i2, const std::__1::basic_string<char> &__str);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, basic_string<char> &>::type replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i2, const _Tp &__t);
            std::__1::basic_string<char> &replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i2, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n);
            std::__1::basic_string<char> &replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i2, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s);
            std::__1::basic_string<char> &replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i2, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c);
            template <class _InputIterator> inline typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value, basic_string<char> &>::type replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type copy(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const;
            std::__1::basic_string<char> basic_string<char, char_traits<char>, allocator<char> >::substr(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n) const             {
                return std::__1::basic_string<char>(*this, __pos, __n, this->__alloc());
            }
            void swap(std::__1::basic_string<char> &__str);
            const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *c_str() const throw() __attribute__((internal_linkage))             {
                return this->data();
            }
            const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *data() const throw() __attribute__((internal_linkage))             {
                return std::__1::__to_address(this->__get_pointer());
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type get_allocator() const throw() __attribute__((internal_linkage))             {
                return this->__alloc();
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, size_type>::type find(const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const;
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type basic_string<char, char_traits<char>, allocator<char> >::find(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos = 0) const throw()             {
                ((void)0);
                return __str_find<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::traits_type, npos>(this->data(), this->size(), __s, __pos, traits_type::length(__s));
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type rfind(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, size_type>::type rfind(const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const;
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type rfind(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type rfind(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type rfind(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_first_of(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, size_type>::type find_first_of(const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const;
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_first_of(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_first_of(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_first_of(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_last_of(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, size_type>::type find_last_of(const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const;
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_last_of(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_last_of(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_last_of(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_first_not_of(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, size_type>::type find_first_not_of(const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const;
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_first_not_of(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_first_not_of(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_first_not_of(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_last_not_of(const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, size_type>::type find_last_not_of(const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const;
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_last_not_of(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_last_not_of(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type find_last_not_of(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos) const throw();
            int compare(const std::__1::basic_string<char> &__str) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, int>::type compare(const _Tp &__t) const;
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, int>::type compare(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const _Tp &__t) const;
            int compare(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const std::__1::basic_string<char> &__str) const;
            int compare(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const std::__1::basic_string<char> &__str, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos2, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n2) const;
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<char, char_traits<char>, _Tp>::value, int>::type compare(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const _Tp &__t, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos2, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n2) const;
            int compare(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s) const throw();
            int compare(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s) const;
            int compare(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos1, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n1, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n2) const;
            bool __invariants() const;
            void __clear_and_shrink() throw();
            bool __is_long() const throw() __attribute__((internal_linkage))             {
                return bool(this->__r_.first().__s.__size_ & __short_mask);
            }
        private:
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type &__alloc() throw() __attribute__((internal_linkage))             {
                return this->__r_.second();
            }
            const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::allocator_type &__alloc() const throw() __attribute__((internal_linkage))             {
                return this->__r_.second();
            }
            void __set_short_size(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __s) throw() __attribute__((internal_linkage))             {
                this->__r_.first().__s.__size_ = (unsigned char)(__s << 1);
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __get_short_size() const throw() __attribute__((internal_linkage))             {
                return this->__r_.first().__s.__size_ >> 1;
            }
            void __set_long_size(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __s) throw() __attribute__((internal_linkage))             {
                this->__r_.first().__l.__size_ = __s;
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __get_long_size() const throw() __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__size_;
            }
            void __set_size(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __s) throw() __attribute__((internal_linkage));
            void __set_long_cap(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __s) throw() __attribute__((internal_linkage))             {
                this->__r_.first().__l.__cap_ = __long_mask | __s;
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __get_long_cap() const throw() __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__cap_ & std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type(~__long_mask);
            }
            void __set_long_pointer(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::pointer __p) throw() __attribute__((internal_linkage))             {
                this->__r_.first().__l.__data_ = __p;
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::pointer __get_long_pointer() throw() __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__data_;
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_pointer __get_long_pointer() const throw() __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__data_;
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::pointer __get_short_pointer() throw() __attribute__((internal_linkage))             {
                return pointer_traits<pointer>::pointer_to(this->__r_.first().__s.__data_[0]);
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_pointer __get_short_pointer() const throw() __attribute__((internal_linkage))             {
                return pointer_traits<const_pointer>::pointer_to(this->__r_.first().__s.__data_[0]);
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::pointer __get_pointer() throw() __attribute__((internal_linkage))             {
                return this->__is_long() ? this->__get_long_pointer() : this->__get_short_pointer();
            }
            std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::const_pointer __get_pointer() const throw() __attribute__((internal_linkage))             {
                return this->__is_long() ? this->__get_long_pointer() : this->__get_short_pointer();
            }
            void __zero() throw() __attribute__((internal_linkage))             {
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type (&__a)[3] = this->__r_.first().__r.__words;
                for (unsigned int __i = 0; __i < __n_words; ++__i)
                    __a[__i] = 0;
            }
            template <std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __a> static std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __align_it(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __s) throw() __attribute__((internal_linkage));
            template<> static std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __align_it<16>(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __s) throw() __attribute__((internal_linkage))             {
                return (__s + (16UL - 1)) & ~(16UL - 1);
            }
;
            enum  {
                __alignment = 16
            };
            static std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __recommend(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __s) throw() __attribute__((internal_linkage))             {
                if (__s < __min_cap)
                    return static_cast<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type>(__min_cap) - 1;
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __guess = __align_it<sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type) < __alignment ? __alignment / sizeof(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type) : 1>(__s + 1) - 1;
                if (__guess == __min_cap)
                    ++__guess;
                return __guess;
            }
            inline void basic_string<char, char_traits<char>, allocator<char> >::__init(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __sz, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __reserve)             {
                if (__reserve > this->max_size())
                    this->__throw_length_error();
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::pointer __p;
                if (__reserve < __min_cap) {
                    this->__set_short_size(__sz);
                    __p = this->__get_short_pointer();
                } else {
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __cap = __recommend(__reserve);
                    __p = __alloc_traits::allocate(this->__alloc(), __cap + 1);
                    this->__set_long_pointer(__p);
                    this->__set_long_cap(__cap + 1);
                    this->__set_long_size(__sz);
                }
                traits_type::copy(std::__1::__to_address(__p), __s, __sz);
                traits_type::assign(__p[__sz], std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type());
            }
            inline void basic_string<char, char_traits<char>, allocator<char> >::__init(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__s, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __sz)             {
                if (__sz > this->max_size())
                    this->__throw_length_error();
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::pointer __p;
                if (__sz < __min_cap) {
                    this->__set_short_size(__sz);
                    __p = this->__get_short_pointer();
                } else {
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __cap = __recommend(__sz);
                    __p = __alloc_traits::allocate(this->__alloc(), __cap + 1);
                    this->__set_long_pointer(__p);
                    this->__set_long_cap(__cap + 1);
                    this->__set_long_size(__sz);
                }
                traits_type::copy(std::__1::__to_address(__p), __s, __sz);
                traits_type::assign(__p[__sz], std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type());
            }
            inline void basic_string<char, char_traits<char>, allocator<char> >::__init(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type __c)             {
                if (__n > this->max_size())
                    this->__throw_length_error();
                std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::pointer __p;
                if (__n < __min_cap) {
                    this->__set_short_size(__n);
                    __p = this->__get_short_pointer();
                } else {
                    std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __cap = __recommend(__n);
                    __p = __alloc_traits::allocate(this->__alloc(), __cap + 1);
                    this->__set_long_pointer(__p);
                    this->__set_long_cap(__cap + 1);
                    this->__set_long_size(__n);
                }
                traits_type::assign(std::__1::__to_address(__p), __n, __c);
                traits_type::assign(__p[__n], std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type());
            }
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __old_cap, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __delta_cap, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __old_sz, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n_copy, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n_del, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n_add);
            void __grow_by_and_replace(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __old_cap, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __delta_cap, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __old_sz, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n_copy, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n_del, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __n_add, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__p_new_stuff);
            void __erase_to_end(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type __pos);
            void __copy_assign_alloc(const std::__1::basic_string<char> &__str) __attribute__((internal_linkage));
            void __copy_assign_alloc(const std::__1::basic_string<char> &__str, std::__1::true_type) __attribute__((internal_linkage));
            void __copy_assign_alloc(const std::__1::basic_string<char> &, std::__1::false_type) throw() __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::basic_string<char> &__str) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::basic_string<char> &__c, std::__1::true_type) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::basic_string<char> &, std::__1::false_type) throw() __attribute__((internal_linkage));
            void __invalidate_all_iterators();
            void __invalidate_iterators_past(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::size_type);
            friend template<> std::__1::basic_string<char> operator+<>(const std::__1::basic_string<char> &__lhs, const std::__1::basic_string<char> &__rhs)             {
                basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > __r(__lhs.get_allocator());
                typename basic_string<char, char_traits<char>, allocator<char> >::size_type __lhs_sz = __lhs.size();
                typename basic_string<char, char_traits<char>, allocator<char> >::size_type __rhs_sz = __rhs.size();
                __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
                __r.append(__rhs.data(), __rhs_sz);
                return __r;
            }
;
            friend template<> std::__1::basic_string<char> operator+<>(const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *, const std::__1::basic_string<char> &);
            friend template<> std::__1::basic_string<char> operator+<>(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type, const std::__1::basic_string<char> &);
            friend template<> std::__1::basic_string<char> operator+<>(const std::__1::basic_string<char> &__lhs, const std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type *__rhs)             {
                basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > __r(__lhs.get_allocator());
                typename basic_string<char, char_traits<char>, allocator<char> >::size_type __lhs_sz = __lhs.size();
                typename basic_string<char, char_traits<char>, allocator<char> >::size_type __rhs_sz = char_traits<char>::length(__rhs);
                __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
                __r.append(__rhs, __rhs_sz);
                return __r;
            }
;
            friend template<> std::__1::basic_string<char> operator+<>(const std::__1::basic_string<char> &, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::value_type);
        };
        template<> class __attribute__((visibility("default"))) basic_string<wchar_t> : private __basic_string_common<true> {
        public:
            typedef std::__1::basic_string<wchar_t> __self;
            typedef basic_string_view<wchar_t, std::__1::char_traits<wchar_t> > __self_view;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef wchar_t value_type;
            typedef std::__1::allocator<wchar_t> allocator_type;
            typedef allocator_traits<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type> __alloc_traits;
            typedef typename __alloc_traits::size_type size_type;
            typedef typename __alloc_traits::difference_type difference_type;
            typedef std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type &reference;
            typedef const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type &const_reference;
            typedef typename __alloc_traits::pointer pointer;
            typedef typename __alloc_traits::const_pointer const_pointer;
            static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
            static_assert((is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
            static_assert((is_trivial<value_type>::value), "Character type of basic_string must be trivial");
            static_assert((is_same<wchar_t, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");
            typedef __wrap_iter<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::pointer> iterator;
            typedef __wrap_iter<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_pointer> const_iterator;
            typedef std::__1::reverse_iterator<iterator> reverse_iterator;
            typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
        private:
            struct __long {
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __cap_;
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __size_;
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::pointer __data_;
            };
            static const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __short_mask = 1;
            static const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __long_mask = 1UL;
            enum  {
                __min_cap = (sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long) - 1) / sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type) > 2 ? (sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long) - 1) / sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type) : 2
            };
            struct __short {
                union {
                    unsigned char __size_;
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __lx;
                };
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __data_[5];
            };
            union __ulx {
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long __lx;
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__short __lxx;
            };
            enum  {
                __n_words = sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__ulx) / sizeof(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type)
            };
            struct __raw {
                std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __words[3];
            };
            struct __rep {
                union {
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__long __l;
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__short __s;
                    std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__raw __r;
                };
            };
            __compressed_pair<std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::__rep, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type> __r_;
        public:
            static const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type npos = -1;
            basic_string();
            explicit basic_string(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type &__a);
            basic_string(const std::__1::basic_string<wchar_t> &__str);
            basic_string(const std::__1::basic_string<wchar_t> &__str, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type &__a);
            template <class = typename enable_if<__is_allocator<allocator<wchar_t> >::value, nullptr_t>::type> basic_string(const wchar_t *__s) __attribute__((internal_linkage));
            template <class = typename enable_if<__is_allocator<allocator<wchar_t> >::value, nullptr_t>::type> basic_string(const wchar_t *__s, const std::__1::allocator<wchar_t> &__a);
            basic_string(const wchar_t *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            basic_string(const wchar_t *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, const std::__1::allocator<wchar_t> &__a);
            basic_string(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, wchar_t __c);
            template <class = typename enable_if<__is_allocator<allocator<wchar_t> >::value, nullptr_t>::type> basic_string(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, wchar_t __c, const std::__1::allocator<wchar_t> &__a);
            basic_string(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, const std::__1::allocator<wchar_t> &__a);
            basic_string(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, const std::__1::allocator<wchar_t> &__a);
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, void>::type> inline basic_string(const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type &__a);
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, void>::type> inline explicit basic_string(const _Tp &__t);
            template<> inline explicit basic_string<std::__1::basic_string<wchar_t>, void>(const std::__1::basic_string<wchar_t> &__t);
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, void>::type> inline explicit basic_string(const _Tp &__t, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type &__a);
            template <class _InputIterator, class = typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value>::type> basic_string(_InputIterator __first, _InputIterator __last);
            template <class _InputIterator, class = typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value>::type> basic_string(_InputIterator __first, _InputIterator __last, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type &__a);
            inline basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::~basic_string<wchar_t>()             {
                if (this->__is_long())
                    __alloc_traits::deallocate(this->__alloc(), this->__get_long_pointer(), this->__get_long_cap());
            }
            operator __self_view() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t> &operator=(const std::__1::basic_string<wchar_t> &__str);
            template <class _Tp, class = typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, void>::type> std::__1::basic_string<wchar_t> &operator=(const _Tp &__t);
            std::__1::basic_string<wchar_t> &operator=(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s) __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t> &operator=(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::iterator begin() throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator begin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::iterator end() throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator end() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::reverse_iterator rbegin() throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_reverse_iterator rbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::reverse_iterator rend() throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_reverse_iterator rend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator cbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator cend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_reverse_iterator crbegin() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_reverse_iterator crend() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type size() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type length() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type max_size() const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type capacity() const throw() __attribute__((internal_linkage));
            void resize(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            void resize(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n) __attribute__((internal_linkage));
            void reserve(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __res_arg);
            void __resize_default_init(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            void reserve() throw() __attribute__((internal_linkage));
            void shrink_to_fit() throw() __attribute__((internal_linkage));
            void clear() throw();
            bool empty() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_reference operator[](std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::reference operator[](std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_reference at(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n) const;
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::reference at(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t> &operator+=(const std::__1::basic_string<wchar_t> &__str) __attribute__((internal_linkage));
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type operator+=(const _Tp &__t);
            std::__1::basic_string<wchar_t> &operator+=(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s) __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t> &operator+=(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c) __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t> &__str);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type append(const _Tp &__t);
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type append(const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t> &append(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s);
            std::__1::basic_string<wchar_t> &append(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            void __append_default_init(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            template <class _ForwardIterator> inline std::__1::basic_string<wchar_t> &__append_forward_unsafe(_ForwardIterator, _ForwardIterator);
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type append(_InputIterator __first, _InputIterator __last) __attribute__((internal_linkage));
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, basic_string<wchar_t> &>::type append(_ForwardIterator __first, _ForwardIterator __last) __attribute__((internal_linkage));
            void push_back(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            void pop_back();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::reference front() throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_reference front() const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::reference back() throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_reference back() const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type assign(const _Tp &__t);
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t> &__str) __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type assign(const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t> &assign(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s);
            std::__1::basic_string<wchar_t> &assign(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type assign(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, basic_string<wchar_t> &>::type assign(_ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<wchar_t> &insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, const std::__1::basic_string<wchar_t> &__str);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, const _Tp &__t);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos2, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t> &insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos2, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t> &insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t> &insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s);
            std::__1::basic_string<wchar_t> &insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::iterator insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::iterator insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value, iterator>::type insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __pos, _InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value, iterator>::type insert(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
            std::__1::basic_string<wchar_t> &erase(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::iterator erase(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __pos);
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::iterator erase(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __first, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __last);
            std::__1::basic_string<wchar_t> &replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const std::__1::basic_string<wchar_t> &__str);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const _Tp &__t);
            std::__1::basic_string<wchar_t> &replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos2, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n2);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos2, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n2);
            std::__1::basic_string<wchar_t> &replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n2) __attribute__((no_sanitize("unsigned-integer-overflow")));
            std::__1::basic_string<wchar_t> &replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s);
            std::__1::basic_string<wchar_t> &replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n2, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c) __attribute__((no_sanitize("unsigned-integer-overflow")));
            std::__1::basic_string<wchar_t> &replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i2, const std::__1::basic_string<wchar_t> &__str);
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, basic_string<wchar_t> &>::type replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i2, const _Tp &__t);
            std::__1::basic_string<wchar_t> &replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i2, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n);
            std::__1::basic_string<wchar_t> &replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i2, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s);
            std::__1::basic_string<wchar_t> &replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i2, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            template <class _InputIterator> inline typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value, basic_string<wchar_t> &>::type replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type copy(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const;
            std::__1::basic_string<wchar_t> substr(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n) const;
            void swap(std::__1::basic_string<wchar_t> &__str);
            const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *c_str() const throw() __attribute__((internal_linkage));
            const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *data() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type get_allocator() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, size_type>::type find(const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const;
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type rfind(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, size_type>::type rfind(const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const;
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type rfind(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type rfind(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type rfind(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_first_of(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, size_type>::type find_first_of(const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const;
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_first_of(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_first_of(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_first_of(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_last_of(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, size_type>::type find_last_of(const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const;
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_last_of(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_last_of(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_last_of(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_first_not_of(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, size_type>::type find_first_not_of(const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const;
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_first_not_of(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_first_not_of(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_first_not_of(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_last_not_of(const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, size_type>::type find_last_not_of(const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const;
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_last_not_of(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_last_not_of(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type find_last_not_of(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos) const throw();
            int compare(const std::__1::basic_string<wchar_t> &__str) const throw();
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, int>::type compare(const _Tp &__t) const;
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, int>::type compare(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const _Tp &__t) const;
            int compare(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const std::__1::basic_string<wchar_t> &__str) const;
            int compare(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const std::__1::basic_string<wchar_t> &__str, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos2, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n2) const;
            template <class _Tp> inline typename enable_if<__can_be_converted_to_string_view<wchar_t, char_traits<wchar_t>, _Tp>::value, int>::type compare(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const _Tp &__t, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos2, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n2) const;
            int compare(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s) const throw();
            int compare(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s) const;
            int compare(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos1, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n1, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n2) const;
            bool __invariants() const;
            void __clear_and_shrink() throw();
            bool __is_long() const throw() __attribute__((internal_linkage))             {
                return bool(this->__r_.first().__s.__size_ & __short_mask);
            }
        private:
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type &__alloc() throw() __attribute__((internal_linkage))             {
                return this->__r_.second();
            }
            const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::allocator_type &__alloc() const throw() __attribute__((internal_linkage));
            void __set_short_size(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __s) throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __get_short_size() const throw() __attribute__((internal_linkage));
            void __set_long_size(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __s) throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __get_long_size() const throw() __attribute__((internal_linkage));
            void __set_size(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __s) throw() __attribute__((internal_linkage));
            void __set_long_cap(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __s) throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __get_long_cap() const throw() __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__cap_ & std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type(~__long_mask);
            }
            void __set_long_pointer(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::pointer __p) throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::pointer __get_long_pointer() throw() __attribute__((internal_linkage))             {
                return this->__r_.first().__l.__data_;
            }
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_pointer __get_long_pointer() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::pointer __get_short_pointer() throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_pointer __get_short_pointer() const throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::pointer __get_pointer() throw() __attribute__((internal_linkage));
            std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::const_pointer __get_pointer() const throw() __attribute__((internal_linkage));
            void __zero() throw() __attribute__((internal_linkage));
            template <std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __a> static std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __align_it(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __s) throw() __attribute__((internal_linkage));
            enum  {
                __alignment = 16
            };
            static std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __recommend(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __s) throw() __attribute__((internal_linkage));
            inline void __init(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __sz, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __reserve);
            inline void __init(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__s, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __sz);
            inline void __init(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type __c);
            template <class _InputIterator> inline typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value, void>::type __init(_InputIterator __first, _InputIterator __last);
            template <class _ForwardIterator> inline typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value, void>::type __init(_ForwardIterator __first, _ForwardIterator __last);
            void __grow_by(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __old_cap, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __delta_cap, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __old_sz, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n_copy, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n_del, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n_add);
            void __grow_by_and_replace(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __old_cap, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __delta_cap, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __old_sz, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n_copy, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n_del, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __n_add, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *__p_new_stuff);
            void __erase_to_end(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type __pos);
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &__str) __attribute__((internal_linkage));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &__str, std::__1::true_type) __attribute__((internal_linkage));
            void __copy_assign_alloc(const std::__1::basic_string<wchar_t> &, std::__1::false_type) throw() __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &__str) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &__c, std::__1::true_type) __attribute__((internal_linkage));
            void __move_assign_alloc(std::__1::basic_string<wchar_t> &, std::__1::false_type) throw() __attribute__((internal_linkage));
            void __invalidate_all_iterators();
            void __invalidate_iterators_past(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::size_type);
            friend template<> std::__1::basic_string<wchar_t> operator+<>(const std::__1::basic_string<wchar_t> &, const std::__1::basic_string<wchar_t> &);
            friend template<> std::__1::basic_string<wchar_t> operator+<>(const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *, const std::__1::basic_string<wchar_t> &);
            friend template<> std::__1::basic_string<wchar_t> operator+<>(std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type, const std::__1::basic_string<wchar_t> &);
            friend template<> std::__1::basic_string<wchar_t> operator+<>(const std::__1::basic_string<wchar_t> &, const std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type *);
            friend template<> std::__1::basic_string<wchar_t> operator+<>(const std::__1::basic_string<wchar_t> &, std::__1::basic_string<wchar_t, std::__1::char_traits<wchar_t>, std::__1::allocator<wchar_t> >::value_type);
        };
        const typename basic_string<char, char_traits<char>, allocator<char> >::size_type npos;
    }
}
namespace std {
    inline namespace __1 {
        using ::clock_t;
        using ::size_t;
        using ::time_t;
        using ::tm;
        using ::clock;
        using ::difftime;
        using ::mktime;
        using ::time;
        using ::asctime;
        using ::ctime;
        using ::gmtime;
        using ::localtime;
        using ::strftime;
    }
}
namespace std {
    inline namespace __1 {
        template <intmax_t _Xp, intmax_t _Yp> struct __static_gcd {
            static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
        };
template<> struct __static_gcd<1, 1000000> {
            static const intmax_t value = __static_gcd<1000000L, 1L % 1000000L>::value;
        };
template<> struct __static_gcd<1000000, 1> {
            static const intmax_t value = __static_gcd<1L, 1000000L % 1L>::value;
        };
template<> struct __static_gcd<1, 0> {
            static const intmax_t value = 1L;
        };
template<> struct __static_gcd<1, 1> {
            static const intmax_t value = __static_gcd<1L, 1L % 1L>::value;
        };
template<> struct __static_gcd<1000000, 1000000> {
            static const intmax_t value = __static_gcd<1000000L, 1000000L % 1000000L>::value;
        };
template<> struct __static_gcd<1000000, 0> {
            static const intmax_t value = 1000000L;
        };
template<> struct __static_gcd<1, 1000000000> {
            static const intmax_t value = __static_gcd<1000000000L, 1L % 1000000000L>::value;
        };
template<> struct __static_gcd<1000000000, 1> {
            static const intmax_t value = __static_gcd<1L, 1000000000L % 1L>::value;
        };
template<> struct __static_gcd<1000000000, 1000000000> {
            static const intmax_t value = __static_gcd<1000000000L, 1000000000L % 1000000000L>::value;
        };
template<> struct __static_gcd<1000000000, 0> {
            static const intmax_t value = 1000000000L;
        };
        template <intmax_t _Xp> struct __static_gcd<_Xp, 0> {
            static const intmax_t value = _Xp;
        };
        template<> struct __static_gcd<0, 0> {
            static const intmax_t value = 1;
        };
        template <intmax_t _Xp, intmax_t _Yp> struct __static_lcm {
            static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
        };
template<> struct __static_lcm<1000000, 1000000> {
            static const intmax_t value = 1000000L / __static_gcd<1000000L, 1000000L>::value * 1000000L;
        };
template<> struct __static_lcm<1000000000, 1000000000> {
            static const intmax_t value = 1000000000L / __static_gcd<1000000000L, 1000000000L>::value * 1000000000L;
        };
template<> struct __static_lcm<1, 1> {
            static const intmax_t value = 1L / __static_gcd<1L, 1L>::value * 1L;
        };
template<> struct __static_lcm<1000000000, 1> {
            static const intmax_t value = 1000000000L / __static_gcd<1000000000L, 1L>::value * 1L;
        };
        template <intmax_t _Xp> struct __static_abs {
            static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
        };
template<> struct __static_abs<1> {
            static const intmax_t value = 1L < 0 ? -1L : 1L;
        };
template<> struct __static_abs<1000000> {
            static const intmax_t value = 1000000L < 0 ? -1000000L : 1000000L;
        };
template<> struct __static_abs<1000000000> {
            static const intmax_t value = 1000000000L < 0 ? -1000000000L : 1000000000L;
        };
        template <intmax_t _Xp> struct __static_sign {
            static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
        };
template<> struct __static_sign<1> {
            static const intmax_t value = 1L == 0 ? 0 : (1L < 0 ? -1 : 1);
        };
template<> struct __static_sign<1000000> {
            static const intmax_t value = 1000000L == 0 ? 0 : (1000000L < 0 ? -1 : 1);
        };
template<> struct __static_sign<1000000000> {
            static const intmax_t value = 1000000000L == 0 ? 0 : (1000000000L < 0 ? -1 : 1);
        };
        template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value> class __ll_add;
        template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, 1> {
            static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
            static const intmax_t max = -min;
            static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
        public:
            static const intmax_t value = _Xp + _Yp;
        };
        template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, 0> {
        public:
            static const intmax_t value = _Xp;
        };
        template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, -1> {
            static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
            static const intmax_t max = -min;
            static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
        public:
            static const intmax_t value = _Xp + _Yp;
        };
        template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value> class __ll_sub;
        template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, 1> {
            static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
            static const intmax_t max = -min;
            static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
        public:
            static const intmax_t value = _Xp - _Yp;
        };
        template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, 0> {
        public:
            static const intmax_t value = _Xp;
        };
        template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, -1> {
            static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
            static const intmax_t max = -min;
            static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
        public:
            static const intmax_t value = _Xp - _Yp;
        };
        template <intmax_t _Xp, intmax_t _Yp> class __ll_mul {
            static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
            static const intmax_t min = nan + 1;
            static const intmax_t max = -min;
            static const intmax_t __a_x = __static_abs<_Xp>::value;
            static const intmax_t __a_y = __static_abs<_Yp>::value;
            static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
        public:
            static const intmax_t value = _Xp * _Yp;
        };
template<> class __ll_mul<1, 1> {
            static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
            static const intmax_t min = nan + 1;
            static const intmax_t max = -min;
            static const intmax_t __a_x = __static_abs<1L>::value;
            static const intmax_t __a_y = __static_abs<1L>::value;
            static_assert(1L != nan && 1L != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
        public:
            static const intmax_t value = 1L * 1L;
        };
template<> class __ll_mul<1, 1000000000> {
            static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
            static const intmax_t min = nan + 1;
            static const intmax_t max = -min;
            static const intmax_t __a_x = __static_abs<1L>::value;
            static const intmax_t __a_y = __static_abs<1000000000L>::value;
            static_assert(1L != nan && 1000000000L != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
        public:
            static const intmax_t value = 1L * 1000000000L;
        };
        template <intmax_t _Yp> class __ll_mul<0, _Yp> {
        public:
            static const intmax_t value = 0;
        };
        template <intmax_t _Xp> class __ll_mul<_Xp, 0> {
        public:
            static const intmax_t value = 0;
        };
        template<> class __ll_mul<0, 0> {
        public:
            static const intmax_t value = 0;
        };
        template <intmax_t _Xp, intmax_t _Yp> class __ll_div {
            static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
            static const intmax_t min = nan + 1;
            static const intmax_t max = -min;
            static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
        public:
            static const intmax_t value = _Xp / _Yp;
        };
        template <intmax_t _Num, intmax_t _Den = 1> class __attribute__((type_visibility("default"))) ratio {
            static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
            static_assert(_Den != 0, "ratio divide by 0");
            static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
            static const intmax_t __na = __static_abs<_Num>::value;
            static const intmax_t __da = __static_abs<_Den>::value;
            static const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
            static const intmax_t __gcd = __static_gcd<__na, __da>::value;
        public:
            static const intmax_t num = __s * __na / __gcd;
            static const intmax_t den = __da / __gcd;
            typedef ratio<num, den> type;
        };
template<> class ratio<1, 1000000000> {
            static_assert(__static_abs<1L>::value >= 0, "ratio numerator is out of range");
            static_assert(1000000000L != 0, "ratio divide by 0");
            static_assert(__static_abs<1000000000L>::value > 0, "ratio denominator is out of range");
            static const intmax_t __na = __static_abs<1L>::value;
            static const intmax_t __da = __static_abs<1000000000L>::value;
            static const intmax_t __s = __static_sign<1L>::value * __static_sign<1000000000L>::value;
            static const intmax_t __gcd = __static_gcd<__na, __da>::value;
        public:
            static const intmax_t num = __s * __na / __gcd;
            static const intmax_t den = __da / __gcd;
            typedef ratio<num, den> type;
        };
template<> class ratio<1, 1000000> {
            static_assert(__static_abs<1L>::value >= 0, "ratio numerator is out of range");
            static_assert(1000000L != 0, "ratio divide by 0");
            static_assert(__static_abs<1000000L>::value > 0, "ratio denominator is out of range");
            static const intmax_t __na = __static_abs<1L>::value;
            static const intmax_t __da = __static_abs<1000000L>::value;
            static const intmax_t __s = __static_sign<1L>::value * __static_sign<1000000L>::value;
            static const intmax_t __gcd = __static_gcd<__na, __da>::value;
        public:
            static const intmax_t num = __s * __na / __gcd;
            static const intmax_t den = __da / __gcd;
            typedef ratio<num, den> type;
        };
template<> class ratio<1000000000, 1> {
            static_assert(__static_abs<1000000000L>::value >= 0, "ratio numerator is out of range");
            static_assert(1L != 0, "ratio divide by 0");
            static_assert(__static_abs<1L>::value > 0, "ratio denominator is out of range");
            static const intmax_t __na = __static_abs<1000000000L>::value;
            static const intmax_t __da = __static_abs<1L>::value;
            static const intmax_t __s = __static_sign<1000000000L>::value * __static_sign<1L>::value;
            static const intmax_t __gcd = __static_gcd<__na, __da>::value;
        public:
            static const intmax_t num = __s * __na / __gcd;
            static const intmax_t den = __da / __gcd;
            typedef ratio<num, den> type;
        };
template<> class ratio<1, 1> {
            static_assert(__static_abs<1L>::value >= 0, "ratio numerator is out of range");
            static_assert(1L != 0, "ratio divide by 0");
            static_assert(__static_abs<1L>::value > 0, "ratio denominator is out of range");
            static const intmax_t __na = __static_abs<1L>::value;
            static const intmax_t __da = __static_abs<1L>::value;
            static const intmax_t __s = __static_sign<1L>::value * __static_sign<1L>::value;
            static const intmax_t __gcd = __static_gcd<__na, __da>::value;
        public:
            static const intmax_t num = __s * __na / __gcd;
            static const intmax_t den = __da / __gcd;
            typedef ratio<num, den> type;
        };
        const intmax_t num;
        const intmax_t den;
        template <class _Tp> struct __is_ratio : std::__1::false_type {
        };
template<> struct __is_ratio<std::__1::ratio<1, 1000000>> : std::__1::true_type {
        };
template<> struct __is_ratio<std::__1::ratio<1, 1000000000>> : std::__1::true_type {
        };
template<> struct __is_ratio<std::__1::ratio<1, 1>> : std::__1::true_type {
        };
        template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den>> : std::__1::true_type {
        };
        typedef ratio<1LL, 1000000000000000000LL> atto;
        typedef ratio<1LL, 1000000000000000LL> femto;
        typedef ratio<1LL, 1000000000000LL> pico;
        typedef ratio<1LL, 1000000000LL> nano;
        typedef ratio<1LL, 1000000LL> micro;
        typedef ratio<1LL, 1000LL> milli;
        typedef ratio<1LL, 100LL> centi;
        typedef ratio<1LL, 10LL> deci;
        typedef ratio<10LL, 1LL> deca;
        typedef ratio<100LL, 1LL> hecto;
        typedef ratio<1000LL, 1LL> kilo;
        typedef ratio<1000000LL, 1LL> mega;
        typedef ratio<1000000000LL, 1LL> giga;
        typedef ratio<1000000000000LL, 1LL> tera;
        typedef ratio<1000000000000000LL, 1LL> peta;
        typedef ratio<1000000000000000000LL, 1LL> exa;
        template <class _R1, class _R2> struct __ratio_multiply {
        private:
            static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
            static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
        public:
            typedef typename ratio<__ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value, __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value>::type type;
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_multiply : public __ratio_multiply<_R1, _R2>::type {
        };
        template <class _R1, class _R2> struct __ratio_divide {
        private:
            static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
            static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        public:
            typedef typename ratio<__ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value, __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::type type;
        };
template<> struct __ratio_divide<std::__1::ratio<1, 1000000000>, std::__1::ratio<1, 1>> {
        private:
            static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000000>::num, ratio<1, 1>::num>::value;
            static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000000>::den, ratio<1, 1>::den>::value;
        public:
            typedef typename ratio<__ll_mul<ratio<1, 1000000000>::num / __gcd_n1_n2, ratio<1, 1>::den / __gcd_d1_d2>::value, __ll_mul<ratio<1, 1>::num / __gcd_n1_n2, ratio<1, 1000000000>::den / __gcd_d1_d2>::value>::type type;
        };
template<> struct __ratio_divide<std::__1::ratio<1, 1>, std::__1::ratio<1, 1000000000>> {
        private:
            static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1>::num, ratio<1, 1000000000>::num>::value;
            static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1>::den, ratio<1, 1000000000>::den>::value;
        public:
            typedef typename ratio<__ll_mul<ratio<1, 1>::num / __gcd_n1_n2, ratio<1, 1000000000>::den / __gcd_d1_d2>::value, __ll_mul<ratio<1, 1000000000>::num / __gcd_n1_n2, ratio<1, 1>::den / __gcd_d1_d2>::value>::type type;
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_divide : public __ratio_divide<_R1, _R2>::type {
        };
template<> struct ratio_divide<std::__1::ratio<1, 1000000000>, std::__1::ratio<1, 1>> : public __ratio_divide<ratio<1, 1000000000>, ratio<1, 1> >::type {
        };
template<> struct ratio_divide<std::__1::ratio<1, 1>, std::__1::ratio<1, 1000000000>> : public __ratio_divide<ratio<1, 1>, ratio<1, 1000000000> >::type {
        };
        template <class _R1, class _R2> struct __ratio_add {
        private:
            static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
            static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        public:
            typedef typename ratio_multiply<ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>, ratio<__ll_add<__ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value, __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::value, _R2::den> >::type type;
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_add : public __ratio_add<_R1, _R2>::type {
        };
        template <class _R1, class _R2> struct __ratio_subtract {
        private:
            static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
            static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        public:
            typedef typename ratio_multiply<ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>, ratio<__ll_sub<__ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value, __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::value, _R2::den> >::type type;
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_subtract : public __ratio_subtract<_R1, _R2>::type {
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_equal : public integral_constant<bool, ((_R1::num == _R2::num && _R1::den == _R2::den))> {
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_not_equal : public integral_constant<bool, ((!ratio_equal<_R1, _R2>::value))> {
        };
        template <class _R1, class _R2, bool _Odd = false, intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den, intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den> struct __ratio_less1 {
            static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
        };
        template <class _R1, class _R2, bool _Odd, intmax_t _Qp> struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0> {
            static const bool value = false;
        };
        template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2> struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2> {
            static const bool value = !_Odd;
        };
        template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1> struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0> {
            static const bool value = _Odd;
        };
        template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1, intmax_t _M2> struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2> {
            static const bool value = __ratio_less1<ratio<_R1::den, _M1>, ratio<_R2::den, _M2>, !_Odd>::value;
        };
        template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value, intmax_t _S2 = __static_sign<_R2::num>::value> struct __ratio_less {
            static const bool value = _S1 < _S2;
        };
        template <class _R1, class _R2> struct __ratio_less<_R1, _R2, 1LL, 1LL> {
            static const bool value = __ratio_less1<_R1, _R2>::value;
        };
        template <class _R1, class _R2> struct __ratio_less<_R1, _R2, -1LL, -1LL> {
            static const bool value = __ratio_less1<ratio<- _R2::num, _R2::den>, ratio<- _R1::num, _R1::den> >::value;
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_less : public integral_constant<bool, ((__ratio_less<_R1, _R2>::value))> {
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_less_equal : public integral_constant<bool, ((!ratio_less<_R2, _R1>::value))> {
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_greater : public integral_constant<bool, ((ratio_less<_R2, _R1>::value))> {
        };
        template <class _R1, class _R2> struct __attribute__((type_visibility("default"))) ratio_greater_equal : public integral_constant<bool, ((!ratio_less<_R1, _R2>::value))> {
        };
        template <class _R1, class _R2> struct __ratio_gcd {
            typedef ratio<__static_gcd<_R1::num, _R2::num>::value, __static_lcm<_R1::den, _R2::den>::value> type;
        };
template<> struct __ratio_gcd<std::__1::ratio<1, 1000000>, std::__1::ratio<1, 1000000>> {
            typedef ratio<__static_gcd<ratio<1, 1000000>::num, ratio<1, 1000000>::num>::value, __static_lcm<ratio<1, 1000000>::den, ratio<1, 1000000>::den>::value> type;
        };
template<> struct __ratio_gcd<std::__1::ratio<1, 1000000000>, std::__1::ratio<1, 1000000000>> {
            typedef ratio<__static_gcd<ratio<1, 1000000000>::num, ratio<1, 1000000000>::num>::value, __static_lcm<ratio<1, 1000000000>::den, ratio<1, 1000000000>::den>::value> type;
        };
template<> struct __ratio_gcd<std::__1::ratio<1, 1>, std::__1::ratio<1, 1>> {
            typedef ratio<__static_gcd<ratio<1, 1>::num, ratio<1, 1>::num>::value, __static_lcm<ratio<1, 1>::den, ratio<1, 1>::den>::value> type;
        };
template<> struct __ratio_gcd<std::__1::ratio<1, 1000000000>, std::__1::ratio<1, 1>> {
            typedef ratio<__static_gcd<ratio<1, 1000000000>::num, ratio<1, 1>::num>::value, __static_lcm<ratio<1, 1000000000>::den, ratio<1, 1>::den>::value> type;
        };
        const intmax_t num;
        const intmax_t den;
        const intmax_t num;
        const intmax_t den;
        const intmax_t num;
        const intmax_t den;
        const intmax_t num;
        const intmax_t den;
    }
}
namespace std {
    inline namespace __1 {
        namespace chrono {
            template <class _Rep, class _Period = ratio<1>> class __attribute__((type_visibility("default"))) duration
template<> class duration<long long, std::__1::ratio<1, 1000000000>> {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000000>::num > 0, "duration period must be positive");
                template <class _R1, class _R2> struct __no_overflow
template<> struct __no_overflow<std::__1::ratio<1, 1000000000>, std::__1::ratio<1, 1000000000>> {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000000>::num, ratio<1, 1000000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000000>::den, ratio<1, 1000000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul
template<> struct __mul<1, 1, false> {
                        static const intmax_t value = 1L * 1L;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                }
template<> struct __no_overflow<std::__1::ratio<1, 1>, std::__1::ratio<1, 1000000000>> {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1>::num, ratio<1, 1000000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1>::den, ratio<1, 1000000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul
template<> struct __mul<1, 1000000000, false> {
                        static const intmax_t value = 1L * 1000000000L;
                    }
template<> struct __mul<1, 1, false> {
                        static const intmax_t value = 1L * 1L;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                };
            public:
                typedef long long rep;
                typedef typename ratio<1, 1000000000>::type period;
            private:
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep __rep_;
            public:
                duration() __attribute__((internal_linkage));
                template <class _Rep2> explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((internal_linkage));
                template<> explicit duration<int>(const int &__r, typename enable_if<is_convertible<int, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<int>::value)>::type * = 0) __attribute__((internal_linkage));
                template<> explicit duration<long long>(const long long &__r, typename enable_if<is_convertible<long long, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<long long>::value)>::type * = 0) : __rep_(__r) __attribute__((internal_linkage))                 {
                }
;
                template <class _Rep2, class _Period2> duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((internal_linkage));
                template<> duration<long long, std::__1::ratio<1, 1000000000>>(const duration<long long, std::__1::ratio<1, 1000000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((internal_linkage));
                template<> duration<long long, std::__1::ratio<1, 1>>(const duration<long long, std::__1::ratio<1, 1> > &__d, typename enable_if<__no_overflow<ratio<1, 1>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type * = 0) : __rep_(std::__1::chrono::duration_cast<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >(__d).count()) __attribute__((internal_linkage))                 {
                }
;
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep count() const __attribute__((internal_linkage))                 {
                    return this->__rep_;
                }
                typename common_type<duration<long long, ratio<1, 1000000000> > >::type operator+() const __attribute__((internal_linkage));
                typename common_type<duration<long long, ratio<1, 1000000000> > >::type operator-() const __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator++() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator++(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator--() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator--(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator*=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator/=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &rhs) __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > zero() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > min() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > max() throw() __attribute__((internal_linkage));
            }
template<> class duration<long long, std::__1::ratio<1, 1000000>> {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000>::num > 0, "duration period must be positive");
                template <class _R1, class _R2> struct __no_overflow
template<> struct __no_overflow<std::__1::ratio<1, 1000000>, std::__1::ratio<1, 1000000>> {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000>::num, ratio<1, 1000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000>::den, ratio<1, 1000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul
template<> struct __mul<1, 1, false> {
                        static const intmax_t value = 1L * 1L;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                };
            public:
                typedef long long rep;
                typedef typename ratio<1, 1000000>::type period;
            private:
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep __rep_;
            public:
                duration() __attribute__((internal_linkage));
                template <class _Rep2> explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((internal_linkage));
                template <class _Rep2, class _Period2> duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((internal_linkage));
                template<> duration<long long, std::__1::ratio<1, 1000000>>(const duration<long long, std::__1::ratio<1, 1000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep count() const __attribute__((internal_linkage));
                typename common_type<duration<long long, ratio<1, 1000000> > >::type operator+() const __attribute__((internal_linkage));
                typename common_type<duration<long long, ratio<1, 1000000> > >::type operator-() const __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator++() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator++(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator--() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator--(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator*=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator/=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &rhs) __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > zero() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > min() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > max() throw() __attribute__((internal_linkage));
            }
template<> class duration<long long, std::__1::ratio<1, 1>> {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1>::num > 0, "duration period must be positive");
                template <class _R1, class _R2> struct __no_overflow
template<> struct __no_overflow<std::__1::ratio<1, 1>, std::__1::ratio<1, 1>> {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1>::num, ratio<1, 1>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1>::den, ratio<1, 1>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul
template<> struct __mul<1, 1, false> {
                        static const intmax_t value = 1L * 1L;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                };
            public:
                typedef long long rep;
                typedef typename ratio<1, 1>::type period;
            private:
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep __rep_;
            public:
                duration() __attribute__((internal_linkage));
                template <class _Rep2> explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((internal_linkage));
                template<> explicit duration<long long>(const long long &__r, typename enable_if<is_convertible<long long, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<long long>::value)>::type * = 0) : __rep_(__r) __attribute__((internal_linkage))                 {
                }
;
                template <class _Rep2, class _Period2> duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((internal_linkage));
                template<> duration<long long, std::__1::ratio<1, 1>>(const duration<long long, std::__1::ratio<1, 1> > &__d, typename enable_if<__no_overflow<ratio<1, 1>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep count() const __attribute__((internal_linkage))                 {
                    return this->__rep_;
                }
                typename common_type<duration<long long, ratio<1, 1> > >::type operator+() const __attribute__((internal_linkage));
                typename common_type<duration<long long, ratio<1, 1> > >::type operator-() const __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator++() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > operator++(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator--() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > operator--(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator*=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator/=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &rhs) __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > zero() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > min() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > max() throw() __attribute__((internal_linkage));
            };
            template <class _Tp> struct __is_duration : std::__1::false_type {
            };
template<> struct __is_duration<long long> : std::__1::false_type {
            };
template<> struct __is_duration<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >> : std::__1::true_type {
            };
template<> struct __is_duration<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> : std::__1::true_type {
            };
template<> struct __is_duration<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> : std::__1::true_type {
            };
            template <class _Rep, class _Period> struct __is_duration<duration<_Rep, _Period>> : std::__1::true_type {
            };
            template <class _Rep, class _Period> struct __is_duration<const duration<_Rep, _Period>> : std::__1::true_type {
            };
            template <class _Rep, class _Period> struct __is_duration<volatile duration<_Rep, _Period>> : std::__1::true_type {
            };
            template <class _Rep, class _Period> struct __is_duration<const volatile duration<_Rep, _Period>> : std::__1::true_type {
            };
        }
        template <class _Rep1, class _Period1, class _Rep2, class _Period2> struct __attribute__((type_visibility("default"))) common_type<chrono::duration<_Rep1, _Period1>, chrono::duration<_Rep2, _Period2>> {
            typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type, typename __ratio_gcd<_Period1, _Period2>::type> type;
        };
        namespace chrono {
            template <class _FromDuration, class _ToDuration, class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type, bool = _Period::num == 1, bool = _Period::den == 1> struct __duration_cast
template<> struct __duration_cast<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >, std::__1::ratio<1, 1000000000>, true, false> {
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > operator()(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__fd) const __attribute__((internal_linkage))                 {
                    typedef typename common_type<typename duration<long long, ratio<1, 1> >::rep, typename duration<long long, ratio<1, 1000000000> >::rep, intmax_t>::type _Ct;
                    return std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >(static_cast<typename duration<long long, ratio<1, 1> >::rep>(static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(ratio<1, 1000000000>::den)));
                }
            }
template<> struct __duration_cast<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::ratio<1000000000, 1>, false, true> {
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator()(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &__fd) const __attribute__((internal_linkage))                 {
                    typedef typename common_type<typename duration<long long, ratio<1, 1000000000> >::rep, typename duration<long long, ratio<1, 1> >::rep, intmax_t>::type _Ct;
                    return std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >(static_cast<typename duration<long long, ratio<1, 1000000000> >::rep>(static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(ratio<1000000000, 1>::num)));
                }
            };
            template <class _FromDuration, class _ToDuration, class _Period> struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true> {
                _ToDuration operator()(const _FromDuration &__fd) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
                }
            };
            template <class _FromDuration, class _ToDuration, class _Period> struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false> {
                _ToDuration operator()(const _FromDuration &__fd) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
                    return _ToDuration(static_cast<typename _ToDuration::rep>(static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
                }
            };
            template <class _FromDuration, class _ToDuration, class _Period> struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true> {
                _ToDuration operator()(const _FromDuration &__fd) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
                    return _ToDuration(static_cast<typename _ToDuration::rep>(static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
                }
            };
            template <class _FromDuration, class _ToDuration, class _Period> struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false> {
                _ToDuration operator()(const _FromDuration &__fd) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
                    return _ToDuration(static_cast<typename _ToDuration::rep>(static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num) / static_cast<_Ct>(_Period::den)));
                }
            };
            template <class _ToDuration, class _Rep, class _Period> inline typename enable_if<__is_duration<_ToDuration>::value, _ToDuration>::type duration_cast(const duration<_Rep, _Period> &__fd) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
            }
            template<> inline typename enable_if<__is_duration<duration<long long, ratio<1, 1> > >::value, duration<long long, ratio<1, 1> > >::type duration_cast<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >, long long, std::__1::ratio<1, 1000000000>>(const duration<long long, std::__1::ratio<1, 1000000000> > &__fd) __attribute__((internal_linkage))             {
                return __duration_cast<duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > >()(__fd);
            }
            template<> inline typename enable_if<__is_duration<duration<long long, ratio<1, 1000000000> > >::value, duration<long long, ratio<1, 1000000000> > >::type duration_cast<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, long long, std::__1::ratio<1, 1>>(const duration<long long, std::__1::ratio<1, 1> > &__fd) __attribute__((internal_linkage))             {
                return __duration_cast<duration<long long, std::__1::ratio<1, 1> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >()(__fd);
            }
            template <class _Rep> struct __attribute__((type_visibility("default"))) treat_as_floating_point : is_floating_point<_Rep> {
            };
template<> struct treat_as_floating_point<long long> : is_floating_point<long long> {
            };
template<> struct treat_as_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >> : is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > > {
            };
template<> struct treat_as_floating_point<int> : is_floating_point<int> {
            };
template<> struct treat_as_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> : is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > {
            };
template<> struct treat_as_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> : is_floating_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > {
            };
            template <class _Rep> struct __attribute__((type_visibility("default"))) duration_values {
            public:
                static _Rep zero() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return _Rep(0);
                }
                static _Rep max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return numeric_limits<_Rep>::max();
                }
                static _Rep min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return numeric_limits<_Rep>::lowest();
                }
            };
            template <class _Rep, class _Period = ratio<1>> class __attribute__((type_visibility("default"))) duration {
                static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
                static_assert(_Period::num > 0, "duration period must be positive");
                template <class _R1, class _R2> struct __no_overflow {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
                    static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
                    static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
                    static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
                    static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul {
                        static const intmax_t value = _Xp * _Yp;
                    };
                    template <intmax_t _Xp, intmax_t _Yp> struct __mul<_Xp, _Yp, true> {
                        static const intmax_t value = 1;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                };
            public:
                typedef _Rep rep;
                typedef typename _Period::type period;
            private:
                std::__1::chrono::duration::rep __rep_;
            public:
                duration<_Rep, _Period>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                template <class _Rep2> explicit duration<_Rep, _Period>(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type * = 0) : __rep_(__r) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                template <class _Rep2, class _Period2> duration<_Rep, _Period>(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type * = 0) : __rep_(std::__1::chrono::duration_cast<duration<_Rep, _Period> >(__d).count()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                std::__1::chrono::duration::rep count() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return this->__rep_;
                }
                typename common_type<duration<_Rep, _Period> >::type operator+() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return typename common_type<duration<_Rep, _Period> >::type(*this);
                }
                typename common_type<duration<_Rep, _Period> >::type operator-() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return typename common_type<duration<_Rep, _Period> >::type(- this->__rep_);
                }
                duration<_Rep, _Period> &operator++() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    ++this->__rep_;
                    return *this;
                }
                duration<_Rep, _Period> operator++(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return duration<_Rep, _Period>(this->__rep_++);
                }
                duration<_Rep, _Period> &operator--() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    --this->__rep_;
                    return *this;
                }
                duration<_Rep, _Period> operator--(int) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return duration<_Rep, _Period>(this->__rep_--);
                }
                duration<_Rep, _Period> &operator+=(const duration<_Rep, _Period> &__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__rep_ += __d.count();
                    return *this;
                }
                duration<_Rep, _Period> &operator-=(const duration<_Rep, _Period> &__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__rep_ -= __d.count();
                    return *this;
                }
                duration<_Rep, _Period> &operator*=(const std::__1::chrono::duration::rep &rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__rep_ *= rhs;
                    return *this;
                }
                duration<_Rep, _Period> &operator/=(const std::__1::chrono::duration::rep &rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__rep_ /= rhs;
                    return *this;
                }
                duration<_Rep, _Period> &operator%=(const std::__1::chrono::duration::rep &rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__rep_ %= rhs;
                    return *this;
                }
                duration<_Rep, _Period> &operator%=(const duration<_Rep, _Period> &rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__rep_ %= rhs.count();
                    return *this;
                }
                static duration<_Rep, _Period> zero() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return duration<_Rep, _Period>(duration_values<rep>::zero());
                }
                static duration<_Rep, _Period> min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return duration<_Rep, _Period>(duration_values<rep>::min());
                }
                static duration<_Rep, _Period> max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return duration<_Rep, _Period>(duration_values<rep>::max());
                }
            };
template<> class duration<long long, std::__1::ratio<1, 1000000000>> {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000000>::num > 0, "duration period must be positive");
                template <class _R1, class _R2> struct __no_overflow
template<> struct __no_overflow<std::__1::ratio<1, 1000000000>, std::__1::ratio<1, 1000000000>> {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000000>::num, ratio<1, 1000000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000000>::den, ratio<1, 1000000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul
template<> struct __mul<1, 1, false> {
                        static const intmax_t value = 1L * 1L;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                }
template<> struct __no_overflow<std::__1::ratio<1, 1>, std::__1::ratio<1, 1000000000>> {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1>::num, ratio<1, 1000000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1>::den, ratio<1, 1000000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul
template<> struct __mul<1, 1000000000, false> {
                        static const intmax_t value = 1L * 1000000000L;
                    }
template<> struct __mul<1, 1, false> {
                        static const intmax_t value = 1L * 1L;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                };
            public:
                typedef long long rep;
                typedef typename ratio<1, 1000000000>::type period;
            private:
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep __rep_;
            public:
                duration() __attribute__((internal_linkage));
                template <class _Rep2> explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((internal_linkage));
                template<> explicit duration<int>(const int &__r, typename enable_if<is_convertible<int, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<int>::value)>::type * = 0) __attribute__((internal_linkage));
                template<> explicit duration<long long>(const long long &__r, typename enable_if<is_convertible<long long, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<long long>::value)>::type * = 0) : __rep_(__r) __attribute__((internal_linkage))                 {
                }
;
                template <class _Rep2, class _Period2> duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((internal_linkage));
                template<> duration<long long, std::__1::ratio<1, 1000000000>>(const duration<long long, std::__1::ratio<1, 1000000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((internal_linkage));
                template<> duration<long long, std::__1::ratio<1, 1>>(const duration<long long, std::__1::ratio<1, 1> > &__d, typename enable_if<__no_overflow<ratio<1, 1>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type * = 0) : __rep_(std::__1::chrono::duration_cast<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >(__d).count()) __attribute__((internal_linkage))                 {
                }
;
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep count() const __attribute__((internal_linkage))                 {
                    return this->__rep_;
                }
                typename common_type<duration<long long, ratio<1, 1000000000> > >::type operator+() const __attribute__((internal_linkage));
                typename common_type<duration<long long, ratio<1, 1000000000> > >::type operator-() const __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator++() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator++(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator--() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > operator--(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator*=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator/=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > &rhs) __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > zero() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > min() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > max() throw() __attribute__((internal_linkage));
            };
template<> class duration<long long, std::__1::ratio<1, 1000000>> {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1000000> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1000000>::num > 0, "duration period must be positive");
                template <class _R1, class _R2> struct __no_overflow
template<> struct __no_overflow<std::__1::ratio<1, 1000000>, std::__1::ratio<1, 1000000>> {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1000000>::num, ratio<1, 1000000>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1000000>::den, ratio<1, 1000000>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1000000>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1000000>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1000000>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1000000>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul
template<> struct __mul<1, 1, false> {
                        static const intmax_t value = 1L * 1L;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                };
            public:
                typedef long long rep;
                typedef typename ratio<1, 1000000>::type period;
            private:
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep __rep_;
            public:
                duration() __attribute__((internal_linkage));
                template <class _Rep2> explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((internal_linkage));
                template <class _Rep2, class _Period2> duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((internal_linkage));
                template<> duration<long long, std::__1::ratio<1, 1000000>>(const duration<long long, std::__1::ratio<1, 1000000> > &__d, typename enable_if<__no_overflow<ratio<1, 1000000>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1000000>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep count() const __attribute__((internal_linkage));
                typename common_type<duration<long long, ratio<1, 1000000> > >::type operator+() const __attribute__((internal_linkage));
                typename common_type<duration<long long, ratio<1, 1000000> > >::type operator-() const __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator++() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator++(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator--() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > operator--(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator*=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator/=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > &rhs) __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > zero() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > min() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > max() throw() __attribute__((internal_linkage));
            };
template<> class duration<long long, std::__1::ratio<1, 1>> {
                static_assert(!__is_duration<long long>::value, "A duration representation can not be a duration");
                static_assert(__is_ratio<ratio<1, 1> >::value, "Second template parameter of duration must be a std::ratio");
                static_assert(ratio<1, 1>::num > 0, "duration period must be positive");
                template <class _R1, class _R2> struct __no_overflow
template<> struct __no_overflow<std::__1::ratio<1, 1>, std::__1::ratio<1, 1>> {
                private:
                    static const intmax_t __gcd_n1_n2 = __static_gcd<ratio<1, 1>::num, ratio<1, 1>::num>::value;
                    static const intmax_t __gcd_d1_d2 = __static_gcd<ratio<1, 1>::den, ratio<1, 1>::den>::value;
                    static const intmax_t __n1 = ratio<1, 1>::num / __gcd_n1_n2;
                    static const intmax_t __d1 = ratio<1, 1>::den / __gcd_d1_d2;
                    static const intmax_t __n2 = ratio<1, 1>::num / __gcd_n1_n2;
                    static const intmax_t __d2 = ratio<1, 1>::den / __gcd_d1_d2;
                    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
                    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul
template<> struct __mul<1, 1, false> {
                        static const intmax_t value = 1L * 1L;
                    };
                public:
                    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
                    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
                };
            public:
                typedef long long rep;
                typedef typename ratio<1, 1>::type period;
            private:
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep __rep_;
            public:
                duration() __attribute__((internal_linkage));
                template <class _Rep2> explicit duration(const _Rep2 &__r, typename enable_if<is_convertible<_Rep2, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value)>::type *) __attribute__((internal_linkage));
                template<> explicit duration<long long>(const long long &__r, typename enable_if<is_convertible<long long, rep>::value && (treat_as_floating_point<rep>::value || !treat_as_floating_point<long long>::value)>::type * = 0) : __rep_(__r) __attribute__((internal_linkage))                 {
                }
;
                template <class _Rep2, class _Period2> duration(const duration<_Rep2, _Period2> &__d, typename enable_if<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<_Period2, period>::type::den == 1 && !treat_as_floating_point<_Rep2>::value))>::type *) __attribute__((internal_linkage));
                template<> duration<long long, std::__1::ratio<1, 1>>(const duration<long long, std::__1::ratio<1, 1> > &__d, typename enable_if<__no_overflow<ratio<1, 1>, period>::value && (treat_as_floating_point<rep>::value || (__no_overflow<ratio<1, 1>, period>::type::den == 1 && !treat_as_floating_point<long long>::value))>::type *) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep count() const __attribute__((internal_linkage))                 {
                    return this->__rep_;
                }
                typename common_type<duration<long long, ratio<1, 1> > >::type operator+() const __attribute__((internal_linkage));
                typename common_type<duration<long long, ratio<1, 1> > >::type operator-() const __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator++() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > operator++(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator--() __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > operator--(int) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator+=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator-=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &__d) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator*=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator/=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> >::rep &rhs) __attribute__((internal_linkage));
                std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &operator%=(const std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > &rhs) __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > zero() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > min() throw() __attribute__((internal_linkage));
                static std::__1::chrono::duration<long long, std::__1::ratio<1, 1> > max() throw() __attribute__((internal_linkage));
            };
            typedef duration<long long, std::__1::nano> nanoseconds;
            typedef duration<long long, std::__1::micro> microseconds;
            typedef duration<long long, std::__1::milli> milliseconds;
            typedef duration<long long> seconds;
            typedef duration<long, ratio<60> > minutes;
            typedef duration<long, ratio<3600> > hours;
            template <class _LhsDuration, class _RhsDuration> struct __duration_eq {
                bool operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
                    return _Ct(__lhs).count() == _Ct(__rhs).count();
                }
            };
            template <class _LhsDuration> struct __duration_eq<_LhsDuration, _LhsDuration> {
                bool operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __lhs.count() == __rhs.count();
                }
            };
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline bool operator==(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
            }
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline bool operator!=(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__lhs == __rhs);
            }
            template <class _LhsDuration, class _RhsDuration> struct __duration_lt {
                bool operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
                    return _Ct(__lhs).count() < _Ct(__rhs).count();
                }
            };
            template <class _LhsDuration> struct __duration_lt<_LhsDuration, _LhsDuration> {
                bool operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return __lhs.count() < __rhs.count();
                }
            };
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline bool operator<(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
            }
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline bool operator>(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __rhs < __lhs;
            }
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline bool operator<=(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__rhs < __lhs);
            }
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline bool operator>=(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__lhs < __rhs);
            }
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type operator+(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
                return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
            }
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type operator-(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
                return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
            }
            template<> inline typename common_type<duration<long long, ratio<1, 1000000000> >, duration<long long, ratio<1, 1> > >::type operator-<long long, std::__1::ratio<1, 1000000000>, long long, std::__1::ratio<1, 1>>(const duration<long long, std::__1::ratio<1, 1000000000> > &__lhs, const duration<long long, std::__1::ratio<1, 1> > &__rhs) __attribute__((internal_linkage))             {
                typedef typename common_type<duration<long long, ratio<1, 1000000000> >, duration<long long, ratio<1, 1> > >::type _Cd;
                return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
            }
            template <class _Rep1, class _Period, class _Rep2> inline typename enable_if<is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value, duration<typename common_type<_Rep1, _Rep2>::type, _Period> >::type operator*(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef typename common_type<_Rep1, _Rep2>::type _Cr;
                typedef duration<_Cr, _Period> _Cd;
                return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
            }
            template <class _Rep1, class _Period, class _Rep2> inline typename enable_if<is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value, duration<typename common_type<_Rep1, _Rep2>::type, _Period> >::type operator*(const _Rep1 &__s, const duration<_Rep2, _Period> &__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __d * __s;
            }
            template <class _Rep1, class _Period, class _Rep2> inline typename enable_if<!__is_duration<_Rep2>::value && is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value, duration<typename common_type<_Rep1, _Rep2>::type, _Period> >::type operator/(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef typename common_type<_Rep1, _Rep2>::type _Cr;
                typedef duration<_Cr, _Period> _Cd;
                return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
            }
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline typename common_type<_Rep1, _Rep2>::type operator/(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
                return _Ct(__lhs).count() / _Ct(__rhs).count();
            }
            template <class _Rep1, class _Period, class _Rep2> inline typename enable_if<!__is_duration<_Rep2>::value && is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value, duration<typename common_type<_Rep1, _Rep2>::type, _Period> >::type operator%(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef typename common_type<_Rep1, _Rep2>::type _Cr;
                typedef duration<_Cr, _Period> _Cd;
                return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
            }
            template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type operator%(const duration<_Rep1, _Period1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef typename common_type<_Rep1, _Rep2>::type _Cr;
                typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
                return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
            }
            template <class _Clock, class _Duration = typename _Clock::duration> class __attribute__((type_visibility("default"))) time_point {
                static_assert(__is_duration<_Duration>::value, "Second template parameter of time_point must be a std::chrono::duration");
            public:
                typedef _Clock clock;
                typedef _Duration duration;
                typedef typename duration::rep rep;
                typedef typename duration::period period;
            private:
                std::__1::chrono::time_point::duration __d_;
            public:
                time_point<_Clock, _Duration>() : __d_(duration::zero()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                explicit time_point<_Clock, _Duration>(const std::__1::chrono::time_point::duration &__d) : __d_(__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                template <class _Duration2> time_point<_Clock, _Duration>(const time_point<std::__1::chrono::time_point::clock, _Duration2> &t, typename enable_if<is_convertible<_Duration2, duration>::value>::type * = 0) : __d_(t.time_since_epoch()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                }
                std::__1::chrono::time_point::duration time_since_epoch() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return this->__d_;
                }
                time_point<_Clock, _Duration> &operator+=(const std::__1::chrono::time_point::duration &__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__d_ += __d;
                    return * this;
                }
                time_point<_Clock, _Duration> &operator-=(const std::__1::chrono::time_point::duration &__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    this->__d_ -= __d;
                    return * this;
                }
                static time_point<_Clock, _Duration> min() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return time_point<_Clock, _Duration>(duration::min());
                }
                static time_point<_Clock, _Duration> max() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))                 {
                    return time_point<_Clock, _Duration>(duration::max());
                }
            };
template<> class time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> >> {
                static_assert(__is_duration<duration<long long, ratio<1, 1000000> > >::value, "Second template parameter of time_point must be a std::chrono::duration");
            public:
                typedef std::__1::chrono::system_clock clock;
                typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > duration;
                typedef typename duration::rep rep;
                typedef typename duration::period period;
            private:
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > >::duration __d_;
            public:
                time_point() __attribute__((internal_linkage));
                explicit time_point(const std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > >::duration &__d) __attribute__((internal_linkage));
                template <class _Duration2> time_point(const time_point<std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > >::clock, _Duration2> &t, typename enable_if<is_convertible<_Duration2, duration>::value>::type *) __attribute__((internal_linkage));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > >::duration time_since_epoch() const __attribute__((internal_linkage));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > &operator+=(const std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > >::duration &__d) __attribute__((internal_linkage));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > &operator-=(const std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > >::duration &__d) __attribute__((internal_linkage));
                static std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > min() throw() __attribute__((internal_linkage));
                static std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000> > > max() throw() __attribute__((internal_linkage));
            };
template<> class time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> {
                static_assert(__is_duration<duration<long long, ratio<1, 1000000000> > >::value, "Second template parameter of time_point must be a std::chrono::duration");
            public:
                typedef std::__1::chrono::steady_clock clock;
                typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > duration;
                typedef typename duration::rep rep;
                typedef typename duration::period period;
            private:
                std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration __d_;
            public:
                time_point() __attribute__((internal_linkage));
                explicit time_point(const std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration &__d) __attribute__((internal_linkage));
                template <class _Duration2> time_point(const time_point<std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::clock, _Duration2> &t, typename enable_if<is_convertible<_Duration2, duration>::value>::type *) __attribute__((internal_linkage));
                template<> time_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >>(const time_point<std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &t, typename enable_if<is_convertible<duration<long long, ratio<1, 1000000000> >, duration>::value>::type *) __attribute__((internal_linkage));
                std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration time_since_epoch() const __attribute__((internal_linkage));
                std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &operator+=(const std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration &__d) __attribute__((internal_linkage));
                std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &operator-=(const std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration &__d) __attribute__((internal_linkage));
                static std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > min() throw() __attribute__((internal_linkage));
                static std::__1::chrono::time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > max() throw() __attribute__((internal_linkage));
            };
template<> class time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >> {
                static_assert(__is_duration<duration<long long, ratio<1, 1000000000> > >::value, "Second template parameter of time_point must be a std::chrono::duration");
            public:
                typedef std::__1::chrono::system_clock clock;
                typedef std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > duration;
                typedef typename duration::rep rep;
                typedef typename duration::period period;
            private:
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration __d_;
            public:
                time_point() __attribute__((internal_linkage));
                explicit time_point(const std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration &__d) __attribute__((internal_linkage));
                template <class _Duration2> time_point(const time_point<std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::clock, _Duration2> &t, typename enable_if<is_convertible<_Duration2, duration>::value>::type *) __attribute__((internal_linkage));
                template<> time_point<std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >>(const time_point<std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &t, typename enable_if<is_convertible<duration<long long, ratio<1, 1000000000> >, duration>::value>::type *) __attribute__((internal_linkage));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration time_since_epoch() const __attribute__((internal_linkage));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &operator+=(const std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration &__d) __attribute__((internal_linkage));
                std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &operator-=(const std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > >::duration &__d) __attribute__((internal_linkage));
                static std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > min() throw() __attribute__((internal_linkage));
                static std::__1::chrono::time_point<std::__1::chrono::system_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > max() throw() __attribute__((internal_linkage));
            };
        }
        template <class _Clock, class _Duration1, class _Duration2> struct __attribute__((type_visibility("default"))) common_type<chrono::time_point<_Clock, _Duration1>, chrono::time_point<_Clock, _Duration2>> {
            typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
        };
        namespace chrono {
            template <class _ToDuration, class _Clock, class _Duration> inline time_point<_Clock, _ToDuration> time_point_cast(const time_point<_Clock, _Duration> &__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return time_point<_Clock, _ToDuration>(std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
            }
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator==(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __lhs.time_since_epoch() == __rhs.time_since_epoch();
            }
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator!=(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__lhs == __rhs);
            }
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator<(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __lhs.time_since_epoch() < __rhs.time_since_epoch();
            }
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator>(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __rhs < __lhs;
            }
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator<=(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__rhs < __lhs);
            }
            template <class _Clock, class _Duration1, class _Duration2> inline bool operator>=(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__lhs < __rhs);
            }
            template <class _Clock, class _Duration1, class _Rep2, class _Period2> inline time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> operator+(const time_point<_Clock, _Duration1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
                return _Tr(__lhs.time_since_epoch() + __rhs);
            }
            template <class _Rep1, class _Period1, class _Clock, class _Duration2> inline time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type> operator+(const duration<_Rep1, _Period1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __rhs + __lhs;
            }
            template <class _Clock, class _Duration1, class _Rep2, class _Period2> inline time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> operator-(const time_point<_Clock, _Duration1> &__lhs, const duration<_Rep2, _Period2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
                return _Ret(__lhs.time_since_epoch() - __rhs);
            }
            template <class _Clock, class _Duration1, class _Duration2> inline typename common_type<_Duration1, _Duration2>::type operator-(const time_point<_Clock, _Duration1> &__lhs, const time_point<_Clock, _Duration2> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __lhs.time_since_epoch() - __rhs.time_since_epoch();
            }
            template<> inline typename common_type<duration<long long, ratio<1, 1000000000> >, duration<long long, ratio<1, 1000000000> > >::type operator-<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> >>(const time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &__lhs, const time_point<std::__1::chrono::steady_clock, std::__1::chrono::duration<long long, std::__1::ratio<1, 1000000000> > > &__rhs) __attribute__((internal_linkage))            class __attribute__((visibility("default"))) system_clock {
            public:
                typedef std::__1::chrono::microseconds duration;
                typedef duration::rep rep;
                typedef duration::period period;
                typedef chrono::time_point<system_clock> time_point;
                static const bool is_steady = false;
                static std::__1::chrono::system_clock::time_point now() throw();
                static time_t to_time_t(const std::__1::chrono::system_clock::time_point &__t) throw();
                static std::__1::chrono::system_clock::time_point from_time_t(time_t __t) throw();
            };
            class __attribute__((visibility("default"))) steady_clock {
            public:
                typedef std::__1::chrono::nanoseconds duration;
                typedef duration::rep rep;
                typedef duration::period period;
                typedef chrono::time_point<steady_clock, duration> time_point;
                static const bool is_steady = true;
                static std::__1::chrono::steady_clock::time_point now() throw();
            };
            typedef std::__1::chrono::steady_clock high_resolution_clock;
        }
    }
}
extern "C" {
    extern int *__error();
}
namespace std {
    inline namespace __1 {
        struct __attribute__((visibility("default"))) errc {
            enum __lx {
                address_family_not_supported = 47,
                address_in_use = 48,
                address_not_available = 49,
                already_connected = 56,
                argument_list_too_long = 7,
                argument_out_of_domain = 33,
                bad_address = 14,
                bad_file_descriptor = 9,
                bad_message = 94,
                broken_pipe = 32,
                connection_aborted = 53,
                connection_already_in_progress = 37,
                connection_refused = 61,
                connection_reset = 54,
                cross_device_link = 18,
                destination_address_required = 39,
                device_or_resource_busy = 16,
                directory_not_empty = 66,
                executable_format_error = 8,
                file_exists = 17,
                file_too_large = 27,
                filename_too_long = 63,
                function_not_supported = 78,
                host_unreachable = 65,
                identifier_removed = 90,
                illegal_byte_sequence = 92,
                inappropriate_io_control_operation = 25,
                interrupted = 4,
                invalid_argument = 22,
                invalid_seek = 29,
                io_error = 5,
                is_a_directory = 21,
                message_size = 40,
                network_down = 50,
                network_reset = 52,
                network_unreachable = 51,
                no_buffer_space = 55,
                no_child_process = 10,
                no_link = 97,
                no_lock_available = 77,
                no_message_available = 96,
                no_message = 91,
                no_protocol_option = 42,
                no_space_on_device = 28,
                no_stream_resources = 98,
                no_such_device_or_address = 6,
                no_such_device = 19,
                no_such_file_or_directory = 2,
                no_such_process = 3,
                not_a_directory = 20,
                not_a_socket = 38,
                not_a_stream = 99,
                not_connected = 57,
                not_enough_memory = 12,
                not_supported = 45,
                operation_canceled = 89,
                operation_in_progress = 36,
                operation_not_permitted = 1,
                operation_not_supported = 102,
                operation_would_block = 35,
                owner_dead = 105,
                permission_denied = 13,
                protocol_error = 100,
                protocol_not_supported = 43,
                read_only_file_system = 30,
                resource_deadlock_would_occur = 11,
                resource_unavailable_try_again = 35,
                result_out_of_range = 34,
                state_not_recoverable = 104,
                stream_timeout = 101,
                text_file_busy = 26,
                timed_out = 60,
                too_many_files_open_in_system = 23,
                too_many_files_open = 24,
                too_many_links = 31,
                too_many_symbolic_link_levels = 62,
                value_too_large = 84,
                wrong_protocol_type = 41
            };
            std::__1::errc::__lx __v_;
            errc(std::__1::errc::__lx __v) : __v_(__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit errc(int __v) : __v_(static_cast<std::__1::errc::__lx>(__v)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            operator int() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__v_;
            }
        };
    }
}
namespace std {
    inline namespace __1 {
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_error_code_enum : public std::__1::false_type {
        };
template<> struct is_error_code_enum<int> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::error_code> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::error_category> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::error_condition> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::__thread_id> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::locale> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::system_error> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::basic_string<char>> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::ios_base &(*)(std::__1::ios_base &)> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::__iom_t6> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::__iom_t4<char>> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<const char *> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::basic_streambuf<char> *> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::basic_string<char> *> : public std::__1::false_type {
        };
template<> struct is_error_code_enum<std::__1::__wrap_iter<const std::__1::basic_string<char> *>> : public std::__1::false_type {
        };
        template <class _Tp> struct __attribute__((type_visibility("default"))) is_error_condition_enum : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<int> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::error_condition> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::error_category> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::error_code> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::__thread_id> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::locale> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::basic_string<char>> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::basic_streambuf<char> *> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::basic_string<char> *> : public std::__1::false_type {
        };
template<> struct is_error_condition_enum<std::__1::__wrap_iter<const std::__1::basic_string<char> *>> : public std::__1::false_type {
        };
        template<> struct __attribute__((type_visibility("default"))) is_error_condition_enum<std::__1::errc> : std::__1::true_type {
        };
        template<> struct __attribute__((type_visibility("default"))) is_error_condition_enum<errc::__lx> : std::__1::true_type {
        };
        class __attribute__((visibility("default"))) error_condition;
        class __attribute__((visibility("default"))) error_code;
        class __attribute__((visibility("hidden"))) __do_message;
        class __attribute__((visibility("default"))) error_category {
        public:
            virtual ~error_category() throw();
            error_category() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        private:
            error_category(const std::__1::error_category &);
            std::__1::error_category &operator=(const std::__1::error_category &);
        public:
            virtual const char *name() const throw() = 0;
            virtual std::__1::error_condition default_error_condition(int __ev) const throw();
            virtual bool equivalent(int __code, const std::__1::error_condition &__condition) const throw();
            virtual bool equivalent(const std::__1::error_code &__code, int __condition) const throw();
            virtual std::__1::string message(int __ev) const = 0;
            bool operator==(const std::__1::error_category &__rhs) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this == &__rhs;
            }
            bool operator!=(const std::__1::error_category &__rhs) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(*this == __rhs);
            }
            bool operator<(const std::__1::error_category &__rhs) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this < &__rhs;
            }
            friend  class __do_message;
        };
        class __attribute__((visibility("hidden"))) __do_message : public std::__1::error_category {
        public:
            virtual std::__1::string message(int ev) const;
        };
        const std::__1::error_category &generic_category() throw() __attribute__((visibility("default")));
        const std::__1::error_category &system_category() throw() __attribute__((visibility("default")));
        class __attribute__((visibility("default"))) error_condition {
            int __val_;
            const std::__1::error_category *__cat_;
        public:
            error_condition() throw() : __val_(0), __cat_(&generic_category()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            error_condition(int __val, const std::__1::error_category &__cat) throw() : __val_(__val), __cat_(&__cat) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Ep> error_condition(_Ep __e, typename enable_if<is_error_condition_enum<_Ep>::value>::type * = 0) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                *this = make_error_condition(__e);
            }
            void assign(int __val, const std::__1::error_category &__cat) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__val_ = __val;
                this->__cat_ = &__cat;
            }
            template <class _Ep> typename enable_if<is_error_condition_enum<_Ep>::value, error_condition &>::type operator=(_Ep __e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                *this = make_error_condition(__e);
                return *this;
            }
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__val_ = 0;
                this->__cat_ = &generic_category();
            }
            int value() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__val_;
            }
            const std::__1::error_category &category() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__cat_;
            }
            std::__1::string message() const;
            operator bool() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__val_ != 0;
            }
        };
        inline std::__1::error_condition make_error_condition(std::__1::errc __e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::error_condition(static_cast<int>(__e), generic_category());
        }
        inline bool operator<(const std::__1::error_condition &__x, const std::__1::error_condition &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.category() < __y.category() || (__x.category() == __y.category() && __x.value() < __y.value());
        }
        class __attribute__((visibility("default"))) error_code {
            int __val_;
            const std::__1::error_category *__cat_;
        public:
            error_code() throw() : __val_(0), __cat_(&system_category()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            error_code(int __val, const std::__1::error_category &__cat) throw() : __val_(__val), __cat_(&__cat) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Ep> error_code(_Ep __e, typename enable_if<is_error_code_enum<_Ep>::value>::type * = 0) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                *this = make_error_code(__e);
            }
            template<> error_code<std::__1::io_errc::__lx>(std::__1::io_errc::__lx __e, typename enable_if<is_error_code_enum<__lx>::value>::type * = 0) throw() __attribute__((internal_linkage))             {
                *this = make_error_code(__e);
            }
            void assign(int __val, const std::__1::error_category &__cat) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__val_ = __val;
                this->__cat_ = &__cat;
            }
            template <class _Ep> typename enable_if<is_error_code_enum<_Ep>::value, error_code &>::type operator=(_Ep __e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                *this = make_error_code(__e);
                return *this;
            }
            void clear() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__val_ = 0;
                this->__cat_ = &system_category();
            }
            int value() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__val_;
            }
            const std::__1::error_category &category() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this->__cat_;
            }
            std::__1::error_condition default_error_condition() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cat_->default_error_condition(this->__val_);
            }
            std::__1::string message() const;
            operator bool() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__val_ != 0;
            }
        };
        inline std::__1::error_code make_error_code(std::__1::errc __e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::error_code(static_cast<int>(__e), generic_category());
        }
        inline bool operator<(const std::__1::error_code &__x, const std::__1::error_code &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.category() < __y.category() || (__x.category() == __y.category() && __x.value() < __y.value());
        }
        inline bool operator==(const std::__1::error_code &__x, const std::__1::error_code &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.category() == __y.category() && __x.value() == __y.value();
        }
        inline bool operator==(const std::__1::error_code &__x, const std::__1::error_condition &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.category().equivalent(__x.value(), __y) || __y.category().equivalent(__x, __y.value());
        }
        inline bool operator==(const std::__1::error_condition &__x, const std::__1::error_code &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __y == __x;
        }
        inline bool operator==(const std::__1::error_condition &__x, const std::__1::error_condition &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __x.category() == __y.category() && __x.value() == __y.value();
        }
        inline bool operator!=(const std::__1::error_code &__x, const std::__1::error_code &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        inline bool operator!=(const std::__1::error_code &__x, const std::__1::error_condition &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        inline bool operator!=(const std::__1::error_condition &__x, const std::__1::error_code &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        inline bool operator!=(const std::__1::error_condition &__x, const std::__1::error_condition &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return !(__x == __y);
        }
        template<> struct __attribute__((type_visibility("default"))) hash<std::__1::error_code> : public unary_function<std::__1::error_code, size_t> {
            size_t operator()(const std::__1::error_code &__ec) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__ec.value());
            }
        };
        template<> struct __attribute__((type_visibility("default"))) hash<std::__1::error_condition> : public unary_function<std::__1::error_condition, size_t> {
            size_t operator()(const std::__1::error_condition &__ec) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return static_cast<size_t>(__ec.value());
            }
        };
        class __attribute__((visibility("default"))) system_error : public std::runtime_error {
            std::__1::error_code __ec_;
        public:
            system_error(std::__1::error_code __ec, const std::__1::string &__what_arg);
            system_error(std::__1::error_code __ec, const char *__what_arg);
            system_error(std::__1::error_code __ec);
            system_error(int __ev, const std::__1::error_category &__ecat, const std::__1::string &__what_arg);
            system_error(int __ev, const std::__1::error_category &__ecat, const char *__what_arg);
            system_error(int __ev, const std::__1::error_category &__ecat);
            ~system_error() throw();
            const std::__1::error_code &code() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ec_;
            }
        private:
            static std::__1::string __init(const std::__1::error_code &, std::__1::string);
        };
        void __throw_system_error(int ev, const char *what_arg) __attribute__((visibility("default")));
    }
}
extern "C" {
    struct sched_param {
        int sched_priority;
        char __opaque[4];
    };
    extern int sched_yield();
    extern int sched_get_priority_min(int);
    extern int sched_get_priority_max(int);
}
typedef __darwin_pthread_cond_t pthread_cond_t;
typedef __darwin_pthread_condattr_t pthread_condattr_t;
typedef __darwin_pthread_key_t pthread_key_t;
typedef __darwin_pthread_mutex_t pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
typedef __darwin_pthread_once_t pthread_once_t;
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
typedef __darwin_pthread_t pthread_t;
enum  {
    QOS_CLASS_USER_INTERACTIVE __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0))) = 33,
    QOS_CLASS_USER_INITIATED __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0))) = 25,
    QOS_CLASS_DEFAULT __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0))) = 21,
    QOS_CLASS_UTILITY __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0))) = 17,
    QOS_CLASS_BACKGROUND __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0))) = 9,
    QOS_CLASS_UNSPECIFIED __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0))) = 0
};
typedef unsigned int qos_class_t;
extern "C" {
    qos_class_t qos_class_self() __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0)));
    qos_class_t qos_class_main() __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0)));
}
extern "C" {
    int pthread_attr_set_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t __qos_class, int __relative_priority) __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0)));
    int pthread_attr_get_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t * _Nullable __qos_class, int * _Nullable __relative_priority) __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0)));
    int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority) __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0)));
    int pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t * _Nullable __qos_class, int * _Nullable __relative_priority) __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0)));
    typedef struct pthread_override_s *pthread_override_t,  _Nonnull pthread_override_qos_class_start_np(pthread_t  _Nonnull __pthread, qos_class_t __qos_class, int __relative_priority) __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0)));
    int pthread_override_qos_class_end_np(pthread_override_t  _Nonnull __override) __attribute__((availability(macos, introduced=10.10))) __attribute__((availability(ios, introduced=8.0)));
}
typedef __darwin_mach_port_t mach_port_t;
extern "C" {
    int pthread_atfork(void (* _Nullable)(), void (* _Nullable)(), void (* _Nullable)()) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_destroy(pthread_attr_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_getdetachstate(const pthread_attr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_getguardsize(const pthread_attr_t * _Nonnull, size_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_getinheritsched(const pthread_attr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_getschedparam(const pthread_attr_t * _Nonnull, struct sched_param * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_getschedpolicy(const pthread_attr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_getscope(const pthread_attr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_getstack(const pthread_attr_t * _Nonnull, void * _Nullable * _Nonnull, size_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_getstackaddr(const pthread_attr_t * _Nonnull, void * _Nullable * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_getstacksize(const pthread_attr_t * _Nonnull, size_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_init(pthread_attr_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_setdetachstate(pthread_attr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_setguardsize(pthread_attr_t * _Nonnull, size_t) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_setinheritsched(pthread_attr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_setschedparam(pthread_attr_t * _Nonnull, const struct sched_param * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_setschedpolicy(pthread_attr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_setscope(pthread_attr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_setstack(pthread_attr_t * _Nonnull, void * _Nonnull, size_t) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_setstackaddr(pthread_attr_t * _Nonnull, void * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_attr_setstacksize(pthread_attr_t * _Nonnull, size_t) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_cancel(pthread_t _Nonnull) asm("_pthread_cancel") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_cond_broadcast(pthread_cond_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_cond_destroy(pthread_cond_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_cond_init(pthread_cond_t * _Nonnull, const pthread_condattr_t * _Nullable) asm("_pthread_cond_init") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_cond_signal(pthread_cond_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_cond_timedwait(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable) asm("_pthread_cond_timedwait") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_cond_wait(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull) asm("_pthread_cond_wait") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_condattr_destroy(pthread_condattr_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_condattr_init(pthread_condattr_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_condattr_getpshared(const pthread_condattr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_condattr_setpshared(pthread_condattr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_create(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_detach(pthread_t _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_equal(pthread_t _Nullable, pthread_t _Nullable) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    void pthread_exit(void * _Nullable) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_getconcurrency() __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_getschedparam(pthread_t _Nonnull, int * _Nullable, struct sched_param * _Nullable) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    void * _Nullable pthread_getspecific(pthread_key_t) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_join(pthread_t _Nonnull, void * _Nullable * _Nullable) asm("_pthread_join") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_key_create(pthread_key_t * _Nonnull, void (* _Nullable)(void * _Nonnull)) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_key_delete(pthread_key_t) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutex_destroy(pthread_mutex_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutex_getprioceiling(const pthread_mutex_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutex_init(pthread_mutex_t * _Nonnull, const pthread_mutexattr_t * _Nullable) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutex_lock(pthread_mutex_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutex_setprioceiling(pthread_mutex_t * _Nonnull, int, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutex_trylock(pthread_mutex_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutex_unlock(pthread_mutex_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_destroy(pthread_mutexattr_t * _Nonnull) asm("_pthread_mutexattr_destroy") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_getpshared(const pthread_mutexattr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_gettype(const pthread_mutexattr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.13.4))) __attribute__((availability(ios, introduced=11.3))) __attribute__((availability(watchos, introduced=4.3))) __attribute__((availability(tvos, introduced=11.3)));
    int pthread_mutexattr_init(pthread_mutexattr_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_setprotocol(pthread_mutexattr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_setpshared(pthread_mutexattr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_settype(pthread_mutexattr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.7))) __attribute__((availability(ios, introduced=5.0)));
    int pthread_once(pthread_once_t * _Nonnull, void (* _Nonnull)()) __attribute__((availability(swift, unavailable))) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlock_destroy(pthread_rwlock_t * _Nonnull) asm("_pthread_rwlock_destroy") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlock_init(pthread_rwlock_t * _Nonnull, const pthread_rwlockattr_t * _Nullable) asm("_pthread_rwlock_init") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlock_rdlock(pthread_rwlock_t * _Nonnull) asm("_pthread_rwlock_rdlock") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlock_tryrdlock(pthread_rwlock_t * _Nonnull) asm("_pthread_rwlock_tryrdlock") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlock_trywrlock(pthread_rwlock_t * _Nonnull) asm("_pthread_rwlock_trywrlock") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlock_wrlock(pthread_rwlock_t * _Nonnull) asm("_pthread_rwlock_wrlock") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlock_unlock(pthread_rwlock_t * _Nonnull) asm("_pthread_rwlock_unlock") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlockattr_destroy(pthread_rwlockattr_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * _Nonnull, int * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlockattr_init(pthread_rwlockattr_t * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    pthread_t  _Nonnull pthread_self() __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_setcancelstate(int, int * _Nullable) asm("_pthread_setcancelstate") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_setcanceltype(int, int * _Nullable) asm("_pthread_setcanceltype") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_setconcurrency(int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_setschedparam(pthread_t _Nonnull, int, const struct sched_param * _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_setspecific(pthread_key_t, const void * _Nullable) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    void pthread_testcancel() asm("_pthread_testcancel") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_is_threaded_np() __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_threadid_np(pthread_t _Nullable, __uint64_t * _Nullable) __attribute__((availability(macos, introduced=10.6))) __attribute__((availability(ios, introduced=3.2)));
    int pthread_getname_np(pthread_t _Nonnull, char * _Nonnull, size_t) __attribute__((availability(macos, introduced=10.6))) __attribute__((availability(ios, introduced=3.2)));
    int pthread_setname_np(const char * _Nonnull) __attribute__((availability(macos, introduced=10.6))) __attribute__((availability(ios, introduced=3.2)));
    int pthread_main_np() __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    mach_port_t pthread_mach_thread_np(pthread_t _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    size_t pthread_get_stacksize_np(pthread_t _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    void * _Nonnull pthread_get_stackaddr_np(pthread_t _Nonnull) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_cond_signal_thread_np(pthread_cond_t * _Nonnull, pthread_t _Nullable) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_cond_timedwait_relative_np(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_create_suspended_np(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_kill(pthread_t _Nonnull, int) __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    pthread_t  _Nullable pthread_from_mach_thread_np(mach_port_t) __attribute__((availability(macos, introduced=10.5))) __attribute__((availability(ios, introduced=2.0)));
    int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable) asm("_pthread_sigmask") __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
    void pthread_yield_np() __attribute__((availability(macos, introduced=10.4))) __attribute__((availability(ios, introduced=2.0)));
}
typedef ::timespec __libcpp_timespec_t;
namespace std {
    inline namespace __1 {
        typedef pthread_mutex_t __libcpp_mutex_t;
        typedef pthread_mutex_t __libcpp_recursive_mutex_t;
        typedef pthread_cond_t __libcpp_condvar_t;
        typedef pthread_once_t __libcpp_exec_once_flag;
        typedef pthread_t __libcpp_thread_id;
        typedef pthread_t __libcpp_thread_t;
        typedef pthread_key_t __libcpp_tls_key;
        inline int __libcpp_recursive_mutex_init(std::__1::__libcpp_recursive_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_recursive_mutex_lock(std::__1::__libcpp_recursive_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline bool __libcpp_recursive_mutex_trylock(std::__1::__libcpp_recursive_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_recursive_mutex_unlock(std::__1::__libcpp_recursive_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_recursive_mutex_destroy(std::__1::__libcpp_recursive_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_mutex_lock(std::__1::__libcpp_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline bool __libcpp_mutex_trylock(std::__1::__libcpp_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_mutex_unlock(std::__1::__libcpp_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_mutex_destroy(std::__1::__libcpp_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_condvar_signal(std::__1::__libcpp_condvar_t *__cv) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_condvar_broadcast(std::__1::__libcpp_condvar_t *__cv) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_condvar_wait(std::__1::__libcpp_condvar_t *__cv, std::__1::__libcpp_mutex_t *__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_condvar_timedwait(std::__1::__libcpp_condvar_t *__cv, std::__1::__libcpp_mutex_t *__m, __libcpp_timespec_t *__ts) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_condvar_destroy(std::__1::__libcpp_condvar_t *__cv) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_execute_once(std::__1::__libcpp_exec_once_flag *flag, void (*init_routine)()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline bool __libcpp_thread_id_equal(std::__1::__libcpp_thread_id t1, std::__1::__libcpp_thread_id t2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline bool __libcpp_thread_id_less(std::__1::__libcpp_thread_id t1, std::__1::__libcpp_thread_id t2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline bool __libcpp_thread_isnull(const std::__1::__libcpp_thread_t *__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_thread_create(std::__1::__libcpp_thread_t *__t, void *(*__func)(void *), void *__arg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline std::__1::__libcpp_thread_id __libcpp_thread_get_current_id() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline std::__1::__libcpp_thread_id __libcpp_thread_get_id(const std::__1::__libcpp_thread_t *__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_thread_join(std::__1::__libcpp_thread_t *__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_thread_detach(std::__1::__libcpp_thread_t *__t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline void __libcpp_thread_yield() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline void __libcpp_thread_sleep_for(const chrono::nanoseconds &__ns) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_tls_create(std::__1::__libcpp_tls_key *__key, void (*__at_exit)(void *)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline void *__libcpp_tls_get(std::__1::__libcpp_tls_key __key) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        inline int __libcpp_tls_set(std::__1::__libcpp_tls_key __key, void *__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        int __libcpp_recursive_mutex_init(std::__1::__libcpp_recursive_mutex_t *__m)         {
            pthread_mutexattr_t attr;
            int __ec = pthread_mutexattr_init(&attr);
            if (__ec)
                return __ec;
            __ec = pthread_mutexattr_settype(&attr, 2);
            if (__ec) {
                pthread_mutexattr_destroy(&attr);
                return __ec;
            }
            __ec = pthread_mutex_init(__m, &attr);
            if (__ec) {
                pthread_mutexattr_destroy(&attr);
                return __ec;
            }
            __ec = pthread_mutexattr_destroy(&attr);
            if (__ec) {
                pthread_mutex_destroy(__m);
                return __ec;
            }
            return 0;
        }
        int __libcpp_recursive_mutex_lock(std::__1::__libcpp_recursive_mutex_t *__m)         {
            return pthread_mutex_lock(__m);
        }
        bool __libcpp_recursive_mutex_trylock(std::__1::__libcpp_recursive_mutex_t *__m)         {
            return pthread_mutex_trylock(__m) == 0;
        }
        int __libcpp_recursive_mutex_unlock(std::__1::__libcpp_mutex_t *__m)         {
            return pthread_mutex_unlock(__m);
        }
        int __libcpp_recursive_mutex_destroy(std::__1::__libcpp_recursive_mutex_t *__m)         {
            return pthread_mutex_destroy(__m);
        }
        int __libcpp_mutex_lock(std::__1::__libcpp_mutex_t *__m)         {
            return pthread_mutex_lock(__m);
        }
        bool __libcpp_mutex_trylock(std::__1::__libcpp_mutex_t *__m)         {
            return pthread_mutex_trylock(__m) == 0;
        }
        int __libcpp_mutex_unlock(std::__1::__libcpp_mutex_t *__m)         {
            return pthread_mutex_unlock(__m);
        }
        int __libcpp_mutex_destroy(std::__1::__libcpp_mutex_t *__m)         {
            return pthread_mutex_destroy(__m);
        }
        int __libcpp_condvar_signal(std::__1::__libcpp_condvar_t *__cv)         {
            return pthread_cond_signal(__cv);
        }
        int __libcpp_condvar_broadcast(std::__1::__libcpp_condvar_t *__cv)         {
            return pthread_cond_broadcast(__cv);
        }
        int __libcpp_condvar_wait(std::__1::__libcpp_condvar_t *__cv, std::__1::__libcpp_mutex_t *__m)         {
            return pthread_cond_wait(__cv, __m);
        }
        int __libcpp_condvar_timedwait(std::__1::__libcpp_condvar_t *__cv, std::__1::__libcpp_mutex_t *__m, __libcpp_timespec_t *__ts)         {
            return pthread_cond_timedwait(__cv, __m, __ts);
        }
        int __libcpp_condvar_destroy(std::__1::__libcpp_condvar_t *__cv)         {
            return pthread_cond_destroy(__cv);
        }
        int __libcpp_execute_once(std::__1::__libcpp_exec_once_flag *flag, void (*init_routine)())         {
            return pthread_once(flag, init_routine);
        }
        bool __libcpp_thread_id_equal(std::__1::__libcpp_thread_id t1, std::__1::__libcpp_thread_id t2)         {
            return pthread_equal(t1, t2) != 0;
        }
        bool __libcpp_thread_id_less(std::__1::__libcpp_thread_id t1, std::__1::__libcpp_thread_id t2)         {
            return t1 < t2;
        }
        bool __libcpp_thread_isnull(const std::__1::__libcpp_thread_t *__t)         {
            return *__t == 0;
        }
        int __libcpp_thread_create(std::__1::__libcpp_thread_t *__t, void *(*__func)(void *), void *__arg)         {
            return pthread_create(__t, 0, __func, __arg);
        }
        std::__1::__libcpp_thread_id __libcpp_thread_get_current_id()         {
            return pthread_self();
        }
        std::__1::__libcpp_thread_id __libcpp_thread_get_id(const std::__1::__libcpp_thread_t *__t)         {
            return *__t;
        }
        int __libcpp_thread_join(std::__1::__libcpp_thread_t *__t)         {
            return pthread_join(*__t, 0);
        }
        int __libcpp_thread_detach(std::__1::__libcpp_thread_t *__t)         {
            return pthread_detach(*__t);
        }
        void __libcpp_thread_yield()         {
            sched_yield();
        }
        void __libcpp_thread_sleep_for(const chrono::nanoseconds &__ns)         {
            using namespace chrono;
            std::__1::chrono::seconds __s = duration_cast<std::__1::chrono::seconds>(__ns);
            __libcpp_timespec_t __ts;
            typedef decltype(__ts.tv_sec) ts_sec;
            ts_sec __ts_sec_max = numeric_limits<ts_sec>::max();
            if (__s.count() < __ts_sec_max) {
                __ts.tv_sec = static_cast<ts_sec>(__s.count());
                __ts.tv_nsec = static_cast<decltype(__ts.tv_nsec)>((__ns - __s).count());
            } else {
                __ts.tv_sec = __ts_sec_max;
                __ts.tv_nsec = 999999999;
            }
            while (nanosleep(&__ts, &__ts) == -1 && (*__error()) == 4)
                ;
        }
        int __libcpp_tls_create(std::__1::__libcpp_tls_key *__key, void (*__at_exit)(void *))         {
            return pthread_key_create(__key, __at_exit);
        }
        void *__libcpp_tls_get(std::__1::__libcpp_tls_key __key)         {
            return pthread_getspecific(__key);
        }
        int __libcpp_tls_set(std::__1::__libcpp_tls_key __key, void *__p)         {
            return pthread_setspecific(__key, __p);
        }
        class __attribute__((visibility("default"))) thread;
        class __attribute__((visibility("default"))) __thread_id;
        namespace this_thread {
            std::__1::__thread_id get_id() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        }
        template<> struct hash<std::__1::__thread_id>;
        class __attribute__((type_visibility("default"))) __thread_id {
            std::__1::__libcpp_thread_id __id_;
        public:
            __thread_id() throw() : __id_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend bool operator==(std::__1::__thread_id __x, std::__1::__thread_id __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__x.__id_ == 0)
                    return __y.__id_ == 0;
                if (__y.__id_ == 0)
                    return false;
                return __libcpp_thread_id_equal(__x.__id_, __y.__id_);
            }
;
            friend bool operator!=(std::__1::__thread_id __x, std::__1::__thread_id __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x == __y);
            }
;
            friend bool operator<(std::__1::__thread_id __x, std::__1::__thread_id __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (__x.__id_ == 0)
                    return __y.__id_ != 0;
                if (__y.__id_ == 0)
                    return false;
                return __libcpp_thread_id_less(__x.__id_, __y.__id_);
            }
;
            friend bool operator<=(std::__1::__thread_id __x, std::__1::__thread_id __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__y < __x);
            }
;
            friend bool operator>(std::__1::__thread_id __x, std::__1::__thread_id __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __y < __x;
            }
;
            friend bool operator>=(std::__1::__thread_id __x, std::__1::__thread_id __y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !(__x < __y);
            }
;
            void __reset() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__id_ = 0;
            }
            friend template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, std::__1::__thread_id __id) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        private:
            __thread_id(std::__1::__libcpp_thread_id __id) : __id_(__id) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend std::__1::__thread_id this_thread::get_id() throw();
            friend  class thread;
            friend  struct hash<__thread_id>;
        };
        namespace this_thread {
            inline std::__1::__thread_id get_id() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __libcpp_thread_get_current_id();
            }
        }
    }
}
namespace std {
    inline namespace __1 {
        class __attribute__((visibility("default"))) mutex {
            std::__1::__libcpp_mutex_t __m_ = {850045863, {0}};
        public:
            mutex() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = default
            mutex(const std::__1::mutex &) = delete
            std::__1::mutex &operator=(const std::__1::mutex &) = delete
            ~mutex() throw();
            void lock();
            bool try_lock() throw();
            void unlock() throw();
            typedef std::__1::__libcpp_mutex_t *native_handle_type;
            std::__1::mutex::native_handle_type native_handle() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return &this->__m_;
            }
        };
        static_assert(is_nothrow_default_constructible<mutex>::value, "the default constructor for std::mutex must be nothrow");
        struct __attribute__((visibility("default"))) defer_lock_t {
            explicit defer_lock_t() = default
        };
        struct __attribute__((visibility("default"))) try_to_lock_t {
            explicit try_to_lock_t() = default
        };
        struct __attribute__((visibility("default"))) adopt_lock_t {
            explicit adopt_lock_t() = default
        };
        extern const std::__1::defer_lock_t defer_lock __attribute__((visibility("default")));
        extern const std::__1::try_to_lock_t try_to_lock __attribute__((visibility("default")));
        extern const std::__1::adopt_lock_t adopt_lock __attribute__((visibility("default")));
        template <class _Mutex> class __attribute__((type_visibility("default"))) lock_guard {
        public:
            typedef _Mutex mutex_type;
        private:
            std::__1::lock_guard::mutex_type &__m_;
        public:
            explicit lock_guard<_Mutex>(std::__1::lock_guard::mutex_type &__m) : __m_(__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__m_.lock();
            }
            lock_guard<_Mutex>(std::__1::lock_guard::mutex_type &__m, std::__1::adopt_lock_t) : __m_(__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~lock_guard<_Mutex>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__m_.unlock();
            }
        private:
            lock_guard<_Mutex>(const lock_guard<_Mutex> &);
            lock_guard<_Mutex> &operator=(const lock_guard<_Mutex> &);
        };
        template <class _Mutex> class __attribute__((type_visibility("default"))) unique_lock {
        public:
            typedef _Mutex mutex_type;
        private:
            std::__1::unique_lock::mutex_type *__m_;
            bool __owns_;
        public:
            unique_lock<_Mutex>() throw() : __m_(std::__1::__get_nullptr_t()), __owns_(false) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit unique_lock<_Mutex>(std::__1::unique_lock::mutex_type &__m) : __m_(std::__1::addressof(__m)), __owns_(true) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__m_->lock();
            }
            unique_lock<_Mutex>(std::__1::unique_lock::mutex_type &__m, std::__1::defer_lock_t) throw() : __m_(std::__1::addressof(__m)), __owns_(false) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            unique_lock<_Mutex>(std::__1::unique_lock::mutex_type &__m, std::__1::try_to_lock_t) : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            unique_lock<_Mutex>(std::__1::unique_lock::mutex_type &__m, std::__1::adopt_lock_t) : __m_(std::__1::addressof(__m)), __owns_(true) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Clock, class _Duration> unique_lock<_Mutex>(std::__1::unique_lock::mutex_type &__m, const chrono::time_point<_Clock, _Duration> &__t) : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_until(__t)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Rep, class _Period> unique_lock<_Mutex>(std::__1::unique_lock::mutex_type &__m, const chrono::duration<_Rep, _Period> &__d) : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_for(__d)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~unique_lock<_Mutex>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__owns_)
                    this->__m_->unlock();
            }
        private:
            unique_lock<_Mutex>(const unique_lock<_Mutex> &);
            unique_lock<_Mutex> &operator=(const unique_lock<_Mutex> &);
        public:
            void lock();
            bool try_lock();
            template <class _Rep, class _Period> bool try_lock_for(const chrono::duration<_Rep, _Period> &__d);
            template <class _Clock, class _Duration> bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
            void unlock();
            void swap(unique_lock<_Mutex> &__u) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::swap(this->__m_, __u.__m_);
                std::__1::swap(this->__owns_, __u.__owns_);
            }
            std::__1::unique_lock::mutex_type *release() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::unique_lock::mutex_type *__m = this->__m_;
                this->__m_ = std::__1::__get_nullptr_t();
                this->__owns_ = false;
                return __m;
            }
            bool owns_lock() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__owns_;
            }
            operator bool() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__owns_;
            }
            std::__1::unique_lock::mutex_type *mutex() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__m_;
            }
        };
template<> class unique_lock<std::__1::mutex> {
        public:
            typedef std::__1::mutex mutex_type;
        private:
            std::__1::unique_lock<std::__1::mutex>::mutex_type *__m_;
            bool __owns_;
        public:
            unique_lock() throw() __attribute__((internal_linkage));
            explicit unique_lock(std::__1::unique_lock<std::__1::mutex>::mutex_type &__m) __attribute__((internal_linkage));
            unique_lock(std::__1::unique_lock<std::__1::mutex>::mutex_type &__m, std::__1::defer_lock_t) throw() __attribute__((internal_linkage));
            unique_lock(std::__1::unique_lock<std::__1::mutex>::mutex_type &__m, std::__1::try_to_lock_t) __attribute__((internal_linkage));
            unique_lock(std::__1::unique_lock<std::__1::mutex>::mutex_type &__m, std::__1::adopt_lock_t) __attribute__((internal_linkage));
            template <class _Clock, class _Duration> unique_lock(std::__1::unique_lock<std::__1::mutex>::mutex_type &__m, const chrono::time_point<_Clock, _Duration> &__t) __attribute__((internal_linkage));
            template <class _Rep, class _Period> unique_lock(std::__1::unique_lock<std::__1::mutex>::mutex_type &__m, const chrono::duration<_Rep, _Period> &__d) __attribute__((internal_linkage));
            ~unique_lock<mutex>() __attribute__((internal_linkage));
        private:
            unique_lock(const std::__1::unique_lock<std::__1::mutex> &);
            std::__1::unique_lock<std::__1::mutex> &operator=(const std::__1::unique_lock<std::__1::mutex> &);
        public:
            void lock();
            bool try_lock();
            template <class _Rep, class _Period> bool try_lock_for(const chrono::duration<_Rep, _Period> &__d);
            template <class _Clock, class _Duration> bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
            void unlock();
            void swap(std::__1::unique_lock<std::__1::mutex> &__u) throw() __attribute__((internal_linkage));
            std::__1::unique_lock<std::__1::mutex>::mutex_type *release() throw() __attribute__((internal_linkage));
            bool owns_lock() const throw() __attribute__((internal_linkage));
            operator bool() const throw() __attribute__((internal_linkage));
            std::__1::unique_lock<std::__1::mutex>::mutex_type *mutex() const throw() __attribute__((internal_linkage));
        };
        template <class _Mutex> void unique_lock<_Mutex>::lock()         {
            if (this->__m_ == std::__1::__get_nullptr_t())
                __throw_system_error(1, "unique_lock::lock: references null mutex");
            if (this->__owns_)
                __throw_system_error(11, "unique_lock::lock: already locked");
            this->__m_->lock();
            this->__owns_ = true;
        }
        template <class _Mutex> bool unique_lock<_Mutex>::try_lock()         {
            if (this->__m_ == std::__1::__get_nullptr_t())
                __throw_system_error(1, "unique_lock::try_lock: references null mutex");
            if (this->__owns_)
                __throw_system_error(11, "unique_lock::try_lock: already locked");
            this->__owns_ = this->__m_->try_lock();
            return this->__owns_;
        }
        template <class _Mutex> template <class _Rep, class _Period> bool unique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period> &__d)         {
            if (this->__m_ == std::__1::__get_nullptr_t())
                __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
            if (this->__owns_)
                __throw_system_error(11, "unique_lock::try_lock_for: already locked");
            this->__owns_ = this->__m_->try_lock_for(__d);
            return this->__owns_;
        }
        template <class _Mutex> template <class _Clock, class _Duration> bool unique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration> &__t)         {
            if (this->__m_ == std::__1::__get_nullptr_t())
                __throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
            if (this->__owns_)
                __throw_system_error(11, "unique_lock::try_lock_until: already locked");
            this->__owns_ = this->__m_->try_lock_until(__t);
            return this->__owns_;
        }
        template <class _Mutex> void unique_lock<_Mutex>::unlock()         {
            if (!this->__owns_)
                __throw_system_error(1, "unique_lock::unlock: not locked");
            this->__m_->unlock();
            this->__owns_ = false;
        }
        template <class _Mutex> inline void swap(unique_lock<_Mutex> &__x, unique_lock<_Mutex> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        struct __attribute__((visibility("default"))) cv_status {
            enum __lx {
                no_timeout,
                timeout
            };
            std::__1::cv_status::__lx __v_;
            cv_status(std::__1::cv_status::__lx __v) : __v_(__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit cv_status(int __v) : __v_(static_cast<std::__1::cv_status::__lx>(__v)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            operator int() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__v_;
            }
        };
        class __attribute__((visibility("default"))) condition_variable {
            std::__1::__libcpp_condvar_t __cv_ = {1018212795, {0}};
        public:
            condition_variable() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) = default
            ~condition_variable();
            condition_variable(const std::__1::condition_variable &) = delete
            std::__1::condition_variable &operator=(const std::__1::condition_variable &) = delete
            void notify_one() throw();
            void notify_all() throw();
            void wait(unique_lock<std::__1::mutex> &__lk) throw();
            template <class _Predicate> inline void wait(unique_lock<std::__1::mutex> &__lk, _Predicate __pred) __attribute__((visibility("hidden")));
            template <class _Clock, class _Duration> inline std::__1::cv_status wait_until(unique_lock<std::__1::mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t) __attribute__((visibility("hidden")));
            template <class _Clock, class _Duration, class _Predicate> inline bool wait_until(unique_lock<std::__1::mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t, _Predicate __pred) __attribute__((visibility("hidden")));
            template <class _Rep, class _Period> inline std::__1::cv_status wait_for(unique_lock<std::__1::mutex> &__lk, const chrono::duration<_Rep, _Period> &__d) __attribute__((visibility("hidden")));
            template <class _Rep, class _Period, class _Predicate> bool wait_for(unique_lock<std::__1::mutex> &__lk, const chrono::duration<_Rep, _Period> &__d, _Predicate __pred) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            typedef std::__1::__libcpp_condvar_t *native_handle_type;
            std::__1::condition_variable::native_handle_type native_handle() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return &this->__cv_;
            }
        private:
            void __do_timed_wait(unique_lock<std::__1::mutex> &__lk, chrono::time_point<chrono::system_clock, chrono::nanoseconds>) throw();
            template <class _Clock> void __do_timed_wait(unique_lock<std::__1::mutex> &__lk, chrono::time_point<_Clock, chrono::nanoseconds>) throw();
        };
        template <class _Rep, class _Period> inline typename enable_if<is_floating_point<_Rep>::value, chrono::nanoseconds>::type __safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            using namespace chrono;
            using __ratio = ratio_divide<_Period, std::__1::nano>;
            using __ns_rep = nanoseconds::rep;
            _Rep __result_float = __d.count() * __ratio::num / __ratio::den;
            _Rep __result_max = numeric_limits<__ns_rep>::max();
            if (__result_float >= __result_max) {
                return nanoseconds::max();
            }
            _Rep __result_min = numeric_limits<__ns_rep>::min();
            if (__result_float <= __result_min) {
                return nanoseconds::min();
            }
            return std::__1::chrono::nanoseconds(static_cast<__ns_rep>(__result_float));
        }
        template <class _Rep, class _Period> inline typename enable_if<!is_floating_point<_Rep>::value, chrono::nanoseconds>::type __safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            using namespace chrono;
            if (__d.count() == 0) {
                return std::__1::chrono::nanoseconds(0);
            }
            using __ratio = ratio_divide<_Period, std::__1::nano>;
            using __ns_rep = nanoseconds::rep;
            __ns_rep __result_max = std::numeric_limits<__ns_rep>::max();
            if (__d.count() > 0 && __d.count() > __result_max / __ratio::num) {
                return nanoseconds::max();
            }
            __ns_rep __result_min = std::numeric_limits<__ns_rep>::min();
            if (__d.count() < 0 && __d.count() < __result_min / __ratio::num) {
                return nanoseconds::min();
            }
            __ns_rep __result = __d.count() * __ratio::num / __ratio::den;
            if (__result == 0) {
                return std::__1::chrono::nanoseconds(1);
            }
            return std::__1::chrono::nanoseconds(__result);
        }
        template<> inline typename enable_if<!is_floating_point<long long>::value, chrono::nanoseconds>::type __safe_nanosecond_cast<long long, std::__1::ratio<1, 1000000>>(chrono::duration<long long, ratio<1, 1000000> > __d) __attribute__((internal_linkage))        template <class _Predicate> void condition_variable::wait(unique_lock<std::__1::mutex> &__lk, _Predicate __pred)         {
            while (!__pred())
                this->wait(__lk);
        }
        template <class _Clock, class _Duration> std::__1::cv_status condition_variable::wait_until(unique_lock<std::__1::mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t)         {
            using namespace chrono;
            using __clock_tp_ns = time_point<_Clock, std::__1::chrono::nanoseconds>;
            typename _Clock::time_point __now = _Clock::now();
            if (__t <= __now)
                return cv_status::timeout;
            __clock_tp_ns __t_ns = __clock_tp_ns(__safe_nanosecond_cast(__t.time_since_epoch()));
            __do_timed_wait(__lk, __t_ns);
            return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
        }
        template <class _Clock, class _Duration, class _Predicate> bool condition_variable::wait_until(unique_lock<std::__1::mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t, _Predicate __pred)         {
            while (!__pred())
                {
                    if (wait_until(__lk, __t) == cv_status::timeout)
                        return __pred();
                }
            return true;
        }
        template <class _Rep, class _Period> std::__1::cv_status condition_variable::wait_for(unique_lock<std::__1::mutex> &__lk, const chrono::duration<_Rep, _Period> &__d)         {
            using namespace chrono;
            if (__d <= __d.zero())
                return cv_status::timeout;
            using __ns_rep = nanoseconds::rep;
            steady_clock::time_point __c_now = steady_clock::now();
            using __clock_tp_ns = time_point<std::__1::chrono::system_clock, std::__1::chrono::nanoseconds>;
            __ns_rep __now_count_ns = __safe_nanosecond_cast(system_clock::now().time_since_epoch()).count();
            __ns_rep __d_ns_count = __safe_nanosecond_cast(__d).count();
            if (__now_count_ns > numeric_limits<__ns_rep>::max() - __d_ns_count) {
                this->__do_timed_wait(__lk, __clock_tp_ns::max());
            } else {
                this->__do_timed_wait(__lk, __clock_tp_ns(std::__1::chrono::nanoseconds(__now_count_ns + __d_ns_count)));
            }
            return steady_clock::now() - __c_now < __d ? cv_status::no_timeout : cv_status::timeout;
        }
        template <class _Rep, class _Period, class _Predicate> inline bool condition_variable::wait_for(unique_lock<std::__1::mutex> &__lk, const chrono::duration<_Rep, _Period> &__d, _Predicate __pred)         {
            return wait_until(__lk, chrono::steady_clock::now() + __d, std::__1::move(__pred));
        }
        template <class _Clock> inline void condition_variable::__do_timed_wait(unique_lock<std::__1::mutex> &__lk, chrono::time_point<_Clock, chrono::nanoseconds> __tp) throw()         {
            wait_for(__lk, __tp - _Clock::now());
        }
        template<> void __do_timed_wait<std::__1::chrono::system_clock>(unique_lock<std::__1::mutex> &__lk, chrono::time_point<system_clock, chrono::nanoseconds>) throw()    }
}
namespace std {
    inline namespace __1 {
        class __attribute__((visibility("default"))) recursive_mutex {
            std::__1::__libcpp_recursive_mutex_t __m_;
        public:
            recursive_mutex();
            ~recursive_mutex();
        private:
            recursive_mutex(const std::__1::recursive_mutex &);
            std::__1::recursive_mutex &operator=(const std::__1::recursive_mutex &);
        public:
            void lock();
            bool try_lock() throw();
            void unlock() throw();
            typedef std::__1::__libcpp_recursive_mutex_t *native_handle_type;
            std::__1::recursive_mutex::native_handle_type native_handle() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return &this->__m_;
            }
        };
        class __attribute__((visibility("default"))) timed_mutex {
            std::__1::mutex __m_;
            std::__1::condition_variable __cv_;
            bool __locked_;
        public:
            timed_mutex();
            ~timed_mutex();
        private:
            timed_mutex(const std::__1::timed_mutex &);
            std::__1::timed_mutex &operator=(const std::__1::timed_mutex &);
        public:
            void lock();
            bool try_lock() throw();
            template <class _Rep, class _Period> bool try_lock_for(const chrono::duration<_Rep, _Period> &__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return try_lock_until(chrono::steady_clock::now() + __d);
            }
            template <class _Clock, class _Duration> inline bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t) __attribute__((visibility("hidden")));
            void unlock() throw();
        };
        template <class _Clock, class _Duration> bool timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration> &__t)         {
            using namespace chrono;
            unique_lock<std::__1::mutex> __lk(this->__m_);
            bool no_timeout = _Clock::now() < __t;
            while (no_timeout && this->__locked_)
                no_timeout = this->__cv_.wait_until(__lk, __t) == cv_status::no_timeout;
            if (!this->__locked_) {
                this->__locked_ = true;
                return true;
            }
            return false;
        }
        class __attribute__((visibility("default"))) recursive_timed_mutex {
            std::__1::mutex __m_;
            std::__1::condition_variable __cv_;
            size_t __count_;
            std::__1::__thread_id __id_;
        public:
            recursive_timed_mutex();
            ~recursive_timed_mutex();
        private:
            recursive_timed_mutex(const std::__1::recursive_timed_mutex &);
            std::__1::recursive_timed_mutex &operator=(const std::__1::recursive_timed_mutex &);
        public:
            void lock();
            bool try_lock() throw();
            template <class _Rep, class _Period> bool try_lock_for(const chrono::duration<_Rep, _Period> &__d) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return try_lock_until(chrono::steady_clock::now() + __d);
            }
            template <class _Clock, class _Duration> inline bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t) __attribute__((visibility("hidden")));
            void unlock() throw();
        };
        template <class _Clock, class _Duration> bool recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration> &__t)         {
            using namespace chrono;
            std::__1::__thread_id __id = this_thread::get_id();
            unique_lock<std::__1::mutex> lk(this->__m_);
            if (__id == this->__id_) {
                if (this->__count_ == numeric_limits<size_t>::max())
                    return false;
                ++this->__count_;
                return true;
            }
            bool no_timeout = _Clock::now() < __t;
            while (no_timeout && this->__count_ != 0)
                no_timeout = this->__cv_.wait_until(lk, __t) == cv_status::no_timeout;
            if (this->__count_ == 0) {
                this->__count_ = 1;
                this->__id_ = __id;
                return true;
            }
            return false;
        }
        template <class _L0, class _L1> int try_lock(_L0 &__l0, _L1 &__l1)         {
            unique_lock<_L0> __u0(__l0, try_to_lock);
            if (__u0.owns_lock()) {
                if (__l1.try_lock()) {
                    __u0.release();
                    return -1;
                } else
                    return 1;
            }
            return 0;
        }
        template <class _L0, class _L1> void lock(_L0 &__l0, _L1 &__l1)         {
            while (true)
                {
                    {
                        unique_lock<_L0> __u0(__l0);
                        if (__l1.try_lock()) {
                            __u0.release();
                            break;
                        }
                    }
                    __libcpp_thread_yield();
                    {
                        unique_lock<_L1> __u1(__l1);
                        if (__l0.try_lock()) {
                            __u1.release();
                            break;
                        }
                    }
                    __libcpp_thread_yield();
                }
        }
        struct __attribute__((type_visibility("default"))) once_flag;
        template <class _Callable> void call_once(std::__1::once_flag &, _Callable &) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Callable> void call_once(std::__1::once_flag &, const _Callable &) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        struct __attribute__((type_visibility("default"))) once_flag {
            once_flag() throw() : __state_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            typedef unsigned long _State_type;
        private:
            once_flag(const std::__1::once_flag &);
            std::__1::once_flag &operator=(const std::__1::once_flag &);
            std::__1::once_flag::_State_type __state_;
            friend template <class _Callable> void call_once(std::__1::once_flag &, _Callable &);
            friend template <class _Callable> void call_once(std::__1::once_flag &, const _Callable &);
        };
        template <class _Fp> class __call_once_param {
            _Fp &__f_;
        public:
            explicit __call_once_param<_Fp>(_Fp &__f) : __f_(__f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void operator()() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__f_();
            }
        };
        template <class _Fp> void __call_once_proxy(void *__vp) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __call_once_param<_Fp> *__p = static_cast<__call_once_param<_Fp> *>(__vp);
            (*__p)();
        }
        void __call_once(volatile once_flag::_State_type &, void *, void (*)(void *)) __attribute__((visibility("default")));
        template <class _Callable> inline void call_once(std::__1::once_flag &__flag, _Callable &__func) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__libcpp_acquire_load(&__flag.__state_) != ~once_flag::_State_type(0)) {
                __call_once_param<_Callable> __p(__func);
                __call_once(__flag.__state_, &__p, &__call_once_proxy<_Callable>);
            }
        }
        template <class _Callable> inline void call_once(std::__1::once_flag &__flag, const _Callable &__func) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (__libcpp_acquire_load(&__flag.__state_) != ~once_flag::_State_type(0)) {
                __call_once_param<const _Callable> __p(__func);
                __call_once(__flag.__state_, &__p, &__call_once_proxy<const _Callable>);
            }
        }
    }
}
struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_n_cs_precedes;
    char int_p_sep_by_space;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};
extern "C" {
    struct lconv *localeconv();
}
extern "C" {
    char *setlocale(int, const char *);
}
struct _xlocale;
typedef struct _xlocale *locale_t;
extern "C" {
    int ___mb_cur_max();
    int ___mb_cur_max_l(locale_t);
}
extern "C" {
    extern const locale_t _c_locale;
    locale_t duplocale(locale_t);
    int freelocale(locale_t);
    struct lconv *localeconv_l(locale_t);
    locale_t newlocale(int, const char *, locale_t);
    const char *querylocale(int, locale_t);
    locale_t uselocale(locale_t);
}
extern "C" {
    unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
    __darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
    __darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}
extern "C" {
    int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}
inline int __istype_l(__darwin_ct_rune_t _c, unsigned long _f, locale_t _l) {
    return !!(isascii(_c) ? (_DefaultRuneLocale.__runetype[_c] & _f) : __maskrune_l(_c, _f, _l));
}
inline __darwin_ct_rune_t __toupper_l(__darwin_ct_rune_t _c, locale_t _l) {
    return isascii(_c) ? _DefaultRuneLocale.__mapupper[_c] : ___toupper_l(_c, _l);
}
inline __darwin_ct_rune_t __tolower_l(__darwin_ct_rune_t _c, locale_t _l) {
    return isascii(_c) ? _DefaultRuneLocale.__maplower[_c] : ___tolower_l(_c, _l);
}
inline int __wcwidth_l(__darwin_ct_rune_t _c, locale_t _l) {
    unsigned int _x;
    if (_c == 0)
        return (0);
    _x = (unsigned int)__maskrune_l(_c, 3758096384L | 262144L, _l);
    if ((_x & 3758096384L) != 0)
        return ((_x & 3758096384L) >> 30);
    return ((_x & 262144L) != 0 ? 1 : -1);
}
inline int digittoint_l(int c, locale_t l) {
    return (__maskrune_l(c, 15, l));
}
inline int isalnum_l(int c, locale_t l) {
    return (__istype_l(c, 256L | 1024L, l));
}
inline int isalpha_l(int c, locale_t l) {
    return (__istype_l(c, 256L, l));
}
inline int isblank_l(int c, locale_t l) {
    return (__istype_l(c, 131072L, l));
}
inline int iscntrl_l(int c, locale_t l) {
    return (__istype_l(c, 512L, l));
}
inline int isdigit_l(int c, locale_t l) {
    return (__istype_l(c, 1024L, l));
}
inline int isgraph_l(int c, locale_t l) {
    return (__istype_l(c, 2048L, l));
}
inline int ishexnumber_l(int c, locale_t l) {
    return (__istype_l(c, 65536L, l));
}
inline int isideogram_l(int c, locale_t l) {
    return (__istype_l(c, 524288L, l));
}
inline int islower_l(int c, locale_t l) {
    return (__istype_l(c, 4096L, l));
}
inline int isnumber_l(int c, locale_t l) {
    return (__istype_l(c, 1024L, l));
}
inline int isphonogram_l(int c, locale_t l) {
    return (__istype_l(c, 2097152L, l));
}
inline int isprint_l(int c, locale_t l) {
    return (__istype_l(c, 262144L, l));
}
inline int ispunct_l(int c, locale_t l) {
    return (__istype_l(c, 8192L, l));
}
inline int isrune_l(int c, locale_t l) {
    return (__istype_l(c, 4294967280L, l));
}
inline int isspace_l(int c, locale_t l) {
    return (__istype_l(c, 16384L, l));
}
inline int isspecial_l(int c, locale_t l) {
    return (__istype_l(c, 1048576L, l));
}
inline int isupper_l(int c, locale_t l) {
    return (__istype_l(c, 32768L, l));
}
inline int isxdigit_l(int c, locale_t l) {
    return (__istype_l(c, 65536L, l));
}
inline int tolower_l(int c, locale_t l) {
    return (__tolower_l(c, l));
}
inline int toupper_l(int c, locale_t l) {
    return (__toupper_l(c, l));
}
inline int iswalnum_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 256L | 1024L, _l));
}
inline int iswalpha_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 256L, _l));
}
inline int iswcntrl_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 512L, _l));
}
inline int iswctype_l(wint_t _wc, wctype_t _charclass, locale_t _l) {
    return (__istype_l(_wc, _charclass, _l));
}
inline int iswdigit_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 1024L, _l));
}
inline int iswgraph_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 2048L, _l));
}
inline int iswlower_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 4096L, _l));
}
inline int iswprint_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 262144L, _l));
}
inline int iswpunct_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 8192L, _l));
}
inline int iswspace_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 16384L, _l));
}
inline int iswupper_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 32768L, _l));
}
inline int iswxdigit_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 65536L, _l));
}
inline wint_t towlower_l(wint_t _wc, locale_t _l) {
    return (__tolower_l(_wc, _l));
}
inline wint_t towupper_l(wint_t _wc, locale_t _l) {
    return (__toupper_l(_wc, _l));
}
extern "C" {
    wctype_t wctype_l(const char *, locale_t);
}
extern "C" {
    int fprintf_l(FILE *, locale_t, const char *, ...) __attribute__((format(printf, 3, 4)));
    int fscanf_l(FILE *, locale_t, const char *, ...) __attribute__((format(scanf, 3, 4)));
    int printf_l(locale_t, const char *, ...) __attribute__((format(printf, 2, 3)));
    int scanf_l(locale_t, const char *, ...) __attribute__((format(scanf, 2, 3)));
    int sprintf_l(char *, locale_t, const char *, ...) __attribute__((format(printf, 3, 4))) __attribute__((availability(swift, unavailable)));
    int sscanf_l(const char *, locale_t, const char *, ...) __attribute__((format(scanf, 3, 4)));
    int vfprintf_l(FILE *, locale_t, const char *, va_list) __attribute__((format(printf, 3, 0)));
    int vprintf_l(locale_t, const char *, va_list) __attribute__((format(printf, 2, 0)));
    int vsprintf_l(char *, locale_t, const char *, va_list) __attribute__((format(printf, 3, 0))) __attribute__((availability(swift, unavailable)));
    int snprintf_l(char *, size_t, locale_t, const char *, ...) __attribute__((format(printf, 4, 5)));
    int vfscanf_l(FILE *, locale_t, const char *, va_list) __attribute__((format(scanf, 3, 0)));
    int vscanf_l(locale_t, const char *, va_list) __attribute__((format(scanf, 2, 0)));
    int vsnprintf_l(char *, size_t, locale_t, const char *, va_list) __attribute__((format(printf, 4, 0)));
    int vsscanf_l(const char *, locale_t, const char *, va_list) __attribute__((format(scanf, 3, 0)));
    int dprintf_l(int, locale_t, const char *, ...) __attribute__((format(printf, 3, 4))) __attribute__((availability(macos, introduced=10.7)));
    int vdprintf_l(int, locale_t, const char *, va_list) __attribute__((format(printf, 3, 0))) __attribute__((availability(macos, introduced=10.7)));
    int asprintf_l(char **, locale_t, const char *, ...) __attribute__((format(printf, 3, 4)));
    int vasprintf_l(char **, locale_t, const char *, va_list) __attribute__((format(printf, 3, 0)));
}
extern "C" {
    double atof_l(const char *, locale_t);
    int atoi_l(const char *, locale_t);
    long atol_l(const char *, locale_t);
    long long atoll_l(const char *, locale_t);
    int mblen_l(const char *, size_t, locale_t);
    size_t mbstowcs_l(wchar_t *, const char *, size_t, locale_t);
    int mbtowc_l(wchar_t *, const char *, size_t, locale_t);
    double strtod_l(const char *, char **, locale_t) asm("_strtod_l");
    float strtof_l(const char *, char **, locale_t) asm("_strtof_l");
    long strtol_l(const char *, char **, int, locale_t);
    long double strtold_l(const char *, char **, locale_t);
    long long strtoll_l(const char *, char **, int, locale_t);
    long long strtoq_l(const char *, char **, int, locale_t);
    unsigned long strtoul_l(const char *, char **, int, locale_t);
    unsigned long long strtoull_l(const char *, char **, int, locale_t);
    unsigned long long strtouq_l(const char *, char **, int, locale_t);
    size_t wcstombs_l(char *, const wchar_t *, size_t, locale_t);
    int wctomb_l(char *, wchar_t, locale_t);
}
extern "C" {
    int strcoll_l(const char *, const char *, locale_t);
    size_t strxfrm_l(char *, const char *, size_t, locale_t);
    int strcasecmp_l(const char *, const char *, locale_t);
    char *strcasestr_l(const char *, const char *, locale_t);
    int strncasecmp_l(const char *, const char *, size_t, locale_t);
}
extern "C" {
    size_t strftime_l(char *, size_t, const char *, const struct tm *, locale_t) asm("_strftime_l") __attribute__((format(strftime, 3, 0)));
    char *strptime_l(const char *, const char *, struct tm *, locale_t) asm("_strptime_l") __attribute__((format(strftime, 2, 0)));
}
extern "C" {
    wint_t btowc_l(int, locale_t);
    wint_t fgetwc_l(FILE *, locale_t);
    wchar_t *fgetws_l(wchar_t *, int, FILE *, locale_t);
    wint_t fputwc_l(wchar_t, FILE *, locale_t);
    int fputws_l(const wchar_t *, FILE *, locale_t);
    int fwprintf_l(FILE *, locale_t, const wchar_t *, ...);
    int fwscanf_l(FILE *, locale_t, const wchar_t *, ...);
    wint_t getwc_l(FILE *, locale_t);
    wint_t getwchar_l(locale_t);
    size_t mbrlen_l(const char *, size_t, mbstate_t *, locale_t);
    size_t mbrtowc_l(wchar_t *, const char *, size_t, mbstate_t *, locale_t);
    int mbsinit_l(const mbstate_t *, locale_t);
    size_t mbsrtowcs_l(wchar_t *, const char **, size_t, mbstate_t *, locale_t);
    wint_t putwc_l(wchar_t, FILE *, locale_t);
    wint_t putwchar_l(wchar_t, locale_t);
    int swprintf_l(wchar_t *, size_t n, locale_t, const wchar_t *, ...);
    int swscanf_l(const wchar_t *, locale_t, const wchar_t *, ...);
    wint_t ungetwc_l(wint_t, FILE *, locale_t);
    int vfwprintf_l(FILE *, locale_t, const wchar_t *, __darwin_va_list);
    int vswprintf_l(wchar_t *, size_t n, locale_t, const wchar_t *, __darwin_va_list);
    int vwprintf_l(locale_t, const wchar_t *, __darwin_va_list);
    size_t wcrtomb_l(char *, wchar_t, mbstate_t *, locale_t);
    int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
    size_t wcsftime_l(wchar_t *, size_t, const wchar_t *, const struct tm *, locale_t) asm("_wcsftime_l");
    size_t wcsrtombs_l(char *, const wchar_t **, size_t, mbstate_t *, locale_t);
    double wcstod_l(const wchar_t *, wchar_t **, locale_t);
    long wcstol_l(const wchar_t *, wchar_t **, int, locale_t);
    unsigned long wcstoul_l(const wchar_t *, wchar_t **, int, locale_t);
    int wcswidth_l(const wchar_t *, size_t, locale_t);
    size_t wcsxfrm_l(wchar_t *, const wchar_t *, size_t, locale_t);
    int wctob_l(wint_t, locale_t);
    int wcwidth_l(wchar_t, locale_t);
    int wprintf_l(locale_t, const wchar_t *, ...);
    int wscanf_l(locale_t, const wchar_t *, ...);
}
extern "C" {
    int vfwscanf_l(FILE *, locale_t, const wchar_t *, __darwin_va_list);
    int vswscanf_l(const wchar_t *, locale_t, const wchar_t *, __darwin_va_list);
    int vwscanf_l(locale_t, const wchar_t *, __darwin_va_list);
    float wcstof_l(const wchar_t *, wchar_t **, locale_t);
    long double wcstold_l(const wchar_t *, wchar_t **, locale_t);
    long long wcstoll_l(const wchar_t *, wchar_t **, int, locale_t);
    unsigned long long wcstoull_l(const wchar_t *, wchar_t **, int, locale_t);
}
extern "C" {
    size_t mbsnrtowcs_l(wchar_t *, const char **, size_t, size_t, mbstate_t *, locale_t);
    int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t) __attribute__((availability(macos, introduced=10.7)));
    int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t n, locale_t) __attribute__((availability(macos, introduced=10.7)));
    size_t wcsnrtombs_l(char *, const wchar_t **, size_t, size_t, mbstate_t *, locale_t);
}
extern "C" {
    wchar_t *fgetwln_l(FILE *, size_t *, locale_t) __attribute__((availability(macos, introduced=10.7)));
}
inline int iswblank_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 131072L, _l));
}
inline int iswhexnumber_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 65536L, _l));
}
inline int iswideogram_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 524288L, _l));
}
inline int iswnumber_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 1024L, _l));
}
inline int iswphonogram_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 2097152L, _l));
}
inline int iswrune_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 4294967280L, _l));
}
inline int iswspecial_l(wint_t _wc, locale_t _l) {
    return (__istype_l(_wc, 1048576L, _l));
}
extern "C" {
    wint_t nextwctype_l(wint_t, wctype_t, locale_t);
    wint_t towctrans_l(wint_t, wctrans_t, locale_t);
    wctrans_t wctrans_l(const char *, locale_t);
}
namespace std {
    inline namespace __1 {
        class __attribute__((visibility("default"))) locale;
        template <class _Facet> bool has_facet(const std::__1::locale &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template <class _Facet> const _Facet &use_facet(const std::__1::locale &) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        class __attribute__((visibility("default"))) locale {
        public:
            class __attribute__((visibility("default"))) facet;
            class __attribute__((visibility("default"))) id;
            typedef int category;
            static const std::__1::locale::category none = 0 __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
            static const std::__1::locale::category collate = (1 << 0) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
            static const std::__1::locale::category ctype = (1 << 1) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
            static const std::__1::locale::category monetary = (1 << 3) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
            static const std::__1::locale::category numeric = (1 << 4) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
            static const std::__1::locale::category time = (1 << 5) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
            static const std::__1::locale::category messages = (1 << 2) __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
            static const std::__1::locale::category all = collate | ctype | monetary | numeric | time | messages __attribute__((availability(macos, strict, introduced=10.9))) __attribute__((availability(ios, strict, introduced=7.0)));
            locale() throw();
            locale(const std::__1::locale &) throw();
            explicit locale(const char *);
            explicit locale(const std::__1::string &);
            locale(const std::__1::locale &, const char *, std::__1::locale::category);
            locale(const std::__1::locale &, const std::__1::string &, std::__1::locale::category);
            template <class _Facet> locale(const std::__1::locale &, _Facet *) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            locale(const std::__1::locale &, const std::__1::locale &, std::__1::locale::category);
            ~locale();
            const std::__1::locale &operator=(const std::__1::locale &) throw();
            template <class _Facet> inline std::__1::locale combine(const std::__1::locale &) const __attribute__((visibility("hidden")));
            std::__1::string name() const;
            bool operator==(const std::__1::locale &) const;
            bool operator!=(const std::__1::locale &__y) const             {
                return !(*this == __y);
            }
            template <class _CharT, class _Traits, class _Allocator> inline bool operator()(const basic_string<_CharT, _Traits, _Allocator> &, const basic_string<_CharT, _Traits, _Allocator> &) const __attribute__((visibility("hidden")));
            static std::__1::locale global(const std::__1::locale &);
            static const std::__1::locale &classic();
        private:
            class __imp;
            std::__1::locale::__imp *__locale_;
            void __install_ctor(const std::__1::locale &, std::__1::locale::facet *, long);
            static std::__1::locale &__global();
            bool has_facet(std::__1::locale::id &) const;
            const std::__1::locale::facet *use_facet(std::__1::locale::id &) const;
            friend template <class _Facet> bool has_facet(const std::__1::locale &) throw();
            friend template <class _Facet> const _Facet &use_facet(const std::__1::locale &);
        };
        class __attribute__((visibility("default"))) facet : public std::__1::__shared_count {
        protected:
            explicit facet(size_t __refs = 0) : std::__1::__shared_count(static_cast<long>(__refs) - 1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual ~facet();
        private:
            virtual void __on_zero_shared() throw();
        };
        class __attribute__((visibility("default"))) id {
            std::__1::once_flag __flag_;
            int32_t __id_;
            static int32_t __next_id;
        public:
            id() : __flag_(), __id_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        private:
            void __init();
            void operator=(const std::__1::locale::id &);
            id(const std::__1::locale::id &);
        public:
            long __get();
            friend  class locale;
            friend  class locale::__imp;
        };
        template <class _Facet> inline locale::locale(const std::__1::locale &__other, _Facet *__f) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->__install_ctor(__other, __f, __f ? __f->id.__get() : 0);
        }
        template <class _Facet> std::__1::locale locale::combine(const std::__1::locale &__other) const         {
            if (!std::__1::has_facet<_Facet>(__other))
                __throw_runtime_error("locale::combine: locale missing facet");
            return std::__1::locale(*this, &const_cast<_Facet &>(std::__1::use_facet<_Facet>(__other)));
        }
        template <class _Facet> inline bool has_facet(const std::__1::locale &__l) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __l.has_facet(_Facet::id);
        }
        template <class _Facet> inline const _Facet &use_facet(const std::__1::locale &__l) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return static_cast<const _Facet &>(*__l.use_facet(_Facet::id));
        }
        template<> inline const std::__1::ctype<char> &use_facet<std::__1::ctype<char>>(const std::__1::locale &__l) __attribute__((internal_linkage))         {
            return static_cast<const std::__1::ctype<char> &>(*__l.use_facet(ctype<char>::id));
        }
        template <class _CharT> class __attribute__((type_visibility("default"))) collate : public locale::facet {
        public:
            typedef _CharT char_type;
            typedef basic_string<std::__1::collate::char_type> string_type;
            explicit collate<_CharT>(size_t __refs = 0) : locale::facet(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            int compare(const std::__1::collate::char_type *__lo1, const std::__1::collate::char_type *__hi1, const std::__1::collate::char_type *__lo2, const std::__1::collate::char_type *__hi2) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_compare(__lo1, __hi1, __lo2, __hi2);
            }
            std::__1::collate::string_type transform(const std::__1::collate::char_type *__lo, const std::__1::collate::char_type *__hi) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage)) __attribute__((always_inline))             {
                return this->do_transform(__lo, __hi);
            }
            long hash(const std::__1::collate::char_type *__lo, const std::__1::collate::char_type *__hi) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_hash(__lo, __hi);
            }
            static locale::id id;
        protected:
            ~collate<_CharT>();
            virtual int do_compare(const std::__1::collate::char_type *__lo1, const std::__1::collate::char_type *__hi1, const std::__1::collate::char_type *__lo2, const std::__1::collate::char_type *__hi2) const;
            virtual std::__1::collate::string_type do_transform(const std::__1::collate::char_type *__lo, const std::__1::collate::char_type *__hi) const             {
                return std::__1::collate::string_type(__lo, __hi);
            }
            virtual long do_hash(const std::__1::collate::char_type *__lo, const std::__1::collate::char_type *__hi) const;
        };
        locale::id id;
        template <class _CharT> collate<_CharT>::~collate<_CharT>()         {
        }
        template <class _CharT> int collate<_CharT>::do_compare(const std::__1::collate::char_type *__lo1, const std::__1::collate::char_type *__hi1, const std::__1::collate::char_type *__lo2, const std::__1::collate::char_type *__hi2) const         {
            for (; __lo2 != __hi2; ++__lo1 , ++__lo2) {
                if (__lo1 == __hi1 || *__lo1 < *__lo2)
                    return -1;
                if (*__lo2 < *__lo1)
                    return 1;
            }
            return __lo1 != __hi1;
        }
        template <class _CharT> long collate<_CharT>::do_hash(const std::__1::collate::char_type *__lo, const std::__1::collate::char_type *__hi) const         {
            size_t __h = 0;
            const size_t __sr = 8 * sizeof(size_t) - 8;
            const size_t __mask = size_t(15) << (__sr + 4);
            for (const std::__1::collate::char_type *__p = __lo; __p != __hi; ++__p) {
                __h = (__h << 4) + static_cast<size_t>(*__p);
                size_t __g = __h & __mask;
                __h ^= __g | (__g >> __sr);
            }
            return static_cast<long>(__h);
        }
        template<> class __attribute__((visibility("default"))) collate<char> : public locale::facet {
        public:
            typedef char char_type;
            typedef basic_string<std::__1::collate<char>::char_type> string_type;
            explicit collate(size_t __refs) __attribute__((internal_linkage));
            int compare(const std::__1::collate<char>::char_type *__lo1, const std::__1::collate<char>::char_type *__hi1, const std::__1::collate<char>::char_type *__lo2, const std::__1::collate<char>::char_type *__hi2) const __attribute__((internal_linkage));
            std::__1::collate<char>::string_type transform(const std::__1::collate<char>::char_type *__lo, const std::__1::collate<char>::char_type *__hi) const __attribute__((internal_linkage)) __attribute__((always_inline));
            long hash(const std::__1::collate<char>::char_type *__lo, const std::__1::collate<char>::char_type *__hi) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~collate<char>();
            virtual int do_compare(const std::__1::collate<char>::char_type *__lo1, const std::__1::collate<char>::char_type *__hi1, const std::__1::collate<char>::char_type *__lo2, const std::__1::collate<char>::char_type *__hi2) const;
            virtual std::__1::collate<char>::string_type do_transform(const std::__1::collate<char>::char_type *__lo, const std::__1::collate<char>::char_type *__hi) const;
            virtual long do_hash(const std::__1::collate<char>::char_type *__lo, const std::__1::collate<char>::char_type *__hi) const;
        };
        template<> class __attribute__((visibility("default"))) collate<wchar_t> : public locale::facet {
        public:
            typedef wchar_t char_type;
            typedef basic_string<std::__1::collate<wchar_t>::char_type> string_type;
            explicit collate(size_t __refs) __attribute__((internal_linkage));
            int compare(const std::__1::collate<wchar_t>::char_type *__lo1, const std::__1::collate<wchar_t>::char_type *__hi1, const std::__1::collate<wchar_t>::char_type *__lo2, const std::__1::collate<wchar_t>::char_type *__hi2) const __attribute__((internal_linkage));
            std::__1::collate<wchar_t>::string_type transform(const std::__1::collate<wchar_t>::char_type *__lo, const std::__1::collate<wchar_t>::char_type *__hi) const __attribute__((internal_linkage)) __attribute__((always_inline));
            long hash(const std::__1::collate<wchar_t>::char_type *__lo, const std::__1::collate<wchar_t>::char_type *__hi) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~collate<wchar_t>();
            virtual int do_compare(const std::__1::collate<wchar_t>::char_type *__lo1, const std::__1::collate<wchar_t>::char_type *__hi1, const std::__1::collate<wchar_t>::char_type *__lo2, const std::__1::collate<wchar_t>::char_type *__hi2) const;
            virtual std::__1::collate<wchar_t>::string_type do_transform(const std::__1::collate<wchar_t>::char_type *__lo, const std::__1::collate<wchar_t>::char_type *__hi) const;
            virtual long do_hash(const std::__1::collate<wchar_t>::char_type *__lo, const std::__1::collate<wchar_t>::char_type *__hi) const;
        };
        template <class _CharT> class __attribute__((type_visibility("default"))) collate_byname;
        template<> class __attribute__((visibility("default"))) collate_byname<char> : public collate<char> {
            locale_t __l;
        public:
            typedef char char_type;
            typedef basic_string<std::__1::collate_byname<char>::char_type> string_type;
            explicit collate_byname(const char *__n, size_t __refs = 0);
            explicit collate_byname(const std::__1::string &__n, size_t __refs = 0);
        protected:
            ~collate_byname<char>();
            virtual int do_compare(const std::__1::collate_byname<char>::char_type *__lo1, const std::__1::collate_byname<char>::char_type *__hi1, const std::__1::collate_byname<char>::char_type *__lo2, const std::__1::collate_byname<char>::char_type *__hi2) const;
            virtual std::__1::collate_byname<char>::string_type do_transform(const std::__1::collate_byname<char>::char_type *__lo, const std::__1::collate_byname<char>::char_type *__hi) const;
        };
        template<> class __attribute__((visibility("default"))) collate_byname<wchar_t> : public collate<wchar_t> {
            locale_t __l;
        public:
            typedef wchar_t char_type;
            typedef basic_string<std::__1::collate_byname<wchar_t>::char_type> string_type;
            explicit collate_byname(const char *__n, size_t __refs = 0);
            explicit collate_byname(const std::__1::string &__n, size_t __refs = 0);
        protected:
            ~collate_byname<wchar_t>();
            virtual int do_compare(const std::__1::collate_byname<wchar_t>::char_type *__lo1, const std::__1::collate_byname<wchar_t>::char_type *__hi1, const std::__1::collate_byname<wchar_t>::char_type *__lo2, const std::__1::collate_byname<wchar_t>::char_type *__hi2) const;
            virtual std::__1::collate_byname<wchar_t>::string_type do_transform(const std::__1::collate_byname<wchar_t>::char_type *__lo, const std::__1::collate_byname<wchar_t>::char_type *__hi) const;
        };
        template <class _CharT, class _Traits, class _Allocator> bool locale::operator()(const basic_string<_CharT, _Traits, _Allocator> &__x, const basic_string<_CharT, _Traits, _Allocator> &__y) const         {
            return std::__1::use_facet<std::__1::collate<_CharT> >(*this).compare(__x.data(), __x.data() + __x.size(), __y.data(), __y.data() + __y.size()) < 0;
        }
        class __attribute__((visibility("default"))) ctype_base {
        public:
            typedef __uint32_t mask;
            static const std::__1::ctype_base::mask space = 16384L;
            static const std::__1::ctype_base::mask print = 262144L;
            static const std::__1::ctype_base::mask cntrl = 512L;
            static const std::__1::ctype_base::mask upper = 32768L;
            static const std::__1::ctype_base::mask lower = 4096L;
            static const std::__1::ctype_base::mask alpha = 256L;
            static const std::__1::ctype_base::mask digit = 1024L;
            static const std::__1::ctype_base::mask punct = 8192L;
            static const std::__1::ctype_base::mask xdigit = 65536L;
            static const std::__1::ctype_base::mask blank = 131072L;
            static const std::__1::ctype_base::mask __regex_word = 128;
            static const std::__1::ctype_base::mask alnum = alpha | digit;
            static const std::__1::ctype_base::mask graph = alnum | punct;
            ctype_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
        template <class _CharT> class __attribute__((type_visibility("default"))) ctype;
        template<> class __attribute__((visibility("default"))) ctype<wchar_t> : public locale::facet, public std::__1::ctype_base {
        public:
            typedef wchar_t char_type;
            explicit ctype(size_t __refs = 0) : locale::facet(__refs), std::__1::ctype_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            bool is(std::__1::ctype_base::mask __m, std::__1::ctype<wchar_t>::char_type __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_is(__m, __c);
            }
            const std::__1::ctype<wchar_t>::char_type *is(const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high, std::__1::ctype_base::mask *__vec) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_is(__low, __high, __vec);
            }
            const std::__1::ctype<wchar_t>::char_type *scan_is(std::__1::ctype_base::mask __m, const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_scan_is(__m, __low, __high);
            }
            const std::__1::ctype<wchar_t>::char_type *scan_not(std::__1::ctype_base::mask __m, const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_scan_not(__m, __low, __high);
            }
            std::__1::ctype<wchar_t>::char_type toupper(std::__1::ctype<wchar_t>::char_type __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_toupper(__c);
            }
            const std::__1::ctype<wchar_t>::char_type *toupper(std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_toupper(__low, __high);
            }
            std::__1::ctype<wchar_t>::char_type tolower(std::__1::ctype<wchar_t>::char_type __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_tolower(__c);
            }
            const std::__1::ctype<wchar_t>::char_type *tolower(std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_tolower(__low, __high);
            }
            std::__1::ctype<wchar_t>::char_type widen(char __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_widen(__c);
            }
            const char *widen(const char *__low, const char *__high, std::__1::ctype<wchar_t>::char_type *__to) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_widen(__low, __high, __to);
            }
            char narrow(std::__1::ctype<wchar_t>::char_type __c, char __dfault) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_narrow(__c, __dfault);
            }
            const std::__1::ctype<wchar_t>::char_type *narrow(const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high, char __dfault, char *__to) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_narrow(__low, __high, __dfault, __to);
            }
            static locale::id id;
        protected:
            ~ctype<wchar_t>();
            virtual bool do_is(std::__1::ctype_base::mask __m, std::__1::ctype<wchar_t>::char_type __c) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_is(const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high, std::__1::ctype_base::mask *__vec) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_scan_is(std::__1::ctype_base::mask __m, const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_scan_not(std::__1::ctype_base::mask __m, const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const;
            virtual std::__1::ctype<wchar_t>::char_type do_toupper(std::__1::ctype<wchar_t>::char_type) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_toupper(std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const;
            virtual std::__1::ctype<wchar_t>::char_type do_tolower(std::__1::ctype<wchar_t>::char_type) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_tolower(std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const;
            virtual std::__1::ctype<wchar_t>::char_type do_widen(char) const;
            virtual const char *do_widen(const char *__low, const char *__high, std::__1::ctype<wchar_t>::char_type *__dest) const;
            virtual char do_narrow(std::__1::ctype<wchar_t>::char_type, char __dfault) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_narrow(const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high, char __dfault, char *__dest) const;
        };
        template<> class __attribute__((visibility("default"))) ctype<char> : public locale::facet, public std::__1::ctype_base {
            const std::__1::ctype_base::mask *__tab_;
            bool __del_;
        public:
            typedef char char_type;
            explicit ctype(const std::__1::ctype_base::mask *__tab = 0, bool __del = false, size_t __refs = 0);
            bool is(std::__1::ctype_base::mask __m, std::__1::ctype<char>::char_type __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return isascii(__c) ? (this->__tab_[static_cast<int>(__c)] & __m) != 0 : false;
            }
            const std::__1::ctype<char>::char_type *is(const std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high, std::__1::ctype_base::mask *__vec) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (; __low != __high; ++__low , ++__vec)
                    *__vec = isascii(*__low) ? this->__tab_[static_cast<int>(*__low)] : 0;
                return __low;
            }
            const std::__1::ctype<char>::char_type *scan_is(std::__1::ctype_base::mask __m, const std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (; __low != __high; ++__low)
                    if (isascii(*__low) && (this->__tab_[static_cast<int>(*__low)] & __m))
                        break;
                return __low;
            }
            const std::__1::ctype<char>::char_type *scan_not(std::__1::ctype_base::mask __m, const std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (; __low != __high; ++__low)
                    if (!(isascii(*__low) && (this->__tab_[static_cast<int>(*__low)] & __m)))
                        break;
                return __low;
            }
            std::__1::ctype<char>::char_type toupper(std::__1::ctype<char>::char_type __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_toupper(__c);
            }
            const std::__1::ctype<char>::char_type *toupper(std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_toupper(__low, __high);
            }
            std::__1::ctype<char>::char_type tolower(std::__1::ctype<char>::char_type __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_tolower(__c);
            }
            const std::__1::ctype<char>::char_type *tolower(std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_tolower(__low, __high);
            }
            std::__1::ctype<char>::char_type widen(char __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_widen(__c);
            }
            const char *widen(const char *__low, const char *__high, std::__1::ctype<char>::char_type *__to) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_widen(__low, __high, __to);
            }
            char narrow(std::__1::ctype<char>::char_type __c, char __dfault) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_narrow(__c, __dfault);
            }
            const char *narrow(const std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high, char __dfault, char *__to) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_narrow(__low, __high, __dfault, __to);
            }
            static locale::id id;
            static const size_t table_size = (1 << 8);
            const std::__1::ctype_base::mask *table() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__tab_;
            }
            static const std::__1::ctype_base::mask *classic_table() throw();
        protected:
            ~ctype<char>();
            virtual std::__1::ctype<char>::char_type do_toupper(std::__1::ctype<char>::char_type __c) const;
            virtual const std::__1::ctype<char>::char_type *do_toupper(std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high) const;
            virtual std::__1::ctype<char>::char_type do_tolower(std::__1::ctype<char>::char_type __c) const;
            virtual const std::__1::ctype<char>::char_type *do_tolower(std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high) const;
            virtual std::__1::ctype<char>::char_type do_widen(char __c) const;
            virtual const char *do_widen(const char *__low, const char *__high, std::__1::ctype<char>::char_type *__to) const;
            virtual char do_narrow(std::__1::ctype<char>::char_type __c, char __dfault) const;
            virtual const char *do_narrow(const std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high, char __dfault, char *__to) const;
        };
        template <class _CharT> class __attribute__((type_visibility("default"))) ctype_byname;
        template<> class __attribute__((visibility("default"))) ctype_byname<char> : public ctype<char> {
            locale_t __l;
        public:
            explicit ctype_byname(const char *, size_t = 0);
            explicit ctype_byname(const std::__1::string &, size_t = 0);
        protected:
            ~ctype_byname<char>();
            virtual std::__1::ctype<char>::char_type do_toupper(std::__1::ctype<char>::char_type) const;
            virtual const std::__1::ctype<char>::char_type *do_toupper(std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high) const;
            virtual std::__1::ctype<char>::char_type do_tolower(std::__1::ctype<char>::char_type) const;
            virtual const std::__1::ctype<char>::char_type *do_tolower(std::__1::ctype<char>::char_type *__low, const std::__1::ctype<char>::char_type *__high) const;
        };
        template<> class __attribute__((visibility("default"))) ctype_byname<wchar_t> : public ctype<wchar_t> {
            locale_t __l;
        public:
            explicit ctype_byname(const char *, size_t = 0);
            explicit ctype_byname(const std::__1::string &, size_t = 0);
        protected:
            ~ctype_byname<wchar_t>();
            virtual bool do_is(std::__1::ctype_base::mask __m, std::__1::ctype<wchar_t>::char_type __c) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_is(const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high, std::__1::ctype_base::mask *__vec) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_scan_is(std::__1::ctype_base::mask __m, const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_scan_not(std::__1::ctype_base::mask __m, const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const;
            virtual std::__1::ctype<wchar_t>::char_type do_toupper(std::__1::ctype<wchar_t>::char_type) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_toupper(std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const;
            virtual std::__1::ctype<wchar_t>::char_type do_tolower(std::__1::ctype<wchar_t>::char_type) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_tolower(std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high) const;
            virtual std::__1::ctype<wchar_t>::char_type do_widen(char) const;
            virtual const char *do_widen(const char *__low, const char *__high, std::__1::ctype<wchar_t>::char_type *__dest) const;
            virtual char do_narrow(std::__1::ctype<wchar_t>::char_type, char __dfault) const;
            virtual const std::__1::ctype<wchar_t>::char_type *do_narrow(const std::__1::ctype<wchar_t>::char_type *__low, const std::__1::ctype<wchar_t>::char_type *__high, char __dfault, char *__dest) const;
        };
        template <class _CharT> inline bool isspace(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
        }
        template <class _CharT> inline bool isprint(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
        }
        template <class _CharT> inline bool iscntrl(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
        }
        template <class _CharT> inline bool isupper(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
        }
        template <class _CharT> inline bool islower(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
        }
        template <class _CharT> inline bool isalpha(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
        }
        template <class _CharT> inline bool isdigit(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
        }
        template <class _CharT> inline bool ispunct(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
        }
        template <class _CharT> inline bool isxdigit(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
        }
        template <class _CharT> inline bool isalnum(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
        }
        template <class _CharT> inline bool isgraph(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
        }
        template <class _CharT> inline _CharT toupper(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).toupper(__c);
        }
        template <class _CharT> inline _CharT tolower(_CharT __c, const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<_CharT> >(__loc).tolower(__c);
        }
        class __attribute__((visibility("default"))) codecvt_base {
        public:
            codecvt_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            enum result {
                ok,
                partial,
                error,
                noconv
            };
        };
        template <class _InternT, class _ExternT, class _StateT> class __attribute__((type_visibility("default"))) codecvt;
        template<> class __attribute__((visibility("default"))) codecvt<char, char, mbstate_t> : public locale::facet, public std::__1::codecvt_base {
        public:
            typedef char intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::codecvt_base::result out(std::__1::codecvt<char, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char, char, __mbstate_t>::intern_type *__frm, const std::__1::codecvt<char, char, __mbstate_t>::intern_type *__frm_end, const std::__1::codecvt<char, char, __mbstate_t>::intern_type *&__frm_nxt, std::__1::codecvt<char, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char, char, __mbstate_t>::extern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }
            std::__1::codecvt_base::result unshift(std::__1::codecvt<char, char, __mbstate_t>::state_type &__st, std::__1::codecvt<char, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char, char, __mbstate_t>::extern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }
            std::__1::codecvt_base::result in(std::__1::codecvt<char, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *__frm_end, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *&__frm_nxt, std::__1::codecvt<char, char, __mbstate_t>::intern_type *__to, std::__1::codecvt<char, char, __mbstate_t>::intern_type *__to_end, std::__1::codecvt<char, char, __mbstate_t>::intern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }
            int encoding() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_encoding();
            }
            bool always_noconv() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_always_noconv();
            }
            int length(std::__1::codecvt<char, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *__end, size_t __mx) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_length(__st, __frm, __end, __mx);
            }
            int max_length() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_max_length();
            }
            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~codecvt<char, char, mbstate_t>();
            virtual std::__1::codecvt_base::result do_out(std::__1::codecvt<char, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char, char, __mbstate_t>::intern_type *__frm, const std::__1::codecvt<char, char, __mbstate_t>::intern_type *__frm_end, const std::__1::codecvt<char, char, __mbstate_t>::intern_type *&__frm_nxt, std::__1::codecvt<char, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char, char, __mbstate_t>::extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(std::__1::codecvt<char, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *__frm_end, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *&__frm_nxt, std::__1::codecvt<char, char, __mbstate_t>::intern_type *__to, std::__1::codecvt<char, char, __mbstate_t>::intern_type *__to_end, std::__1::codecvt<char, char, __mbstate_t>::intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(std::__1::codecvt<char, char, __mbstate_t>::state_type &__st, std::__1::codecvt<char, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char, char, __mbstate_t>::extern_type *&__to_nxt) const;
            virtual int do_encoding() const throw();
            virtual bool do_always_noconv() const throw();
            virtual int do_length(std::__1::codecvt<char, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char, char, __mbstate_t>::extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const throw();
        };
        template<> class __attribute__((visibility("default"))) codecvt<wchar_t, char, mbstate_t> : public locale::facet, public std::__1::codecvt_base {
            locale_t __l;
        public:
            typedef wchar_t intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0);
            std::__1::codecvt_base::result out(std::__1::codecvt<wchar_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *__frm, const std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *__frm_end, const std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *&__frm_nxt, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }
            std::__1::codecvt_base::result unshift(std::__1::codecvt<wchar_t, char, __mbstate_t>::state_type &__st, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }
            std::__1::codecvt_base::result in(std::__1::codecvt<wchar_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__frm_end, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *&__frm_nxt, std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *__to, std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *__to_end, std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }
            int encoding() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_encoding();
            }
            bool always_noconv() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_always_noconv();
            }
            int length(std::__1::codecvt<wchar_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__end, size_t __mx) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_length(__st, __frm, __end, __mx);
            }
            int max_length() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_max_length();
            }
            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0);
            ~codecvt<wchar_t, char, mbstate_t>();
            virtual std::__1::codecvt_base::result do_out(std::__1::codecvt<wchar_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *__frm, const std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *__frm_end, const std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *&__frm_nxt, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(std::__1::codecvt<wchar_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__frm_end, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *&__frm_nxt, std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *__to, std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *__to_end, std::__1::codecvt<wchar_t, char, __mbstate_t>::intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(std::__1::codecvt<wchar_t, char, __mbstate_t>::state_type &__st, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *&__to_nxt) const;
            virtual int do_encoding() const throw();
            virtual bool do_always_noconv() const throw();
            virtual int do_length(std::__1::codecvt<wchar_t, char, __mbstate_t>::state_type &, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<wchar_t, char, __mbstate_t>::extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const throw();
        };
        template<> class __attribute__((visibility("default"))) codecvt<char16_t, char, mbstate_t> : public locale::facet, public std::__1::codecvt_base {
        public:
            typedef char16_t intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::codecvt_base::result out(std::__1::codecvt<char16_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *__frm, const std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *__frm_end, const std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *&__frm_nxt, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }
            std::__1::codecvt_base::result unshift(std::__1::codecvt<char16_t, char, __mbstate_t>::state_type &__st, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }
            std::__1::codecvt_base::result in(std::__1::codecvt<char16_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__frm_end, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *&__frm_nxt, std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *__to, std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *__to_end, std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }
            int encoding() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_encoding();
            }
            bool always_noconv() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_always_noconv();
            }
            int length(std::__1::codecvt<char16_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__end, size_t __mx) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_length(__st, __frm, __end, __mx);
            }
            int max_length() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_max_length();
            }
            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~codecvt<char16_t, char, mbstate_t>();
            virtual std::__1::codecvt_base::result do_out(std::__1::codecvt<char16_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *__frm, const std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *__frm_end, const std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *&__frm_nxt, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(std::__1::codecvt<char16_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__frm_end, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *&__frm_nxt, std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *__to, std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *__to_end, std::__1::codecvt<char16_t, char, __mbstate_t>::intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(std::__1::codecvt<char16_t, char, __mbstate_t>::state_type &__st, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *&__to_nxt) const;
            virtual int do_encoding() const throw();
            virtual bool do_always_noconv() const throw();
            virtual int do_length(std::__1::codecvt<char16_t, char, __mbstate_t>::state_type &, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char16_t, char, __mbstate_t>::extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const throw();
        };
        template<> class __attribute__((visibility("default"))) codecvt<char32_t, char, mbstate_t> : public locale::facet, public std::__1::codecvt_base {
        public:
            typedef char32_t intern_type;
            typedef char extern_type;
            typedef mbstate_t state_type;
            explicit codecvt(size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::codecvt_base::result out(std::__1::codecvt<char32_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *__frm, const std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *__frm_end, const std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *&__frm_nxt, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }
            std::__1::codecvt_base::result unshift(std::__1::codecvt<char32_t, char, __mbstate_t>::state_type &__st, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_unshift(__st, __to, __to_end, __to_nxt);
            }
            std::__1::codecvt_base::result in(std::__1::codecvt<char32_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__frm_end, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *&__frm_nxt, std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *__to, std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *__to_end, std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *&__to_nxt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
            }
            int encoding() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_encoding();
            }
            bool always_noconv() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_always_noconv();
            }
            int length(std::__1::codecvt<char32_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__end, size_t __mx) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_length(__st, __frm, __end, __mx);
            }
            int max_length() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_max_length();
            }
            static locale::id id;
        protected:
            explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs), std::__1::codecvt_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~codecvt<char32_t, char, mbstate_t>();
            virtual std::__1::codecvt_base::result do_out(std::__1::codecvt<char32_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *__frm, const std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *__frm_end, const std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *&__frm_nxt, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_in(std::__1::codecvt<char32_t, char, __mbstate_t>::state_type &__st, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__frm_end, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *&__frm_nxt, std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *__to, std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *__to_end, std::__1::codecvt<char32_t, char, __mbstate_t>::intern_type *&__to_nxt) const;
            virtual std::__1::codecvt_base::result do_unshift(std::__1::codecvt<char32_t, char, __mbstate_t>::state_type &__st, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__to, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__to_end, std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *&__to_nxt) const;
            virtual int do_encoding() const throw();
            virtual bool do_always_noconv() const throw();
            virtual int do_length(std::__1::codecvt<char32_t, char, __mbstate_t>::state_type &, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__frm, const std::__1::codecvt<char32_t, char, __mbstate_t>::extern_type *__end, size_t __mx) const;
            virtual int do_max_length() const throw();
        };
        template <class _InternT, class _ExternT, class _StateT> class __attribute__((type_visibility("default"))) codecvt_byname : public codecvt<_InternT, _ExternT, _StateT> {
        public:
            explicit codecvt_byname<_InternT, _ExternT, _StateT>(const char *__nm, size_t __refs = 0) : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit codecvt_byname<_InternT, _ExternT, _StateT>(const std::__1::string &__nm, size_t __refs = 0) : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        protected:
            ~codecvt_byname<_InternT, _ExternT, _StateT>();
        };
        template <class _InternT, class _ExternT, class _StateT> codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname<_InternT, _ExternT, _StateT>()         {
        }
        template<> class __attribute__((visibility("default"))) codecvt_byname<char, char, mbstate_t> : public codecvt<char, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit codecvt_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~codecvt_byname<char, char, mbstate_t>();
        };
        template<> class __attribute__((visibility("default"))) codecvt_byname<wchar_t, char, mbstate_t> : public codecvt<wchar_t, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit codecvt_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~codecvt_byname<wchar_t, char, mbstate_t>();
        };
        template<> class __attribute__((visibility("default"))) codecvt_byname<char16_t, char, mbstate_t> : public codecvt<char16_t, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit codecvt_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~codecvt_byname<char16_t, char, mbstate_t>();
        };
        template<> class __attribute__((visibility("default"))) codecvt_byname<char32_t, char, mbstate_t> : public codecvt<char32_t, char, __mbstate_t> {
        public:
            explicit codecvt_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit codecvt_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~codecvt_byname<char32_t, char, mbstate_t>();
        };
        template <size_t _Np> struct __narrow_to_utf8 {
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const;
        };
        template<> struct __narrow_to_utf8<8> {
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (; __wb < __we; ++__wb , ++__s)
                    *__s = *__wb;
                return __s;
            }
        };
        template<> struct __attribute__((type_visibility("default"))) __narrow_to_utf8<16> : public codecvt<char16_t, char, mbstate_t> {
            __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~__narrow_to_utf8<16>() __attribute__((visibility("default")));
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__wb < __we && __r != error)
                    {
                        const int __sz = 32;
                        char __buf[32];
                        char *__bn;
                        const char16_t *__wn = (const char16_t *)__wb;
                        __r = this->do_out(__mb, (const char16_t *)__wb, (const char16_t *)__we, __wn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __wn == (const char16_t *)__wb)
                            __throw_runtime_error("locale not supported");
                        for (const char *__p = __buf; __p < __bn; ++__p , ++__s)
                            *__s = *__p;
                        __wb = (const _CharT *)__wn;
                    }
                return __s;
            }
        };
        template<> struct __attribute__((type_visibility("default"))) __narrow_to_utf8<32> : public codecvt<char32_t, char, mbstate_t> {
            __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~__narrow_to_utf8<32>() __attribute__((visibility("default")));
            template <class _OutputIterator, class _CharT> _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb, const _CharT *__we) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__wb < __we && __r != error)
                    {
                        const int __sz = 32;
                        char __buf[32];
                        char *__bn;
                        const char32_t *__wn = (const char32_t *)__wb;
                        __r = this->do_out(__mb, (const char32_t *)__wb, (const char32_t *)__we, __wn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __wn == (const char32_t *)__wb)
                            __throw_runtime_error("locale not supported");
                        for (const char *__p = __buf; __p < __bn; ++__p , ++__s)
                            *__s = *__p;
                        __wb = (const _CharT *)__wn;
                    }
                return __s;
            }
        };
        template <size_t _Np> struct __widen_from_utf8 {
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const;
        };
        template<> struct __widen_from_utf8<8> {
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                for (; __nb < __ne; ++__nb , ++__s)
                    *__s = *__nb;
                return __s;
            }
        };
        template<> struct __attribute__((type_visibility("default"))) __widen_from_utf8<16> : public codecvt<char16_t, char, mbstate_t> {
            __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~__widen_from_utf8<16>() __attribute__((visibility("default")));
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__nb < __ne && __r != error)
                    {
                        const int __sz = 32;
                        char16_t __buf[32];
                        char16_t *__bn;
                        const char *__nn = __nb;
                        __r = this->do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __nn == __nb)
                            __throw_runtime_error("locale not supported");
                        for (const char16_t *__p = __buf; __p < __bn; ++__p , ++__s)
                            *__s = (wchar_t)*__p;
                        __nb = __nn;
                    }
                return __s;
            }
        };
        template<> struct __attribute__((type_visibility("default"))) __widen_from_utf8<32> : public codecvt<char32_t, char, mbstate_t> {
            __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~__widen_from_utf8<32>() __attribute__((visibility("default")));
            template <class _OutputIterator> _OutputIterator operator()(_OutputIterator __s, const char *__nb, const char *__ne) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::codecvt_base::result __r = ok;
                mbstate_t __mb;
                while (__nb < __ne && __r != error)
                    {
                        const int __sz = 32;
                        char32_t __buf[32];
                        char32_t *__bn;
                        const char *__nn = __nb;
                        __r = this->do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn, __buf, __buf + __sz, __bn);
                        if (__r == codecvt_base::error || __nn == __nb)
                            __throw_runtime_error("locale not supported");
                        for (const char32_t *__p = __buf; __p < __bn; ++__p , ++__s)
                            *__s = (wchar_t)*__p;
                        __nb = __nn;
                    }
                return __s;
            }
        };
        template <class _CharT> class __attribute__((type_visibility("default"))) numpunct;
        template<> class __attribute__((visibility("default"))) numpunct<char> : public locale::facet {
        public:
            typedef char char_type;
            typedef basic_string<std::__1::numpunct<char>::char_type> string_type;
            explicit numpunct(size_t __refs = 0);
            std::__1::numpunct<char>::char_type decimal_point() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_decimal_point();
            }
            std::__1::numpunct<char>::char_type thousands_sep() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_thousands_sep();
            }
            std::__1::string grouping() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_grouping();
            }
            std::__1::numpunct<char>::string_type truename() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_truename();
            }
            std::__1::numpunct<char>::string_type falsename() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_falsename();
            }
            static locale::id id;
        protected:
            ~numpunct<char>();
            virtual std::__1::numpunct<char>::char_type do_decimal_point() const;
            virtual std::__1::numpunct<char>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::numpunct<char>::string_type do_truename() const;
            virtual std::__1::numpunct<char>::string_type do_falsename() const;
            std::__1::numpunct<char>::char_type __decimal_point_;
            std::__1::numpunct<char>::char_type __thousands_sep_;
            std::__1::string __grouping_;
        };
        template<> class __attribute__((visibility("default"))) numpunct<wchar_t> : public locale::facet {
        public:
            typedef wchar_t char_type;
            typedef basic_string<std::__1::numpunct<wchar_t>::char_type> string_type;
            explicit numpunct(size_t __refs = 0);
            std::__1::numpunct<wchar_t>::char_type decimal_point() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_decimal_point();
            }
            std::__1::numpunct<wchar_t>::char_type thousands_sep() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_thousands_sep();
            }
            std::__1::string grouping() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_grouping();
            }
            std::__1::numpunct<wchar_t>::string_type truename() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_truename();
            }
            std::__1::numpunct<wchar_t>::string_type falsename() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_falsename();
            }
            static locale::id id;
        protected:
            ~numpunct<wchar_t>();
            virtual std::__1::numpunct<wchar_t>::char_type do_decimal_point() const;
            virtual std::__1::numpunct<wchar_t>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::numpunct<wchar_t>::string_type do_truename() const;
            virtual std::__1::numpunct<wchar_t>::string_type do_falsename() const;
            std::__1::numpunct<wchar_t>::char_type __decimal_point_;
            std::__1::numpunct<wchar_t>::char_type __thousands_sep_;
            std::__1::string __grouping_;
        };
        template <class _CharT> class __attribute__((type_visibility("default"))) numpunct_byname;
        template<> class __attribute__((visibility("default"))) numpunct_byname<char> : public numpunct<char> {
        public:
            typedef char char_type;
            typedef basic_string<std::__1::numpunct_byname<char>::char_type> string_type;
            explicit numpunct_byname(const char *__nm, size_t __refs = 0);
            explicit numpunct_byname(const std::__1::string &__nm, size_t __refs = 0);
        protected:
            ~numpunct_byname<char>();
        private:
            void __init(const char *);
        };
        template<> class __attribute__((visibility("default"))) numpunct_byname<wchar_t> : public numpunct<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef basic_string<std::__1::numpunct_byname<wchar_t>::char_type> string_type;
            explicit numpunct_byname(const char *__nm, size_t __refs = 0);
            explicit numpunct_byname(const std::__1::string &__nm, size_t __refs = 0);
        protected:
            ~numpunct_byname<wchar_t>();
        private:
            void __init(const char *);
        };
    }
}
namespace std {
    inline namespace __1 {
        typedef ptrdiff_t streamsize;
        class __attribute__((visibility("default"))) ios_base {
        public:
            class __attribute__((visibility("default"))) failure;
            typedef unsigned int fmtflags;
            static const std::__1::ios_base::fmtflags boolalpha = 1;
            static const std::__1::ios_base::fmtflags dec = 2;
            static const std::__1::ios_base::fmtflags fixed = 4;
            static const std::__1::ios_base::fmtflags hex = 8;
            static const std::__1::ios_base::fmtflags internal = 16;
            static const std::__1::ios_base::fmtflags left = 32;
            static const std::__1::ios_base::fmtflags oct = 64;
            static const std::__1::ios_base::fmtflags right = 128;
            static const std::__1::ios_base::fmtflags scientific = 256;
            static const std::__1::ios_base::fmtflags showbase = 512;
            static const std::__1::ios_base::fmtflags showpoint = 1024;
            static const std::__1::ios_base::fmtflags showpos = 2048;
            static const std::__1::ios_base::fmtflags skipws = 4096;
            static const std::__1::ios_base::fmtflags unitbuf = 8192;
            static const std::__1::ios_base::fmtflags uppercase = 16384;
            static const std::__1::ios_base::fmtflags adjustfield = left | right | internal;
            static const std::__1::ios_base::fmtflags basefield = dec | oct | hex;
            static const std::__1::ios_base::fmtflags floatfield = scientific | fixed;
            typedef unsigned int iostate;
            static const std::__1::ios_base::iostate badbit = 1;
            static const std::__1::ios_base::iostate eofbit = 2;
            static const std::__1::ios_base::iostate failbit = 4;
            static const std::__1::ios_base::iostate goodbit = 0;
            typedef unsigned int openmode;
            static const std::__1::ios_base::openmode app = 1;
            static const std::__1::ios_base::openmode ate = 2;
            static const std::__1::ios_base::openmode binary = 4;
            static const std::__1::ios_base::openmode in = 8;
            static const std::__1::ios_base::openmode out = 16;
            static const std::__1::ios_base::openmode trunc = 32;
            enum seekdir {
                beg,
                cur,
                end
            };
            typedef std::__1::ios_base::iostate io_state;
            typedef std::__1::ios_base::openmode open_mode;
            typedef std::__1::ios_base::seekdir seek_dir;
            typedef std::__1::streamoff streamoff;
            typedef std::__1::streampos streampos;
            class __attribute__((visibility("default"))) Init;
            std::__1::ios_base::fmtflags flags() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::ios_base::fmtflags flags(std::__1::ios_base::fmtflags __fmtfl) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::ios_base::fmtflags setf(std::__1::ios_base::fmtflags __fmtfl) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::ios_base::fmtflags setf(std::__1::ios_base::fmtflags __fmtfl, std::__1::ios_base::fmtflags __mask) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void unsetf(std::__1::ios_base::fmtflags __mask) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::streamsize precision() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::streamsize precision(std::__1::streamsize __prec) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::streamsize width() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::streamsize width(std::__1::streamsize __wide) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::locale imbue(const std::__1::locale &__loc);
            std::__1::locale getloc() const;
            static int xalloc();
            long &iword(int __index);
            void *&pword(int __index);
            virtual ~ios_base();
            enum event {
                erase_event,
                imbue_event,
                copyfmt_event
            };
            typedef void (*event_callback)(std::__1::ios_base::event, std::__1::ios_base &, int);
            void register_callback(std::__1::ios_base::event_callback __fn, int __index);
        private:
            ios_base(const std::__1::ios_base &);
            std::__1::ios_base &operator=(const std::__1::ios_base &);
        public:
            static bool sync_with_stdio(bool __sync = true);
            std::__1::ios_base::iostate rdstate() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void clear(std::__1::ios_base::iostate __state = goodbit);
            void setstate(std::__1::ios_base::iostate __state) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool good() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool eof() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool fail() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool bad() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::ios_base::iostate exceptions() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void exceptions(std::__1::ios_base::iostate __iostate) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void __set_badbit_and_consider_rethrow();
            void __set_failbit_and_consider_rethrow();
            void __setstate_nothrow(std::__1::ios_base::iostate __state) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__rdbuf_)
                    this->__rdstate_ |= __state;
                else
                    this->__rdstate_ |= __state | ios_base::badbit;
            }
        protected:
            ios_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void init(void *__sb);
            void *rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__rdbuf_;
            }
            void rdbuf(void *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__rdbuf_ = __sb;
                this->clear();
            }
            void __call_callbacks(std::__1::ios_base::event);
            void copyfmt(const std::__1::ios_base &);
            void move(std::__1::ios_base &);
            void swap(std::__1::ios_base &) throw();
            void set_rdbuf(void *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__rdbuf_ = __sb;
            }
        private:
            std::__1::ios_base::fmtflags __fmtflags_;
            std::__1::streamsize __precision_;
            std::__1::streamsize __width_;
            std::__1::ios_base::iostate __rdstate_;
            std::__1::ios_base::iostate __exceptions_;
            void *__rdbuf_;
            void *__loc_;
            std::__1::ios_base::event_callback *__fn_;
            int *__index_;
            size_t __event_size_;
            size_t __event_cap_;
            static atomic<int> __xindex_;
            long *__iarray_;
            size_t __iarray_size_;
            size_t __iarray_cap_;
            void **__parray_;
            size_t __parray_size_;
            size_t __parray_cap_;
        };
        struct __attribute__((visibility("default"))) io_errc {
            enum __lx {
                stream = 1
            };
            std::__1::io_errc::__lx __v_;
            io_errc(std::__1::io_errc::__lx __v) : __v_(__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit io_errc(int __v) : __v_(static_cast<std::__1::io_errc::__lx>(__v)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            operator int() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__v_;
            }
        };
        template<> struct __attribute__((type_visibility("default"))) is_error_code_enum<std::__1::io_errc> : public std::__1::true_type {
        };
        template<> struct __attribute__((type_visibility("default"))) is_error_code_enum<io_errc::__lx> : public std::__1::true_type {
        };
        const std::__1::error_category &iostream_category() throw() __attribute__((visibility("default")));
        inline std::__1::error_code make_error_code(std::__1::io_errc __e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::error_code(static_cast<int>(__e), iostream_category());
        }
        inline std::__1::error_condition make_error_condition(std::__1::io_errc __e) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::error_condition(static_cast<int>(__e), iostream_category());
        }
        class __attribute__((visibility("default"))) failure : public std::__1::system_error {
        public:
            explicit failure(const std::__1::string &__msg, const std::__1::error_code &__ec = io_errc::stream);
            explicit failure(const char *__msg, const std::__1::error_code &__ec = io_errc::stream);
            virtual ~failure() throw();
        };
        inline void __throw_failure(const char *__msg) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            throw ios_base::failure(__msg);
        }
        class __attribute__((visibility("default"))) Init {
        public:
            Init();
            ~Init();
        };
        inline ios_base::fmtflags ios_base::flags() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return this->__fmtflags_;
        }
        inline ios_base::fmtflags ios_base::flags(std::__1::ios_base::fmtflags __fmtfl) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::ios_base::fmtflags __r = this->__fmtflags_;
            this->__fmtflags_ = __fmtfl;
            return __r;
        }
        inline ios_base::fmtflags ios_base::setf(std::__1::ios_base::fmtflags __fmtfl) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::ios_base::fmtflags __r = this->__fmtflags_;
            this->__fmtflags_ |= __fmtfl;
            return __r;
        }
        inline void ios_base::unsetf(std::__1::ios_base::fmtflags __mask) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->__fmtflags_ &= ~__mask;
        }
        inline ios_base::fmtflags ios_base::setf(std::__1::ios_base::fmtflags __fmtfl, std::__1::ios_base::fmtflags __mask) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::ios_base::fmtflags __r = this->__fmtflags_;
            this->unsetf(__mask);
            this->__fmtflags_ |= __fmtfl & __mask;
            return __r;
        }
        inline std::__1::streamsize ios_base::precision() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return this->__precision_;
        }
        inline std::__1::streamsize ios_base::precision(std::__1::streamsize __prec) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::streamsize __r = this->__precision_;
            this->__precision_ = __prec;
            return __r;
        }
        inline std::__1::streamsize ios_base::width() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return this->__width_;
        }
        inline std::__1::streamsize ios_base::width(std::__1::streamsize __wide) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::streamsize __r = this->__width_;
            this->__width_ = __wide;
            return __r;
        }
        inline ios_base::iostate ios_base::rdstate() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return this->__rdstate_;
        }
        inline void ios_base::setstate(std::__1::ios_base::iostate __state) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->clear(this->__rdstate_ | __state);
        }
        inline bool ios_base::good() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return this->__rdstate_ == 0;
        }
        inline bool ios_base::eof() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (this->__rdstate_ & eofbit) != 0;
        }
        inline bool ios_base::fail() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (this->__rdstate_ & (failbit | badbit)) != 0;
        }
        inline bool ios_base::bad() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return (this->__rdstate_ & badbit) != 0;
        }
        inline ios_base::iostate ios_base::exceptions() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return this->__exceptions_;
        }
        inline void ios_base::exceptions(std::__1::ios_base::iostate __iostate) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->__exceptions_ = __iostate;
            this->clear(this->__rdstate_);
        }
        struct __attribute__((visibility("default"))) __cxx03_bool {
            typedef void (std::__1::__cxx03_bool::*__bool_type)();
            void __true_value()             {
            }
        };
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ios : public std::__1::ios_base {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            operator __cxx03_bool::__bool_type() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !this->fail() ? &__cxx03_bool::__true_value : std::__1::__get_nullptr_t();
            }
            bool operator!() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->fail();
            }
            std::__1::ios_base::iostate rdstate() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->ios_base::rdstate();
            }
            void clear(std::__1::ios_base::iostate __state = goodbit) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->ios_base::clear(__state);
            }
            void setstate(std::__1::ios_base::iostate __state) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->ios_base::setstate(__state);
            }
            bool good() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->ios_base::good();
            }
            bool eof() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->ios_base::eof();
            }
            bool fail() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->ios_base::fail();
            }
            bool bad() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->ios_base::bad();
            }
            std::__1::ios_base::iostate exceptions() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return ios_base::exceptions();
            }
            void exceptions(std::__1::ios_base::iostate __iostate) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                ios_base::exceptions(__iostate);
            }
            explicit basic_ios<_CharT, _Traits>(basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            virtual ~basic_ios<_CharT, _Traits>();
            basic_ostream<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *tie() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_ostream<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *tie(basic_ostream<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__tiestr) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *rdbuf(basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs);
            std::__1::basic_ios::char_type fill() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_ios::char_type fill(std::__1::basic_ios::char_type __ch) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            char narrow(std::__1::basic_ios::char_type __c, char __dfault) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::basic_ios::char_type widen(char __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        protected:
            basic_ios<_CharT, _Traits>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void init(basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void move(basic_ios<_CharT, _Traits> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void swap(basic_ios<_CharT, _Traits> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void set_rdbuf(basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        private:
            basic_ostream<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__tie_;
            mutable std::__1::basic_ios::int_type __fill_;
        };
        template <class _CharT, class _Traits> inline explicit basic_ios<_CharT, _Traits>::basic_ios<_CharT, _Traits>(basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->init(__sb);
        }
        template <class _CharT, class _Traits> basic_ios<_CharT, _Traits>::~basic_ios<_CharT, _Traits>()         {
        }
        template <class _CharT, class _Traits> inline void basic_ios<_CharT, _Traits>::init(basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->ios_base::init(__sb);
            this->__tie_ = 0;
            this->__fill_ = traits_type::eof();
        }
        template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> *basic_ios<_CharT, _Traits>::tie() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return this->__tie_;
        }
        template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> *basic_ios<_CharT, _Traits>::tie(basic_ostream<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__tiestr) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            basic_ostream<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__r = this->__tie_;
            this->__tie_ = __tiestr;
            return __r;
        }
        template <class _CharT, class _Traits> inline basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return static_cast<basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *>(ios_base::rdbuf());
        }
        template <class _CharT, class _Traits> inline basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__r = rdbuf();
            ios_base::rdbuf(__sb);
            return __r;
        }
        template <class _CharT, class _Traits> inline std::__1::locale basic_ios<_CharT, _Traits>::imbue(const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::locale __r = this->getloc();
            this->ios_base::imbue(__loc);
            if (rdbuf())
                rdbuf()->pubimbue(__loc);
            return __r;
        }
        template <class _CharT, class _Traits> inline char basic_ios<_CharT, _Traits>::narrow(std::__1::basic_ios::char_type __c, char __dfault) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<std::__1::basic_ios::char_type> >(this->getloc()).narrow(__c, __dfault);
        }
        template <class _CharT, class _Traits> inline _CharT basic_ios<_CharT, _Traits>::widen(char __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return use_facet<ctype<std::__1::basic_ios::char_type> >(this->getloc()).widen(__c);
        }
        template <class _CharT, class _Traits> inline _CharT basic_ios<_CharT, _Traits>::fill() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            if (traits_type::eq_int_type(traits_type::eof(), this->__fill_))
                this->__fill_ = this->widen(' ');
            return this->__fill_;
        }
        template <class _CharT, class _Traits> inline _CharT basic_ios<_CharT, _Traits>::fill(std::__1::basic_ios::char_type __ch) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::basic_ios::char_type __r = this->__fill_;
            this->__fill_ = __ch;
            return __r;
        }
        template <class _CharT, class _Traits> basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits> &__rhs)         {
            if (this != &__rhs) {
                this->__call_callbacks(erase_event);
                this->ios_base::copyfmt(__rhs);
                this->__tie_ = __rhs.__tie_;
                this->__fill_ = __rhs.__fill_;
                this->__call_callbacks(copyfmt_event);
                exceptions(__rhs.exceptions());
            }
            return *this;
        }
        template <class _CharT, class _Traits> inline void basic_ios<_CharT, _Traits>::move(basic_ios<_CharT, _Traits> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->ios_base::move(__rhs);
            this->__tie_ = __rhs.__tie_;
            __rhs.__tie_ = 0;
            this->__fill_ = __rhs.__fill_;
        }
        template <class _CharT, class _Traits> inline void basic_ios<_CharT, _Traits>::swap(basic_ios<_CharT, _Traits> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->ios_base::swap(__rhs);
            std::__1::swap(this->__tie_, __rhs.__tie_);
            std::__1::swap(this->__fill_, __rhs.__fill_);
        }
        template <class _CharT, class _Traits> inline void basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<std::__1::basic_ios::char_type, std::__1::basic_ios::traits_type> *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->ios_base::set_rdbuf(__sb);
        }
        inline std::__1::ios_base &boolalpha(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::boolalpha);
            return __str;
        }
        inline std::__1::ios_base &noboolalpha(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.unsetf(ios_base::boolalpha);
            return __str;
        }
        inline std::__1::ios_base &showbase(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::showbase);
            return __str;
        }
        inline std::__1::ios_base &noshowbase(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.unsetf(ios_base::showbase);
            return __str;
        }
        inline std::__1::ios_base &showpoint(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::showpoint);
            return __str;
        }
        inline std::__1::ios_base &noshowpoint(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.unsetf(ios_base::showpoint);
            return __str;
        }
        inline std::__1::ios_base &showpos(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::showpos);
            return __str;
        }
        inline std::__1::ios_base &noshowpos(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.unsetf(ios_base::showpos);
            return __str;
        }
        inline std::__1::ios_base &skipws(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::skipws);
            return __str;
        }
        inline std::__1::ios_base &noskipws(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.unsetf(ios_base::skipws);
            return __str;
        }
        inline std::__1::ios_base &uppercase(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::uppercase);
            return __str;
        }
        inline std::__1::ios_base &nouppercase(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.unsetf(ios_base::uppercase);
            return __str;
        }
        inline std::__1::ios_base &unitbuf(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::unitbuf);
            return __str;
        }
        inline std::__1::ios_base &nounitbuf(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.unsetf(ios_base::unitbuf);
            return __str;
        }
        inline std::__1::ios_base &internal(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::internal, ios_base::adjustfield);
            return __str;
        }
        inline std::__1::ios_base &left(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::left, ios_base::adjustfield);
            return __str;
        }
        inline std::__1::ios_base &right(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::right, ios_base::adjustfield);
            return __str;
        }
        inline std::__1::ios_base &dec(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::dec, ios_base::basefield);
            return __str;
        }
        inline std::__1::ios_base &hex(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::hex, ios_base::basefield);
            return __str;
        }
        inline std::__1::ios_base &oct(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::oct, ios_base::basefield);
            return __str;
        }
        inline std::__1::ios_base &fixed(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::fixed, ios_base::floatfield);
            return __str;
        }
        inline std::__1::ios_base &scientific(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::scientific, ios_base::floatfield);
            return __str;
        }
        inline std::__1::ios_base &hexfloat(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
            return __str;
        }
        inline std::__1::ios_base &defaultfloat(std::__1::ios_base &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __str.unsetf(ios_base::floatfield);
            return __str;
        }
        template <class _CharT, class _Traits> class __save_flags {
            typedef basic_ios<_CharT, _Traits> __stream_type;
            typedef typename __stream_type::fmtflags fmtflags;
            std::__1::__save_flags::__stream_type &__stream_;
            std::__1::__save_flags::fmtflags __fmtflags_;
            _CharT __fill_;
            __save_flags<_CharT, _Traits>(const __save_flags<_CharT, _Traits> &);
            __save_flags<_CharT, _Traits> &operator=(const __save_flags<_CharT, _Traits> &);
        public:
            explicit __save_flags<_CharT, _Traits>(std::__1::__save_flags::__stream_type &__stream) : __stream_(__stream), __fmtflags_(__stream.flags()), __fill_(__stream.fill()) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            ~__save_flags<_CharT, _Traits>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__stream_.flags(this->__fmtflags_);
                this->__stream_.fill(this->__fill_);
            }
        };
    }
}
namespace std {
    inline namespace __1 {
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_streambuf {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            virtual ~basic_streambuf<_CharT, _Traits>();
            inline std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->imbue(__loc);
                std::__1::locale __r = this->__loc_;
                this->__loc_ = __loc;
                return __r;
            }
            inline std::__1::locale getloc() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__loc_;
            }
            inline basic_streambuf<_CharT, _Traits> *pubsetbuf(std::__1::basic_streambuf::char_type *__s, std::__1::streamsize __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->setbuf(__s, __n);
            }
            inline std::__1::basic_streambuf::pos_type pubseekoff(std::__1::basic_streambuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->seekoff(__off, __way, __which);
            }
            inline std::__1::basic_streambuf::pos_type pubseekpos(std::__1::basic_streambuf::pos_type __sp, ios_base::openmode __which = ios_base::in | ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->seekpos(__sp, __which);
            }
            inline int pubsync() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->sync();
            }
            inline std::__1::streamsize in_avail() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__ninp_ < this->__einp_)
                    return static_cast<std::__1::streamsize>(this->__einp_ - this->__ninp_);
                return this->showmanyc();
            }
            inline std::__1::basic_streambuf::int_type snextc() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->sbumpc() == traits_type::eof())
                    return traits_type::eof();
                return this->sgetc();
            }
            inline std::__1::basic_streambuf::int_type sbumpc() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__ninp_ == this->__einp_)
                    return this->uflow();
                return traits_type::to_int_type(*this->__ninp_++);
            }
            inline std::__1::basic_streambuf::int_type sgetc() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__ninp_ == this->__einp_)
                    return this->underflow();
                return traits_type::to_int_type(*this->__ninp_);
            }
            inline std::__1::streamsize sgetn(std::__1::basic_streambuf::char_type *__s, std::__1::streamsize __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->xsgetn(__s, __n);
            }
            inline std::__1::basic_streambuf::int_type sputbackc(std::__1::basic_streambuf::char_type __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__binp_ == this->__ninp_ || !traits_type::eq(__c, this->__ninp_[-1]))
                    return this->pbackfail(traits_type::to_int_type(__c));
                return traits_type::to_int_type(*--this->__ninp_);
            }
            inline std::__1::basic_streambuf::int_type sungetc() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__binp_ == this->__ninp_)
                    return this->pbackfail();
                return traits_type::to_int_type(*--this->__ninp_);
            }
            inline std::__1::basic_streambuf::int_type sputc(std::__1::basic_streambuf::char_type __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                if (this->__nout_ == this->__eout_)
                    return this->overflow(traits_type::to_int_type(__c));
                *this->__nout_++ = __c;
                return traits_type::to_int_type(__c);
            }
            inline std::__1::streamsize sputn(const std::__1::basic_streambuf::char_type *__s, std::__1::streamsize __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->xsputn(__s, __n);
            }
        protected:
            basic_streambuf<_CharT, _Traits>();
            basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &__rhs);
            basic_streambuf<_CharT, _Traits> &operator=(const basic_streambuf<_CharT, _Traits> &__rhs);
            void swap(basic_streambuf<_CharT, _Traits> &__rhs);
            std::__1::basic_streambuf::char_type *eback() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__binp_;
            }
            std::__1::basic_streambuf::char_type *gptr() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ninp_;
            }
            std::__1::basic_streambuf::char_type *egptr() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__einp_;
            }
            inline void gbump(int __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__ninp_ += __n;
            }
            inline void setg(std::__1::basic_streambuf::char_type *__gbeg, std::__1::basic_streambuf::char_type *__gnext, std::__1::basic_streambuf::char_type *__gend) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__binp_ = __gbeg;
                this->__ninp_ = __gnext;
                this->__einp_ = __gend;
            }
            std::__1::basic_streambuf::char_type *pbase() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__bout_;
            }
            std::__1::basic_streambuf::char_type *pptr() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__nout_;
            }
            std::__1::basic_streambuf::char_type *epptr() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__eout_;
            }
            inline void pbump(int __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__nout_ += __n;
            }
            void __pbump(std::__1::streamsize __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__nout_ += __n;
            }
            inline void setp(std::__1::basic_streambuf::char_type *__pbeg, std::__1::basic_streambuf::char_type *__pend) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->__bout_ = this->__nout_ = __pbeg;
                this->__eout_ = __pend;
            }
            virtual void imbue(const std::__1::locale &__loc);
            virtual basic_streambuf<_CharT, _Traits> *setbuf(std::__1::basic_streambuf::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_streambuf::pos_type seekoff(std::__1::basic_streambuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out);
            virtual std::__1::basic_streambuf::pos_type seekpos(std::__1::basic_streambuf::pos_type __sp, ios_base::openmode __which = ios_base::in | ios_base::out);
            virtual int sync();
            virtual std::__1::streamsize showmanyc();
            virtual std::__1::streamsize xsgetn(std::__1::basic_streambuf::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_streambuf::int_type underflow();
            virtual std::__1::basic_streambuf::int_type uflow();
            virtual std::__1::basic_streambuf::int_type pbackfail(std::__1::basic_streambuf::int_type __c = traits_type::eof());
            virtual std::__1::streamsize xsputn(const std::__1::basic_streambuf::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_streambuf::int_type overflow(std::__1::basic_streambuf::int_type __c = traits_type::eof());
        private:
            std::__1::locale __loc_;
            std::__1::basic_streambuf::char_type *__binp_;
            std::__1::basic_streambuf::char_type *__ninp_;
            std::__1::basic_streambuf::char_type *__einp_;
            std::__1::basic_streambuf::char_type *__bout_;
            std::__1::basic_streambuf::char_type *__nout_;
            std::__1::basic_streambuf::char_type *__eout_;
        };
        template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits>::~basic_streambuf<_CharT, _Traits>()         {
        }
        template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits>::basic_streambuf<_CharT, _Traits>() : __binp_(0), __ninp_(0), __einp_(0), __bout_(0), __nout_(0), __eout_(0)         {
        }
        template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits>::basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &__sb) : __loc_(__sb.__loc_), __binp_(__sb.__binp_), __ninp_(__sb.__ninp_), __einp_(__sb.__einp_), __bout_(__sb.__bout_), __nout_(__sb.__nout_), __eout_(__sb.__eout_)         {
        }
        template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits> &basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf<_CharT, _Traits> &__sb)         {
            this->__loc_ = __sb.__loc_;
            this->__binp_ = __sb.__binp_;
            this->__ninp_ = __sb.__ninp_;
            this->__einp_ = __sb.__einp_;
            this->__bout_ = __sb.__bout_;
            this->__nout_ = __sb.__nout_;
            this->__eout_ = __sb.__eout_;
            return *this;
        }
        template <class _CharT, class _Traits> void basic_streambuf<_CharT, _Traits>::swap(basic_streambuf<_CharT, _Traits> &__sb)         {
            std::__1::swap(this->__loc_, __sb.__loc_);
            std::__1::swap(this->__binp_, __sb.__binp_);
            std::__1::swap(this->__ninp_, __sb.__ninp_);
            std::__1::swap(this->__einp_, __sb.__einp_);
            std::__1::swap(this->__bout_, __sb.__bout_);
            std::__1::swap(this->__nout_, __sb.__nout_);
            std::__1::swap(this->__eout_, __sb.__eout_);
        }
        template <class _CharT, class _Traits> void basic_streambuf<_CharT, _Traits>::imbue(const std::__1::locale &)         {
        }
        template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits> *basic_streambuf<_CharT, _Traits>::setbuf(std::__1::basic_streambuf::char_type *, std::__1::streamsize)         {
            return this;
        }
        template <class _CharT, class _Traits> typename basic_streambuf<_CharT, _Traits>::pos_type basic_streambuf<_CharT, _Traits>::seekoff(std::__1::basic_streambuf::off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out)         {
            return std::__1::basic_streambuf::pos_type(std::__1::basic_streambuf::off_type(-1));
        }
        template <class _CharT, class _Traits> typename basic_streambuf<_CharT, _Traits>::pos_type basic_streambuf<_CharT, _Traits>::seekpos(std::__1::basic_streambuf::pos_type, ios_base::openmode = ios_base::in | ios_base::out)         {
            return std::__1::basic_streambuf::pos_type(std::__1::basic_streambuf::off_type(-1));
        }
        template <class _CharT, class _Traits> int basic_streambuf<_CharT, _Traits>::sync()         {
            return 0;
        }
        template <class _CharT, class _Traits> std::__1::streamsize basic_streambuf<_CharT, _Traits>::showmanyc()         {
            return 0;
        }
        template <class _CharT, class _Traits> std::__1::streamsize basic_streambuf<_CharT, _Traits>::xsgetn(std::__1::basic_streambuf::char_type *__s, std::__1::streamsize __n)         {
            const std::__1::basic_streambuf::int_type __eof = traits_type::eof();
            std::__1::basic_streambuf::int_type __c;
            std::__1::streamsize __i = 0;
            while (__i < __n)
                {
                    if (this->__ninp_ < this->__einp_) {
                        const std::__1::streamsize __len = std::__1::min(static_cast<std::__1::streamsize>(2147483647), std::__1::min(this->__einp_ - this->__ninp_, __n - __i));
                        traits_type::copy(__s, this->__ninp_, __len);
                        __s += __len;
                        __i += __len;
                        this->gbump(__len);
                    } else if ((__c = this->uflow()) != __eof) {
                        *__s = traits_type::to_char_type(__c);
                        ++__s;
                        ++__i;
                    } else
                        break;
                }
            return __i;
        }
        template <class _CharT, class _Traits> typename basic_streambuf<_CharT, _Traits>::int_type basic_streambuf<_CharT, _Traits>::underflow()         {
            return traits_type::eof();
        }
        template <class _CharT, class _Traits> typename basic_streambuf<_CharT, _Traits>::int_type basic_streambuf<_CharT, _Traits>::uflow()         {
            if (this->underflow() == traits_type::eof())
                return traits_type::eof();
            return traits_type::to_int_type(*this->__ninp_++);
        }
        template <class _CharT, class _Traits> typename basic_streambuf<_CharT, _Traits>::int_type basic_streambuf<_CharT, _Traits>::pbackfail(std::__1::basic_streambuf::int_type = traits_type::eof())         {
            return traits_type::eof();
        }
        template <class _CharT, class _Traits> std::__1::streamsize basic_streambuf<_CharT, _Traits>::xsputn(const std::__1::basic_streambuf::char_type *__s, std::__1::streamsize __n)         {
            std::__1::streamsize __i = 0;
            std::__1::basic_streambuf::int_type __eof = traits_type::eof();
            while (__i < __n)
                {
                    if (this->__nout_ >= this->__eout_) {
                        if (this->overflow(traits_type::to_int_type(*__s)) == __eof)
                            break;
                        ++__s;
                        ++__i;
                    } else {
                        std::__1::streamsize __chunk_size = std::__1::min(this->__eout_ - this->__nout_, __n - __i);
                        traits_type::copy(this->__nout_, __s, __chunk_size);
                        this->__nout_ += __chunk_size;
                        __s += __chunk_size;
                        __i += __chunk_size;
                    }
                }
            return __i;
        }
        template <class _CharT, class _Traits> typename basic_streambuf<_CharT, _Traits>::int_type basic_streambuf<_CharT, _Traits>::overflow(std::__1::basic_streambuf::int_type = traits_type::eof())         {
            return traits_type::eof();
        }
        template<> class __attribute__((visibility("default"))) basic_streambuf<char> {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            static_assert((is_same<char, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            virtual ~basic_streambuf<char>();
            inline std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((internal_linkage));
            inline std::__1::locale getloc() const __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<char> *pubsetbuf(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<char, std::__1::char_traits<char> >::pos_type pubseekoff(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::off_type __off, ios_base::seekdir __way, ios_base::openmode __which) __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<char, std::__1::char_traits<char> >::pos_type pubseekpos(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::pos_type __sp, ios_base::openmode __which) __attribute__((internal_linkage));
            inline int pubsync() __attribute__((internal_linkage));
            inline std::__1::streamsize in_avail() __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type snextc() __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type sbumpc() __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type sgetc() __attribute__((internal_linkage));
            inline std::__1::streamsize sgetn(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type sputbackc(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type __c) __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type sungetc() __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type sputc(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type __c) __attribute__((internal_linkage));
            inline std::__1::streamsize sputn(const std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage))             {
                return this->xsputn(__s, __n);
            }
        protected:
            basic_streambuf();
            basic_streambuf(const std::__1::basic_streambuf<char> &__rhs);
            std::__1::basic_streambuf<char> &operator=(const std::__1::basic_streambuf<char> &__rhs);
            void swap(std::__1::basic_streambuf<char> &__rhs);
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *eback() const __attribute__((internal_linkage));
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *gptr() const __attribute__((internal_linkage));
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *egptr() const __attribute__((internal_linkage));
            inline void gbump(int __n) __attribute__((internal_linkage));
            inline void setg(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__gbeg, std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__gnext, std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__gend) __attribute__((internal_linkage));
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *pbase() const __attribute__((internal_linkage));
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *pptr() const __attribute__((internal_linkage));
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *epptr() const __attribute__((internal_linkage));
            inline void pbump(int __n) __attribute__((internal_linkage));
            void __pbump(std::__1::streamsize __n) __attribute__((internal_linkage));
            inline void setp(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__pbeg, std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__pend) __attribute__((internal_linkage));
            virtual void imbue(const std::__1::locale &__loc);
            virtual std::__1::basic_streambuf<char> *setbuf(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_streambuf<char, std::__1::char_traits<char> >::pos_type seekoff(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::off_type __off, ios_base::seekdir __way, ios_base::openmode __which);
            virtual std::__1::basic_streambuf<char, std::__1::char_traits<char> >::pos_type seekpos(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::pos_type __sp, ios_base::openmode __which);
            virtual int sync();
            virtual std::__1::streamsize showmanyc();
            virtual std::__1::streamsize xsgetn(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type underflow();
            virtual std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type uflow();
            virtual std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type pbackfail(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type __c);
            virtual std::__1::streamsize xsputn(const std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type overflow(std::__1::basic_streambuf<char, std::__1::char_traits<char> >::int_type __c);
        private:
            std::__1::locale __loc_;
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__binp_;
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__ninp_;
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__einp_;
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__bout_;
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__nout_;
            std::__1::basic_streambuf<char, std::__1::char_traits<char> >::char_type *__eout_;
        };
        template<> class __attribute__((visibility("default"))) basic_streambuf<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            static_assert((is_same<wchar_t, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            virtual ~basic_streambuf<wchar_t>();
            inline std::__1::locale pubimbue(const std::__1::locale &__loc) __attribute__((internal_linkage));
            inline std::__1::locale getloc() const __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<wchar_t> *pubsetbuf(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::pos_type pubseekoff(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::off_type __off, ios_base::seekdir __way, ios_base::openmode __which) __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::pos_type pubseekpos(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::pos_type __sp, ios_base::openmode __which) __attribute__((internal_linkage));
            inline int pubsync() __attribute__((internal_linkage));
            inline std::__1::streamsize in_avail() __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type snextc() __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type sbumpc() __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type sgetc() __attribute__((internal_linkage));
            inline std::__1::streamsize sgetn(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type sputbackc(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type __c) __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type sungetc() __attribute__((internal_linkage));
            inline std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type sputc(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type __c) __attribute__((internal_linkage));
            inline std::__1::streamsize sputn(const std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage));
        protected:
            basic_streambuf();
            basic_streambuf(const std::__1::basic_streambuf<wchar_t> &__rhs);
            std::__1::basic_streambuf<wchar_t> &operator=(const std::__1::basic_streambuf<wchar_t> &__rhs);
            void swap(std::__1::basic_streambuf<wchar_t> &__rhs);
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *eback() const __attribute__((internal_linkage));
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *gptr() const __attribute__((internal_linkage));
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *egptr() const __attribute__((internal_linkage));
            inline void gbump(int __n) __attribute__((internal_linkage));
            inline void setg(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__gbeg, std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__gnext, std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__gend) __attribute__((internal_linkage));
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *pbase() const __attribute__((internal_linkage));
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *pptr() const __attribute__((internal_linkage));
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *epptr() const __attribute__((internal_linkage));
            inline void pbump(int __n) __attribute__((internal_linkage));
            void __pbump(std::__1::streamsize __n) __attribute__((internal_linkage));
            inline void setp(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__pbeg, std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__pend) __attribute__((internal_linkage));
            virtual void imbue(const std::__1::locale &__loc);
            virtual std::__1::basic_streambuf<wchar_t> *setbuf(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::pos_type seekoff(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::off_type __off, ios_base::seekdir __way, ios_base::openmode __which);
            virtual std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::pos_type seekpos(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::pos_type __sp, ios_base::openmode __which);
            virtual int sync();
            virtual std::__1::streamsize showmanyc();
            virtual std::__1::streamsize xsgetn(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type underflow();
            virtual std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type uflow();
            virtual std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type pbackfail(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type __c);
            virtual std::__1::streamsize xsputn(const std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type overflow(std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::int_type __c);
        private:
            std::__1::locale __loc_;
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__binp_;
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__ninp_;
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__einp_;
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__bout_;
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__nout_;
            std::__1::basic_streambuf<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__eout_;
        };
        template<> class __attribute__((visibility("default"))) basic_ios<char> : public std::__1::ios_base {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            static_assert((is_same<char, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            operator __cxx03_bool::__bool_type() const __attribute__((internal_linkage));
            bool operator!() const __attribute__((internal_linkage));
            std::__1::ios_base::iostate rdstate() const __attribute__((internal_linkage));
            void clear(std::__1::ios_base::iostate __state) __attribute__((internal_linkage));
            void setstate(std::__1::ios_base::iostate __state) __attribute__((internal_linkage))             {
                this->ios_base::setstate(__state);
            }
            bool good() const __attribute__((internal_linkage));
            bool eof() const __attribute__((internal_linkage));
            bool fail() const __attribute__((internal_linkage));
            bool bad() const __attribute__((internal_linkage));
            std::__1::ios_base::iostate exceptions() const __attribute__((internal_linkage));
            void exceptions(std::__1::ios_base::iostate __iostate) __attribute__((internal_linkage));
            explicit basic_ios(basic_streambuf<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *__sb) __attribute__((internal_linkage));
            virtual ~basic_ios<char>();
            basic_ostream<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *tie() const __attribute__((internal_linkage));
            basic_ostream<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *tie(basic_ostream<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *__tiestr) __attribute__((internal_linkage));
            basic_streambuf<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *basic_ios<char, char_traits<char> >::rdbuf() const __attribute__((internal_linkage))             {
                return static_cast<basic_streambuf<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *>(this->ios_base::rdbuf());
            }
            basic_streambuf<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *rdbuf(basic_streambuf<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *__sb) __attribute__((internal_linkage));
            std::__1::basic_ios<char> &copyfmt(const std::__1::basic_ios<char> &__rhs);
            std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type basic_ios<char, char_traits<char> >::fill() const __attribute__((internal_linkage))             {
                if (traits_type::eq_int_type(traits_type::eof(), this->__fill_))
                    this->__fill_ = this->widen(' ');
                return this->__fill_;
            }
            std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type basic_ios<char, char_traits<char> >::fill(std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type __ch) __attribute__((internal_linkage))             {
                std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type __r = this->__fill_;
                this->__fill_ = __ch;
                return __r;
            }
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((internal_linkage));
            char narrow(std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type __c, char __dfault) const __attribute__((internal_linkage));
            std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type basic_ios<char, char_traits<char> >::widen(char __c) const __attribute__((internal_linkage))             {
                return use_facet<ctype<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type> >(this->getloc()).widen(__c);
            }
        protected:
            basic_ios() __attribute__((internal_linkage));
            void init(basic_streambuf<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *__sb) __attribute__((internal_linkage));
            void move(std::__1::basic_ios<char> &__rhs) __attribute__((internal_linkage));
            void swap(std::__1::basic_ios<char> &__rhs) throw() __attribute__((internal_linkage));
            void set_rdbuf(basic_streambuf<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *__sb) __attribute__((internal_linkage));
        private:
            basic_ostream<std::__1::basic_ios<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ios<char, std::__1::char_traits<char> >::traits_type> *__tie_;
            mutable std::__1::basic_ios<char, std::__1::char_traits<char> >::int_type __fill_;
        };
        template<> class __attribute__((visibility("default"))) basic_ios<wchar_t> : public std::__1::ios_base {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            static_assert((is_same<wchar_t, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");
            operator __cxx03_bool::__bool_type() const __attribute__((internal_linkage));
            bool operator!() const __attribute__((internal_linkage));
            std::__1::ios_base::iostate rdstate() const __attribute__((internal_linkage));
            void clear(std::__1::ios_base::iostate __state) __attribute__((internal_linkage));
            void setstate(std::__1::ios_base::iostate __state) __attribute__((internal_linkage));
            bool good() const __attribute__((internal_linkage));
            bool eof() const __attribute__((internal_linkage));
            bool fail() const __attribute__((internal_linkage));
            bool bad() const __attribute__((internal_linkage));
            std::__1::ios_base::iostate exceptions() const __attribute__((internal_linkage));
            void exceptions(std::__1::ios_base::iostate __iostate) __attribute__((internal_linkage));
            explicit basic_ios(basic_streambuf<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__sb) __attribute__((internal_linkage));
            virtual ~basic_ios<wchar_t>();
            basic_ostream<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *tie() const __attribute__((internal_linkage));
            basic_ostream<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *tie(basic_ostream<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__tiestr) __attribute__((internal_linkage));
            basic_streambuf<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *rdbuf() const __attribute__((internal_linkage));
            basic_streambuf<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *rdbuf(basic_streambuf<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__sb) __attribute__((internal_linkage));
            std::__1::basic_ios<wchar_t> &copyfmt(const std::__1::basic_ios<wchar_t> &__rhs);
            std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type fill() const __attribute__((internal_linkage));
            std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type fill(std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type __ch) __attribute__((internal_linkage));
            std::__1::locale imbue(const std::__1::locale &__loc) __attribute__((internal_linkage));
            char narrow(std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type __c, char __dfault) const __attribute__((internal_linkage));
            std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type widen(char __c) const __attribute__((internal_linkage));
        protected:
            basic_ios() __attribute__((internal_linkage));
            void init(basic_streambuf<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__sb) __attribute__((internal_linkage));
            void move(std::__1::basic_ios<wchar_t> &__rhs) __attribute__((internal_linkage));
            void swap(std::__1::basic_ios<wchar_t> &__rhs) throw() __attribute__((internal_linkage));
            void set_rdbuf(basic_streambuf<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__sb) __attribute__((internal_linkage));
        private:
            basic_ostream<std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__tie_;
            mutable std::__1::basic_ios<wchar_t, std::__1::char_traits<wchar_t> >::int_type __fill_;
        };
    }
}
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t *qaddr_t;
typedef char *caddr_t;
typedef int32_t daddr_t;
typedef u_int32_t fixpt_t;
typedef __darwin_blkcnt_t blkcnt_t;
typedef __darwin_blksize_t blksize_t;
typedef __darwin_gid_t gid_t;
typedef __uint32_t in_addr_t;
typedef __uint16_t in_port_t;
typedef __darwin_ino_t ino_t;
typedef __darwin_ino64_t ino64_t;
typedef __int32_t key_t;
typedef __uint16_t nlink_t;
typedef int32_t segsz_t;
typedef int32_t swblk_t;
static inline __int32_t major(__uint32_t _x) {
    return (__int32_t)(((__uint32_t)_x >> 24) & 255);
}
static inline __int32_t minor(__uint32_t _x) {
    return (__int32_t)((_x) & 16777215);
}
static inline dev_t makedev(__uint32_t _major, __uint32_t _minor) {
    return (dev_t)(((_major) << 24) | (_minor));
}
typedef __darwin_useconds_t useconds_t;
typedef __darwin_suseconds_t suseconds_t;
extern "C" {
    typedef struct fd_set {
        __int32_t fds_bits[32];
    } fd_set;
    int __darwin_check_fd_set_overflow(int, const void *, int) __attribute__((weak_import));
}
inline int __darwin_check_fd_set(int _a, const void *_b) __attribute__((always_inline)) {
    if ((uintptr_t)&__darwin_check_fd_set_overflow != (uintptr_t)0) {
        return __darwin_check_fd_set_overflow(_a, _b, 0);
    } else {
        return 1;
    }
}
inline int __darwin_fd_isset(int _fd, const struct fd_set *_p) __attribute__((always_inline)) {
    if (__darwin_check_fd_set(_fd, (const void *)_p)) {
        return _p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8))));
    }
    return 0;
}
inline void __darwin_fd_set(int _fd, struct fd_set *const _p) __attribute__((always_inline)) {
    if (__darwin_check_fd_set(_fd, (const void *)_p)) {
        (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] |= ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
    }
}
inline void __darwin_fd_clr(int _fd, struct fd_set *const _p) __attribute__((always_inline)) {
    if (__darwin_check_fd_set(_fd, (const void *)_p)) {
        (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &= ~((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
    }
}
typedef __int32_t fd_mask;
typedef __darwin_fsblkcnt_t fsblkcnt_t;
typedef __darwin_fsfilcnt_t fsfilcnt_t;
typedef struct __nl_cat_d {
    void *__data;
    int __size;
} *nl_catd;
typedef __darwin_nl_item nl_item;
extern "C" {
    nl_catd catopen(const char *, int);
    char *catgets(nl_catd, int, int, const char *) __attribute__((format_arg(4)));
    int catclose(nl_catd);
}
namespace std {
    inline namespace __1 {
        template <class _InputIterator, class _ForwardIterator, class _Ctype> _ForwardIterator __scan_keyword(_InputIterator &__b, _InputIterator __e, _ForwardIterator __kb, _ForwardIterator __ke, const _Ctype &__ct, ios_base::iostate &__err, bool __case_sensitive = true) __attribute__((visibility("hidden")))         {
            typedef typename iterator_traits<_InputIterator>::value_type _CharT;
            size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
            const unsigned char __doesnt_match = '\x00';
            const unsigned char __might_match = '\x01';
            const unsigned char __does_match = '\x02';
            unsigned char __statbuf[100];
            unsigned char *__status = __statbuf;
            unique_ptr<unsigned char, void (*)(void *)> __stat_hold(0, free);
            if (__nkw > sizeof (__statbuf)) {
                __status = (unsigned char *)malloc(__nkw);
                if (__status == 0)
                    __throw_bad_alloc();
                __stat_hold.reset(__status);
            }
            size_t __n_might_match = __nkw;
            size_t __n_does_match = 0;
            unsigned char *__st = __status;
            for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky , (void)++__st) {
                if (!__ky->empty())
                    *__st = __might_match;
                else {
                    *__st = __does_match;
                    --__n_might_match;
                    ++__n_does_match;
                }
            }
            for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx) {
                _CharT __c = *__b;
                if (!__case_sensitive)
                    __c = __ct.toupper(__c);
                bool __consume = false;
                __st = __status;
                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky , (void)++__st) {
                    if (*__st == __might_match) {
                        _CharT __kc = (*__ky)[__indx];
                        if (!__case_sensitive)
                            __kc = __ct.toupper(__kc);
                        if (__c == __kc) {
                            __consume = true;
                            if (__ky->size() == __indx + 1) {
                                *__st = __does_match;
                                --__n_might_match;
                                ++__n_does_match;
                            }
                        } else {
                            *__st = __doesnt_match;
                            --__n_might_match;
                        }
                    }
                }
                if (__consume) {
                    ++__b;
                    if (__n_might_match + __n_does_match > 1) {
                        __st = __status;
                        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky , (void)++__st) {
                            if (*__st == __does_match && __ky->size() != __indx + 1) {
                                *__st = __doesnt_match;
                                --__n_does_match;
                            }
                        }
                    }
                }
            }
            if (__b == __e)
                __err |= ios_base::eofbit;
            for (__st = __status; __kb != __ke; ++__kb , (void)++__st)
                if (*__st == __does_match)
                    break;
            if (__kb == __ke)
                __err |= ios_base::failbit;
            return __kb;
        }
        struct __attribute__((visibility("default"))) __num_get_base {
            static const int __num_get_buf_sz = 40;
            static int __get_base(std::__1::ios_base &);
            static const char __src[33];
        };
        void __check_grouping(const std::__1::string &__grouping, unsigned int *__g, unsigned int *__g_end, ios_base::iostate &__err) __attribute__((visibility("default")));
        template <class _CharT> struct __num_get : protected std::__1::__num_get_base {
            static std::__1::string __stage2_float_prep(std::__1::ios_base &__iob, _CharT *__atoms, _CharT &__decimal_point, _CharT &__thousands_sep);
            static int __stage2_float_loop(_CharT __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, _CharT __decimal_point, _CharT __thousands_sep, const std::__1::string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, _CharT *__atoms);
            static std::__1::string __stage2_int_prep(std::__1::ios_base &__iob, _CharT *__atoms, _CharT &__thousands_sep);
            static int __stage2_int_loop(_CharT __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, _CharT __thousands_sep, const std::__1::string &__grouping, unsigned int *__g, unsigned int *&__g_end, _CharT *__atoms);
        };
        template <class _CharT> std::__1::string __num_get<_CharT>::__stage2_int_prep(std::__1::ios_base &__iob, _CharT *__atoms, _CharT &__thousands_sep)         {
            std::__1::locale __loc = __iob.getloc();
            use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
            const numpunct<_CharT> &__np = use_facet<numpunct<_CharT> >(__loc);
            __thousands_sep = __np.thousands_sep();
            return __np.grouping();
        }
        template <class _CharT> std::__1::string __num_get<_CharT>::__stage2_float_prep(std::__1::ios_base &__iob, _CharT *__atoms, _CharT &__decimal_point, _CharT &__thousands_sep)         {
            std::__1::locale __loc = __iob.getloc();
            use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
            const numpunct<_CharT> &__np = use_facet<numpunct<_CharT> >(__loc);
            __decimal_point = __np.decimal_point();
            __thousands_sep = __np.thousands_sep();
            return __np.grouping();
        }
        template <class _CharT> int __num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, _CharT __thousands_sep, const std::__1::string &__grouping, unsigned int *__g, unsigned int *&__g_end, _CharT *__atoms)         {
            if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25])) {
                *__a_end++ = __ct == __atoms[24] ? '+' : '-';
                __dc = 0;
                return 0;
            }
            if (__grouping.size() != 0 && __ct == __thousands_sep) {
                if (__g_end - __g < __num_get_buf_sz) {
                    *__g_end++ = __dc;
                    __dc = 0;
                }
                return 0;
            }
            ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
            if (__f >= 24)
                return -1;
            switch (__base) {
              case 8:
              case 10:
                if (__f >= __base)
                    return -1;
                break;
              case 16:
                if (__f < 22)
                    break;
                if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0') {
                    __dc = 0;
                    *__a_end++ = __src[__f];
                    return 0;
                }
                return -1;
            }
            *__a_end++ = __src[__f];
            ++__dc;
            return 0;
        }
        template <class _CharT> int __num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, _CharT __decimal_point, _CharT __thousands_sep, const std::__1::string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, _CharT *__atoms)         {
            if (__ct == __decimal_point) {
                if (!__in_units)
                    return -1;
                __in_units = false;
                *__a_end++ = '.';
                if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
                    *__g_end++ = __dc;
                return 0;
            }
            if (__ct == __thousands_sep && __grouping.size() != 0) {
                if (!__in_units)
                    return -1;
                if (__g_end - __g < __num_get_buf_sz) {
                    *__g_end++ = __dc;
                    __dc = 0;
                }
                return 0;
            }
            ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
            if (__f >= 32)
                return -1;
            char __x = __src[__f];
            if (__x == '-' || __x == '+') {
                if (__a_end == __a || (__a_end[-1] & 95) == (__exp & 127)) {
                    *__a_end++ = __x;
                    return 0;
                }
                return -1;
            }
            if (__x == 'x' || __x == 'X')
                __exp = 'P';
            else if ((__x & 95) == __exp) {
                __exp |= (char)128;
                if (__in_units) {
                    __in_units = false;
                    if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
                        *__g_end++ = __dc;
                }
            }
            *__a_end++ = __x;
            if (__f >= 22)
                return 0;
            ++__dc;
            return 0;
        }
        template<> struct __attribute__((visibility("default"))) __num_get<char> : protected std::__1::__num_get_base {
            static std::__1::string __stage2_float_prep(std::__1::ios_base &__iob, char *__atoms, char &__decimal_point, char &__thousands_sep);
            static int __stage2_float_loop(char __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, char __decimal_point, char __thousands_sep, const std::__1::string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, char *__atoms);
            static std::__1::string __stage2_int_prep(std::__1::ios_base &__iob, char *__atoms, char &__thousands_sep);
            static int __stage2_int_loop(char __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, char __thousands_sep, const std::__1::string &__grouping, unsigned int *__g, unsigned int *&__g_end, char *__atoms);
        };
        template<> struct __attribute__((visibility("default"))) __num_get<wchar_t> : protected std::__1::__num_get_base {
            static std::__1::string __stage2_float_prep(std::__1::ios_base &__iob, wchar_t *__atoms, wchar_t &__decimal_point, wchar_t &__thousands_sep);
            static int __stage2_float_loop(wchar_t __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end, wchar_t __decimal_point, wchar_t __thousands_sep, const std::__1::string &__grouping, unsigned int *__g, unsigned int *&__g_end, unsigned int &__dc, wchar_t *__atoms);
            static std::__1::string __stage2_int_prep(std::__1::ios_base &__iob, wchar_t *__atoms, wchar_t &__thousands_sep);
            static int __stage2_int_loop(wchar_t __ct, int __base, char *__a, char *&__a_end, unsigned int &__dc, wchar_t __thousands_sep, const std::__1::string &__grouping, unsigned int *__g, unsigned int *&__g_end, wchar_t *__atoms);
        };
        template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) num_get : public locale::facet, private __num_get<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _InputIterator iter_type;
            explicit num_get<_CharT, _InputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            std::__1::num_get::iter_type get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __iob, __err, __v);
            }
            static locale::id id;
        protected:
            ~num_get<_CharT, _InputIterator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _Fp> inline std::__1::num_get::iter_type __do_get_floating_point(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const __attribute__((visibility("hidden")));
            template <class _Signed> inline std::__1::num_get::iter_type __do_get_signed(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const __attribute__((visibility("hidden")));
            template <class _Unsigned> inline std::__1::num_get::iter_type __do_get_unsigned(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const __attribute__((visibility("hidden")));
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const;
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const             {
                return this->__do_get_signed(__b, __e, __iob, __err, __v);
            }
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const             {
                return this->__do_get_signed(__b, __e, __iob, __err, __v);
            }
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const             {
                return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
            }
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const             {
                return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
            }
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const             {
                return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
            }
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const             {
                return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
            }
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const             {
                return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
            }
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const             {
                return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
            }
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const             {
                return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
            }
            virtual std::__1::num_get::iter_type do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const;
        };
        locale::id id;
        template <class _Tp> _Tp __num_get_signed_integral(const char *__a, const char *__a_end, ios_base::iostate &__err, int __base) __attribute__((visibility("hidden")))         {
            if (__a != __a_end) {
                typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
                (*__error()) = 0;
                char *__p2;
                long long __ll = strtoll_l(__a, &__p2, __base, 0);
                typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
                if (__current_errno == 0)
                    (*__error()) = __save_errno;
                if (__p2 != __a_end) {
                    __err = ios_base::failbit;
                    return 0;
                } else if (__current_errno == 34 || __ll < numeric_limits<_Tp>::min() || numeric_limits<_Tp>::max() < __ll) {
                    __err = ios_base::failbit;
                    if (__ll > 0)
                        return numeric_limits<_Tp>::max();
                    else
                        return numeric_limits<_Tp>::min();
                }
                return static_cast<_Tp>(__ll);
            }
            __err = ios_base::failbit;
            return 0;
        }
        template <class _Tp> _Tp __num_get_unsigned_integral(const char *__a, const char *__a_end, ios_base::iostate &__err, int __base) __attribute__((visibility("hidden")))         {
            if (__a != __a_end) {
                const bool __negate = *__a == '-';
                if (__negate && ++__a == __a_end) {
                    __err = ios_base::failbit;
                    return 0;
                }
                typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
                (*__error()) = 0;
                char *__p2;
                unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
                typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
                if (__current_errno == 0)
                    (*__error()) = __save_errno;
                if (__p2 != __a_end) {
                    __err = ios_base::failbit;
                    return 0;
                } else if (__current_errno == 34 || numeric_limits<_Tp>::max() < __ll) {
                    __err = ios_base::failbit;
                    return numeric_limits<_Tp>::max();
                }
                _Tp __res = static_cast<_Tp>(__ll);
                if (__negate)
                    __res = - __res;
                return __res;
            }
            __err = ios_base::failbit;
            return 0;
        }
        template <class _Tp> _Tp __do_strtod(const char *__a, char **__p2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        template<> inline float __do_strtod<float>(const char *__a, char **__p2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return strtof_l(__a, __p2, 0);
        }
        template<> inline double __do_strtod<double>(const char *__a, char **__p2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return strtod_l(__a, __p2, 0);
        }
        template<> inline long double __do_strtod<long double>(const char *__a, char **__p2) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return strtold_l(__a, __p2, 0);
        }
        template <class _Tp> _Tp __num_get_float(const char *__a, const char *__a_end, ios_base::iostate &__err) __attribute__((visibility("hidden")))         {
            if (__a != __a_end) {
                typename remove_reference<decltype((*__error()))>::type __save_errno = (*__error());
                (*__error()) = 0;
                char *__p2;
                _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
                typename remove_reference<decltype((*__error()))>::type __current_errno = (*__error());
                if (__current_errno == 0)
                    (*__error()) = __save_errno;
                if (__p2 != __a_end) {
                    __err = ios_base::failbit;
                    return 0;
                } else if (__current_errno == 34)
                    __err = ios_base::failbit;
                return __ld;
            }
            __err = ios_base::failbit;
            return 0;
        }
        template <class _CharT, class _InputIterator> _InputIterator num_get<_CharT, _InputIterator>::do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const         {
            if ((__iob.flags() & ios_base::boolalpha) == 0) {
                long __lv = -1;
                __b = do_get(__b, __e, __iob, __err, __lv);
                switch (__lv) {
                  case 0:
                    __v = false;
                    break;
                  case 1:
                    __v = true;
                    break;
                  default:
                    __v = true;
                    __err = ios_base::failbit;
                    break;
                }
                return __b;
            }
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__iob.getloc());
            const numpunct<_CharT> &__np = use_facet<numpunct<_CharT> >(__iob.getloc());
            typedef typename numpunct<_CharT>::string_type string_type;
            const string_type __names[2] = {__np.truename(), __np.falsename()};
            const string_type *__i = __scan_keyword(__b, __e, __names, __names + 2, __ct, __err);
            __v = __i == __names;
            return __b;
        }
        template <class _CharT, class _InputIterator> template <class _Signed> _InputIterator num_get<_CharT, _InputIterator>::__do_get_signed(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const         {
            int __base = this->__get_base(__iob);
            std::__1::num_get::char_type __thousands_sep;
            const int __atoms_size = 26;
            std::__1::num_get::char_type __atoms[26];
            std::__1::string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
            std::__1::string __buf;
            __buf.resize(__buf.capacity());
            char *__a = &__buf[0];
            char *__a_end = __a;
            unsigned int __g[40];
            unsigned int *__g_end = __g;
            unsigned int __dc = 0;
            for (; __b != __e; ++__b) {
                if (__a_end == __a + __buf.size()) {
                    size_t __tmp = __buf.size();
                    __buf.resize(2 * __buf.size());
                    __buf.resize(__buf.capacity());
                    __a = &__buf[0];
                    __a_end = __a + __tmp;
                }
                if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
                    break;
            }
            if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
                *__g_end++ = __dc;
            __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);
            __check_grouping(__grouping, __g, __g_end, __err);
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }
        template <class _CharT, class _InputIterator> template <class _Unsigned> _InputIterator num_get<_CharT, _InputIterator>::__do_get_unsigned(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const         {
            int __base = this->__get_base(__iob);
            std::__1::num_get::char_type __thousands_sep;
            const int __atoms_size = 26;
            std::__1::num_get::char_type __atoms[26];
            std::__1::string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
            std::__1::string __buf;
            __buf.resize(__buf.capacity());
            char *__a = &__buf[0];
            char *__a_end = __a;
            unsigned int __g[40];
            unsigned int *__g_end = __g;
            unsigned int __dc = 0;
            for (; __b != __e; ++__b) {
                if (__a_end == __a + __buf.size()) {
                    size_t __tmp = __buf.size();
                    __buf.resize(2 * __buf.size());
                    __buf.resize(__buf.capacity());
                    __a = &__buf[0];
                    __a_end = __a + __tmp;
                }
                if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
                    break;
            }
            if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
                *__g_end++ = __dc;
            __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);
            __check_grouping(__grouping, __g, __g_end, __err);
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }
        template <class _CharT, class _InputIterator> template <class _Fp> _InputIterator num_get<_CharT, _InputIterator>::__do_get_floating_point(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const         {
            std::__1::num_get::char_type __atoms[32];
            std::__1::num_get::char_type __decimal_point;
            std::__1::num_get::char_type __thousands_sep;
            std::__1::string __grouping = this->__stage2_float_prep(__iob, __atoms, __decimal_point, __thousands_sep);
            std::__1::string __buf;
            __buf.resize(__buf.capacity());
            char *__a = &__buf[0];
            char *__a_end = __a;
            unsigned int __g[40];
            unsigned int *__g_end = __g;
            unsigned int __dc = 0;
            bool __in_units = true;
            char __exp = 'E';
            for (; __b != __e; ++__b) {
                if (__a_end == __a + __buf.size()) {
                    size_t __tmp = __buf.size();
                    __buf.resize(2 * __buf.size());
                    __buf.resize(__buf.capacity());
                    __a = &__buf[0];
                    __a_end = __a + __tmp;
                }
                if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end, __decimal_point, __thousands_sep, __grouping, __g, __g_end, __dc, __atoms))
                    break;
            }
            if (__grouping.size() != 0 && __in_units && __g_end - __g < __num_get_base::__num_get_buf_sz)
                *__g_end++ = __dc;
            __v = __num_get_float<_Fp>(__a, __a_end, __err);
            __check_grouping(__grouping, __g, __g_end, __err);
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }
        template <class _CharT, class _InputIterator> _InputIterator num_get<_CharT, _InputIterator>::do_get(std::__1::num_get::iter_type __b, std::__1::num_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const         {
            int __base = 16;
            std::__1::num_get::char_type __atoms[26];
            std::__1::num_get::char_type __thousands_sep = 0;
            std::__1::string __grouping;
            use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src, __num_get_base::__src + 26, __atoms);
            std::__1::string __buf;
            __buf.resize(__buf.capacity());
            char *__a = &__buf[0];
            char *__a_end = __a;
            unsigned int __g[40];
            unsigned int *__g_end = __g;
            unsigned int __dc = 0;
            for (; __b != __e; ++__b) {
                if (__a_end == __a + __buf.size()) {
                    size_t __tmp = __buf.size();
                    __buf.resize(2 * __buf.size());
                    __buf.resize(__buf.capacity());
                    __a = &__buf[0];
                    __a_end = __a + __tmp;
                }
                if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
                    break;
            }
            __buf.resize(__a_end - __a);
            if (sscanf_l(__buf.c_str(), 0, "%p", &__v) != 1)
                __err = ios_base::failbit;
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }
        template<> class __attribute__((visibility("default"))) num_get<char> : public locale::facet, private __num_get<char> {
        public:
            typedef char char_type;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            explicit num_get(size_t __refs) __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((internal_linkage));
            std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~num_get<char>() __attribute__((internal_linkage));
            template <class _Fp> inline std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __do_get_floating_point(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const;
            template <class _Signed> inline std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __do_get_signed(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const;
            template <class _Unsigned> inline std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __do_get_unsigned(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::num_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const;
        };
        template<> class __attribute__((visibility("default"))) num_get<wchar_t> : public locale::facet, private __num_get<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            explicit num_get(size_t __refs) __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((internal_linkage));
            std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~num_get<wchar_t>() __attribute__((internal_linkage));
            template <class _Fp> inline std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __do_get_floating_point(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Fp &__v) const;
            template <class _Signed> inline std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __do_get_signed(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Signed &__v) const;
            template <class _Unsigned> inline std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __do_get_unsigned(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, _Unsigned &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, bool &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long long &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned short &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned int &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, unsigned long long &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, float &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, double &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::num_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, void *&__v) const;
        };
        struct __attribute__((visibility("default"))) __num_put_base {
        protected:
            static void __format_int(char *__fmt, const char *__len, bool __signd, ios_base::fmtflags __flags);
            static bool __format_float(char *__fmt, const char *__len, ios_base::fmtflags __flags);
            static char *__identify_padding(char *__nb, char *__ne, const std::__1::ios_base &__iob);
        };
        template <class _CharT> struct __num_put : protected std::__1::__num_put_base {
            static void __widen_and_group_int(char *__nb, char *__np, char *__ne, _CharT *__ob, _CharT *&__op, _CharT *&__oe, const std::__1::locale &__loc);
            static void __widen_and_group_float(char *__nb, char *__np, char *__ne, _CharT *__ob, _CharT *&__op, _CharT *&__oe, const std::__1::locale &__loc);
        };
        template <class _CharT> void __num_put<_CharT>::__widen_and_group_int(char *__nb, char *__np, char *__ne, _CharT *__ob, _CharT *&__op, _CharT *&__oe, const std::__1::locale &__loc)         {
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__loc);
            const numpunct<_CharT> &__npt = use_facet<numpunct<_CharT> >(__loc);
            std::__1::string __grouping = __npt.grouping();
            if (__grouping.empty()) {
                __ct.widen(__nb, __ne, __ob);
                __oe = __ob + (__ne - __nb);
            } else {
                __oe = __ob;
                char *__nf = __nb;
                if (*__nf == '-' || *__nf == '+')
                    *__oe++ = __ct.widen(*__nf++);
                if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X')) {
                    *__oe++ = __ct.widen(*__nf++);
                    *__oe++ = __ct.widen(*__nf++);
                }
                reverse(__nf, __ne);
                _CharT __thousands_sep = __npt.thousands_sep();
                unsigned int __dc = 0;
                unsigned int __dg = 0;
                for (char *__p = __nf; __p < __ne; ++__p) {
                    if (static_cast<unsigned int>(__grouping[__dg]) > 0 && __dc == static_cast<unsigned int>(__grouping[__dg])) {
                        *__oe++ = __thousands_sep;
                        __dc = 0;
                        if (__dg < __grouping.size() - 1)
                            ++__dg;
                    }
                    *__oe++ = __ct.widen(*__p);
                    ++__dc;
                }
                reverse(__ob + (__nf - __nb), __oe);
            }
            if (__np == __ne)
                __op = __oe;
            else
                __op = __ob + (__np - __nb);
        }
        template <class _CharT> void __num_put<_CharT>::__widen_and_group_float(char *__nb, char *__np, char *__ne, _CharT *__ob, _CharT *&__op, _CharT *&__oe, const std::__1::locale &__loc)         {
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__loc);
            const numpunct<_CharT> &__npt = use_facet<numpunct<_CharT> >(__loc);
            std::__1::string __grouping = __npt.grouping();
            __oe = __ob;
            char *__nf = __nb;
            if (*__nf == '-' || *__nf == '+')
                *__oe++ = __ct.widen(*__nf++);
            char *__ns;
            if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X')) {
                *__oe++ = __ct.widen(*__nf++);
                *__oe++ = __ct.widen(*__nf++);
                for (__ns = __nf; __ns < __ne; ++__ns)
                    if (!isxdigit_l(*__ns, 0))
                        break;
            } else {
                for (__ns = __nf; __ns < __ne; ++__ns)
                    if (!isdigit_l(*__ns, 0))
                        break;
            }
            if (__grouping.empty()) {
                __ct.widen(__nf, __ns, __oe);
                __oe += __ns - __nf;
            } else {
                reverse(__nf, __ns);
                _CharT __thousands_sep = __npt.thousands_sep();
                unsigned int __dc = 0;
                unsigned int __dg = 0;
                for (char *__p = __nf; __p < __ns; ++__p) {
                    if (__grouping[__dg] > 0 && __dc == static_cast<unsigned int>(__grouping[__dg])) {
                        *__oe++ = __thousands_sep;
                        __dc = 0;
                        if (__dg < __grouping.size() - 1)
                            ++__dg;
                    }
                    *__oe++ = __ct.widen(*__p);
                    ++__dc;
                }
                reverse(__ob + (__nf - __nb), __oe);
            }
            for (__nf = __ns; __nf < __ne; ++__nf) {
                if (*__nf == '.') {
                    *__oe++ = __npt.decimal_point();
                    ++__nf;
                    break;
                } else
                    *__oe++ = __ct.widen(*__nf);
            }
            __ct.widen(__nf, __ne, __oe);
            __oe += __ne - __nf;
            if (__np == __ne)
                __op = __oe;
            else
                __op = __ob + (__np - __nb);
        }
        template<> struct __attribute__((visibility("default"))) __num_put<char> : protected std::__1::__num_put_base {
            static void __widen_and_group_int(char *__nb, char *__np, char *__ne, char *__ob, char *&__op, char *&__oe, const std::__1::locale &__loc);
            static void __widen_and_group_float(char *__nb, char *__np, char *__ne, char *__ob, char *&__op, char *&__oe, const std::__1::locale &__loc);
        };
        template<> struct __attribute__((visibility("default"))) __num_put<wchar_t> : protected std::__1::__num_put_base {
            static void __widen_and_group_int(char *__nb, char *__np, char *__ne, wchar_t *__ob, wchar_t *&__op, wchar_t *&__oe, const std::__1::locale &__loc);
            static void __widen_and_group_float(char *__nb, char *__np, char *__ne, wchar_t *__ob, wchar_t *&__op, wchar_t *&__oe, const std::__1::locale &__loc);
        };
        template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) num_put : public locale::facet, private __num_put<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _OutputIterator iter_type;
            explicit num_put<_CharT, _OutputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::num_put::iter_type put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, bool __v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __iob, __fl, __v);
            }
            std::__1::num_put::iter_type put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, long __v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __iob, __fl, __v);
            }
            std::__1::num_put::iter_type put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, long long __v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __iob, __fl, __v);
            }
            std::__1::num_put::iter_type put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, unsigned long __v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __iob, __fl, __v);
            }
            std::__1::num_put::iter_type put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, unsigned long long __v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __iob, __fl, __v);
            }
            std::__1::num_put::iter_type put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, double __v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __iob, __fl, __v);
            }
            std::__1::num_put::iter_type put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, long double __v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __iob, __fl, __v);
            }
            std::__1::num_put::iter_type put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, const void *__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __iob, __fl, __v);
            }
            static locale::id id;
        protected:
            ~num_put<_CharT, _OutputIterator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual std::__1::num_put::iter_type do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, bool __v) const;
            virtual std::__1::num_put::iter_type do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, long __v) const;
            virtual std::__1::num_put::iter_type do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, long long __v) const;
            virtual std::__1::num_put::iter_type do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, unsigned long) const;
            virtual std::__1::num_put::iter_type do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, unsigned long long) const;
            virtual std::__1::num_put::iter_type do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, double __v) const;
            virtual std::__1::num_put::iter_type do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, long double __v) const;
            virtual std::__1::num_put::iter_type do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, const void *__v) const;
        };
        locale::id id;
        template <class _CharT, class _OutputIterator> _OutputIterator __pad_and_output(_OutputIterator __s, const _CharT *__ob, const _CharT *__op, const _CharT *__oe, std::__1::ios_base &__iob, _CharT __fl) __attribute__((visibility("hidden")))         {
            std::__1::streamsize __sz = __oe - __ob;
            std::__1::streamsize __ns = __iob.width();
            if (__ns > __sz)
                __ns -= __sz;
            else
                __ns = 0;
            for (; __ob < __op; ++__ob , ++__s)
                *__s = *__ob;
            for (; __ns; --__ns , ++__s)
                *__s = __fl;
            for (; __ob < __oe; ++__ob , ++__s)
                *__s = *__ob;
            __iob.width(0);
            return __s;
        }
        template<> std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > __pad_and_output<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> >>(std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > __s, const char *__ob, const char *__op, const char *__oe, std::__1::ios_base &__iob, char __fl)        template <class _CharT, class _Traits> ostreambuf_iterator<_CharT, _Traits> __pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s, const _CharT *__ob, const _CharT *__op, const _CharT *__oe, std::__1::ios_base &__iob, _CharT __fl) __attribute__((visibility("hidden")))         {
            if (__s.__sbuf_ == std::__1::__get_nullptr_t())
                return __s;
            std::__1::streamsize __sz = __oe - __ob;
            std::__1::streamsize __ns = __iob.width();
            if (__ns > __sz)
                __ns -= __sz;
            else
                __ns = 0;
            std::__1::streamsize __np = __op - __ob;
            if (__np > 0) {
                if (__s.__sbuf_->sputn(__ob, __np) != __np) {
                    __s.__sbuf_ = std::__1::__get_nullptr_t();
                    return __s;
                }
            }
            if (__ns > 0) {
                basic_string<_CharT, _Traits> __sp(__ns, __fl);
                if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns) {
                    __s.__sbuf_ = std::__1::__get_nullptr_t();
                    return __s;
                }
            }
            __np = __oe - __op;
            if (__np > 0) {
                if (__s.__sbuf_->sputn(__op, __np) != __np) {
                    __s.__sbuf_ = std::__1::__get_nullptr_t();
                    return __s;
                }
            }
            __iob.width(0);
            return __s;
        }
        template<> ostreambuf_iterator<char, std::__1::char_traits<char> > __pad_and_output<char, std::__1::char_traits<char>>(ostreambuf_iterator<char, std::__1::char_traits<char> > __s, const char *__ob, const char *__op, const char *__oe, std::__1::ios_base &__iob, char __fl)         {
            if (__s.__sbuf_ == std::__1::__get_nullptr_t())
                return __s;
            std::__1::streamsize __sz = __oe - __ob;
            std::__1::streamsize __ns = __iob.width();
            if (__ns > __sz)
                __ns -= __sz;
            else
                __ns = 0;
            std::__1::streamsize __np = __op - __ob;
            if (__np > 0) {
                if (__s.__sbuf_->sputn(__ob, __np) != __np) {
                    __s.__sbuf_ = std::__1::__get_nullptr_t();
                    return __s;
                }
            }
            if (__ns > 0) {
                basic_string<char, std::__1::char_traits<char> > __sp(__ns, __fl);
                if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns) {
                    __s.__sbuf_ = std::__1::__get_nullptr_t();
                    return __s;
                }
            }
            __np = __oe - __op;
            if (__np > 0) {
                if (__s.__sbuf_->sputn(__op, __np) != __np) {
                    __s.__sbuf_ = std::__1::__get_nullptr_t();
                    return __s;
                }
            }
            __iob.width(0);
            return __s;
        }
        template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, bool __v) const         {
            if ((__iob.flags() & ios_base::boolalpha) == 0)
                return do_put(__s, __iob, __fl, (unsigned long)__v);
            const numpunct<std::__1::num_put::char_type> &__np = use_facet<numpunct<std::__1::num_put::char_type> >(__iob.getloc());
            typedef typename numpunct<char_type>::string_type string_type;
            string_type __nm = __v ? __np.truename() : __np.falsename();
            for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i , ++__s)
                *__s = *__i;
            return __s;
        }
        template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, long __v) const         {
            char __fmt[6] = {'%', 0};
            const char *__len = "l";
            this->__format_int(__fmt + 1, __len, true, __iob.flags());
            const unsigned int __nbuf = (numeric_limits<long>::digits / 3) + ((numeric_limits<long>::digits % 3) != 0) + ((__iob.flags() & ios_base::showbase) != 0) + 2;
            char __nar[__nbuf];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            std::__1::num_put::char_type __o[2 * (__nbuf - 1) - 1];
            std::__1::num_put::char_type *__op;
            std::__1::num_put::char_type *__oe;
            this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }
        template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, long long __v) const         {
            char __fmt[8] = {'%', 0};
            const char *__len = "ll";
            this->__format_int(__fmt + 1, __len, true, __iob.flags());
            const unsigned int __nbuf = (numeric_limits<long long>::digits / 3) + ((numeric_limits<long long>::digits % 3) != 0) + ((__iob.flags() & ios_base::showbase) != 0) + 2;
            char __nar[__nbuf];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            std::__1::num_put::char_type __o[2 * (__nbuf - 1) - 1];
            std::__1::num_put::char_type *__op;
            std::__1::num_put::char_type *__oe;
            this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }
        template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, unsigned long __v) const         {
            char __fmt[6] = {'%', 0};
            const char *__len = "l";
            this->__format_int(__fmt + 1, __len, false, __iob.flags());
            const unsigned int __nbuf = (numeric_limits<unsigned long>::digits / 3) + ((numeric_limits<unsigned long>::digits % 3) != 0) + ((__iob.flags() & ios_base::showbase) != 0) + 1;
            char __nar[__nbuf];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            std::__1::num_put::char_type __o[2 * (__nbuf - 1) - 1];
            std::__1::num_put::char_type *__op;
            std::__1::num_put::char_type *__oe;
            this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }
        template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, unsigned long long __v) const         {
            char __fmt[8] = {'%', 0};
            const char *__len = "ll";
            this->__format_int(__fmt + 1, __len, false, __iob.flags());
            const unsigned int __nbuf = (numeric_limits<unsigned long long>::digits / 3) + ((numeric_limits<unsigned long long>::digits % 3) != 0) + ((__iob.flags() & ios_base::showbase) != 0) + 1;
            char __nar[__nbuf];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            std::__1::num_put::char_type __o[2 * (__nbuf - 1) - 1];
            std::__1::num_put::char_type *__op;
            std::__1::num_put::char_type *__oe;
            this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }
        template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, double __v) const         {
            char __fmt[8] = {'%', 0};
            const char *__len = "";
            bool __specify_precision = this->__format_float(__fmt + 1, __len, __iob.flags());
            const unsigned int __nbuf = 30;
            char __nar[30];
            char *__nb = __nar;
            int __nc;
            if (__specify_precision)
                __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);
            else
                __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
            unique_ptr<char, void (*)(void *)> __nbh(0, free);
            if (__nc > static_cast<int>(__nbuf - 1)) {
                if (__specify_precision)
                    __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
                else
                    __nc = asprintf_l(&__nb, 0, __fmt, __v);
                if (__nb == 0)
                    __throw_bad_alloc();
                __nbh.reset(__nb);
            }
            char *__ne = __nb + __nc;
            char *__np = this->__identify_padding(__nb, __ne, __iob);
            std::__1::num_put::char_type __o[57];
            std::__1::num_put::char_type *__ob = __o;
            unique_ptr<std::__1::num_put::char_type, void (*)(void *)> __obh(0, free);
            if (__nb != __nar) {
                __ob = (std::__1::num_put::char_type *)malloc(2 * static_cast<size_t>(__nc) * sizeof(std::__1::num_put::char_type));
                if (__ob == 0)
                    __throw_bad_alloc();
                __obh.reset(__ob);
            }
            std::__1::num_put::char_type *__op;
            std::__1::num_put::char_type *__oe;
            this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
            __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
            return __s;
        }
        template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, long double __v) const         {
            char __fmt[8] = {'%', 0};
            const char *__len = "L";
            bool __specify_precision = this->__format_float(__fmt + 1, __len, __iob.flags());
            const unsigned int __nbuf = 30;
            char __nar[30];
            char *__nb = __nar;
            int __nc;
            if (__specify_precision)
                __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);
            else
                __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
            unique_ptr<char, void (*)(void *)> __nbh(0, free);
            if (__nc > static_cast<int>(__nbuf - 1)) {
                if (__specify_precision)
                    __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
                else
                    __nc = asprintf_l(&__nb, 0, __fmt, __v);
                if (__nb == 0)
                    __throw_bad_alloc();
                __nbh.reset(__nb);
            }
            char *__ne = __nb + __nc;
            char *__np = this->__identify_padding(__nb, __ne, __iob);
            std::__1::num_put::char_type __o[57];
            std::__1::num_put::char_type *__ob = __o;
            unique_ptr<std::__1::num_put::char_type, void (*)(void *)> __obh(0, free);
            if (__nb != __nar) {
                __ob = (std::__1::num_put::char_type *)malloc(2 * static_cast<size_t>(__nc) * sizeof(std::__1::num_put::char_type));
                if (__ob == 0)
                    __throw_bad_alloc();
                __obh.reset(__ob);
            }
            std::__1::num_put::char_type *__op;
            std::__1::num_put::char_type *__oe;
            this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
            __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
            return __s;
        }
        template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(std::__1::num_put::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put::char_type __fl, const void *__v) const         {
            char __fmt[6] = "%p";
            const unsigned int __nbuf = 20;
            char __nar[20];
            int __nc = snprintf_l(__nar, sizeof (__nar), 0, __fmt, __v);
            char *__ne = __nar + __nc;
            char *__np = this->__identify_padding(__nar, __ne, __iob);
            std::__1::num_put::char_type __o[37];
            std::__1::num_put::char_type *__op;
            std::__1::num_put::char_type *__oe;
            const ctype<std::__1::num_put::char_type> &__ct = use_facet<ctype<std::__1::num_put::char_type> >(__iob.getloc());
            __ct.widen(__nar, __ne, __o);
            __oe = __o + (__ne - __nar);
            if (__np == __ne)
                __op = __oe;
            else
                __op = __o + (__np - __nar);
            return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
        }
        template<> class __attribute__((visibility("default"))) num_put<char> : public locale::facet, private __num_put<char> {
        public:
            typedef char char_type;
            typedef std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            explicit num_put(size_t __refs) __attribute__((internal_linkage));
            std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, bool __v) const __attribute__((internal_linkage));
            std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, long __v) const __attribute__((internal_linkage));
            std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, long long __v) const __attribute__((internal_linkage));
            std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, unsigned long __v) const __attribute__((internal_linkage));
            std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, unsigned long long __v) const __attribute__((internal_linkage));
            std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, double __v) const __attribute__((internal_linkage));
            std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, long double __v) const __attribute__((internal_linkage));
            std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, const void *__v) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~num_put<char>() __attribute__((internal_linkage));
            virtual std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, bool __v) const;
            virtual std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, long __v) const;
            virtual std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, long long __v) const;
            virtual std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, unsigned long) const;
            virtual std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, unsigned long long) const;
            virtual std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, double __v) const;
            virtual std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, long double __v) const;
            virtual std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, const void *__v) const;
        };
        template<> class __attribute__((visibility("default"))) num_put<wchar_t> : public locale::facet, private __num_put<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            explicit num_put(size_t __refs) __attribute__((internal_linkage));
            std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, bool __v) const __attribute__((internal_linkage));
            std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, long __v) const __attribute__((internal_linkage));
            std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, long long __v) const __attribute__((internal_linkage));
            std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, unsigned long __v) const __attribute__((internal_linkage));
            std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, unsigned long long __v) const __attribute__((internal_linkage));
            std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, double __v) const __attribute__((internal_linkage));
            std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, long double __v) const __attribute__((internal_linkage));
            std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, const void *__v) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~num_put<wchar_t>() __attribute__((internal_linkage));
            virtual std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, bool __v) const;
            virtual std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, long __v) const;
            virtual std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, long long __v) const;
            virtual std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, unsigned long) const;
            virtual std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, unsigned long long) const;
            virtual std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, double __v) const;
            virtual std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, long double __v) const;
            virtual std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::num_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, const void *__v) const;
        };
        template <class _CharT, class _InputIterator> int __get_up_to_n_digits(_InputIterator &__b, _InputIterator __e, ios_base::iostate &__err, const ctype<_CharT> &__ct, int __n) __attribute__((visibility("hidden")))         {
            if (__b == __e) {
                __err |= ios_base::eofbit | ios_base::failbit;
                return 0;
            }
            _CharT __c = *__b;
            if (!__ct.is(ctype_base::digit, __c)) {
                __err |= ios_base::failbit;
                return 0;
            }
            int __r = __ct.narrow(__c, 0) - '0';
            for (++__b , (void)--__n; __b != __e && __n > 0; ++__b , (void)--__n) {
                __c = *__b;
                if (!__ct.is(ctype_base::digit, __c))
                    return __r;
                __r = __r * 10 + __ct.narrow(__c, 0) - '0';
            }
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __r;
        }
        class __attribute__((visibility("default"))) time_base {
        public:
            enum dateorder {
                no_order,
                dmy,
                mdy,
                ymd,
                ydm
            };
        };
        template <class _CharT> class __attribute__((type_visibility("default"))) __time_get_c_storage {
        protected:
            typedef basic_string<_CharT> string_type;
            virtual const std::__1::__time_get_c_storage::string_type *__weeks() const;
            virtual const std::__1::__time_get_c_storage::string_type *__months() const;
            virtual const std::__1::__time_get_c_storage::string_type *__am_pm() const;
            virtual const std::__1::__time_get_c_storage::string_type &__c() const;
            virtual const std::__1::__time_get_c_storage::string_type &__r() const;
            virtual const std::__1::__time_get_c_storage::string_type &__x() const;
            virtual const std::__1::__time_get_c_storage::string_type &__X() const;
            ~__time_get_c_storage<_CharT>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
template<> class __time_get_c_storage<char> {
        protected:
            typedef basic_string<char> string_type;
            virtual const std::__1::__time_get_c_storage<char>::string_type *__weeks() const;
            virtual const std::__1::__time_get_c_storage<char>::string_type *__months() const;
            virtual const std::__1::__time_get_c_storage<char>::string_type *__am_pm() const;
            virtual const std::__1::__time_get_c_storage<char>::string_type &__c() const;
            virtual const std::__1::__time_get_c_storage<char>::string_type &__r() const;
            virtual const std::__1::__time_get_c_storage<char>::string_type &__x() const;
            virtual const std::__1::__time_get_c_storage<char>::string_type &__X() const;
            ~__time_get_c_storage<char>() __attribute__((internal_linkage));
        };
template<> class __time_get_c_storage<wchar_t> {
        protected:
            typedef basic_string<wchar_t> string_type;
            virtual const std::__1::__time_get_c_storage<wchar_t>::string_type *__weeks() const;
            virtual const std::__1::__time_get_c_storage<wchar_t>::string_type *__months() const;
            virtual const std::__1::__time_get_c_storage<wchar_t>::string_type *__am_pm() const;
            virtual const std::__1::__time_get_c_storage<wchar_t>::string_type &__c() const;
            virtual const std::__1::__time_get_c_storage<wchar_t>::string_type &__r() const;
            virtual const std::__1::__time_get_c_storage<wchar_t>::string_type &__x() const;
            virtual const std::__1::__time_get_c_storage<wchar_t>::string_type &__X() const;
            ~__time_get_c_storage<wchar_t>() __attribute__((internal_linkage));
        };
        template <> const std::__1::string *__time_get_c_storage<char>::__weeks() const __attribute__((visibility("default")));
        template <> const std::__1::string *__time_get_c_storage<char>::__months() const __attribute__((visibility("default")));
        template <> const std::__1::string *__time_get_c_storage<char>::__am_pm() const __attribute__((visibility("default")));
        template <> const std::__1::string &__time_get_c_storage<char>::__c() const __attribute__((visibility("default")));
        template <> const std::__1::string &__time_get_c_storage<char>::__r() const __attribute__((visibility("default")));
        template <> const std::__1::string &__time_get_c_storage<char>::__x() const __attribute__((visibility("default")));
        template <> const std::__1::string &__time_get_c_storage<char>::__X() const __attribute__((visibility("default")));
        template <> const std::__1::wstring *__time_get_c_storage<wchar_t>::__weeks() const __attribute__((visibility("default")));
        template <> const std::__1::wstring *__time_get_c_storage<wchar_t>::__months() const __attribute__((visibility("default")));
        template <> const std::__1::wstring *__time_get_c_storage<wchar_t>::__am_pm() const __attribute__((visibility("default")));
        template <> const std::__1::wstring &__time_get_c_storage<wchar_t>::__c() const __attribute__((visibility("default")));
        template <> const std::__1::wstring &__time_get_c_storage<wchar_t>::__r() const __attribute__((visibility("default")));
        template <> const std::__1::wstring &__time_get_c_storage<wchar_t>::__x() const __attribute__((visibility("default")));
        template <> const std::__1::wstring &__time_get_c_storage<wchar_t>::__X() const __attribute__((visibility("default")));
        template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) time_get : public locale::facet, public std::__1::time_base, private __time_get_c_storage<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _InputIterator iter_type;
            typedef time_base::dateorder dateorder;
            typedef basic_string<std::__1::time_get::char_type> string_type;
            explicit time_get<_CharT, _InputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::time_get::dateorder date_order() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_date_order();
            }
            std::__1::time_get::iter_type get_time(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_get_time(__b, __e, __iob, __err, __tm);
            }
            std::__1::time_get::iter_type get_date(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_get_date(__b, __e, __iob, __err, __tm);
            }
            std::__1::time_get::iter_type get_weekday(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_get_weekday(__b, __e, __iob, __err, __tm);
            }
            std::__1::time_get::iter_type get_monthname(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_get_monthname(__b, __e, __iob, __err, __tm);
            }
            std::__1::time_get::iter_type get_year(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_get_year(__b, __e, __iob, __err, __tm);
            }
            std::__1::time_get::iter_type get(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod = 0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
            }
            std::__1::time_get::iter_type get(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const std::__1::time_get::char_type *__fmtb, const std::__1::time_get::char_type *__fmte) const;
            static locale::id id;
        protected:
            ~time_get<_CharT, _InputIterator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual std::__1::time_get::dateorder do_date_order() const;
            virtual std::__1::time_get::iter_type do_get_time(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get::iter_type do_get_date(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get::iter_type do_get_weekday(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get::iter_type do_get_monthname(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get::iter_type do_get_year(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get::iter_type do_get(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const;
        private:
            void __get_white_space(std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_percent(std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_weekdayname(int &__m, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_monthname(int &__m, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_day(int &__d, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_month(int &__m, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_year(int &__y, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_year4(int &__y, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_hour(int &__d, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_12_hour(int &__h, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_am_pm(int &__h, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_minute(int &__m, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_second(int &__s, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_weekday(int &__w, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
            void __get_day_year_num(int &__w, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const;
        };
        locale::id id;
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_weekdayname(int &__w, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            const std::__1::time_get::string_type *__wk = this->__weeks();
            ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk + 14, __ct, __err, false) - __wk;
            if (__i < 14)
                __w = __i % 7;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_monthname(int &__m, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            const std::__1::time_get::string_type *__month = this->__months();
            ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month + 24, __ct, __err, false) - __month;
            if (__i < 24)
                __m = __i % 12;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_day(int &__d, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
                __d = __t;
            else
                __err |= ios_base::failbit;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_month(int &__m, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
            if (!(__err & ios_base::failbit) && __t <= 11)
                __m = __t;
            else
                __err |= ios_base::failbit;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_year(int &__y, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
            if (!(__err & ios_base::failbit)) {
                if (__t < 69)
                    __t += 2000;
                else if (69 <= __t && __t <= 99)
                    __t += 1900;
                __y = __t - 1900;
            }
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_year4(int &__y, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
            if (!(__err & ios_base::failbit))
                __y = __t - 1900;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_hour(int &__h, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && __t <= 23)
                __h = __t;
            else
                __err |= ios_base::failbit;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_12_hour(int &__h, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
                __h = __t;
            else
                __err |= ios_base::failbit;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_minute(int &__m, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && __t <= 59)
                __m = __t;
            else
                __err |= ios_base::failbit;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_second(int &__s, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
            if (!(__err & ios_base::failbit) && __t <= 60)
                __s = __t;
            else
                __err |= ios_base::failbit;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_weekday(int &__w, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
            if (!(__err & ios_base::failbit) && __t <= 6)
                __w = __t;
            else
                __err |= ios_base::failbit;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_day_year_num(int &__d, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
            if (!(__err & ios_base::failbit) && __t <= 365)
                __d = __t;
            else
                __err |= ios_base::failbit;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_white_space(std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                ;
            if (__b == __e)
                __err |= ios_base::eofbit;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_am_pm(int &__h, std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            const std::__1::time_get::string_type *__ap = this->__am_pm();
            if (__ap[0].size() + __ap[1].size() == 0) {
                __err |= ios_base::failbit;
                return;
            }
            ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap + 2, __ct, __err, false) - __ap;
            if (__i == 0 && __h == 12)
                __h = 0;
            else if (__i == 1 && __h < 12)
                __h += 12;
        }
        template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_percent(std::__1::time_get::iter_type &__b, std::__1::time_get::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get::char_type> &__ct) const         {
            if (__b == __e) {
                __err |= ios_base::eofbit | ios_base::failbit;
                return;
            }
            if (__ct.narrow(*__b, 0) != '%')
                __err |= ios_base::failbit;
            else if (++__b == __e)
                __err |= ios_base::eofbit;
        }
        template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::get(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const std::__1::time_get::char_type *__fmtb, const std::__1::time_get::char_type *__fmte) const         {
            const ctype<std::__1::time_get::char_type> &__ct = use_facet<ctype<std::__1::time_get::char_type> >(__iob.getloc());
            __err = ios_base::goodbit;
            while (__fmtb != __fmte && __err == ios_base::goodbit)
                {
                    if (__b == __e) {
                        __err = ios_base::failbit;
                        break;
                    }
                    if (__ct.narrow(*__fmtb, 0) == '%') {
                        if (++__fmtb == __fmte) {
                            __err = ios_base::failbit;
                            break;
                        }
                        char __cmd = __ct.narrow(*__fmtb, 0);
                        char __opt = '\x00';
                        if (__cmd == 'E' || __cmd == '0') {
                            if (++__fmtb == __fmte) {
                                __err = ios_base::failbit;
                                break;
                            }
                            __opt = __cmd;
                            __cmd = __ct.narrow(*__fmtb, 0);
                        }
                        __b = this->do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
                        ++__fmtb;
                    } else if (__ct.is(ctype_base::space, *__fmtb)) {
                        for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
                            ;
                        for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
                            ;
                    } else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb)) {
                        ++__b;
                        ++__fmtb;
                    } else
                        __err = ios_base::failbit;
                }
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }
        template <class _CharT, class _InputIterator> typename time_get<_CharT, _InputIterator>::dateorder time_get<_CharT, _InputIterator>::do_date_order() const         {
            return mdy;
        }
        template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::do_get_time(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const std::__1::time_get::char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
            return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof (__fmt) / sizeof (__fmt[0]));
        }
        template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::do_get_date(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const std::__1::time_get::string_type &__fmt = this->__x();
            return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
        }
        template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::do_get_weekday(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const ctype<std::__1::time_get::char_type> &__ct = use_facet<ctype<std::__1::time_get::char_type> >(__iob.getloc());
            this->__get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
            return __b;
        }
        template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::do_get_monthname(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const ctype<std::__1::time_get::char_type> &__ct = use_facet<ctype<std::__1::time_get::char_type> >(__iob.getloc());
            this->__get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
            return __b;
        }
        template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::do_get_year(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const         {
            const ctype<std::__1::time_get::char_type> &__ct = use_facet<ctype<std::__1::time_get::char_type> >(__iob.getloc());
            this->__get_year(__tm->tm_year, __b, __e, __err, __ct);
            return __b;
        }
        template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::do_get(std::__1::time_get::iter_type __b, std::__1::time_get::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char) const         {
            __err = ios_base::goodbit;
            const ctype<std::__1::time_get::char_type> &__ct = use_facet<ctype<std::__1::time_get::char_type> >(__iob.getloc());
            switch (__fmt) {
              case 'a':
              case 'A':
                this->__get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
                break;
              case 'b':
              case 'B':
              case 'h':
                this->__get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
                break;
              case 'c':
                {
                    const std::__1::time_get::string_type &__fm = this->__c();
                    __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
                }
                break;
              case 'd':
              case 'e':
                this->__get_day(__tm->tm_mday, __b, __e, __err, __ct);
                break;
              case 'D':
                {
                    const std::__1::time_get::char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'F':
                {
                    const std::__1::time_get::char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'H':
                this->__get_hour(__tm->tm_hour, __b, __e, __err, __ct);
                break;
              case 'I':
                this->__get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
                break;
              case 'j':
                this->__get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
                break;
              case 'm':
                this->__get_month(__tm->tm_mon, __b, __e, __err, __ct);
                break;
              case 'M':
                this->__get_minute(__tm->tm_min, __b, __e, __err, __ct);
                break;
              case 'n':
              case 't':
                this->__get_white_space(__b, __e, __err, __ct);
                break;
              case 'p':
                this->__get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
                break;
              case 'r':
                {
                    const std::__1::time_get::char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'R':
                {
                    const std::__1::time_get::char_type __fm[] = {'%', 'H', ':', '%', 'M'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'S':
                this->__get_second(__tm->tm_sec, __b, __e, __err, __ct);
                break;
              case 'T':
                {
                    const std::__1::time_get::char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
                    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof (__fm) / sizeof (__fm[0]));
                }
                break;
              case 'w':
                this->__get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
                break;
              case 'x':
                return this->do_get_date(__b, __e, __iob, __err, __tm);
              case 'X':
                {
                    const std::__1::time_get::string_type &__fm = this->__X();
                    __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
                }
                break;
              case 'y':
                this->__get_year(__tm->tm_year, __b, __e, __err, __ct);
                break;
              case 'Y':
                this->__get_year4(__tm->tm_year, __b, __e, __err, __ct);
                break;
              case '%':
                this->__get_percent(__b, __e, __err, __ct);
                break;
              default:
                __err |= ios_base::failbit;
            }
            return __b;
        }
        template<> class __attribute__((visibility("default"))) time_get<char> : public locale::facet, public std::__1::time_base, private __time_get_c_storage<char> {
        public:
            typedef char char_type;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef time_base::dateorder dateorder;
            typedef basic_string<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> string_type;
            explicit time_get(size_t __refs) __attribute__((internal_linkage));
            std::__1::time_get::dateorder date_order() const __attribute__((internal_linkage));
            std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get_time(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get_date(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get_weekday(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get_monthname(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get_year(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const __attribute__((internal_linkage));
            std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type *__fmtb, const std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type *__fmte) const;
            static locale::id id;
        protected:
            ~time_get<char>() __attribute__((internal_linkage));
            virtual std::__1::time_get::dateorder do_date_order() const;
            virtual std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get_time(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get_date(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get_weekday(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get_monthname(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get_year(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const;
        private:
            void __get_white_space(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_percent(std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_weekdayname(int &__m, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_monthname(int &__m, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_day(int &__d, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_month(int &__m, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_year(int &__y, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_year4(int &__y, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_hour(int &__d, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_12_hour(int &__h, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_am_pm(int &__h, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_minute(int &__m, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_second(int &__s, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_weekday(int &__w, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
            void __get_day_year_num(int &__w, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct) const;
        };
        template<> class __attribute__((visibility("default"))) time_get<wchar_t> : public locale::facet, public std::__1::time_base, private __time_get_c_storage<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef time_base::dateorder dateorder;
            typedef basic_string<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> string_type;
            explicit time_get(size_t __refs) __attribute__((internal_linkage));
            std::__1::time_get::dateorder date_order() const __attribute__((internal_linkage));
            std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get_time(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get_date(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get_weekday(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get_monthname(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get_year(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const __attribute__((internal_linkage));
            std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const __attribute__((internal_linkage));
            std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, const std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type *__fmtb, const std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type *__fmte) const;
            static locale::id id;
        protected:
            ~time_get<wchar_t>() __attribute__((internal_linkage));
            virtual std::__1::time_get::dateorder do_date_order() const;
            virtual std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get_time(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get_date(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get_weekday(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get_monthname(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get_year(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm) const;
            virtual std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, std::__1::ios_base &__iob, ios_base::iostate &__err, tm *__tm, char __fmt, char __mod) const;
        private:
            void __get_white_space(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_percent(std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_weekdayname(int &__m, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_monthname(int &__m, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_day(int &__d, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_month(int &__m, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_year(int &__y, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_year4(int &__y, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_hour(int &__d, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_12_hour(int &__h, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_am_pm(int &__h, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_minute(int &__m, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_second(int &__s, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_weekday(int &__w, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
            void __get_day_year_num(int &__w, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, ios_base::iostate &__err, const ctype<std::__1::time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct) const;
        };
        class __attribute__((visibility("default"))) __time_get {
        protected:
            locale_t __loc_;
            __time_get(const char *__nm);
            __time_get(const std::__1::string &__nm);
            ~__time_get();
        };
        template <class _CharT> class __attribute__((type_visibility("default"))) __time_get_storage : public std::__1::__time_get {
        protected:
            typedef basic_string<_CharT> string_type;
            std::__1::__time_get_storage::string_type __weeks_[14];
            std::__1::__time_get_storage::string_type __months_[24];
            std::__1::__time_get_storage::string_type __am_pm_[2];
            std::__1::__time_get_storage::string_type __c_;
            std::__1::__time_get_storage::string_type __r_;
            std::__1::__time_get_storage::string_type __x_;
            std::__1::__time_get_storage::string_type __X_;
            explicit __time_get_storage<_CharT>(const char *__nm);
            explicit __time_get_storage<_CharT>(const std::__1::string &__nm);
            ~__time_get_storage<_CharT>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            time_base::dateorder __do_date_order() const;
        private:
            void init(const ctype<_CharT> &);
            std::__1::__time_get_storage::string_type __analyze(char __fmt, const ctype<_CharT> &);
        };
template<> class __time_get_storage<char> : public std::__1::__time_get {
        protected:
            typedef basic_string<char> string_type;
            std::__1::__time_get_storage<char>::string_type __weeks_[14];
            std::__1::__time_get_storage<char>::string_type __months_[24];
            std::__1::__time_get_storage<char>::string_type __am_pm_[2];
            std::__1::__time_get_storage<char>::string_type __c_;
            std::__1::__time_get_storage<char>::string_type __r_;
            std::__1::__time_get_storage<char>::string_type __x_;
            std::__1::__time_get_storage<char>::string_type __X_;
            explicit __time_get_storage(const char *__nm);
            explicit __time_get_storage(const std::__1::string &__nm);
            ~__time_get_storage<char>() __attribute__((internal_linkage));
            time_base::dateorder __do_date_order() const;
        private:
            void init(const ctype<char> &);
            std::__1::__time_get_storage<char>::string_type __analyze(char __fmt, const ctype<char> &);
        };
template<> class __time_get_storage<wchar_t> : public std::__1::__time_get {
        protected:
            typedef basic_string<wchar_t> string_type;
            std::__1::__time_get_storage<wchar_t>::string_type __weeks_[14];
            std::__1::__time_get_storage<wchar_t>::string_type __months_[24];
            std::__1::__time_get_storage<wchar_t>::string_type __am_pm_[2];
            std::__1::__time_get_storage<wchar_t>::string_type __c_;
            std::__1::__time_get_storage<wchar_t>::string_type __r_;
            std::__1::__time_get_storage<wchar_t>::string_type __x_;
            std::__1::__time_get_storage<wchar_t>::string_type __X_;
            explicit __time_get_storage(const char *__nm);
            explicit __time_get_storage(const std::__1::string &__nm);
            ~__time_get_storage<wchar_t>() __attribute__((internal_linkage));
            time_base::dateorder __do_date_order() const;
        private:
            void init(const ctype<wchar_t> &);
            std::__1::__time_get_storage<wchar_t>::string_type __analyze(char __fmt, const ctype<wchar_t> &);
        };
        template <> time_base::dateorder __time_get_storage<char>::__do_date_order() const __attribute__((visibility("default")));
        template <> explicit __time_get_storage<char>::__time_get_storage(const char *) __attribute__((visibility("default")));
        template <> explicit __time_get_storage<char>::__time_get_storage(const std::__1::string &) __attribute__((visibility("default")));
        template <> void __time_get_storage<char>::init(const ctype<char> &) __attribute__((visibility("default")));
        template <> __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char> &) __attribute__((visibility("default")));
        template <> time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const __attribute__((visibility("default")));
        template <> explicit __time_get_storage<wchar_t>::__time_get_storage(const char *) __attribute__((visibility("default")));
        template <> explicit __time_get_storage<wchar_t>::__time_get_storage(const std::__1::string &) __attribute__((visibility("default")));
        template <> void __time_get_storage<wchar_t>::init(const ctype<wchar_t> &) __attribute__((visibility("default")));
        template <> __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t> &) __attribute__((visibility("default")));
        template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) time_get_byname : public time_get<_CharT, _InputIterator>, private __time_get_storage<_CharT> {
        public:
            typedef time_base::dateorder dateorder;
            typedef _InputIterator iter_type;
            typedef _CharT char_type;
            typedef basic_string<std::__1::time_get_byname::char_type> string_type;
            explicit time_get_byname<_CharT, _InputIterator>(const char *__nm, size_t __refs = 0) : time_get<_CharT, _InputIterator>(__refs), __time_get_storage<_CharT>(__nm) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit time_get_byname<_CharT, _InputIterator>(const std::__1::string &__nm, size_t __refs = 0) : time_get<_CharT, _InputIterator>(__refs), __time_get_storage<_CharT>(__nm) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        protected:
            ~time_get_byname<_CharT, _InputIterator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual std::__1::time_get_byname::dateorder do_date_order() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__do_date_order();
            }
        private:
            virtual const std::__1::time_get_byname::string_type *__weeks() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__weeks_;
            }
            virtual const std::__1::time_get_byname::string_type *__months() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__months_;
            }
            virtual const std::__1::time_get_byname::string_type *__am_pm() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__am_pm_;
            }
            virtual const std::__1::time_get_byname::string_type &__c() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__c_;
            }
            virtual const std::__1::time_get_byname::string_type &__r() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__r_;
            }
            virtual const std::__1::time_get_byname::string_type &__x() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__x_;
            }
            virtual const std::__1::time_get_byname::string_type &__X() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__X_;
            }
        };
        template<> class __attribute__((visibility("default"))) time_get_byname<char> : public time_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >, private __time_get_storage<char> {
        public:
            typedef time_base::dateorder dateorder;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef char char_type;
            typedef basic_string<std::__1::time_get_byname<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> string_type;
            explicit time_get_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit time_get_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~time_get_byname<char>() __attribute__((internal_linkage));
            virtual std::__1::time_get_byname::dateorder do_date_order() const __attribute__((internal_linkage));
        private:
            virtual const std::__1::time_get_byname<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::string_type *__weeks() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::string_type *__months() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::string_type *__am_pm() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::string_type &__c() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::string_type &__r() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::string_type &__x() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::string_type &__X() const __attribute__((internal_linkage));
        };
        template<> class __attribute__((visibility("default"))) time_get_byname<wchar_t> : public time_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >, private __time_get_storage<wchar_t> {
        public:
            typedef time_base::dateorder dateorder;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef wchar_t char_type;
            typedef basic_string<std::__1::time_get_byname<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> string_type;
            explicit time_get_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit time_get_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~time_get_byname<wchar_t>() __attribute__((internal_linkage));
            virtual std::__1::time_get_byname::dateorder do_date_order() const __attribute__((internal_linkage));
        private:
            virtual const std::__1::time_get_byname<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type *__weeks() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type *__months() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type *__am_pm() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type &__c() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type &__r() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type &__x() const __attribute__((internal_linkage));
            virtual const std::__1::time_get_byname<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type &__X() const __attribute__((internal_linkage));
        };
        class __attribute__((visibility("default"))) __time_put {
            locale_t __loc_;
        protected:
            __time_put() : __loc_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            __time_put(const char *__nm);
            __time_put(const std::__1::string &__nm);
            ~__time_put();
            void __do_put(char *__nb, char *&__ne, const tm *__tm, char __fmt, char __mod) const;
            void __do_put(wchar_t *__wb, wchar_t *&__we, const tm *__tm, char __fmt, char __mod) const;
        };
        template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) time_put : public locale::facet, private std::__1::__time_put {
        public:
            typedef _CharT char_type;
            typedef _OutputIterator iter_type;
            explicit time_put<_CharT, _OutputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::time_put::iter_type put(std::__1::time_put::iter_type __s, std::__1::ios_base &__iob, std::__1::time_put::char_type __fl, const tm *__tm, const std::__1::time_put::char_type *__pb, const std::__1::time_put::char_type *__pe) const;
            std::__1::time_put::iter_type put(std::__1::time_put::iter_type __s, std::__1::ios_base &__iob, std::__1::time_put::char_type __fl, const tm *__tm, char __fmt, char __mod = 0) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_put(__s, __iob, __fl, __tm, __fmt, __mod);
            }
            static locale::id id;
        protected:
            ~time_put<_CharT, _OutputIterator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual std::__1::time_put::iter_type do_put(std::__1::time_put::iter_type __s, std::__1::ios_base &, std::__1::time_put::char_type, const tm *__tm, char __fmt, char __mod) const;
            explicit time_put<_CharT, _OutputIterator>(const char *__nm, size_t __refs) : locale::facet(__refs), std::__1::__time_put(__nm) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit time_put<_CharT, _OutputIterator>(const std::__1::string &__nm, size_t __refs) : locale::facet(__refs), std::__1::__time_put(__nm) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
        locale::id id;
        template <class _CharT, class _OutputIterator> _OutputIterator time_put<_CharT, _OutputIterator>::put(std::__1::time_put::iter_type __s, std::__1::ios_base &__iob, std::__1::time_put::char_type __fl, const tm *__tm, const std::__1::time_put::char_type *__pb, const std::__1::time_put::char_type *__pe) const         {
            const ctype<std::__1::time_put::char_type> &__ct = use_facet<ctype<std::__1::time_put::char_type> >(__iob.getloc());
            for (; __pb != __pe; ++__pb) {
                if (__ct.narrow(*__pb, 0) == '%') {
                    if (++__pb == __pe) {
                        *__s++ = __pb[-1];
                        break;
                    }
                    char __mod = 0;
                    char __fmt = __ct.narrow(*__pb, 0);
                    if (__fmt == 'E' || __fmt == 'O') {
                        if (++__pb == __pe) {
                            *__s++ = __pb[-2];
                            *__s++ = __pb[-1];
                            break;
                        }
                        __mod = __fmt;
                        __fmt = __ct.narrow(*__pb, 0);
                    }
                    __s = this->do_put(__s, __iob, __fl, __tm, __fmt, __mod);
                } else
                    *__s++ = *__pb;
            }
            return __s;
        }
        template <class _CharT, class _OutputIterator> _OutputIterator time_put<_CharT, _OutputIterator>::do_put(std::__1::time_put::iter_type __s, std::__1::ios_base &, std::__1::time_put::char_type, const tm *__tm, char __fmt, char __mod) const         {
            std::__1::time_put::char_type __nar[100];
            std::__1::time_put::char_type *__nb = __nar;
            std::__1::time_put::char_type *__ne = __nb + 100;
            __do_put(__nb, __ne, __tm, __fmt, __mod);
            return std::__1::copy(__nb, __ne, __s);
        }
        template<> class __attribute__((visibility("default"))) time_put<char> : public locale::facet, private std::__1::__time_put {
        public:
            typedef char char_type;
            typedef std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            explicit time_put(size_t __refs) __attribute__((internal_linkage));
            std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, const tm *__tm, const std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type *__pb, const std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type *__pe) const;
            std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, const tm *__tm, char __fmt, char __mod) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~time_put<char>() __attribute__((internal_linkage));
            virtual std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, std::__1::ios_base &, std::__1::time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type, const tm *__tm, char __fmt, char __mod) const;
            explicit time_put(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit time_put(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        };
        template<> class __attribute__((visibility("default"))) time_put<wchar_t> : public locale::facet, private std::__1::__time_put {
        public:
            typedef wchar_t char_type;
            typedef std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            explicit time_put(size_t __refs) __attribute__((internal_linkage));
            std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, const tm *__tm, const std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type *__pb, const std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type *__pe) const;
            std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &__iob, std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, const tm *__tm, char __fmt, char __mod) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~time_put<wchar_t>() __attribute__((internal_linkage));
            virtual std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, std::__1::ios_base &, std::__1::time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type, const tm *__tm, char __fmt, char __mod) const;
            explicit time_put(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit time_put(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        };
        template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) time_put_byname : public time_put<_CharT, _OutputIterator> {
        public:
            explicit time_put_byname<_CharT, _OutputIterator>(const char *__nm, size_t __refs = 0) : time_put<_CharT, _OutputIterator>(__nm, __refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit time_put_byname<_CharT, _OutputIterator>(const std::__1::string &__nm, size_t __refs = 0) : time_put<_CharT, _OutputIterator>(__nm, __refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        protected:
            ~time_put_byname<_CharT, _OutputIterator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
        template<> class __attribute__((visibility("default"))) time_put_byname<char> : public time_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > > {
        public:
            explicit time_put_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit time_put_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~time_put_byname<char>() __attribute__((internal_linkage));
        };
        template<> class __attribute__((visibility("default"))) time_put_byname<wchar_t> : public time_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > > {
        public:
            explicit time_put_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit time_put_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~time_put_byname<wchar_t>() __attribute__((internal_linkage));
        };
        class __attribute__((visibility("default"))) money_base {
        public:
            enum part {
                none,
                space,
                symbol,
                sign,
                value
            };
            struct pattern {
                char field[4];
            };
            money_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
        template <class _CharT, bool _International = false> class __attribute__((type_visibility("default"))) moneypunct : public locale::facet, public std::__1::money_base {
        public:
            typedef _CharT char_type;
            typedef basic_string<std::__1::moneypunct::char_type> string_type;
            explicit moneypunct<_CharT, _International>(size_t __refs = 0) : locale::facet(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::moneypunct::char_type decimal_point() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_decimal_point();
            }
            std::__1::moneypunct::char_type thousands_sep() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_thousands_sep();
            }
            std::__1::string grouping() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_grouping();
            }
            std::__1::moneypunct::string_type curr_symbol() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_curr_symbol();
            }
            std::__1::moneypunct::string_type positive_sign() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_positive_sign();
            }
            std::__1::moneypunct::string_type negative_sign() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_negative_sign();
            }
            int frac_digits() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_frac_digits();
            }
            std::__1::money_base::pattern pos_format() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_pos_format();
            }
            std::__1::money_base::pattern neg_format() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_neg_format();
            }
            static locale::id id;
            static const bool intl = _International;
        protected:
            ~moneypunct<_CharT, _International>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual std::__1::moneypunct::char_type do_decimal_point() const             {
                return numeric_limits<char_type>::max();
            }
            virtual std::__1::moneypunct::char_type do_thousands_sep() const             {
                return numeric_limits<char_type>::max();
            }
            virtual std::__1::string do_grouping() const             {
                return std::__1::string();
            }
            virtual std::__1::moneypunct::string_type do_curr_symbol() const             {
                return std::__1::moneypunct::string_type();
            }
            virtual std::__1::moneypunct::string_type do_positive_sign() const             {
                return std::__1::moneypunct::string_type();
            }
            virtual std::__1::moneypunct::string_type do_negative_sign() const             {
                return std::__1::moneypunct::string_type(1, '-');
            }
            virtual int do_frac_digits() const             {
                return 0;
            }
            virtual std::__1::money_base::pattern do_pos_format() const             {
                std::__1::money_base::pattern __p = {{symbol, sign, none, value}};
                return __p;
            }
            virtual std::__1::money_base::pattern do_neg_format() const             {
                std::__1::money_base::pattern __p = {{symbol, sign, none, value}};
                return __p;
            }
        };
        locale::id id;
        const bool intl;
        template<> class __attribute__((visibility("default"))) moneypunct<char, false> : public locale::facet, public std::__1::money_base {
        public:
            typedef char char_type;
            typedef basic_string<std::__1::moneypunct<char, false>::char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((internal_linkage));
            std::__1::moneypunct<char, false>::char_type decimal_point() const __attribute__((internal_linkage));
            std::__1::moneypunct<char, false>::char_type thousands_sep() const __attribute__((internal_linkage));
            std::__1::string grouping() const __attribute__((internal_linkage));
            std::__1::moneypunct<char, false>::string_type curr_symbol() const __attribute__((internal_linkage));
            std::__1::moneypunct<char, false>::string_type positive_sign() const __attribute__((internal_linkage));
            std::__1::moneypunct<char, false>::string_type negative_sign() const __attribute__((internal_linkage));
            int frac_digits() const __attribute__((internal_linkage));
            std::__1::money_base::pattern pos_format() const __attribute__((internal_linkage));
            std::__1::money_base::pattern neg_format() const __attribute__((internal_linkage));
            static locale::id id;
            static const bool intl = false;
        protected:
            ~moneypunct<char, false>() __attribute__((internal_linkage));
            virtual std::__1::moneypunct<char, false>::char_type do_decimal_point() const;
            virtual std::__1::moneypunct<char, false>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::moneypunct<char, false>::string_type do_curr_symbol() const;
            virtual std::__1::moneypunct<char, false>::string_type do_positive_sign() const;
            virtual std::__1::moneypunct<char, false>::string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        };
        template<> class __attribute__((visibility("default"))) moneypunct<char, true> : public locale::facet, public std::__1::money_base {
        public:
            typedef char char_type;
            typedef basic_string<std::__1::moneypunct<char, true>::char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((internal_linkage));
            std::__1::moneypunct<char, true>::char_type decimal_point() const __attribute__((internal_linkage));
            std::__1::moneypunct<char, true>::char_type thousands_sep() const __attribute__((internal_linkage));
            std::__1::string grouping() const __attribute__((internal_linkage));
            std::__1::moneypunct<char, true>::string_type curr_symbol() const __attribute__((internal_linkage));
            std::__1::moneypunct<char, true>::string_type positive_sign() const __attribute__((internal_linkage));
            std::__1::moneypunct<char, true>::string_type negative_sign() const __attribute__((internal_linkage));
            int frac_digits() const __attribute__((internal_linkage));
            std::__1::money_base::pattern pos_format() const __attribute__((internal_linkage));
            std::__1::money_base::pattern neg_format() const __attribute__((internal_linkage));
            static locale::id id;
            static const bool intl = true;
        protected:
            ~moneypunct<char, true>() __attribute__((internal_linkage));
            virtual std::__1::moneypunct<char, true>::char_type do_decimal_point() const;
            virtual std::__1::moneypunct<char, true>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::moneypunct<char, true>::string_type do_curr_symbol() const;
            virtual std::__1::moneypunct<char, true>::string_type do_positive_sign() const;
            virtual std::__1::moneypunct<char, true>::string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        };
        template<> class __attribute__((visibility("default"))) moneypunct<wchar_t, false> : public locale::facet, public std::__1::money_base {
        public:
            typedef wchar_t char_type;
            typedef basic_string<std::__1::moneypunct<wchar_t, false>::char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, false>::char_type decimal_point() const __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, false>::char_type thousands_sep() const __attribute__((internal_linkage));
            std::__1::string grouping() const __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, false>::string_type curr_symbol() const __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, false>::string_type positive_sign() const __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, false>::string_type negative_sign() const __attribute__((internal_linkage));
            int frac_digits() const __attribute__((internal_linkage));
            std::__1::money_base::pattern pos_format() const __attribute__((internal_linkage));
            std::__1::money_base::pattern neg_format() const __attribute__((internal_linkage));
            static locale::id id;
            static const bool intl = false;
        protected:
            ~moneypunct<wchar_t, false>() __attribute__((internal_linkage));
            virtual std::__1::moneypunct<wchar_t, false>::char_type do_decimal_point() const;
            virtual std::__1::moneypunct<wchar_t, false>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::moneypunct<wchar_t, false>::string_type do_curr_symbol() const;
            virtual std::__1::moneypunct<wchar_t, false>::string_type do_positive_sign() const;
            virtual std::__1::moneypunct<wchar_t, false>::string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        };
        template<> class __attribute__((visibility("default"))) moneypunct<wchar_t, true> : public locale::facet, public std::__1::money_base {
        public:
            typedef wchar_t char_type;
            typedef basic_string<std::__1::moneypunct<wchar_t, true>::char_type> string_type;
            explicit moneypunct(size_t __refs) __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, true>::char_type decimal_point() const __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, true>::char_type thousands_sep() const __attribute__((internal_linkage));
            std::__1::string grouping() const __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, true>::string_type curr_symbol() const __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, true>::string_type positive_sign() const __attribute__((internal_linkage));
            std::__1::moneypunct<wchar_t, true>::string_type negative_sign() const __attribute__((internal_linkage));
            int frac_digits() const __attribute__((internal_linkage));
            std::__1::money_base::pattern pos_format() const __attribute__((internal_linkage));
            std::__1::money_base::pattern neg_format() const __attribute__((internal_linkage));
            static locale::id id;
            static const bool intl = true;
        protected:
            ~moneypunct<wchar_t, true>() __attribute__((internal_linkage));
            virtual std::__1::moneypunct<wchar_t, true>::char_type do_decimal_point() const;
            virtual std::__1::moneypunct<wchar_t, true>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::moneypunct<wchar_t, true>::string_type do_curr_symbol() const;
            virtual std::__1::moneypunct<wchar_t, true>::string_type do_positive_sign() const;
            virtual std::__1::moneypunct<wchar_t, true>::string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::money_base::pattern do_pos_format() const;
            virtual std::__1::money_base::pattern do_neg_format() const;
        };
        template <class _CharT, bool _International = false> class __attribute__((type_visibility("default"))) moneypunct_byname : public moneypunct<_CharT, _International> {
        public:
            typedef money_base::pattern pattern;
            typedef _CharT char_type;
            typedef basic_string<std::__1::moneypunct_byname::char_type> string_type;
            explicit moneypunct_byname<_CharT, _International>(const char *__nm, size_t __refs = 0) : moneypunct<_CharT, _International>(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->init(__nm);
            }
            explicit moneypunct_byname<_CharT, _International>(const std::__1::string &__nm, size_t __refs = 0) : moneypunct<_CharT, _International>(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->init(__nm.c_str());
            }
        protected:
            ~moneypunct_byname<_CharT, _International>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual std::__1::moneypunct_byname::char_type do_decimal_point() const             {
                return this->__decimal_point_;
            }
            virtual std::__1::moneypunct_byname::char_type do_thousands_sep() const             {
                return this->__thousands_sep_;
            }
            virtual std::__1::string do_grouping() const             {
                return this->__grouping_;
            }
            virtual std::__1::moneypunct_byname::string_type do_curr_symbol() const             {
                return this->__curr_symbol_;
            }
            virtual std::__1::moneypunct_byname::string_type do_positive_sign() const             {
                return this->__positive_sign_;
            }
            virtual std::__1::moneypunct_byname::string_type do_negative_sign() const             {
                return this->__negative_sign_;
            }
            virtual int do_frac_digits() const             {
                return this->__frac_digits_;
            }
            virtual std::__1::moneypunct_byname::pattern do_pos_format() const             {
                return this->__pos_format_;
            }
            virtual std::__1::moneypunct_byname::pattern do_neg_format() const             {
                return this->__neg_format_;
            }
        private:
            std::__1::moneypunct_byname::char_type __decimal_point_;
            std::__1::moneypunct_byname::char_type __thousands_sep_;
            std::__1::string __grouping_;
            std::__1::moneypunct_byname::string_type __curr_symbol_;
            std::__1::moneypunct_byname::string_type __positive_sign_;
            std::__1::moneypunct_byname::string_type __negative_sign_;
            int __frac_digits_;
            std::__1::moneypunct_byname::pattern __pos_format_;
            std::__1::moneypunct_byname::pattern __neg_format_;
            void init(const char *);
        };
        template <> void moneypunct_byname<char, false>::init(const char *) __attribute__((visibility("default")));
        template <> void moneypunct_byname<char, true>::init(const char *) __attribute__((visibility("default")));
        template <> void moneypunct_byname<wchar_t, false>::init(const char *) __attribute__((visibility("default")));
        template <> void moneypunct_byname<wchar_t, true>::init(const char *) __attribute__((visibility("default")));
        template<> class __attribute__((visibility("default"))) moneypunct_byname<char, false> : public moneypunct<char, false> {
        public:
            typedef money_base::pattern pattern;
            typedef char char_type;
            typedef basic_string<std::__1::moneypunct_byname<char, false>::char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit moneypunct_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~moneypunct_byname<char, false>() __attribute__((internal_linkage));
            virtual std::__1::moneypunct_byname<char, false>::char_type do_decimal_point() const;
            virtual std::__1::moneypunct_byname<char, false>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::moneypunct_byname<char, false>::string_type do_curr_symbol() const;
            virtual std::__1::moneypunct_byname<char, false>::string_type do_positive_sign() const;
            virtual std::__1::moneypunct_byname<char, false>::string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::moneypunct_byname::pattern do_pos_format() const;
            virtual std::__1::moneypunct_byname::pattern do_neg_format() const;
        private:
            std::__1::moneypunct_byname<char, false>::char_type __decimal_point_;
            std::__1::moneypunct_byname<char, false>::char_type __thousands_sep_;
            std::__1::string __grouping_;
            std::__1::moneypunct_byname<char, false>::string_type __curr_symbol_;
            std::__1::moneypunct_byname<char, false>::string_type __positive_sign_;
            std::__1::moneypunct_byname<char, false>::string_type __negative_sign_;
            int __frac_digits_;
            std::__1::moneypunct_byname::pattern __pos_format_;
            std::__1::moneypunct_byname::pattern __neg_format_;
            void init(const char *);
        };
        template<> class __attribute__((visibility("default"))) moneypunct_byname<char, true> : public moneypunct<char, true> {
        public:
            typedef money_base::pattern pattern;
            typedef char char_type;
            typedef basic_string<std::__1::moneypunct_byname<char, true>::char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit moneypunct_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~moneypunct_byname<char, true>() __attribute__((internal_linkage));
            virtual std::__1::moneypunct_byname<char, true>::char_type do_decimal_point() const;
            virtual std::__1::moneypunct_byname<char, true>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::moneypunct_byname<char, true>::string_type do_curr_symbol() const;
            virtual std::__1::moneypunct_byname<char, true>::string_type do_positive_sign() const;
            virtual std::__1::moneypunct_byname<char, true>::string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::moneypunct_byname::pattern do_pos_format() const;
            virtual std::__1::moneypunct_byname::pattern do_neg_format() const;
        private:
            std::__1::moneypunct_byname<char, true>::char_type __decimal_point_;
            std::__1::moneypunct_byname<char, true>::char_type __thousands_sep_;
            std::__1::string __grouping_;
            std::__1::moneypunct_byname<char, true>::string_type __curr_symbol_;
            std::__1::moneypunct_byname<char, true>::string_type __positive_sign_;
            std::__1::moneypunct_byname<char, true>::string_type __negative_sign_;
            int __frac_digits_;
            std::__1::moneypunct_byname::pattern __pos_format_;
            std::__1::moneypunct_byname::pattern __neg_format_;
            void init(const char *);
        };
        template<> class __attribute__((visibility("default"))) moneypunct_byname<wchar_t, false> : public moneypunct<wchar_t, false> {
        public:
            typedef money_base::pattern pattern;
            typedef wchar_t char_type;
            typedef basic_string<std::__1::moneypunct_byname<wchar_t, false>::char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit moneypunct_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~moneypunct_byname<wchar_t, false>() __attribute__((internal_linkage));
            virtual std::__1::moneypunct_byname<wchar_t, false>::char_type do_decimal_point() const;
            virtual std::__1::moneypunct_byname<wchar_t, false>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::moneypunct_byname<wchar_t, false>::string_type do_curr_symbol() const;
            virtual std::__1::moneypunct_byname<wchar_t, false>::string_type do_positive_sign() const;
            virtual std::__1::moneypunct_byname<wchar_t, false>::string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::moneypunct_byname::pattern do_pos_format() const;
            virtual std::__1::moneypunct_byname::pattern do_neg_format() const;
        private:
            std::__1::moneypunct_byname<wchar_t, false>::char_type __decimal_point_;
            std::__1::moneypunct_byname<wchar_t, false>::char_type __thousands_sep_;
            std::__1::string __grouping_;
            std::__1::moneypunct_byname<wchar_t, false>::string_type __curr_symbol_;
            std::__1::moneypunct_byname<wchar_t, false>::string_type __positive_sign_;
            std::__1::moneypunct_byname<wchar_t, false>::string_type __negative_sign_;
            int __frac_digits_;
            std::__1::moneypunct_byname::pattern __pos_format_;
            std::__1::moneypunct_byname::pattern __neg_format_;
            void init(const char *);
        };
        template<> class __attribute__((visibility("default"))) moneypunct_byname<wchar_t, true> : public moneypunct<wchar_t, true> {
        public:
            typedef money_base::pattern pattern;
            typedef wchar_t char_type;
            typedef basic_string<std::__1::moneypunct_byname<wchar_t, true>::char_type> string_type;
            explicit moneypunct_byname(const char *__nm, size_t __refs) __attribute__((internal_linkage));
            explicit moneypunct_byname(const std::__1::string &__nm, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~moneypunct_byname<wchar_t, true>() __attribute__((internal_linkage));
            virtual std::__1::moneypunct_byname<wchar_t, true>::char_type do_decimal_point() const;
            virtual std::__1::moneypunct_byname<wchar_t, true>::char_type do_thousands_sep() const;
            virtual std::__1::string do_grouping() const;
            virtual std::__1::moneypunct_byname<wchar_t, true>::string_type do_curr_symbol() const;
            virtual std::__1::moneypunct_byname<wchar_t, true>::string_type do_positive_sign() const;
            virtual std::__1::moneypunct_byname<wchar_t, true>::string_type do_negative_sign() const;
            virtual int do_frac_digits() const;
            virtual std::__1::moneypunct_byname::pattern do_pos_format() const;
            virtual std::__1::moneypunct_byname::pattern do_neg_format() const;
        private:
            std::__1::moneypunct_byname<wchar_t, true>::char_type __decimal_point_;
            std::__1::moneypunct_byname<wchar_t, true>::char_type __thousands_sep_;
            std::__1::string __grouping_;
            std::__1::moneypunct_byname<wchar_t, true>::string_type __curr_symbol_;
            std::__1::moneypunct_byname<wchar_t, true>::string_type __positive_sign_;
            std::__1::moneypunct_byname<wchar_t, true>::string_type __negative_sign_;
            int __frac_digits_;
            std::__1::moneypunct_byname::pattern __pos_format_;
            std::__1::moneypunct_byname::pattern __neg_format_;
            void init(const char *);
        };
        template <class _CharT> class __money_get {
        protected:
            typedef _CharT char_type;
            typedef basic_string<std::__1::__money_get::char_type> string_type;
            __money_get<_CharT>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            static void __gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, std::__1::__money_get::char_type &__dp, std::__1::__money_get::char_type &__ts, std::__1::string &__grp, std::__1::__money_get::string_type &__sym, std::__1::__money_get::string_type &__psn, std::__1::__money_get::string_type &__nsn, int &__fd);
        };
        template <class _CharT> void __money_get<_CharT>::__gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, std::__1::__money_get::char_type &__dp, std::__1::__money_get::char_type &__ts, std::__1::string &__grp, std::__1::__money_get::string_type &__sym, std::__1::__money_get::string_type &__psn, std::__1::__money_get::string_type &__nsn, int &__fd)         {
            if (__intl) {
                const moneypunct<std::__1::__money_get::char_type, true> &__mp = use_facet<moneypunct<std::__1::__money_get::char_type, true> >(__loc);
                __pat = __mp.neg_format();
                __nsn = __mp.negative_sign();
                __psn = __mp.positive_sign();
                __dp = __mp.decimal_point();
                __ts = __mp.thousands_sep();
                __grp = __mp.grouping();
                __sym = __mp.curr_symbol();
                __fd = __mp.frac_digits();
            } else {
                const moneypunct<std::__1::__money_get::char_type, false> &__mp = use_facet<moneypunct<std::__1::__money_get::char_type, false> >(__loc);
                __pat = __mp.neg_format();
                __nsn = __mp.negative_sign();
                __psn = __mp.positive_sign();
                __dp = __mp.decimal_point();
                __ts = __mp.thousands_sep();
                __grp = __mp.grouping();
                __sym = __mp.curr_symbol();
                __fd = __mp.frac_digits();
            }
        }
        template<> class __attribute__((visibility("default"))) __money_get<char> {
        protected:
            typedef char char_type;
            typedef basic_string<std::__1::__money_get<char>::char_type> string_type;
            __money_get() __attribute__((internal_linkage));
            static void __gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, std::__1::__money_get<char>::char_type &__dp, std::__1::__money_get<char>::char_type &__ts, std::__1::string &__grp, std::__1::__money_get<char>::string_type &__sym, std::__1::__money_get<char>::string_type &__psn, std::__1::__money_get<char>::string_type &__nsn, int &__fd);
        };
        template<> class __attribute__((visibility("default"))) __money_get<wchar_t> {
        protected:
            typedef wchar_t char_type;
            typedef basic_string<std::__1::__money_get<wchar_t>::char_type> string_type;
            __money_get() __attribute__((internal_linkage));
            static void __gather_info(bool __intl, const std::__1::locale &__loc, money_base::pattern &__pat, std::__1::__money_get<wchar_t>::char_type &__dp, std::__1::__money_get<wchar_t>::char_type &__ts, std::__1::string &__grp, std::__1::__money_get<wchar_t>::string_type &__sym, std::__1::__money_get<wchar_t>::string_type &__psn, std::__1::__money_get<wchar_t>::string_type &__nsn, int &__fd);
        };
        template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) money_get : public locale::facet, private __money_get<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _InputIterator iter_type;
            typedef basic_string<std::__1::money_get::char_type> string_type;
            explicit money_get<_CharT, _InputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::money_get::iter_type get(std::__1::money_get::iter_type __b, std::__1::money_get::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __intl, __iob, __err, __v);
            }
            std::__1::money_get::iter_type get(std::__1::money_get::iter_type __b, std::__1::money_get::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, std::__1::money_get::string_type &__v) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_get(__b, __e, __intl, __iob, __err, __v);
            }
            static locale::id id;
        protected:
            ~money_get<_CharT, _InputIterator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual std::__1::money_get::iter_type do_get(std::__1::money_get::iter_type __b, std::__1::money_get::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual std::__1::money_get::iter_type do_get(std::__1::money_get::iter_type __b, std::__1::money_get::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, std::__1::money_get::string_type &__v) const;
        private:
            static bool __do_get(std::__1::money_get::iter_type &__b, std::__1::money_get::iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<std::__1::money_get::char_type> &__ct, unique_ptr<std::__1::money_get::char_type, void (*)(void *)> &__wb, std::__1::money_get::char_type *&__wn, std::__1::money_get::char_type *__we);
        };
        locale::id id;
        void __do_nothing(void *) __attribute__((visibility("default")));
        template <class _Tp> void __double_or_nothing(unique_ptr<_Tp, void (*)(void *)> &__b, _Tp *&__n, _Tp *&__e) __attribute__((visibility("hidden")))         {
            bool __owns = __b.get_deleter() != __do_nothing;
            size_t __cur_cap = static_cast<size_t>(__e - __b.get()) * sizeof(_Tp);
            size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ? 2 * __cur_cap : numeric_limits<size_t>::max();
            if (__new_cap == 0)
                __new_cap = sizeof(_Tp);
            size_t __n_off = static_cast<size_t>(__n - __b.get());
            _Tp *__t = (_Tp *)realloc(__owns ? __b.get() : 0, __new_cap);
            if (__t == 0)
                __throw_bad_alloc();
            if (__owns)
                __b.release();
            __b = unique_ptr<_Tp, void (*)(void *)>(__t, free);
            __new_cap /= sizeof(_Tp);
            __n = __b.get() + __n_off;
            __e = __b.get() + __new_cap;
        }
        template<> void __double_or_nothing<unsigned int>(unique_ptr<unsigned int, void (*)(void *)> &__b, unsigned int *&__n, unsigned int *&__e)        template <class _CharT, class _InputIterator> bool money_get<_CharT, _InputIterator>::__do_get(std::__1::money_get::iter_type &__b, std::__1::money_get::iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<std::__1::money_get::char_type> &__ct, unique_ptr<std::__1::money_get::char_type, void (*)(void *)> &__wb, std::__1::money_get::char_type *&__wn, std::__1::money_get::char_type *__we)         {
            const unsigned int __bz = 100;
            unsigned int __gbuf[100];
            unique_ptr<unsigned int, void (*)(void *)> __gb(__gbuf, __do_nothing);
            unsigned int *__gn = __gb.get();
            unsigned int *__ge = __gn + __bz;
            money_base::pattern __pat;
            std::__1::money_get::char_type __dp;
            std::__1::money_get::char_type __ts;
            std::__1::string __grp;
            std::__1::money_get::string_type __sym;
            std::__1::money_get::string_type __psn;
            std::__1::money_get::string_type __nsn;
            std::__1::money_get::string_type __spaces;
            int __fd;
            __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp, __sym, __psn, __nsn, __fd);
            const std::__1::money_get::string_type *__trailing_sign = 0;
            __wn = __wb.get();
            for (unsigned int __p = 0; __p < 4 && __b != __e; ++__p) {
                switch (__pat.field[__p]) {
                  case money_base::space:
                    if (__p != 3) {
                        if (__ct.is(ctype_base::space, *__b))
                            __spaces.push_back(*__b++);
                        else {
                            __err |= ios_base::failbit;
                            return false;
                        }
                    }
 __attribute__((fallthrough))                    ;
                  case money_base::none:
                    if (__p != 3) {
                        while (__b != __e && __ct.is(ctype_base::space, *__b))
                            __spaces.push_back(*__b++);
                    }
                    break;
                  case money_base::sign:
                    if (__psn.size() + __nsn.size() > 0) {
                        if (__psn.size() == 0 || __nsn.size() == 0) {
                            if (__psn.size() > 0) {
                                if (*__b == __psn[0]) {
                                    ++__b;
                                    if (__psn.size() > 1)
                                        __trailing_sign = &__psn;
                                } else
                                    __neg = true;
                            } else if (*__b == __nsn[0]) {
                                ++__b;
                                __neg = true;
                                if (__nsn.size() > 1)
                                    __trailing_sign = &__nsn;
                            }
                        } else {
                            if (*__b == __psn[0]) {
                                ++__b;
                                if (__psn.size() > 1)
                                    __trailing_sign = &__psn;
                            } else if (*__b == __nsn[0]) {
                                ++__b;
                                __neg = true;
                                if (__nsn.size() > 1)
                                    __trailing_sign = &__nsn;
                            } else {
                                __err |= ios_base::failbit;
                                return false;
                            }
                        }
                    }
                    break;
                  case money_base::symbol:
                    {
                        bool __more_needed = __trailing_sign || (__p < 2) || (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
                        bool __sb = (__flags & ios_base::showbase) != 0;
                        if (__sb || __more_needed) {
                            typename string_type::const_iterator __sym_space_end = __sym.begin();
                            if (__p > 0 && (__pat.field[__p - 1] == money_base::none || __pat.field[__p - 1] == money_base::space)) {
                                while (__sym_space_end != __sym.end() && __ct.is(ctype_base::space, *__sym_space_end))
                                    ++__sym_space_end;
                                const size_t __num_spaces = __sym_space_end - __sym.begin();
                                if (__num_spaces > __spaces.size() || !equal(__spaces.end() - __num_spaces, __spaces.end(), __sym.begin())) {
                                    __sym_space_end = __sym.begin();
                                }
                            }
                            typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                            while (__sym_curr_char != __sym.end() && __b != __e && *__b == *__sym_curr_char)
                                {
                                    ++__b;
                                    ++__sym_curr_char;
                                }
                            if (__sb && __sym_curr_char != __sym.end()) {
                                __err |= ios_base::failbit;
                                return false;
                            }
                        }
                    }
                    break;
                  case money_base::value:
                    {
                        unsigned int __ng = 0;
                        for (; __b != __e; ++__b) {
                            std::__1::money_get::char_type __c = *__b;
                            if (__ct.is(ctype_base::digit, __c)) {
                                if (__wn == __we)
                                    __double_or_nothing(__wb, __wn, __we);
                                *__wn++ = __c;
                                ++__ng;
                            } else if (__grp.size() > 0 && __ng > 0 && __c == __ts) {
                                if (__gn == __ge)
                                    __double_or_nothing(__gb, __gn, __ge);
                                *__gn++ = __ng;
                                __ng = 0;
                            } else
                                break;
                        }
                        if (__gb.get() != __gn && __ng > 0) {
                            if (__gn == __ge)
                                __double_or_nothing(__gb, __gn, __ge);
                            *__gn++ = __ng;
                        }
                        if (__fd > 0) {
                            if (__b == __e || *__b != __dp) {
                                __err |= ios_base::failbit;
                                return false;
                            }
                            for (++__b; __fd > 0; --__fd , ++__b) {
                                if (__b == __e || !__ct.is(ctype_base::digit, *__b)) {
                                    __err |= ios_base::failbit;
                                    return false;
                                }
                                if (__wn == __we)
                                    __double_or_nothing(__wb, __wn, __we);
                                *__wn++ = *__b;
                            }
                        }
                        if (__wn == __wb.get()) {
                            __err |= ios_base::failbit;
                            return false;
                        }
                    }
                    break;
                }
            }
            if (__trailing_sign) {
                for (unsigned int __i = 1; __i < __trailing_sign->size(); ++__i , ++__b) {
                    if (__b == __e || *__b != (*__trailing_sign)[__i]) {
                        __err |= ios_base::failbit;
                        return false;
                    }
                }
            }
            if (__gb.get() != __gn) {
                ios_base::iostate __et = ios_base::goodbit;
                __check_grouping(__grp, __gb.get(), __gn, __et);
                if (__et) {
                    __err |= ios_base::failbit;
                    return false;
                }
            }
            return true;
        }
        template <class _CharT, class _InputIterator> _InputIterator money_get<_CharT, _InputIterator>::do_get(std::__1::money_get::iter_type __b, std::__1::money_get::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const         {
            const int __bz = 100;
            std::__1::money_get::char_type __wbuf[100];
            unique_ptr<std::__1::money_get::char_type, void (*)(void *)> __wb(__wbuf, __do_nothing);
            std::__1::money_get::char_type *__wn;
            std::__1::money_get::char_type *__we = __wbuf + __bz;
            std::__1::locale __loc = __iob.getloc();
            const ctype<std::__1::money_get::char_type> &__ct = use_facet<ctype<std::__1::money_get::char_type> >(__loc);
            bool __neg = false;
            if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb, __wn, __we)) {
                const char __src[] = "0123456789";
                std::__1::money_get::char_type __atoms[10];
                __ct.widen(__src, __src + (sizeof (__src) - 1), __atoms);
                char __nbuf[100];
                char *__nc = __nbuf;
                unique_ptr<char, void (*)(void *)> __h(0, free);
                if (__wn - __wb.get() > __bz - 2) {
                    __h.reset((char *)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
                    if (__h.get() == 0)
                        __throw_bad_alloc();
                    __nc = __h.get();
                }
                if (__neg)
                    *__nc++ = '-';
                for (const std::__1::money_get::char_type *__w = __wb.get(); __w < __wn; ++__w , ++__nc)
                    *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
                *__nc = char();
                if (sscanf(__nbuf, "%Lf", &__v) != 1)
                    __throw_runtime_error("money_get error");
            }
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }
        template <class _CharT, class _InputIterator> _InputIterator money_get<_CharT, _InputIterator>::do_get(std::__1::money_get::iter_type __b, std::__1::money_get::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, std::__1::money_get::string_type &__v) const         {
            const int __bz = 100;
            std::__1::money_get::char_type __wbuf[100];
            unique_ptr<std::__1::money_get::char_type, void (*)(void *)> __wb(__wbuf, __do_nothing);
            std::__1::money_get::char_type *__wn;
            std::__1::money_get::char_type *__we = __wbuf + __bz;
            std::__1::locale __loc = __iob.getloc();
            const ctype<std::__1::money_get::char_type> &__ct = use_facet<ctype<std::__1::money_get::char_type> >(__loc);
            bool __neg = false;
            if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb, __wn, __we)) {
                __v.clear();
                if (__neg)
                    __v.push_back(__ct.widen('-'));
                std::__1::money_get::char_type __z = __ct.widen('0');
                std::__1::money_get::char_type *__w;
                for (__w = __wb.get(); __w < __wn - 1; ++__w)
                    if (*__w != __z)
                        break;
                __v.append(__w, __wn);
            }
            if (__b == __e)
                __err |= ios_base::eofbit;
            return __b;
        }
        template<> class __attribute__((visibility("default"))) money_get<char> : public locale::facet, private __money_get<char> {
        public:
            typedef char char_type;
            typedef std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef basic_string<std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> string_type;
            explicit money_get(size_t __refs) __attribute__((internal_linkage));
            std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((internal_linkage));
            std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type get(std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::string_type &__v) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~money_get<char>() __attribute__((internal_linkage));
            virtual std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_get(std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __b, std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::string_type &__v) const;
        private:
            static bool __do_get(std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type &__b, std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> &__ct, unique_ptr<std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type, void (*)(void *)> &__wb, std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type *&__wn, std::__1::money_get<char, std::__1::istreambuf_iterator<char, std::__1::char_traits<char> > >::char_type *__we);
        };
        template<> class __attribute__((visibility("default"))) money_get<wchar_t> : public locale::facet, private __money_get<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef basic_string<std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> string_type;
            explicit money_get(size_t __refs) __attribute__((internal_linkage));
            std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const __attribute__((internal_linkage));
            std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type get(std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type &__v) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~money_get<wchar_t>() __attribute__((internal_linkage));
            virtual std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, long double &__v) const;
            virtual std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_get(std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __b, std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, bool __intl, std::__1::ios_base &__iob, ios_base::iostate &__err, std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type &__v) const;
        private:
            static bool __do_get(std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type &__b, std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __e, bool __intl, const std::__1::locale &__loc, ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg, const ctype<std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> &__ct, unique_ptr<std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type, void (*)(void *)> &__wb, std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type *&__wn, std::__1::money_get<wchar_t, std::__1::istreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type *__we);
        };
        template <class _CharT> class __money_put {
        protected:
            typedef _CharT char_type;
            typedef basic_string<std::__1::__money_put::char_type> string_type;
            __money_put<_CharT>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            static void __gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, std::__1::__money_put::char_type &__dp, std::__1::__money_put::char_type &__ts, std::__1::string &__grp, std::__1::__money_put::string_type &__sym, std::__1::__money_put::string_type &__sn, int &__fd);
            static void __format(std::__1::__money_put::char_type *__mb, std::__1::__money_put::char_type *&__mi, std::__1::__money_put::char_type *&__me, ios_base::fmtflags __flags, const std::__1::__money_put::char_type *__db, const std::__1::__money_put::char_type *__de, const ctype<std::__1::__money_put::char_type> &__ct, bool __neg, const money_base::pattern &__pat, std::__1::__money_put::char_type __dp, std::__1::__money_put::char_type __ts, const std::__1::string &__grp, const std::__1::__money_put::string_type &__sym, const std::__1::__money_put::string_type &__sn, int __fd);
        };
        template <class _CharT> void __money_put<_CharT>::__gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, std::__1::__money_put::char_type &__dp, std::__1::__money_put::char_type &__ts, std::__1::string &__grp, std::__1::__money_put::string_type &__sym, std::__1::__money_put::string_type &__sn, int &__fd)         {
            if (__intl) {
                const moneypunct<std::__1::__money_put::char_type, true> &__mp = use_facet<moneypunct<std::__1::__money_put::char_type, true> >(__loc);
                if (__neg) {
                    __pat = __mp.neg_format();
                    __sn = __mp.negative_sign();
                } else {
                    __pat = __mp.pos_format();
                    __sn = __mp.positive_sign();
                }
                __dp = __mp.decimal_point();
                __ts = __mp.thousands_sep();
                __grp = __mp.grouping();
                __sym = __mp.curr_symbol();
                __fd = __mp.frac_digits();
            } else {
                const moneypunct<std::__1::__money_put::char_type, false> &__mp = use_facet<moneypunct<std::__1::__money_put::char_type, false> >(__loc);
                if (__neg) {
                    __pat = __mp.neg_format();
                    __sn = __mp.negative_sign();
                } else {
                    __pat = __mp.pos_format();
                    __sn = __mp.positive_sign();
                }
                __dp = __mp.decimal_point();
                __ts = __mp.thousands_sep();
                __grp = __mp.grouping();
                __sym = __mp.curr_symbol();
                __fd = __mp.frac_digits();
            }
        }
        template <class _CharT> void __money_put<_CharT>::__format(std::__1::__money_put::char_type *__mb, std::__1::__money_put::char_type *&__mi, std::__1::__money_put::char_type *&__me, ios_base::fmtflags __flags, const std::__1::__money_put::char_type *__db, const std::__1::__money_put::char_type *__de, const ctype<std::__1::__money_put::char_type> &__ct, bool __neg, const money_base::pattern &__pat, std::__1::__money_put::char_type __dp, std::__1::__money_put::char_type __ts, const std::__1::string &__grp, const std::__1::__money_put::string_type &__sym, const std::__1::__money_put::string_type &__sn, int __fd)         {
            __me = __mb;
            for (unsigned int __p = 0; __p < 4; ++__p) {
                switch (__pat.field[__p]) {
                  case money_base::none:
                    __mi = __me;
                    break;
                  case money_base::space:
                    __mi = __me;
                    *__me++ = __ct.widen(' ');
                    break;
                  case money_base::sign:
                    if (!__sn.empty())
                        *__me++ = __sn[0];
                    break;
                  case money_base::symbol:
                    if (!__sym.empty() && (__flags & ios_base::showbase))
                        __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
                    break;
                  case money_base::value:
                    {
                        std::__1::__money_put::char_type *__t = __me;
                        if (__neg)
                            ++__db;
                        const std::__1::__money_put::char_type *__d;
                        for (__d = __db; __d < __de; ++__d)
                            if (!__ct.is(ctype_base::digit, *__d))
                                break;
                        if (__fd > 0) {
                            int __f;
                            for (__f = __fd; __d > __db && __f > 0; --__f)
                                *__me++ = *--__d;
                            std::__1::__money_put::char_type __z = __f > 0 ? __ct.widen('0') : std::__1::__money_put::char_type();
                            for (; __f > 0; --__f)
                                *__me++ = __z;
                            *__me++ = __dp;
                        }
                        if (__d == __db) {
                            *__me++ = __ct.widen('0');
                        } else {
                            unsigned int __ng = 0;
                            unsigned int __ig = 0;
                            unsigned int __gl = __grp.empty() ? numeric_limits<unsigned int>::max() : static_cast<unsigned int>(__grp[__ig]);
                            while (__d != __db)
                                {
                                    if (__ng == __gl) {
                                        *__me++ = __ts;
                                        __ng = 0;
                                        if (++__ig < __grp.size())
                                            __gl = __grp[__ig] == numeric_limits<char>::max() ? numeric_limits<unsigned int>::max() : static_cast<unsigned int>(__grp[__ig]);
                                    }
                                    *__me++ = *--__d;
                                    ++__ng;
                                }
                        }
                        reverse(__t, __me);
                    }
                    break;
                }
            }
            if (__sn.size() > 1)
                __me = std::__1::copy(__sn.begin() + 1, __sn.end(), __me);
            if ((__flags & ios_base::adjustfield) == ios_base::left)
                __mi = __me;
            else if ((__flags & ios_base::adjustfield) != ios_base::internal)
                __mi = __mb;
        }
        template<> class __attribute__((visibility("default"))) __money_put<char> {
        protected:
            typedef char char_type;
            typedef basic_string<std::__1::__money_put<char>::char_type> string_type;
            __money_put() __attribute__((internal_linkage));
            static void __gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, std::__1::__money_put<char>::char_type &__dp, std::__1::__money_put<char>::char_type &__ts, std::__1::string &__grp, std::__1::__money_put<char>::string_type &__sym, std::__1::__money_put<char>::string_type &__sn, int &__fd);
            static void __format(std::__1::__money_put<char>::char_type *__mb, std::__1::__money_put<char>::char_type *&__mi, std::__1::__money_put<char>::char_type *&__me, ios_base::fmtflags __flags, const std::__1::__money_put<char>::char_type *__db, const std::__1::__money_put<char>::char_type *__de, const ctype<std::__1::__money_put<char>::char_type> &__ct, bool __neg, const money_base::pattern &__pat, std::__1::__money_put<char>::char_type __dp, std::__1::__money_put<char>::char_type __ts, const std::__1::string &__grp, const std::__1::__money_put<char>::string_type &__sym, const std::__1::__money_put<char>::string_type &__sn, int __fd);
        };
        template<> class __attribute__((visibility("default"))) __money_put<wchar_t> {
        protected:
            typedef wchar_t char_type;
            typedef basic_string<std::__1::__money_put<wchar_t>::char_type> string_type;
            __money_put() __attribute__((internal_linkage));
            static void __gather_info(bool __intl, bool __neg, const std::__1::locale &__loc, money_base::pattern &__pat, std::__1::__money_put<wchar_t>::char_type &__dp, std::__1::__money_put<wchar_t>::char_type &__ts, std::__1::string &__grp, std::__1::__money_put<wchar_t>::string_type &__sym, std::__1::__money_put<wchar_t>::string_type &__sn, int &__fd);
            static void __format(std::__1::__money_put<wchar_t>::char_type *__mb, std::__1::__money_put<wchar_t>::char_type *&__mi, std::__1::__money_put<wchar_t>::char_type *&__me, ios_base::fmtflags __flags, const std::__1::__money_put<wchar_t>::char_type *__db, const std::__1::__money_put<wchar_t>::char_type *__de, const ctype<std::__1::__money_put<wchar_t>::char_type> &__ct, bool __neg, const money_base::pattern &__pat, std::__1::__money_put<wchar_t>::char_type __dp, std::__1::__money_put<wchar_t>::char_type __ts, const std::__1::string &__grp, const std::__1::__money_put<wchar_t>::string_type &__sym, const std::__1::__money_put<wchar_t>::string_type &__sn, int __fd);
        };
        template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>> class __attribute__((type_visibility("default"))) money_put : public locale::facet, private __money_put<_CharT> {
        public:
            typedef _CharT char_type;
            typedef _OutputIterator iter_type;
            typedef basic_string<std::__1::money_put::char_type> string_type;
            explicit money_put<_CharT, _OutputIterator>(size_t __refs = 0) : locale::facet(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::money_put::iter_type put(std::__1::money_put::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put::char_type __fl, long double __units) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __intl, __iob, __fl, __units);
            }
            std::__1::money_put::iter_type put(std::__1::money_put::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put::char_type __fl, const std::__1::money_put::string_type &__digits) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return do_put(__s, __intl, __iob, __fl, __digits);
            }
            static locale::id id;
        protected:
            ~money_put<_CharT, _OutputIterator>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual std::__1::money_put::iter_type do_put(std::__1::money_put::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put::char_type __fl, long double __units) const;
            virtual std::__1::money_put::iter_type do_put(std::__1::money_put::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put::char_type __fl, const std::__1::money_put::string_type &__digits) const;
        };
        locale::id id;
        template <class _CharT, class _OutputIterator> _OutputIterator money_put<_CharT, _OutputIterator>::do_put(std::__1::money_put::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put::char_type __fl, long double __units) const         {
            const size_t __bs = 100;
            char __buf[100];
            char *__bb = __buf;
            std::__1::money_put::char_type __digits[100];
            std::__1::money_put::char_type *__db = __digits;
            size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
            unique_ptr<char, void (*)(void *)> __hn(0, free);
            unique_ptr<std::__1::money_put::char_type, void (*)(void *)> __hd(0, free);
            if (__n > __bs - 1) {
                __n = static_cast<size_t>(asprintf_l(&__bb, 0, "%.0Lf", __units));
                if (__bb == 0)
                    __throw_bad_alloc();
                __hn.reset(__bb);
                __hd.reset((std::__1::money_put::char_type *)malloc(__n * sizeof(std::__1::money_put::char_type)));
                if (__hd == std::__1::__get_nullptr_t())
                    __throw_bad_alloc();
                __db = __hd.get();
            }
            std::__1::locale __loc = __iob.getloc();
            const ctype<std::__1::money_put::char_type> &__ct = use_facet<ctype<std::__1::money_put::char_type> >(__loc);
            __ct.widen(__bb, __bb + __n, __db);
            bool __neg = __n > 0 && __bb[0] == '-';
            money_base::pattern __pat;
            std::__1::money_put::char_type __dp;
            std::__1::money_put::char_type __ts;
            std::__1::string __grp;
            std::__1::money_put::string_type __sym;
            std::__1::money_put::string_type __sn;
            int __fd;
            this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
            std::__1::money_put::char_type __mbuf[100];
            std::__1::money_put::char_type *__mb = __mbuf;
            unique_ptr<std::__1::money_put::char_type, void (*)(void *)> __hw(0, free);
            size_t __exn = static_cast<int>(__n) > __fd ? (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
            if (__exn > __bs) {
                __hw.reset((std::__1::money_put::char_type *)malloc(__exn * sizeof(std::__1::money_put::char_type)));
                __mb = __hw.get();
                if (__mb == 0)
                    __throw_bad_alloc();
            }
            std::__1::money_put::char_type *__mi;
            std::__1::money_put::char_type *__me;
            this->__format(__mb, __mi, __me, __iob.flags(), __db, __db + __n, __ct, __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
            return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
        }
        template <class _CharT, class _OutputIterator> _OutputIterator money_put<_CharT, _OutputIterator>::do_put(std::__1::money_put::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put::char_type __fl, const std::__1::money_put::string_type &__digits) const         {
            std::__1::locale __loc = __iob.getloc();
            const ctype<std::__1::money_put::char_type> &__ct = use_facet<ctype<std::__1::money_put::char_type> >(__loc);
            bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
            money_base::pattern __pat;
            std::__1::money_put::char_type __dp;
            std::__1::money_put::char_type __ts;
            std::__1::string __grp;
            std::__1::money_put::string_type __sym;
            std::__1::money_put::string_type __sn;
            int __fd;
            this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
            std::__1::money_put::char_type __mbuf[100];
            std::__1::money_put::char_type *__mb = __mbuf;
            unique_ptr<std::__1::money_put::char_type, void (*)(void *)> __h(0, free);
            size_t __exn = static_cast<int>(__digits.size()) > __fd ? (__digits.size() - static_cast<size_t>(__fd)) * 2 + __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
            if (__exn > 100) {
                __h.reset((std::__1::money_put::char_type *)malloc(__exn * sizeof(std::__1::money_put::char_type)));
                __mb = __h.get();
                if (__mb == 0)
                    __throw_bad_alloc();
            }
            std::__1::money_put::char_type *__mi;
            std::__1::money_put::char_type *__me;
            this->__format(__mb, __mi, __me, __iob.flags(), __digits.data(), __digits.data() + __digits.size(), __ct, __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
            return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
        }
        template<> class __attribute__((visibility("default"))) money_put<char> : public locale::facet, private __money_put<char> {
        public:
            typedef char char_type;
            typedef std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > iter_type;
            typedef basic_string<std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type> string_type;
            explicit money_put(size_t __refs) __attribute__((internal_linkage));
            std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, long double __units) const __attribute__((internal_linkage));
            std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type put(std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, const std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::string_type &__digits) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~money_put<char>() __attribute__((internal_linkage));
            virtual std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, long double __units) const;
            virtual std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type do_put(std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::char_type __fl, const std::__1::money_put<char, std::__1::ostreambuf_iterator<char, std::__1::char_traits<char> > >::string_type &__digits) const;
        };
        template<> class __attribute__((visibility("default"))) money_put<wchar_t> : public locale::facet, private __money_put<wchar_t> {
        public:
            typedef wchar_t char_type;
            typedef std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > iter_type;
            typedef basic_string<std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type> string_type;
            explicit money_put(size_t __refs) __attribute__((internal_linkage));
            std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, long double __units) const __attribute__((internal_linkage));
            std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type put(std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, const std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type &__digits) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~money_put<wchar_t>() __attribute__((internal_linkage));
            virtual std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, long double __units) const;
            virtual std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type do_put(std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::iter_type __s, bool __intl, std::__1::ios_base &__iob, std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::char_type __fl, const std::__1::money_put<wchar_t, std::__1::ostreambuf_iterator<wchar_t, std::__1::char_traits<wchar_t> > >::string_type &__digits) const;
        };
        class __attribute__((visibility("default"))) messages_base {
        public:
            typedef ptrdiff_t catalog;
            messages_base() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
        template <class _CharT> class __attribute__((type_visibility("default"))) messages : public locale::facet, public std::__1::messages_base {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            explicit messages<_CharT>(size_t __refs = 0) : locale::facet(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            std::__1::messages_base::catalog open(const basic_string<char> &__nm, const std::__1::locale &__loc) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_open(__nm, __loc);
            }
            std::__1::messages::string_type get(std::__1::messages_base::catalog __c, int __set, int __msgid, const std::__1::messages::string_type &__dflt) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->do_get(__c, __set, __msgid, __dflt);
            }
            void close(std::__1::messages_base::catalog __c) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->do_close(__c);
            }
            static locale::id id;
        protected:
            ~messages<_CharT>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual std::__1::messages_base::catalog do_open(const basic_string<char> &, const std::__1::locale &) const;
            virtual std::__1::messages::string_type do_get(std::__1::messages_base::catalog, int __set, int __msgid, const std::__1::messages::string_type &__dflt) const;
            virtual void do_close(std::__1::messages_base::catalog) const;
        };
        locale::id id;
        template <class _CharT> typename messages<_CharT>::catalog messages<_CharT>::do_open(const basic_string<char> &__nm, const std::__1::locale &) const         {
            std::__1::messages_base::catalog __cat = (std::__1::messages_base::catalog)catopen(__nm.c_str(), 1);
            if (__cat != -1)
                __cat = static_cast<std::__1::messages_base::catalog>((static_cast<size_t>(__cat) >> 1));
            return __cat;
        }
        template <class _CharT> typename messages<_CharT>::string_type messages<_CharT>::do_get(std::__1::messages_base::catalog __c, int __set, int __msgid, const std::__1::messages::string_type &__dflt) const         {
            std::__1::string __ndflt;
            __narrow_to_utf8<sizeof(std::__1::messages::char_type) * 8>()(back_inserter(__ndflt), __dflt.c_str(), __dflt.c_str() + __dflt.size());
            if (__c != -1)
                __c <<= 1;
            nl_catd __cat = (nl_catd)__c;
            char *__n = catgets(__cat, __set, __msgid, __ndflt.c_str());
            std::__1::messages::string_type __w;
            __widen_from_utf8<sizeof(std::__1::messages::char_type) * 8>()(back_inserter(__w), __n, __n + strlen(__n));
            return __w;
        }
        template <class _CharT> void messages<_CharT>::do_close(std::__1::messages_base::catalog __c) const         {
            if (__c != -1)
                __c <<= 1;
            nl_catd __cat = (nl_catd)__c;
            catclose(__cat);
        }
        template<> class __attribute__((visibility("default"))) messages<char> : public locale::facet, public std::__1::messages_base {
        public:
            typedef char char_type;
            typedef basic_string<char> string_type;
            explicit messages(size_t __refs) __attribute__((internal_linkage));
            std::__1::messages_base::catalog open(const basic_string<char> &__nm, const std::__1::locale &__loc) const __attribute__((internal_linkage));
            std::__1::messages<char>::string_type get(std::__1::messages_base::catalog __c, int __set, int __msgid, const std::__1::messages<char>::string_type &__dflt) const __attribute__((internal_linkage));
            void close(std::__1::messages_base::catalog __c) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~messages<char>() __attribute__((internal_linkage));
            virtual std::__1::messages_base::catalog do_open(const basic_string<char> &, const std::__1::locale &) const;
            virtual std::__1::messages<char>::string_type do_get(std::__1::messages_base::catalog, int __set, int __msgid, const std::__1::messages<char>::string_type &__dflt) const;
            virtual void do_close(std::__1::messages_base::catalog) const;
        };
        template<> class __attribute__((visibility("default"))) messages<wchar_t> : public locale::facet, public std::__1::messages_base {
        public:
            typedef wchar_t char_type;
            typedef basic_string<wchar_t> string_type;
            explicit messages(size_t __refs) __attribute__((internal_linkage));
            std::__1::messages_base::catalog open(const basic_string<char> &__nm, const std::__1::locale &__loc) const __attribute__((internal_linkage));
            std::__1::messages<wchar_t>::string_type get(std::__1::messages_base::catalog __c, int __set, int __msgid, const std::__1::messages<wchar_t>::string_type &__dflt) const __attribute__((internal_linkage));
            void close(std::__1::messages_base::catalog __c) const __attribute__((internal_linkage));
            static locale::id id;
        protected:
            ~messages<wchar_t>() __attribute__((internal_linkage));
            virtual std::__1::messages_base::catalog do_open(const basic_string<char> &, const std::__1::locale &) const;
            virtual std::__1::messages<wchar_t>::string_type do_get(std::__1::messages_base::catalog, int __set, int __msgid, const std::__1::messages<wchar_t>::string_type &__dflt) const;
            virtual void do_close(std::__1::messages_base::catalog) const;
        };
        template <class _CharT> class __attribute__((type_visibility("default"))) messages_byname : public messages<_CharT> {
        public:
            typedef messages_base::catalog catalog;
            typedef basic_string<_CharT> string_type;
            explicit messages_byname<_CharT>(const char *, size_t __refs = 0) : messages<_CharT>(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            explicit messages_byname<_CharT>(const std::__1::string &, size_t __refs = 0) : messages<_CharT>(__refs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        protected:
            ~messages_byname<_CharT>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
        template<> class __attribute__((visibility("default"))) messages_byname<char> : public messages<char> {
        public:
            typedef messages_base::catalog catalog;
            typedef basic_string<char> string_type;
            explicit messages_byname(const char *, size_t __refs) __attribute__((internal_linkage));
            explicit messages_byname(const std::__1::string &, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~messages_byname<char>() __attribute__((internal_linkage));
        };
        template<> class __attribute__((visibility("default"))) messages_byname<wchar_t> : public messages<wchar_t> {
        public:
            typedef messages_base::catalog catalog;
            typedef basic_string<wchar_t> string_type;
            explicit messages_byname(const char *, size_t __refs) __attribute__((internal_linkage));
            explicit messages_byname(const std::__1::string &, size_t __refs) __attribute__((internal_linkage));
        protected:
            ~messages_byname<wchar_t>() __attribute__((internal_linkage));
        };
        template <class _Codecvt, class _Elem = wchar_t, class _Wide_alloc = allocator<_Elem>, class _Byte_alloc = allocator<char>> class __attribute__((type_visibility("default"))) wstring_convert {
        public:
            typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
            typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
            typedef typename _Codecvt::state_type state_type;
            typedef typename wide_string::traits_type::int_type int_type;
        private:
            std::__1::wstring_convert::byte_string __byte_err_string_;
            std::__1::wstring_convert::wide_string __wide_err_string_;
            _Codecvt *__cvtptr_;
            std::__1::wstring_convert::state_type __cvtstate_;
            size_t __cvtcount_;
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(const wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &__wc);
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &operator=(const wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc> &__wc);
        public:
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(_Codecvt *__pcvt = new _Codecvt) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(_Codecvt *__pcvt, std::__1::wstring_convert::state_type __state) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(const std::__1::wstring_convert::byte_string &__byte_err, const std::__1::wstring_convert::wide_string &__wide_err = std::__1::wstring_convert::wide_string());
            ~wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>();
            std::__1::wstring_convert::wide_string from_bytes(char __byte) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return from_bytes(&__byte, &__byte + 1);
            }
            std::__1::wstring_convert::wide_string from_bytes(const char *__ptr) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));
            }
            std::__1::wstring_convert::wide_string from_bytes(const std::__1::wstring_convert::byte_string &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return from_bytes(__str.data(), __str.data() + __str.size());
            }
            std::__1::wstring_convert::wide_string from_bytes(const char *__first, const char *__last);
            std::__1::wstring_convert::byte_string to_bytes(_Elem __wchar) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return to_bytes(&__wchar, &__wchar + 1);
            }
            std::__1::wstring_convert::byte_string to_bytes(const _Elem *__wptr) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));
            }
            std::__1::wstring_convert::byte_string to_bytes(const std::__1::wstring_convert::wide_string &__wstr) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());
            }
            std::__1::wstring_convert::byte_string to_bytes(const _Elem *__first, const _Elem *__last);
            size_t converted() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cvtcount_;
            }
            std::__1::wstring_convert::state_type state() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__cvtstate_;
            }
        };
        template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc> inline wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(_Codecvt *__pcvt = new _Codecvt) : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)         {
        }
        template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc> inline wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(_Codecvt *__pcvt, std::__1::wstring_convert::state_type __state) : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)         {
        }
        template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc> wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>(const std::__1::wstring_convert::byte_string &__byte_err, const std::__1::wstring_convert::wide_string &__wide_err = std::__1::wstring_convert::wide_string()) : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err), __cvtstate_(), __cvtcount_(0)         {
            this->__cvtptr_ = new _Codecvt;
        }
        template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc> wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>()         {
            delete this->__cvtptr_;
        }
        template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc> typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::from_bytes(const char *__frm, const char *__frm_end)         {
            this->__cvtcount_ = 0;
            if (this->__cvtptr_ != std::__1::__get_nullptr_t()) {
                std::__1::wstring_convert::wide_string __ws(2 * (__frm_end - __frm), _Elem());
                if (__frm != __frm_end)
                    __ws.resize(__ws.capacity());
                codecvt_base::result __r = codecvt_base::ok;
                std::__1::wstring_convert::state_type __st = this->__cvtstate_;
                if (__frm != __frm_end) {
                    _Elem *__to = &__ws[0];
                    _Elem *__to_end = __to + __ws.size();
                    const char *__frm_nxt;
                    do {
                        _Elem *__to_nxt;
                        __r = this->__cvtptr_->in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
                        this->__cvtcount_ += __frm_nxt - __frm;
                        if (__frm_nxt == __frm) {
                            __r = codecvt_base::error;
                        } else if (__r == codecvt_base::noconv) {
                            __ws.resize(__to - &__ws[0]);
                            __ws.append((const _Elem *)__frm, (const _Elem *)__frm_end);
                            __frm = __frm_nxt;
                            __r = codecvt_base::ok;
                        } else if (__r == codecvt_base::ok) {
                            __ws.resize(__to_nxt - &__ws[0]);
                            __frm = __frm_nxt;
                        } else if (__r == codecvt_base::partial) {
                            ptrdiff_t __s = __to_nxt - &__ws[0];
                            __ws.resize(2 * __s);
                            __to = &__ws[0] + __s;
                            __to_end = &__ws[0] + __ws.size();
                            __frm = __frm_nxt;
                        }
                    } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
                }
                if (__r == codecvt_base::ok)
                    return __ws;
            }
            if (this->__wide_err_string_.empty())
                __throw_range_error("wstring_convert: from_bytes error");
            return this->__wide_err_string_;
        }
        template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc> typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::to_bytes(const _Elem *__frm, const _Elem *__frm_end)         {
            this->__cvtcount_ = 0;
            if (this->__cvtptr_ != std::__1::__get_nullptr_t()) {
                std::__1::wstring_convert::byte_string __bs(2 * (__frm_end - __frm), char());
                if (__frm != __frm_end)
                    __bs.resize(__bs.capacity());
                codecvt_base::result __r = codecvt_base::ok;
                std::__1::wstring_convert::state_type __st = this->__cvtstate_;
                if (__frm != __frm_end) {
                    char *__to = &__bs[0];
                    char *__to_end = __to + __bs.size();
                    const _Elem *__frm_nxt;
                    do {
                        char *__to_nxt;
                        __r = this->__cvtptr_->out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
                        this->__cvtcount_ += __frm_nxt - __frm;
                        if (__frm_nxt == __frm) {
                            __r = codecvt_base::error;
                        } else if (__r == codecvt_base::noconv) {
                            __bs.resize(__to - &__bs[0]);
                            __bs.append((const char *)__frm, (const char *)__frm_end);
                            __frm = __frm_nxt;
                            __r = codecvt_base::ok;
                        } else if (__r == codecvt_base::ok) {
                            __bs.resize(__to_nxt - &__bs[0]);
                            __frm = __frm_nxt;
                        } else if (__r == codecvt_base::partial) {
                            ptrdiff_t __s = __to_nxt - &__bs[0];
                            __bs.resize(2 * __s);
                            __to = &__bs[0] + __s;
                            __to_end = &__bs[0] + __bs.size();
                            __frm = __frm_nxt;
                        }
                    } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
                }
                if (__r == codecvt_base::ok) {
                    size_t __s = __bs.size();
                    __bs.resize(__bs.capacity());
                    char *__to = &__bs[0] + __s;
                    char *__to_end = __to + __bs.size();
                    do {
                        char *__to_nxt;
                        __r = this->__cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
                        if (__r == codecvt_base::noconv) {
                            __bs.resize(__to - &__bs[0]);
                            __r = codecvt_base::ok;
                        } else if (__r == codecvt_base::ok) {
                            __bs.resize(__to_nxt - &__bs[0]);
                        } else if (__r == codecvt_base::partial) {
                            ptrdiff_t __sp = __to_nxt - &__bs[0];
                            __bs.resize(2 * __sp);
                            __to = &__bs[0] + __sp;
                            __to_end = &__bs[0] + __bs.size();
                        }
                    } while (__r == codecvt_base::partial);
                    if (__r == codecvt_base::ok)
                        return __bs;
                }
            }
            if (this->__byte_err_string_.empty())
                __throw_range_error("wstring_convert: to_bytes error");
            return this->__byte_err_string_;
        }
        template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem>> class __attribute__((type_visibility("default"))) wbuffer_convert : public basic_streambuf<_Elem, _Tr> {
        public:
            typedef _Elem char_type;
            typedef _Tr traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef typename _Codecvt::state_type state_type;
        private:
            char *__extbuf_;
            const char *__extbufnext_;
            const char *__extbufend_;
            char __extbuf_min_[8];
            size_t __ebs_;
            std::__1::wbuffer_convert::char_type *__intbuf_;
            size_t __ibs_;
            std::__1::streambuf *__bufptr_;
            _Codecvt *__cv_;
            std::__1::wbuffer_convert::state_type __st_;
            ios_base::openmode __cm_;
            bool __owns_eb_;
            bool __owns_ib_;
            bool __always_noconv_;
            wbuffer_convert<_Codecvt, _Elem, _Tr>(const wbuffer_convert<_Codecvt, _Elem, _Tr> &);
            wbuffer_convert<_Codecvt, _Elem, _Tr> &operator=(const wbuffer_convert<_Codecvt, _Elem, _Tr> &);
        public:
            wbuffer_convert<_Codecvt, _Elem, _Tr>(std::__1::streambuf *__bytebuf = 0, _Codecvt *__pcvt = new _Codecvt, std::__1::wbuffer_convert::state_type __state = std::__1::wbuffer_convert::state_type());
            ~wbuffer_convert<_Codecvt, _Elem, _Tr>();
            std::__1::streambuf *rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__bufptr_;
            }
            std::__1::streambuf *rdbuf(std::__1::streambuf *__bytebuf) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::streambuf *__r = this->__bufptr_;
                this->__bufptr_ = __bytebuf;
                return __r;
            }
            std::__1::wbuffer_convert::state_type state() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__st_;
            }
        protected:
            virtual std::__1::wbuffer_convert::int_type underflow();
            virtual std::__1::wbuffer_convert::int_type pbackfail(std::__1::wbuffer_convert::int_type __c = traits_type::eof());
            virtual std::__1::wbuffer_convert::int_type overflow(std::__1::wbuffer_convert::int_type __c = traits_type::eof());
            virtual basic_streambuf<std::__1::wbuffer_convert::char_type, std::__1::wbuffer_convert::traits_type> *setbuf(std::__1::wbuffer_convert::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::wbuffer_convert::pos_type seekoff(std::__1::wbuffer_convert::off_type __off, ios_base::seekdir __way, ios_base::openmode __wch = ios_base::in | ios_base::out);
            virtual std::__1::wbuffer_convert::pos_type seekpos(std::__1::wbuffer_convert::pos_type __sp, ios_base::openmode __wch = ios_base::in | ios_base::out);
            virtual int sync();
        private:
            bool __read_mode();
            void __write_mode();
            wbuffer_convert<_Codecvt, _Elem, _Tr> *__close();
        };
        template <class _Codecvt, class _Elem, class _Tr> wbuffer_convert<_Codecvt, _Elem, _Tr>::wbuffer_convert<_Codecvt, _Elem, _Tr>(std::__1::streambuf *__bytebuf = 0, _Codecvt *__pcvt = new _Codecvt, std::__1::wbuffer_convert::state_type __state = std::__1::wbuffer_convert::state_type()) : __extbuf_(0), __extbufnext_(0), __extbufend_(0), __ebs_(0), __intbuf_(0), __ibs_(0), __bufptr_(__bytebuf), __cv_(__pcvt), __st_(__state), __cm_(0), __owns_eb_(false), __owns_ib_(false), __always_noconv_(this->__cv_ ? this->__cv_->always_noconv() : false)         {
            this->setbuf(0, 4096);
        }
        template <class _Codecvt, class _Elem, class _Tr> wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert<_Codecvt, _Elem, _Tr>()         {
            this->__close();
            delete this->__cv_;
            if (this->__owns_eb_)
                delete [] this->__extbuf_;
            if (this->__owns_ib_)
                delete [] this->__intbuf_;
        }
        template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()         {
            if (this->__cv_ == 0 || this->__bufptr_ == 0)
                return traits_type::eof();
            bool __initial = this->__read_mode();
            std::__1::wbuffer_convert::char_type __1buf;
            if (this->gptr() == 0)
                this->setg(&__1buf, &__1buf + 1, &__1buf + 1);
            const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
            std::__1::wbuffer_convert::int_type __c = traits_type::eof();
            if (this->gptr() == this->egptr()) {
                memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(std::__1::wbuffer_convert::char_type));
                if (this->__always_noconv_) {
                    std::__1::streamsize __nmemb = static_cast<std::__1::streamsize>(this->egptr() - this->eback() - __unget_sz);
                    __nmemb = this->__bufptr_->sgetn((char *)this->eback() + __unget_sz, __nmemb);
                    if (__nmemb != 0) {
                        this->setg(this->eback(), this->eback() + __unget_sz, this->eback() + __unget_sz + __nmemb);
                        __c = *this->gptr();
                    }
                } else {
                    ((void)0);
                    if (this->__extbufend_ != this->__extbufnext_)
                        memmove(this->__extbuf_, this->__extbufnext_, this->__extbufend_ - this->__extbufnext_);
                    this->__extbufnext_ = this->__extbuf_ + (this->__extbufend_ - this->__extbufnext_);
                    this->__extbufend_ = this->__extbuf_ + (this->__extbuf_ == this->__extbuf_min_ ? sizeof (this->__extbuf_min_) : this->__ebs_);
                    std::__1::streamsize __nmemb = std::__1::min(static_cast<std::__1::streamsize>(this->egptr() - this->eback() - __unget_sz), static_cast<std::__1::streamsize>(this->__extbufend_ - this->__extbufnext_));
                    codecvt_base::result __r;
                    std::__1::streamsize __nr = this->__bufptr_->sgetn(const_cast<char *>(this->__extbufnext_), __nmemb);
                    if (__nr != 0) {
                        this->__extbufend_ = this->__extbufnext_ + __nr;
                        std::__1::wbuffer_convert::char_type *__inext;
                        __r = this->__cv_->in(this->__st_, this->__extbuf_, this->__extbufend_, this->__extbufnext_, this->eback() + __unget_sz, this->egptr(), __inext);
                        if (__r == codecvt_base::noconv) {
                            this->setg((std::__1::wbuffer_convert::char_type *)this->__extbuf_, (std::__1::wbuffer_convert::char_type *)this->__extbuf_, (std::__1::wbuffer_convert::char_type *)const_cast<char *>(this->__extbufend_));
                            __c = *this->gptr();
                        } else if (__inext != this->eback() + __unget_sz) {
                            this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                            __c = *this->gptr();
                        }
                    }
                }
            } else
                __c = *this->gptr();
            if (this->eback() == &__1buf)
                this->setg(0, 0, 0);
            return __c;
        }
        template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(std::__1::wbuffer_convert::int_type __c = traits_type::eof())         {
            if (this->__cv_ != 0 && this->__bufptr_ != 0 && this->eback() < this->gptr()) {
                if (traits_type::eq_int_type(__c, traits_type::eof())) {
                    this->gbump(-1);
                    return traits_type::not_eof(__c);
                }
                if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])) {
                    this->gbump(-1);
                    *this->gptr() = traits_type::to_char_type(__c);
                    return __c;
                }
            }
            return traits_type::eof();
        }
        template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(std::__1::wbuffer_convert::int_type __c = traits_type::eof())         {
            if (this->__cv_ == 0 || this->__bufptr_ == 0)
                return traits_type::eof();
            this->__write_mode();
            std::__1::wbuffer_convert::char_type __1buf;
            std::__1::wbuffer_convert::char_type *__pb_save = this->pbase();
            std::__1::wbuffer_convert::char_type *__epb_save = this->epptr();
            if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                if (this->pptr() == 0)
                    this->setp(&__1buf, &__1buf + 1);
                *this->pptr() = traits_type::to_char_type(__c);
                this->pbump(1);
            }
            if (this->pptr() != this->pbase()) {
                if (this->__always_noconv_) {
                    std::__1::streamsize __nmemb = static_cast<std::__1::streamsize>(this->pptr() - this->pbase());
                    if (this->__bufptr_->sputn((const char *)this->pbase(), __nmemb) != __nmemb)
                        return traits_type::eof();
                } else {
                    char *__extbe = this->__extbuf_;
                    codecvt_base::result __r;
                    do {
                        const std::__1::wbuffer_convert::char_type *__e;
                        __r = this->__cv_->out(this->__st_, this->pbase(), this->pptr(), __e, this->__extbuf_, this->__extbuf_ + this->__ebs_, __extbe);
                        if (__e == this->pbase())
                            return traits_type::eof();
                        if (__r == codecvt_base::noconv) {
                            std::__1::streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                            if (this->__bufptr_->sputn((const char *)this->pbase(), __nmemb) != __nmemb)
                                return traits_type::eof();
                        } else if (__r == codecvt_base::ok || __r == codecvt_base::partial) {
                            std::__1::streamsize __nmemb = static_cast<size_t>(__extbe - this->__extbuf_);
                            if (this->__bufptr_->sputn(this->__extbuf_, __nmemb) != __nmemb)
                                return traits_type::eof();
                            if (__r == codecvt_base::partial) {
                                this->setp(const_cast<std::__1::wbuffer_convert::char_type *>(__e), this->pptr());
                                this->__pbump(this->epptr() - this->pbase());
                            }
                        } else
                            return traits_type::eof();
                    } while (__r == codecvt_base::partial);
                }
                this->setp(__pb_save, __epb_save);
            }
            return traits_type::not_eof(__c);
        }
        template <class _Codecvt, class _Elem, class _Tr> basic_streambuf<_Elem, _Tr> *wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(std::__1::wbuffer_convert::char_type *__s, std::__1::streamsize __n)         {
            this->setg(0, 0, 0);
            this->setp(0, 0);
            if (this->__owns_eb_)
                delete [] this->__extbuf_;
            if (this->__owns_ib_)
                delete [] this->__intbuf_;
            this->__ebs_ = __n;
            if (this->__ebs_ > sizeof (this->__extbuf_min_)) {
                if (this->__always_noconv_ && __s) {
                    this->__extbuf_ = (char *)__s;
                    this->__owns_eb_ = false;
                } else {
                    this->__extbuf_ = new char [this->__ebs_];
                    this->__owns_eb_ = true;
                }
            } else {
                this->__extbuf_ = this->__extbuf_min_;
                this->__ebs_ = sizeof (this->__extbuf_min_);
                this->__owns_eb_ = false;
            }
            if (!this->__always_noconv_) {
                this->__ibs_ = max<std::__1::streamsize>(__n, sizeof (this->__extbuf_min_));
                if (__s && this->__ibs_ >= sizeof (this->__extbuf_min_)) {
                    this->__intbuf_ = __s;
                    this->__owns_ib_ = false;
                } else {
                    this->__intbuf_ = new std::__1::wbuffer_convert::char_type [this->__ibs_];
                    this->__owns_ib_ = true;
                }
            } else {
                this->__ibs_ = 0;
                this->__intbuf_ = 0;
                this->__owns_ib_ = false;
            }
            return this;
        }
        template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(std::__1::wbuffer_convert::off_type __off, ios_base::seekdir __way, ios_base::openmode __om = ios_base::in | ios_base::out)         {
            int __width = this->__cv_->encoding();
            if (this->__cv_ == 0 || this->__bufptr_ == 0 || (__width <= 0 && __off != 0) || this->sync())
                return std::__1::wbuffer_convert::pos_type(std::__1::wbuffer_convert::off_type(-1));
            if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
                return std::__1::wbuffer_convert::pos_type(std::__1::wbuffer_convert::off_type(-1));
            std::__1::wbuffer_convert::pos_type __r = this->__bufptr_->pubseekoff(__width * __off, __way, __om);
            __r.state(this->__st_);
            return __r;
        }
        template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(std::__1::wbuffer_convert::pos_type __sp, ios_base::openmode __wch = ios_base::in | ios_base::out)         {
            if (this->__cv_ == 0 || this->__bufptr_ == 0 || this->sync())
                return std::__1::wbuffer_convert::pos_type(std::__1::wbuffer_convert::off_type(-1));
            if (this->__bufptr_->pubseekpos(__sp, __wch) == std::__1::wbuffer_convert::pos_type(std::__1::wbuffer_convert::off_type(-1)))
                return std::__1::wbuffer_convert::pos_type(std::__1::wbuffer_convert::off_type(-1));
            return __sp;
        }
        template <class _Codecvt, class _Elem, class _Tr> int wbuffer_convert<_Codecvt, _Elem, _Tr>::sync()         {
            if (this->__cv_ == 0 || this->__bufptr_ == 0)
                return 0;
            if (this->__cm_ & ios_base::out) {
                if (this->pptr() != this->pbase())
                    if (this->overflow() == traits_type::eof())
                        return -1;
                codecvt_base::result __r;
                do {
                    char *__extbe;
                    __r = this->__cv_->unshift(this->__st_, this->__extbuf_, this->__extbuf_ + this->__ebs_, __extbe);
                    std::__1::streamsize __nmemb = static_cast<std::__1::streamsize>(__extbe - this->__extbuf_);
                    if (this->__bufptr_->sputn(this->__extbuf_, __nmemb) != __nmemb)
                        return -1;
                } while (__r == codecvt_base::partial);
                if (__r == codecvt_base::error)
                    return -1;
                if (this->__bufptr_->pubsync())
                    return -1;
            } else if (this->__cm_ & ios_base::in) {
                std::__1::wbuffer_convert::off_type __c;
                if (this->__always_noconv_)
                    __c = this->egptr() - this->gptr();
                else {
                    int __width = this->__cv_->encoding();
                    __c = this->__extbufend_ - this->__extbufnext_;
                    if (__width > 0)
                        __c += __width * (this->egptr() - this->gptr());
                    else {
                        if (this->gptr() != this->egptr()) {
                            reverse(this->gptr(), this->egptr());
                            codecvt_base::result __r;
                            const std::__1::wbuffer_convert::char_type *__e = this->gptr();
                            char *__extbe;
                            do {
                                __r = this->__cv_->out(this->__st_, __e, this->egptr(), __e, this->__extbuf_, this->__extbuf_ + this->__ebs_, __extbe);
                                switch (__r) {
                                  case codecvt_base::noconv:
                                    __c += this->egptr() - this->gptr();
                                    break;
                                  case codecvt_base::ok:
                                  case codecvt_base::partial:
                                    __c += __extbe - this->__extbuf_;
                                    break;
                                  default:
                                    return -1;
                                }
                            } while (__r == codecvt_base::partial);
                        }
                    }
                }
                if (this->__bufptr_->pubseekoff(- __c, ios_base::cur, this->__cm_) == std::__1::wbuffer_convert::pos_type(std::__1::wbuffer_convert::off_type(-1)))
                    return -1;
                this->setg(0, 0, 0);
                this->__cm_ = 0;
            }
            return 0;
        }
        template <class _Codecvt, class _Elem, class _Tr> bool wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()         {
            if (!(this->__cm_ & ios_base::in)) {
                this->setp(0, 0);
                if (this->__always_noconv_)
                    this->setg((std::__1::wbuffer_convert::char_type *)this->__extbuf_, (std::__1::wbuffer_convert::char_type *)this->__extbuf_ + this->__ebs_, (std::__1::wbuffer_convert::char_type *)this->__extbuf_ + this->__ebs_);
                else
                    this->setg(this->__intbuf_, this->__intbuf_ + this->__ibs_, this->__intbuf_ + this->__ibs_);
                this->__cm_ = ios_base::in;
                return true;
            }
            return false;
        }
        template <class _Codecvt, class _Elem, class _Tr> void wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()         {
            if (!(this->__cm_ & ios_base::out)) {
                this->setg(0, 0, 0);
                if (this->__ebs_ > sizeof (this->__extbuf_min_)) {
                    if (this->__always_noconv_)
                        this->setp((std::__1::wbuffer_convert::char_type *)this->__extbuf_, (std::__1::wbuffer_convert::char_type *)this->__extbuf_ + (this->__ebs_ - 1));
                    else
                        this->setp(this->__intbuf_, this->__intbuf_ + (this->__ibs_ - 1));
                } else
                    this->setp(0, 0);
                this->__cm_ = ios_base::out;
            }
        }
        template <class _Codecvt, class _Elem, class _Tr> wbuffer_convert<_Codecvt, _Elem, _Tr> *wbuffer_convert<_Codecvt, _Elem, _Tr>::__close()         {
            wbuffer_convert<_Codecvt, _Elem, _Tr> *__rt = 0;
            if (this->__cv_ != 0 && this->__bufptr_ != 0) {
                __rt = this;
                if ((this->__cm_ & ios_base::out) && this->sync())
                    __rt = 0;
            }
            return __rt;
        }
    }
}
namespace std {
    inline namespace __1 {
        template <size_t _N_words, size_t _Size> class __bitset;
        template <size_t _N_words, size_t _Size> struct __has_storage_type<__bitset<_N_words, _Size>> {
            static const bool value = true;
        };
        template <size_t _N_words, size_t _Size> class __bitset {
        public:
            typedef ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef std::__1::__bitset::size_type __storage_type;
        protected:
            typedef __bitset<_N_words, _Size> __self;
            typedef std::__1::__bitset::__storage_type *__storage_pointer;
            typedef const std::__1::__bitset::__storage_type *__const_storage_pointer;
            static const unsigned int __bits_per_word = static_cast<unsigned int>(sizeof(std::__1::__bitset::__storage_type) * 8);
            friend  class __bit_reference<__bitset<_N_words, _Size> >;
            friend  class __bit_const_reference<__bitset<_N_words, _Size> >;
            friend  class __bit_iterator<__bitset<_N_words, _Size>, false>;
            friend  class __bit_iterator<__bitset<_N_words, _Size>, true>;
            friend  struct __bit_array<__bitset<_N_words, _Size> >;
            std::__1::__bitset::__storage_type __first_[_N_words];
            typedef __bit_reference<__bitset<_N_words, _Size> > reference;
            typedef __bit_const_reference<__bitset<_N_words, _Size> > const_reference;
            typedef __bit_iterator<__bitset<_N_words, _Size>, false> iterator;
            typedef __bit_iterator<__bitset<_N_words, _Size>, true> const_iterator;
            __bitset<_N_words, _Size>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit __bitset<_N_words, _Size>(unsigned long long __v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::__bitset::reference __make_ref(size_t __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset::reference(this->__first_ + __pos / __bits_per_word, std::__1::__bitset::__storage_type(1) << __pos % __bits_per_word);
            }
            std::__1::__bitset::const_reference __make_ref(size_t __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset::const_reference(this->__first_ + __pos / __bits_per_word, std::__1::__bitset::__storage_type(1) << __pos % __bits_per_word);
            }
            std::__1::__bitset::iterator __make_iter(size_t __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset::iterator(this->__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
            }
            std::__1::__bitset::const_iterator __make_iter(size_t __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset::const_iterator(this->__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
            }
            void operator&=(const __bitset<_N_words, _Size> &__v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void operator|=(const __bitset<_N_words, _Size> &__v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void operator^=(const __bitset<_N_words, _Size> &__v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void flip() throw();
            unsigned long to_ulong() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());
            }
            unsigned long long to_ullong() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());
            }
            bool all() const throw();
            bool any() const throw();
            size_t __hash_code() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        private:
            void __init(unsigned long long __v, std::__1::false_type) throw();
            void __init(unsigned long long __v, std::__1::true_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            unsigned long to_ulong(std::__1::false_type) const;
            unsigned long to_ulong(std::__1::true_type) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            unsigned long long to_ullong(std::__1::false_type) const;
            unsigned long long to_ullong(std::__1::true_type) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            unsigned long long to_ullong(std::__1::true_type, std::__1::false_type) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            unsigned long long to_ullong(std::__1::true_type, std::__1::true_type) const;
        };
        template <size_t _N_words, size_t _Size> inline __bitset<_N_words, _Size>::__bitset<_N_words, _Size>() throw()         {
            std::__1::fill_n(this->__first_, _N_words, std::__1::__bitset::__storage_type(0));
        }
        template <size_t _N_words, size_t _Size> void __bitset<_N_words, _Size>::__init(unsigned long long __v, std::__1::false_type) throw()         {
            std::__1::__bitset::__storage_type __t[1];
            size_t __sz = _Size;
            for (size_t __i = 0; __i < sizeof (__t) / sizeof (__t[0]); ++__i , __v >>= __bits_per_word , __sz -= __bits_per_word)
                if (__sz < __bits_per_word)
                    __t[__i] = static_cast<std::__1::__bitset::__storage_type>(__v) & (1ULL << __sz) - 1;
                else
                    __t[__i] = static_cast<std::__1::__bitset::__storage_type>(__v);
            std::__1::copy(__t, __t + sizeof (__t) / sizeof (__t[0]), this->__first_);
            std::__1::fill(this->__first_ + sizeof (__t) / sizeof (__t[0]), this->__first_ + sizeof (this->__first_) / sizeof (this->__first_[0]), std::__1::__bitset::__storage_type(0));
        }
        template <size_t _N_words, size_t _Size> inline void __bitset<_N_words, _Size>::__init(unsigned long long __v, std::__1::true_type) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            this->__first_[0] = __v;
            if (_Size < __bits_per_word)
                this->__first_[0] &= (1ULL << _Size) - 1;
            std::__1::fill(this->__first_ + 1, this->__first_ + sizeof (this->__first_) / sizeof (this->__first_[0]), std::__1::__bitset::__storage_type(0));
        }
        template <size_t _N_words, size_t _Size> inline explicit __bitset<_N_words, _Size>::__bitset<_N_words, _Size>(unsigned long long __v) throw()         {
            __init(__v, integral_constant<bool, sizeof(unsigned long long) == sizeof(std::__1::__bitset::__storage_type)>());
        }
        template <size_t _N_words, size_t _Size> inline void __bitset<_N_words, _Size>::operator&=(const __bitset<_N_words, _Size> &__v) throw()         {
            for (std::__1::__bitset::size_type __i = 0; __i < _N_words; ++__i)
                this->__first_[__i] &= __v.__first_[__i];
        }
        template <size_t _N_words, size_t _Size> inline void __bitset<_N_words, _Size>::operator|=(const __bitset<_N_words, _Size> &__v) throw()         {
            for (std::__1::__bitset::size_type __i = 0; __i < _N_words; ++__i)
                this->__first_[__i] |= __v.__first_[__i];
        }
        template <size_t _N_words, size_t _Size> inline void __bitset<_N_words, _Size>::operator^=(const __bitset<_N_words, _Size> &__v) throw()         {
            for (std::__1::__bitset::size_type __i = 0; __i < _N_words; ++__i)
                this->__first_[__i] ^= __v.__first_[__i];
        }
        template <size_t _N_words, size_t _Size> void __bitset<_N_words, _Size>::flip() throw()         {
            std::__1::__bitset::size_type __n = _Size;
            std::__1::__bitset::__storage_pointer __p = this->__first_;
            for (; __n >= __bits_per_word; ++__p , __n -= __bits_per_word)
                *__p = ~*__p;
            if (__n > 0) {
                std::__1::__bitset::__storage_type __m = ~std::__1::__bitset::__storage_type(0) >> (__bits_per_word - __n);
                std::__1::__bitset::__storage_type __b = *__p & __m;
                *__p &= ~__m;
                *__p |= ~__b & __m;
            }
        }
        template <size_t _N_words, size_t _Size> unsigned long __bitset<_N_words, _Size>::to_ulong(std::__1::false_type) const         {
            std::__1::__bitset::const_iterator __e = __make_iter(_Size);
            std::__1::__bitset::const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
            if (__i != __e)
                __throw_overflow_error("bitset to_ulong overflow error");
            return this->__first_[0];
        }
        template <size_t _N_words, size_t _Size> inline unsigned long __bitset<_N_words, _Size>::to_ulong(std::__1::true_type) const         {
            return this->__first_[0];
        }
        template <size_t _N_words, size_t _Size> unsigned long long __bitset<_N_words, _Size>::to_ullong(std::__1::false_type) const         {
            std::__1::__bitset::const_iterator __e = __make_iter(_Size);
            std::__1::__bitset::const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
            if (__i != __e)
                __throw_overflow_error("bitset to_ullong overflow error");
            return to_ullong(std::__1::true_type());
        }
        template <size_t _N_words, size_t _Size> inline unsigned long long __bitset<_N_words, _Size>::to_ullong(std::__1::true_type) const         {
            return to_ullong(std::__1::true_type(), integral_constant<bool, sizeof(std::__1::__bitset::__storage_type) < sizeof(unsigned long long)>());
        }
        template <size_t _N_words, size_t _Size> inline unsigned long long __bitset<_N_words, _Size>::to_ullong(std::__1::true_type, std::__1::false_type) const         {
            return this->__first_[0];
        }
        template <size_t _N_words, size_t _Size> unsigned long long __bitset<_N_words, _Size>::to_ullong(std::__1::true_type, std::__1::true_type) const         {
            unsigned long long __r = this->__first_[0];
            for (std::size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(std::__1::__bitset::__storage_type); ++__i)
                __r |= static_cast<unsigned long long>(this->__first_[__i]) << (sizeof(std::__1::__bitset::__storage_type) * 8);
            return __r;
        }
        template <size_t _N_words, size_t _Size> bool __bitset<_N_words, _Size>::all() const throw()         {
            std::__1::__bitset::size_type __n = _Size;
            std::__1::__bitset::__const_storage_pointer __p = this->__first_;
            for (; __n >= __bits_per_word; ++__p , __n -= __bits_per_word)
                if (~*__p)
                    return false;
            if (__n > 0) {
                std::__1::__bitset::__storage_type __m = ~std::__1::__bitset::__storage_type(0) >> (__bits_per_word - __n);
                if (~*__p & __m)
                    return false;
            }
            return true;
        }
        template <size_t _N_words, size_t _Size> bool __bitset<_N_words, _Size>::any() const throw()         {
            std::__1::__bitset::size_type __n = _Size;
            std::__1::__bitset::__const_storage_pointer __p = this->__first_;
            for (; __n >= __bits_per_word; ++__p , __n -= __bits_per_word)
                if (*__p)
                    return true;
            if (__n > 0) {
                std::__1::__bitset::__storage_type __m = ~std::__1::__bitset::__storage_type(0) >> (__bits_per_word - __n);
                if (*__p & __m)
                    return true;
            }
            return false;
        }
        template <size_t _N_words, size_t _Size> inline size_t __bitset<_N_words, _Size>::__hash_code() const throw()         {
            size_t __h = 0;
            for (std::__1::__bitset::size_type __i = 0; __i < _N_words; ++__i)
                __h ^= this->__first_[__i];
            return __h;
        }
        template <size_t _Size> class __bitset<1, _Size> {
        public:
            typedef ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef std::__1::__bitset<1, _Size>::size_type __storage_type;
        protected:
            typedef __bitset<1, _Size> __self;
            typedef std::__1::__bitset<1, _Size>::__storage_type *__storage_pointer;
            typedef const std::__1::__bitset<1, _Size>::__storage_type *__const_storage_pointer;
            static const unsigned int __bits_per_word = static_cast<unsigned int>(sizeof(std::__1::__bitset<1, _Size>::__storage_type) * 8);
            friend  class __bit_reference<__bitset<1, _Size> >;
            friend  class __bit_const_reference<__bitset<1, _Size> >;
            friend  class __bit_iterator<__bitset<1, _Size>, false>;
            friend  class __bit_iterator<__bitset<1, _Size>, true>;
            friend  struct __bit_array<__bitset<1, _Size> >;
            std::__1::__bitset<1, _Size>::__storage_type __first_;
            typedef __bit_reference<__bitset<1, _Size> > reference;
            typedef __bit_const_reference<__bitset<1, _Size> > const_reference;
            typedef __bit_iterator<__bitset<1, _Size>, false> iterator;
            typedef __bit_iterator<__bitset<1, _Size>, true> const_iterator;
            __bitset<1, _Size>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit __bitset<1, _Size>(unsigned long long __v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::__bitset<1, _Size>::reference __make_ref(size_t __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset<1, _Size>::reference(&this->__first_, std::__1::__bitset<1, _Size>::__storage_type(1) << __pos);
            }
            std::__1::__bitset<1, _Size>::const_reference __make_ref(size_t __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset<1, _Size>::const_reference(&this->__first_, std::__1::__bitset<1, _Size>::__storage_type(1) << __pos);
            }
            std::__1::__bitset<1, _Size>::iterator __make_iter(size_t __pos) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset<1, _Size>::iterator(&this->__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
            }
            std::__1::__bitset<1, _Size>::const_iterator __make_iter(size_t __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset<1, _Size>::const_iterator(&this->__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
            }
            void operator&=(const __bitset<1, _Size> &__v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void operator|=(const __bitset<1, _Size> &__v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void operator^=(const __bitset<1, _Size> &__v) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void flip() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            unsigned long to_ulong() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            unsigned long long to_ullong() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool all() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool any() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            size_t __hash_code() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        };
        template <size_t _Size> inline __bitset<1, _Size>::__bitset<1, _Size>() throw() : __first_(0)         {
        }
        template <size_t _Size> inline explicit __bitset<1, _Size>::__bitset<1, _Size>(unsigned long long __v) throw() : __first_(_Size == __bits_per_word ? static_cast<std::__1::__bitset<1, _Size>::__storage_type>(__v) : static_cast<std::__1::__bitset<1, _Size>::__storage_type>(__v) & ((std::__1::__bitset<1, _Size>::__storage_type(1) << _Size) - 1))         {
        }
        template <size_t _Size> inline void __bitset<1, _Size>::operator&=(const __bitset<1, _Size> &__v) throw()         {
            this->__first_ &= __v.__first_;
        }
        template <size_t _Size> inline void __bitset<1, _Size>::operator|=(const __bitset<1, _Size> &__v) throw()         {
            this->__first_ |= __v.__first_;
        }
        template <size_t _Size> inline void __bitset<1, _Size>::operator^=(const __bitset<1, _Size> &__v) throw()         {
            this->__first_ ^= __v.__first_;
        }
        template <size_t _Size> inline void __bitset<1, _Size>::flip() throw()         {
            std::__1::__bitset<1, _Size>::__storage_type __m = ~std::__1::__bitset<1, _Size>::__storage_type(0) >> (__bits_per_word - _Size);
            this->__first_ = ~this->__first_;
            this->__first_ &= __m;
        }
        template <size_t _Size> inline unsigned long __bitset<1, _Size>::to_ulong() const         {
            return this->__first_;
        }
        template <size_t _Size> inline unsigned long long __bitset<1, _Size>::to_ullong() const         {
            return this->__first_;
        }
        template <size_t _Size> inline bool __bitset<1, _Size>::all() const throw()         {
            std::__1::__bitset<1, _Size>::__storage_type __m = ~std::__1::__bitset<1, _Size>::__storage_type(0) >> (__bits_per_word - _Size);
            return !(~this->__first_ & __m);
        }
        template <size_t _Size> inline bool __bitset<1, _Size>::any() const throw()         {
            std::__1::__bitset<1, _Size>::__storage_type __m = ~std::__1::__bitset<1, _Size>::__storage_type(0) >> (__bits_per_word - _Size);
            return this->__first_ & __m;
        }
        template <size_t _Size> inline size_t __bitset<1, _Size>::__hash_code() const throw()         {
            return this->__first_;
        }
        template<> class __bitset<0, 0> {
        public:
            typedef ptrdiff_t difference_type;
            typedef size_t size_type;
            typedef std::__1::__bitset<0, 0>::size_type __storage_type;
        protected:
            typedef std::__1::__bitset<0, 0> __self;
            typedef std::__1::__bitset<0, 0>::__storage_type *__storage_pointer;
            typedef const std::__1::__bitset<0, 0>::__storage_type *__const_storage_pointer;
            static const unsigned int __bits_per_word = static_cast<unsigned int>(sizeof(std::__1::__bitset<0, 0>::__storage_type) * 8);
            friend  class __bit_reference<__bitset<0, 0> >;
            friend  class __bit_const_reference<__bitset<0, 0> >;
            friend  class __bit_iterator<__bitset<0, 0>, false>;
            friend  class __bit_iterator<__bitset<0, 0>, true>;
            friend  struct __bit_array<__bitset<0, 0> >;
            typedef __bit_reference<std::__1::__bitset<0, 0> > reference;
            typedef __bit_const_reference<std::__1::__bitset<0, 0> > const_reference;
            typedef __bit_iterator<std::__1::__bitset<0, 0>, false> iterator;
            typedef __bit_iterator<std::__1::__bitset<0, 0>, true> const_iterator;
            __bitset() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit __bitset(unsigned long long) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            std::__1::__bitset<0, 0>::reference __make_ref(size_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset<0, 0>::reference(0, 1);
            }
            std::__1::__bitset<0, 0>::const_reference __make_ref(size_t) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset<0, 0>::const_reference(0, 1);
            }
            std::__1::__bitset<0, 0>::iterator __make_iter(size_t) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset<0, 0>::iterator(0, 0);
            }
            std::__1::__bitset<0, 0>::const_iterator __make_iter(size_t) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return std::__1::__bitset<0, 0>::const_iterator(0, 0);
            }
            void operator&=(const std::__1::__bitset<0, 0> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void operator|=(const std::__1::__bitset<0, 0> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void operator^=(const std::__1::__bitset<0, 0> &) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            void flip() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            unsigned long to_ulong() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return 0;
            }
            unsigned long long to_ullong() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return 0;
            }
            bool all() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return true;
            }
            bool any() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return false;
            }
            size_t __hash_code() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return 0;
            }
        };
        inline __bitset<0, 0>::__bitset() throw()         {
        }
        inline explicit __bitset<0, 0>::__bitset(unsigned long long) throw()         {
        }
        template <size_t _Size> class __attribute__((type_visibility("default"))) bitset;
        template <size_t _Size> struct hash<bitset<_Size>>;
        template <size_t _Size> class __attribute__((type_visibility("default"))) bitset : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size> {
        public:
            static const unsigned int __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
            typedef __bitset<__n_words, _Size> base;
        public:
            typedef typename base::reference reference;
            typedef typename base::const_reference const_reference;
            bitset<_Size>() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            bitset<_Size>(unsigned long long __v) throw() : std::__1::bitset::base(__v) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            template <class _CharT, class = _EnableIf<_IsCharLikeType<_CharT>::value>> explicit bitset<_Size>(const _CharT *__str, typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos, _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
            template <class _CharT, class _Traits, class _Allocator> explicit bitset<_Size>(const basic_string<_CharT, _Traits, _Allocator> &__str, typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos = 0, typename basic_string<_CharT, _Traits, _Allocator>::size_type __n = (basic_string<_CharT, _Traits, _Allocator>::npos), _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
            bitset<_Size> &operator&=(const bitset<_Size> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bitset<_Size> &operator|=(const bitset<_Size> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bitset<_Size> &operator^=(const bitset<_Size> &__rhs) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bitset<_Size> &operator<<=(size_t __pos) throw();
            bitset<_Size> &operator>>=(size_t __pos) throw();
            bitset<_Size> &set() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bitset<_Size> &set(size_t __pos, bool __val = true);
            bitset<_Size> &reset() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bitset<_Size> &reset(size_t __pos);
            bitset<_Size> operator~() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bitset<_Size> &flip() throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bitset<_Size> &flip(size_t __pos);
            std::__1::bitset::const_reference operator[](size_t __p) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return base::__make_ref(__p);
            }
            std::__1::bitset::reference operator[](size_t __p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return base::__make_ref(__p);
            }
            unsigned long to_ulong() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            unsigned long long to_ullong() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
            template <class _CharT, class _Traits> basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            template <class _CharT> basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0', char __one = '1') const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            size_t count() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            size_t size() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return _Size;
            }
            bool operator==(const bitset<_Size> &__rhs) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool operator!=(const bitset<_Size> &__rhs) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool test(size_t __pos) const;
            bool all() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool any() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool none() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return !this->any();
            }
            bitset<_Size> operator<<(size_t __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bitset<_Size> operator>>(size_t __pos) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        private:
            size_t __hash_code() const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return base::__hash_code();
            }
            friend  struct hash<bitset<_Size> >;
        };
        template <size_t _Size> template <class _CharT, class = _EnableIf<_IsCharLikeType<_CharT>::value>> explicit bitset<_Size>::bitset<_Size>(const _CharT *__str, typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos, _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))         {
            size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
            for (size_t __i = 0; __i < __rlen; ++__i)
                if (__str[__i] != __zero && __str[__i] != __one)
                    __throw_invalid_argument("bitset string ctor has invalid argument");
            size_t _Mp = std::__1::min(__rlen, _Size);
            size_t __i = 0;
            for (; __i < _Mp; ++__i) {
                _CharT __c = __str[_Mp - 1 - __i];
                if (__c == __zero)
                    (*this)[__i] = false;
                else
                    (*this)[__i] = true;
            }
            std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
        }
        template <size_t _Size> template <class _CharT, class _Traits, class _Allocator> explicit bitset<_Size>::bitset<_Size>(const basic_string<_CharT, _Traits, _Allocator> &__str, typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos = 0, typename basic_string<_CharT, _Traits, _Allocator>::size_type __n = (basic_string<_CharT, _Traits, _Allocator>::npos), _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))         {
            if (__pos > __str.size())
                __throw_out_of_range("bitset string pos out of range");
            size_t __rlen = std::__1::min(__n, __str.size() - __pos);
            for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
                if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
                    __throw_invalid_argument("bitset string ctor has invalid argument");
            size_t _Mp = std::__1::min(__rlen, _Size);
            size_t __i = 0;
            for (; __i < _Mp; ++__i) {
                _CharT __c = __str[__pos + _Mp - 1 - __i];
                if (_Traits::eq(__c, __zero))
                    (*this)[__i] = false;
                else
                    (*this)[__i] = true;
            }
            std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
        }
        template <size_t _Size> inline bitset<_Size> &bitset<_Size>::operator&=(const bitset<_Size> &__rhs) throw()         {
            base::operator&=(__rhs);
            return *this;
        }
        template <size_t _Size> inline bitset<_Size> &bitset<_Size>::operator|=(const bitset<_Size> &__rhs) throw()         {
            base::operator|=(__rhs);
            return *this;
        }
        template <size_t _Size> inline bitset<_Size> &bitset<_Size>::operator^=(const bitset<_Size> &__rhs) throw()         {
            base::operator^=(__rhs);
            return *this;
        }
        template <size_t _Size> bitset<_Size> &bitset<_Size>::operator<<=(size_t __pos) throw()         {
            __pos = std::__1::min(__pos, _Size);
            std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
            std::__1::fill_n(base::__make_iter(0), __pos, false);
            return *this;
        }
        template <size_t _Size> bitset<_Size> &bitset<_Size>::operator>>=(size_t __pos) throw()         {
            __pos = std::__1::min(__pos, _Size);
            std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
            std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
            return *this;
        }
        template <size_t _Size> inline bitset<_Size> &bitset<_Size>::set() throw()         {
            std::__1::fill_n(base::__make_iter(0), _Size, true);
            return *this;
        }
        template <size_t _Size> bitset<_Size> &bitset<_Size>::set(size_t __pos, bool __val = true)         {
            if (__pos >= _Size)
                __throw_out_of_range("bitset set argument out of range");
            (*this)[__pos] = __val;
            return *this;
        }
        template <size_t _Size> inline bitset<_Size> &bitset<_Size>::reset() throw()         {
            std::__1::fill_n(base::__make_iter(0), _Size, false);
            return *this;
        }
        template <size_t _Size> bitset<_Size> &bitset<_Size>::reset(size_t __pos)         {
            if (__pos >= _Size)
                __throw_out_of_range("bitset reset argument out of range");
            (*this)[__pos] = false;
            return *this;
        }
        template <size_t _Size> inline bitset<_Size> bitset<_Size>::operator~() const throw()         {
            bitset<_Size> __x(*this);
            __x.flip();
            return __x;
        }
        template <size_t _Size> inline bitset<_Size> &bitset<_Size>::flip() throw()         {
            base::flip();
            return *this;
        }
        template <size_t _Size> bitset<_Size> &bitset<_Size>::flip(size_t __pos)         {
            if (__pos >= _Size)
                __throw_out_of_range("bitset flip argument out of range");
            std::__1::bitset::reference r = base::__make_ref(__pos);
            r = ~r;
            return *this;
        }
        template <size_t _Size> inline unsigned long bitset<_Size>::to_ulong() const         {
            return base::to_ulong();
        }
        template <size_t _Size> inline unsigned long long bitset<_Size>::to_ullong() const         {
            return base::to_ullong();
        }
        template <size_t _Size> template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> bitset<_Size>::to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const         {
            basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
            for (size_t __i = 0; __i < _Size; ++__i) {
                if ((*this)[__i])
                    __r[_Size - 1 - __i] = __one;
            }
            return __r;
        }
        template <size_t _Size> template <class _CharT, class _Traits> inline basic_string<_CharT, _Traits, allocator<_CharT> > bitset<_Size>::to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const         {
            return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
        }
        template <size_t _Size> template <class _CharT> inline basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > bitset<_Size>::to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const         {
            return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
        }
        template <size_t _Size> inline basic_string<char, char_traits<char>, allocator<char> > bitset<_Size>::to_string(char __zero = '0', char __one = '1') const         {
            return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
        }
        template <size_t _Size> inline size_t bitset<_Size>::count() const throw()         {
            return static_cast<size_t>(__count_bool_true(base::__make_iter(0), _Size));
        }
        template <size_t _Size> inline bool bitset<_Size>::operator==(const bitset<_Size> &__rhs) const throw()         {
            return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
        }
        template <size_t _Size> inline bool bitset<_Size>::operator!=(const bitset<_Size> &__rhs) const throw()         {
            return !(*this == __rhs);
        }
        template <size_t _Size> bool bitset<_Size>::test(size_t __pos) const         {
            if (__pos >= _Size)
                __throw_out_of_range("bitset test argument out of range");
            return (*this)[__pos];
        }
        template <size_t _Size> inline bool bitset<_Size>::all() const throw()         {
            return base::all();
        }
        template <size_t _Size> inline bool bitset<_Size>::any() const throw()         {
            return base::any();
        }
        template <size_t _Size> inline bitset<_Size> bitset<_Size>::operator<<(size_t __pos) const throw()         {
            bitset<_Size> __r = *this;
            __r <<= __pos;
            return __r;
        }
        template <size_t _Size> inline bitset<_Size> bitset<_Size>::operator>>(size_t __pos) const throw()         {
            bitset<_Size> __r = *this;
            __r >>= __pos;
            return __r;
        }
        template <size_t _Size> inline bitset<_Size> operator&(const bitset<_Size> &__x, const bitset<_Size> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            bitset<_Size> __r = __x;
            __r &= __y;
            return __r;
        }
        template <size_t _Size> inline bitset<_Size> operator|(const bitset<_Size> &__x, const bitset<_Size> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            bitset<_Size> __r = __x;
            __r |= __y;
            return __r;
        }
        template <size_t _Size> inline bitset<_Size> operator^(const bitset<_Size> &__x, const bitset<_Size> &__y) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            bitset<_Size> __r = __x;
            __r ^= __y;
            return __r;
        }
        template <size_t _Size> struct __attribute__((type_visibility("default"))) hash<bitset<_Size>> : public unary_function<bitset<_Size>, size_t> {
            size_t operator()(const bitset<_Size> &__bs) const throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __bs.__hash_code();
            }
        };
        template <class _CharT, class _Traits, size_t _Size> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, bitset<_Size> &__x);
        template <class _CharT, class _Traits, size_t _Size> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const bitset<_Size> &__x);
    }
}
namespace std {
    inline namespace __1 {
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ostream : virtual public basic_ios<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            inline explicit basic_ostream<_CharT, _Traits>(basic_streambuf<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> *__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->init(__sb);
            }
            virtual ~basic_ostream<_CharT, _Traits>();
        protected:
            inline void swap(basic_ostream<_CharT, _Traits> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                basic_ios<char_type, traits_type>::swap(__rhs);
            }
            basic_ostream<_CharT, _Traits>(const basic_ostream<_CharT, _Traits> &__rhs);
            basic_ostream<_CharT, _Traits> &operator=(const basic_ostream<_CharT, _Traits> &__rhs);
        public:
            class __attribute__((type_visibility("default"))) sentry;
            inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &(*__pf)(basic_ostream<_CharT, _Traits> &)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __pf(*this);
            }
            inline basic_ostream<_CharT, _Traits> &operator<<(basic_ios<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> &(*__pf)(basic_ios<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> &)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __pf(*this);
                return *this;
            }
            inline basic_ostream<_CharT, _Traits> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __pf(*this);
                return *this;
            }
            basic_ostream<_CharT, _Traits> &operator<<(bool __n);
            basic_ostream<_CharT, _Traits> &operator<<(short __n);
            basic_ostream<_CharT, _Traits> &operator<<(unsigned short __n);
            basic_ostream<_CharT, _Traits> &operator<<(int __n);
            basic_ostream<_CharT, _Traits> &operator<<(unsigned int __n);
            basic_ostream<_CharT, _Traits> &operator<<(long __n);
            basic_ostream<_CharT, _Traits> &operator<<(unsigned long __n);
            basic_ostream<_CharT, _Traits> &operator<<(long long __n);
            basic_ostream<_CharT, _Traits> &operator<<(unsigned long long __n);
            basic_ostream<_CharT, _Traits> &operator<<(float __f);
            basic_ostream<_CharT, _Traits> &operator<<(double __f);
            basic_ostream<_CharT, _Traits> &operator<<(long double __f);
            basic_ostream<_CharT, _Traits> &operator<<(const void *__p);
            basic_ostream<_CharT, _Traits> &operator<<(basic_streambuf<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> *__sb);
            basic_ostream<_CharT, _Traits> &operator<<(std::__1::nullptr_t) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return *this << "nullptr";
            }
            basic_ostream<_CharT, _Traits> &put(std::__1::basic_ostream::char_type __c);
            basic_ostream<_CharT, _Traits> &write(const std::__1::basic_ostream::char_type *__s, std::__1::streamsize __n);
            basic_ostream<_CharT, _Traits> &flush();
            inline std::__1::basic_ostream::pos_type tellp() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline basic_ostream<_CharT, _Traits> &seekp(std::__1::basic_ostream::pos_type __pos) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline basic_ostream<_CharT, _Traits> &seekp(std::__1::basic_ostream::off_type __off, ios_base::seekdir __dir) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        protected:
            basic_ostream<_CharT, _Traits>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
        };
        class __attribute__((type_visibility("default"))) sentry {
            bool __ok_;
            basic_ostream<_CharT, _Traits> &__os_;
            sentry(const std::__1::basic_ostream::sentry &);
            std::__1::basic_ostream::sentry &operator=(const std::__1::basic_ostream::sentry &);
        public:
            explicit sentry(basic_ostream<_CharT, _Traits> &__os);
            ~sentry();
            operator bool() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ok_;
            }
        };
        template <class _CharT, class _Traits> explicit basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits> &__os) : __ok_(false), __os_(__os)         {
            if (__os.good()) {
                if (__os.tie())
                    __os.tie()->flush();
                this->__ok_ = true;
            }
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>::sentry::~sentry()         {
            if (this->__os_.rdbuf() && this->__os_.good() && (this->__os_.flags() & ios_base::unitbuf) && !uncaught_exception()) {
                try {
                    if (this->__os_.rdbuf()->pubsync() == -1)
                        this->__os_.setstate(ios_base::badbit);
                } catch (...) {
                }
            }
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>::~basic_ostream<_CharT, _Traits>()         {
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> *__sb)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    if (__sb) {
                        try {
                            typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                            typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                            _Ip __i(__sb);
                            _Ip __eof;
                            _Op __o(*this);
                            size_t __c = 0;
                            for (; __i != __eof; ++__i , ++__o , ++__c) {
                                *__o = *__i;
                                if (__o.failed())
                                    break;
                            }
                            if (__c == 0)
                                this->setstate(ios_base::failbit);
                        } catch (...) {
                            this->__set_failbit_and_consider_rethrow();
                        }
                    } else
                        this->setstate(ios_base::badbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(bool __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(short __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __flags == ios_base::oct || __flags == ios_base::hex ? static_cast<long>(static_cast<unsigned short>(__n)) : static_cast<long>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(int __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __flags == ios_base::oct || __flags == ios_base::hex ? static_cast<long>(static_cast<unsigned int>(__n)) : static_cast<long>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(long __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(long long __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(float __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(double __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(long double __n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(const void *__n)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef num_put<std::__1::basic_ostream::char_type, ostreambuf_iterator<std::__1::basic_ostream::char_type, std::__1::basic_ostream::traits_type> > _Fp;
                    const _Fp &__f = use_facet<_Fp>(this->getloc());
                    if (__f.put(*this, *this, this->fill(), __n).failed())
                        this->setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &__put_character_sequence(basic_ostream<_CharT, _Traits> &__os, const _CharT *__str, size_t __len)         {
            try {
                typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
                if (__s) {
                    typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
                    if (__pad_and_output(_Ip(__os), __str, (__os.flags() & ios_base::adjustfield) == ios_base::left ? __str + __len : __str, __str + __len, __os, __os.fill()).failed())
                        __os.setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &__put_character_sequence<char, std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, const char *__str, size_t __len)         {
            try {
                typename basic_ostream<char, char_traits<char> >::sentry __s(__os);
                if (__s) {
                    typedef ostreambuf_iterator<char, std::__1::char_traits<char> > _Ip;
                    if (__pad_and_output(_Ip(__os), __str, (__os.flags() & ios_base::adjustfield) == ios_base::left ? __str + __len : __str, __str + __len, __os, __os.fill()).failed())
                        __os.setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, _CharT __c)         {
            return std::__1::__put_character_sequence(__os, & __c, 1);
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<char, std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, char __c)        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, char __cn)         {
            try {
                typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
                if (__s) {
                    _CharT __c = __os.widen(__cn);
                    typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
                    if (__pad_and_output(_Ip(__os), & __c, (__os.flags() & ios_base::adjustfield) == ios_base::left ? & __c + 1 : & __c, & __c + 1, __os, __os.fill()).failed())
                        __os.setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<char, std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, char __cn)        template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, char __c)         {
            return std::__1::__put_character_sequence(__os, &__c, 1);
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, char __c)        template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, signed char __c)         {
            return std::__1::__put_character_sequence(__os, (char *)&__c, 1);
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, signed char __c)        template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, unsigned char __c)         {
            return std::__1::__put_character_sequence(__os, (char *)&__c, 1);
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, unsigned char __c)        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const _CharT *__str)         {
            return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<char, std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, const char *__str)        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const char *__strn)         {
            try {
                typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
                if (__s) {
                    typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
                    size_t __len = char_traits<char>::length(__strn);
                    const int __bs = 100;
                    _CharT __wbb[100];
                    _CharT *__wb = __wbb;
                    unique_ptr<_CharT, void (*)(void *)> __h(0, free);
                    if (__len > __bs) {
                        __wb = (_CharT *)malloc(__len * sizeof(_CharT));
                        if (__wb == 0)
                            __throw_bad_alloc();
                        __h.reset(__wb);
                    }
                    for (_CharT *__p = __wb; *__strn != '\x00'; ++__strn , ++__p)
                        *__p = __os.widen(*__strn);
                    if (__pad_and_output(_Ip(__os), __wb, (__os.flags() & ios_base::adjustfield) == ios_base::left ? __wb + __len : __wb, __wb + __len, __os, __os.fill()).failed())
                        __os.setstate(ios_base::badbit | ios_base::failbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<char, std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, const char *__strn)        template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, const char *__str)         {
            return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, const char *__str)         {
            return std::__1::__put_character_sequence(__os, __str, char_traits<char>::length(__str));
        }
        template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, const signed char *__str)         {
            const char *__s = (const char *)__str;
            return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
        }
        template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, const unsigned char *__str)         {
            const char *__s = (const char *)__str;
            return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::put(std::__1::basic_ostream::char_type __c)         {
            try {
                std::__1::basic_ostream::sentry __s(*this);
                if (__s) {
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    _Op __o(*this);
                    *__o = __c;
                    if (__o.failed())
                        this->setstate(ios_base::badbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::write(const std::__1::basic_ostream::char_type *__s, std::__1::streamsize __n)         {
            try {
                std::__1::basic_ostream::sentry __sen(*this);
                if (__sen && __n) {
                    if (this->rdbuf()->sputn(__s, __n) != __n)
                        this->setstate(ios_base::badbit);
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::flush()         {
            try {
                if (this->rdbuf()) {
                    std::__1::basic_ostream::sentry __s(*this);
                    if (__s) {
                        if (this->rdbuf()->pubsync() == -1)
                            this->setstate(ios_base::badbit);
                    }
                }
            } catch (...) {
                this->__set_badbit_and_consider_rethrow();
            }
            return *this;
        }
        template <class _CharT, class _Traits> typename basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp()         {
            if (this->fail())
                return std::__1::basic_ostream::pos_type(-1);
            return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::__1::basic_ostream::pos_type __pos)         {
            std::__1::basic_ostream::sentry __s(*this);
            if (!this->fail()) {
                if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == std::__1::basic_ostream::pos_type(-1))
                    this->setstate(ios_base::failbit);
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::__1::basic_ostream::off_type __off, ios_base::seekdir __dir)         {
            std::__1::basic_ostream::sentry __s(*this);
            if (!this->fail()) {
                if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == std::__1::basic_ostream::pos_type(-1))
                    this->setstate(ios_base::failbit);
            }
            return *this;
        }
        template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> &endl(basic_ostream<_CharT, _Traits> &__os) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __os.put(__os.widen('\n'));
            __os.flush();
            return __os;
        }
        template<> inline basic_ostream<char, std::__1::char_traits<char> > &endl<char, std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os) __attribute__((internal_linkage))         {
            __os.put(__os.widen('\n'));
            __os.flush();
            return __os;
        }
        template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> &ends(basic_ostream<_CharT, _Traits> &__os) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __os.put(_CharT());
            return __os;
        }
        template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> &flush(basic_ostream<_CharT, _Traits> &__os) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __os.flush();
            return __os;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Allocator> &__str)         {
            return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<char, std::__1::char_traits<char>, std::__1::allocator<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, const basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > &__str)         {
            return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
        }
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, basic_string_view<_CharT, _Traits> __sv)         {
            return std::__1::__put_character_sequence(__os, __sv.data(), __sv.size());
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<char, std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, basic_string_view<char, std::__1::char_traits<char> > __sv)        template <class _CharT, class _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::__1::error_code &__ec) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __os << __ec.category().name() << ':' << __ec.value();
        }
        template <class _CharT, class _Traits, class _Yp> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const shared_ptr<_Yp> &__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __os << __p.get();
        }
        template <class _CharT, class _Traits, class _Yp, class _Dp> inline typename enable_if<is_same<void, typename __void_t<decltype((declval<basic_ostream<_CharT, _Traits> &>() << declval<typename unique_ptr<_Yp, _Dp>::pointer>()))>::type>::value, basic_ostream<_CharT, _Traits> &>::type operator<<(basic_ostream<_CharT, _Traits> &__os, const unique_ptr<_Yp, _Dp> &__p) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __os << __p.get();
        }
        template <class _CharT, class _Traits, size_t _Size> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const bitset<_Size> &__x)         {
            return __os << __x.template to_string<_CharT, _Traits>(use_facet<ctype<_CharT> >(__os.getloc()).widen('0'), use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
        }
        template<> class __attribute__((visibility("default"))) basic_ostream<char> : virtual public basic_ios<char, std::__1::char_traits<char> > {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            inline explicit basic_ostream(basic_streambuf<std::__1::basic_ostream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ostream<char, std::__1::char_traits<char> >::traits_type> *__sb) __attribute__((internal_linkage));
            virtual ~basic_ostream<char>();
        protected:
            inline void swap(std::__1::basic_ostream<char> &__rhs) __attribute__((internal_linkage));
            basic_ostream(const std::__1::basic_ostream<char> &__rhs);
            std::__1::basic_ostream<char> &operator=(const std::__1::basic_ostream<char> &__rhs);
        public:
            class sentry {
                bool __ok_;
                basic_ostream<char, std::__1::char_traits<char> > &__os_;
                sentry(const std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &);
                std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &operator=(const std::__1::basic_ostream<char, std::__1::char_traits<char> >::sentry &);
            public:
                explicit sentry(basic_ostream<char, std::__1::char_traits<char> > &__os);
                ~sentry();
                operator bool() const __attribute__((internal_linkage))                 {
                    return this->__ok_;
                }
            };
            inline std::__1::basic_ostream<char> &operator<<(std::__1::basic_ostream<char> &(*__pf)(std::__1::basic_ostream<char> &)) __attribute__((internal_linkage))             {
                return __pf(*this);
            }
            inline std::__1::basic_ostream<char> &operator<<(basic_ios<std::__1::basic_ostream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ostream<char, std::__1::char_traits<char> >::traits_type> &(*__pf)(basic_ios<std::__1::basic_ostream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ostream<char, std::__1::char_traits<char> >::traits_type> &)) __attribute__((internal_linkage));
            inline std::__1::basic_ostream<char> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((internal_linkage))             {
                __pf(*this);
                return *this;
            }
            std::__1::basic_ostream<char> &operator<<(bool __n);
            std::__1::basic_ostream<char> &operator<<(short __n);
            std::__1::basic_ostream<char> &operator<<(unsigned short __n);
            std::__1::basic_ostream<char> &operator<<(int __n);
            std::__1::basic_ostream<char> &operator<<(unsigned int __n);
            std::__1::basic_ostream<char> &operator<<(long __n);
            std::__1::basic_ostream<char> &operator<<(unsigned long __n);
            std::__1::basic_ostream<char> &operator<<(long long __n);
            std::__1::basic_ostream<char> &operator<<(unsigned long long __n);
            std::__1::basic_ostream<char> &operator<<(float __f);
            std::__1::basic_ostream<char> &operator<<(double __f);
            std::__1::basic_ostream<char> &operator<<(long double __f);
            std::__1::basic_ostream<char> &operator<<(const void *__p);
            std::__1::basic_ostream<char> &operator<<(basic_streambuf<std::__1::basic_ostream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_ostream<char, std::__1::char_traits<char> >::traits_type> *__sb);
            std::__1::basic_ostream<char> &operator<<(std::__1::nullptr_t) __attribute__((internal_linkage));
            std::__1::basic_ostream<char> &put(std::__1::basic_ostream<char, std::__1::char_traits<char> >::char_type __c);
            std::__1::basic_ostream<char> &write(const std::__1::basic_ostream<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n);
            std::__1::basic_ostream<char> &flush();
            inline std::__1::basic_ostream<char, std::__1::char_traits<char> >::pos_type tellp();
            inline std::__1::basic_ostream<char> &seekp(std::__1::basic_ostream<char, std::__1::char_traits<char> >::pos_type __pos);
            inline std::__1::basic_ostream<char> &seekp(std::__1::basic_ostream<char, std::__1::char_traits<char> >::off_type __off, ios_base::seekdir __dir);
        protected:
            basic_ostream() __attribute__((internal_linkage));
        };
        template<> class __attribute__((visibility("default"))) basic_ostream<wchar_t> : virtual public basic_ios<wchar_t, std::__1::char_traits<wchar_t> > {
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            inline explicit basic_ostream(basic_streambuf<std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__sb) __attribute__((internal_linkage));
            virtual ~basic_ostream<wchar_t>();
        protected:
            inline void swap(std::__1::basic_ostream<wchar_t> &__rhs) __attribute__((internal_linkage));
            basic_ostream(const std::__1::basic_ostream<wchar_t> &__rhs);
            std::__1::basic_ostream<wchar_t> &operator=(const std::__1::basic_ostream<wchar_t> &__rhs);
        public:
            class sentry {
                bool __ok_;
                basic_ostream<wchar_t, std::__1::char_traits<wchar_t> > &__os_;
                sentry(const std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
                std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &operator=(const std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
            public:
                explicit sentry(basic_ostream<wchar_t, std::__1::char_traits<wchar_t> > &__os);
                ~sentry();
                operator bool() const __attribute__((internal_linkage));
            };
            inline std::__1::basic_ostream<wchar_t> &operator<<(std::__1::basic_ostream<wchar_t> &(*__pf)(std::__1::basic_ostream<wchar_t> &)) __attribute__((internal_linkage));
            inline std::__1::basic_ostream<wchar_t> &operator<<(basic_ios<std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> &(*__pf)(basic_ios<std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> &)) __attribute__((internal_linkage));
            inline std::__1::basic_ostream<wchar_t> &operator<<(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((internal_linkage));
            std::__1::basic_ostream<wchar_t> &operator<<(bool __n);
            std::__1::basic_ostream<wchar_t> &operator<<(short __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned short __n);
            std::__1::basic_ostream<wchar_t> &operator<<(int __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned int __n);
            std::__1::basic_ostream<wchar_t> &operator<<(long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(long long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(unsigned long long __n);
            std::__1::basic_ostream<wchar_t> &operator<<(float __f);
            std::__1::basic_ostream<wchar_t> &operator<<(double __f);
            std::__1::basic_ostream<wchar_t> &operator<<(long double __f);
            std::__1::basic_ostream<wchar_t> &operator<<(const void *__p);
            std::__1::basic_ostream<wchar_t> &operator<<(basic_streambuf<std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__sb);
            std::__1::basic_ostream<wchar_t> &operator<<(std::__1::nullptr_t) __attribute__((internal_linkage));
            std::__1::basic_ostream<wchar_t> &put(std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::char_type __c);
            std::__1::basic_ostream<wchar_t> &write(const std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n);
            std::__1::basic_ostream<wchar_t> &flush();
            inline std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::pos_type tellp();
            inline std::__1::basic_ostream<wchar_t> &seekp(std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::pos_type __pos);
            inline std::__1::basic_ostream<wchar_t> &seekp(std::__1::basic_ostream<wchar_t, std::__1::char_traits<wchar_t> >::off_type __off, ios_base::seekdir __dir);
        protected:
            basic_ostream() __attribute__((internal_linkage));
        };
    }
}
namespace std {
    inline namespace __1 {
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_istream : virtual public basic_ios<_CharT, _Traits> {
            std::__1::streamsize __gc_;
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            inline explicit basic_istream<_CharT, _Traits>(basic_streambuf<std::__1::basic_istream::char_type, std::__1::basic_istream::traits_type> *__sb) : __gc_(0) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                this->init(__sb);
            }
            virtual ~basic_istream<_CharT, _Traits>();
        protected:
            inline void swap(basic_istream<_CharT, _Traits> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::swap(this->__gc_, __rhs.__gc_);
                basic_ios<char_type, traits_type>::swap(__rhs);
            }
        public:
            class __attribute__((type_visibility("default"))) sentry;
            inline basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &(*__pf)(basic_istream<_CharT, _Traits> &)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return __pf(*this);
            }
            inline basic_istream<_CharT, _Traits> &operator>>(basic_ios<std::__1::basic_istream::char_type, std::__1::basic_istream::traits_type> &(*__pf)(basic_ios<std::__1::basic_istream::char_type, std::__1::basic_istream::traits_type> &)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __pf(*this);
                return *this;
            }
            inline basic_istream<_CharT, _Traits> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __pf(*this);
                return *this;
            }
            basic_istream<_CharT, _Traits> &operator>>(basic_streambuf<std::__1::basic_istream::char_type, std::__1::basic_istream::traits_type> *__sb);
            basic_istream<_CharT, _Traits> &operator>>(bool &__n);
            basic_istream<_CharT, _Traits> &operator>>(short &__n);
            basic_istream<_CharT, _Traits> &operator>>(unsigned short &__n);
            basic_istream<_CharT, _Traits> &operator>>(int &__n);
            basic_istream<_CharT, _Traits> &operator>>(unsigned int &__n);
            basic_istream<_CharT, _Traits> &operator>>(long &__n);
            basic_istream<_CharT, _Traits> &operator>>(unsigned long &__n);
            basic_istream<_CharT, _Traits> &operator>>(long long &__n);
            basic_istream<_CharT, _Traits> &operator>>(unsigned long long &__n);
            basic_istream<_CharT, _Traits> &operator>>(float &__f);
            basic_istream<_CharT, _Traits> &operator>>(double &__f);
            basic_istream<_CharT, _Traits> &operator>>(long double &__f);
            basic_istream<_CharT, _Traits> &operator>>(void *&__p);
            std::__1::streamsize gcount() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__gc_;
            }
            std::__1::basic_istream::int_type get();
            inline basic_istream<_CharT, _Traits> &get(std::__1::basic_istream::char_type &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                std::__1::basic_istream::int_type __ch = get();
                if (__ch != traits_type::eof())
                    __c = traits_type::to_char_type(__ch);
                return *this;
            }
            inline basic_istream<_CharT, _Traits> &get(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return get(__s, __n, this->widen('\n'));
            }
            basic_istream<_CharT, _Traits> &get(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n, std::__1::basic_istream::char_type __dlm);
            inline basic_istream<_CharT, _Traits> &get(basic_streambuf<std::__1::basic_istream::char_type, std::__1::basic_istream::traits_type> &__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return get(__sb, this->widen('\n'));
            }
            basic_istream<_CharT, _Traits> &get(basic_streambuf<std::__1::basic_istream::char_type, std::__1::basic_istream::traits_type> &__sb, std::__1::basic_istream::char_type __dlm);
            inline basic_istream<_CharT, _Traits> &getline(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return getline(__s, __n, this->widen('\n'));
            }
            basic_istream<_CharT, _Traits> &getline(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n, std::__1::basic_istream::char_type __dlm);
            basic_istream<_CharT, _Traits> &ignore(std::__1::streamsize __n = 1, std::__1::basic_istream::int_type __dlm = traits_type::eof());
            std::__1::basic_istream::int_type peek();
            basic_istream<_CharT, _Traits> &read(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n);
            std::__1::streamsize readsome(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n);
            basic_istream<_CharT, _Traits> &putback(std::__1::basic_istream::char_type __c);
            basic_istream<_CharT, _Traits> &unget();
            int sync();
            std::__1::basic_istream::pos_type tellg();
            basic_istream<_CharT, _Traits> &seekg(std::__1::basic_istream::pos_type __pos);
            basic_istream<_CharT, _Traits> &seekg(std::__1::basic_istream::off_type __off, ios_base::seekdir __dir);
        };
        class __attribute__((type_visibility("default"))) sentry {
            bool __ok_;
            sentry(const std::__1::basic_istream::sentry &);
            std::__1::basic_istream::sentry &operator=(const std::__1::basic_istream::sentry &);
        public:
            explicit sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false);
            operator bool() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                return this->__ok_;
            }
        };
        template <class _CharT, class _Traits> explicit basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false) : __ok_(false)         {
            if (__is.good()) {
                if (__is.tie())
                    __is.tie()->flush();
                if (!__noskipws && (__is.flags() & ios_base::skipws)) {
                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    _Ip __i(__is);
                    _Ip __eof;
                    for (; __i != __eof; ++__i)
                        if (!__ct.is(__ct.space, *__i))
                            break;
                    if (__i == __eof)
                        __is.setstate(ios_base::failbit | ios_base::eofbit);
                }
                this->__ok_ = __is.good();
            } else
                __is.setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>::~basic_istream<_CharT, _Traits>()         {
        }
        template <class _Tp, class _CharT, class _Traits> basic_istream<_CharT, _Traits> &__input_arithmetic(basic_istream<_CharT, _Traits> &__is, _Tp &__n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ios_base::iostate __state = ios_base::goodbit;
            typename basic_istream<_CharT, _Traits>::sentry __s(__is);
            if (__s) {
                try {
                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef num_get<_CharT, _Ip> _Fp;
                    use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __n);
                } catch (...) {
                    __state |= ios_base::badbit;
                    __is.__setstate_nothrow(__state);
                    if (__is.exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                __is.setstate(__state);
            }
            return __is;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(unsigned short &__n)         {
            return std::__1::__input_arithmetic<unsigned short>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(unsigned int &__n)         {
            return std::__1::__input_arithmetic<unsigned int>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(long &__n)         {
            return std::__1::__input_arithmetic<long>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(unsigned long &__n)         {
            return std::__1::__input_arithmetic<unsigned long>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(long long &__n)         {
            return std::__1::__input_arithmetic<long long>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(unsigned long long &__n)         {
            return std::__1::__input_arithmetic<unsigned long long>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(float &__n)         {
            return std::__1::__input_arithmetic<float>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(double &__n)         {
            return std::__1::__input_arithmetic<double>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(long double &__n)         {
            return std::__1::__input_arithmetic<long double>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(bool &__n)         {
            return std::__1::__input_arithmetic<bool>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(void *&__n)         {
            return std::__1::__input_arithmetic<void *>(*this, __n);
        }
        template <class _Tp, class _CharT, class _Traits> basic_istream<_CharT, _Traits> &__input_arithmetic_with_numeric_limits(basic_istream<_CharT, _Traits> &__is, _Tp &__n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ios_base::iostate __state = ios_base::goodbit;
            typename basic_istream<_CharT, _Traits>::sentry __s(__is);
            if (__s) {
                try {
                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef num_get<_CharT, _Ip> _Fp;
                    long __temp;
                    use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __temp);
                    if (__temp < numeric_limits<_Tp>::min()) {
                        __state |= ios_base::failbit;
                        __n = numeric_limits<_Tp>::min();
                    } else if (__temp > numeric_limits<_Tp>::max()) {
                        __state |= ios_base::failbit;
                        __n = numeric_limits<_Tp>::max();
                    } else {
                        __n = static_cast<_Tp>(__temp);
                    }
                } catch (...) {
                    __state |= ios_base::badbit;
                    __is.__setstate_nothrow(__state);
                    if (__is.exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                __is.setstate(__state);
            }
            return __is;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(short &__n)         {
            return std::__1::__input_arithmetic_with_numeric_limits<short>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(int &__n)         {
            return std::__1::__input_arithmetic_with_numeric_limits<int>(*this, __n);
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &__input_c_string(basic_istream<_CharT, _Traits> &__is, _CharT *__p, size_t __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            ios_base::iostate __state = ios_base::goodbit;
            typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
            if (__sen) {
                try {
                    _CharT *__s = __p;
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    while (__s != __p + (__n - 1))
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __state |= ios_base::eofbit;
                                break;
                            }
                            _CharT __ch = _Traits::to_char_type(__i);
                            if (__ct.is(__ct.space, __ch))
                                break;
                            *__s++ = __ch;
                            __is.rdbuf()->sbumpc();
                        }
                    *__s = _CharT();
                    __is.width(0);
                    if (__s == __p)
                        __state |= ios_base::failbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    __is.__setstate_nothrow(__state);
                    if (__is.exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                __is.setstate(__state);
            }
            return __is;
        }
        template <class _CharT, class _Traits> inline basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, _CharT *__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            std::__1::streamsize __n = __is.width();
            if (__n <= 0)
                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
            return std::__1::__input_c_string(__is, __s, size_t(__n));
        }
        template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__is, unsigned char *__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __is >> (char *)__s;
        }
        template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__is, signed char *__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __is >> (char *)__s;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, _CharT &__c)         {
            ios_base::iostate __state = ios_base::goodbit;
            typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
            if (__sen) {
                try {
                    typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                    if (_Traits::eq_int_type(__i, _Traits::eof()))
                        __state |= ios_base::eofbit | ios_base::failbit;
                    else
                        __c = _Traits::to_char_type(__i);
                } catch (...) {
                    __state |= ios_base::badbit;
                    __is.__setstate_nothrow(__state);
                    if (__is.exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                __is.setstate(__state);
            }
            return __is;
        }
        template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__is, unsigned char &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __is >> (char &)__c;
        }
        template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__is, signed char &__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __is >> (char &)__c;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<std::__1::basic_istream::char_type, std::__1::basic_istream::traits_type> *__sb)         {
            ios_base::iostate __state = ios_base::goodbit;
            this->__gc_ = 0;
            std::__1::basic_istream::sentry __s(*this, true);
            if (__s) {
                if (__sb) {
                    try {
                        while (true)
                            {
                                typename traits_type::int_type __i = this->rdbuf()->sgetc();
                                if (traits_type::eq_int_type(__i, _Traits::eof())) {
                                    __state |= ios_base::eofbit;
                                    break;
                                }
                                if (traits_type::eq_int_type(__sb->sputc(traits_type::to_char_type(__i)), traits_type::eof()))
                                    break;
                                ++this->__gc_;
                                this->rdbuf()->sbumpc();
                            }
                        if (this->__gc_ == 0)
                            __state |= ios_base::failbit;
                    } catch (...) {
                        __state |= ios_base::badbit;
                        if (this->__gc_ == 0)
                            __state |= ios_base::failbit;
                        this->__setstate_nothrow(__state);
                        if (this->exceptions() & ios_base::failbit || this->exceptions() & ios_base::badbit) {
                            throw;
                        }
                    }
                } else {
                    __state |= ios_base::failbit;
                }
                this->setstate(__state);
            }
            return *this;
        }
        template <class _CharT, class _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get()         {
            ios_base::iostate __state = ios_base::goodbit;
            this->__gc_ = 0;
            std::__1::basic_istream::int_type __r = traits_type::eof();
            std::__1::basic_istream::sentry __s(*this, true);
            if (__s) {
                try {
                    __r = this->rdbuf()->sbumpc();
                    if (traits_type::eq_int_type(__r, traits_type::eof()))
                        __state |= ios_base::failbit | ios_base::eofbit;
                    else
                        this->__gc_ = 1;
                } catch (...) {
                    this->__setstate_nothrow(this->rdstate() | ios_base::badbit);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                this->setstate(__state);
            }
            return __r;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n, std::__1::basic_istream::char_type __dlm)         {
            ios_base::iostate __state = ios_base::goodbit;
            this->__gc_ = 0;
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                if (__n > 0) {
                    try {
                        while (this->__gc_ < __n - 1)
                            {
                                std::__1::basic_istream::int_type __i = this->rdbuf()->sgetc();
                                if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                    __state |= ios_base::eofbit;
                                    break;
                                }
                                std::__1::basic_istream::char_type __ch = traits_type::to_char_type(__i);
                                if (traits_type::eq(__ch, __dlm))
                                    break;
                                *__s++ = __ch;
                                ++this->__gc_;
                                this->rdbuf()->sbumpc();
                            }
                        if (this->__gc_ == 0)
                            __state |= ios_base::failbit;
                    } catch (...) {
                        __state |= ios_base::badbit;
                        this->__setstate_nothrow(__state);
                        if (this->exceptions() & ios_base::badbit) {
                            if (__n > 0)
                                *__s = std::__1::basic_istream::char_type();
                            throw;
                        }
                    }
                } else {
                    __state |= ios_base::failbit;
                }
                if (__n > 0)
                    *__s = std::__1::basic_istream::char_type();
                this->setstate(__state);
            }
            if (__n > 0)
                *__s = std::__1::basic_istream::char_type();
            return *this;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(basic_streambuf<std::__1::basic_istream::char_type, std::__1::basic_istream::traits_type> &__sb, std::__1::basic_istream::char_type __dlm)         {
            ios_base::iostate __state = ios_base::goodbit;
            this->__gc_ = 0;
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    while (true)
                        {
                            typename traits_type::int_type __i = this->rdbuf()->sgetc();
                            if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                __state |= ios_base::eofbit;
                                break;
                            }
                            std::__1::basic_istream::char_type __ch = traits_type::to_char_type(__i);
                            if (traits_type::eq(__ch, __dlm))
                                break;
                            if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
                                break;
                            ++this->__gc_;
                            this->rdbuf()->sbumpc();
                        }
                } catch (...) {
                    __state |= ios_base::badbit;
                }
                if (this->__gc_ == 0)
                    __state |= ios_base::failbit;
                this->setstate(__state);
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::getline(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n, std::__1::basic_istream::char_type __dlm)         {
            ios_base::iostate __state = ios_base::goodbit;
            this->__gc_ = 0;
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    while (true)
                        {
                            typename traits_type::int_type __i = this->rdbuf()->sgetc();
                            if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                __state |= ios_base::eofbit;
                                break;
                            }
                            std::__1::basic_istream::char_type __ch = traits_type::to_char_type(__i);
                            if (traits_type::eq(__ch, __dlm)) {
                                this->rdbuf()->sbumpc();
                                ++this->__gc_;
                                break;
                            }
                            if (this->__gc_ >= __n - 1) {
                                __state |= ios_base::failbit;
                                break;
                            }
                            *__s++ = __ch;
                            this->rdbuf()->sbumpc();
                            ++this->__gc_;
                        }
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        if (__n > 0)
                            *__s = std::__1::basic_istream::char_type();
                        if (this->__gc_ == 0)
                            __state |= ios_base::failbit;
                        throw;
                    }
                }
            }
            if (__n > 0)
                *__s = std::__1::basic_istream::char_type();
            if (this->__gc_ == 0)
                __state |= ios_base::failbit;
            this->setstate(__state);
            return *this;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(std::__1::streamsize __n = 1, std::__1::basic_istream::int_type __dlm = traits_type::eof())         {
            ios_base::iostate __state = ios_base::goodbit;
            this->__gc_ = 0;
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    if (__n == numeric_limits<streamsize>::max()) {
                        while (true)
                            {
                                typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                                if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                    __state |= ios_base::eofbit;
                                    break;
                                }
                                ++this->__gc_;
                                if (traits_type::eq_int_type(__i, __dlm))
                                    break;
                            }
                    } else {
                        while (this->__gc_ < __n)
                            {
                                typename traits_type::int_type __i = this->rdbuf()->sbumpc();
                                if (traits_type::eq_int_type(__i, traits_type::eof())) {
                                    __state |= ios_base::eofbit;
                                    break;
                                }
                                ++this->__gc_;
                                if (traits_type::eq_int_type(__i, __dlm))
                                    break;
                            }
                    }
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                this->setstate(__state);
            }
            return *this;
        }
        template <class _CharT, class _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek()         {
            ios_base::iostate __state = ios_base::goodbit;
            this->__gc_ = 0;
            std::__1::basic_istream::int_type __r = traits_type::eof();
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    __r = this->rdbuf()->sgetc();
                    if (traits_type::eq_int_type(__r, traits_type::eof()))
                        __state |= ios_base::eofbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                this->setstate(__state);
            }
            return __r;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::read(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n)         {
            ios_base::iostate __state = ios_base::goodbit;
            this->__gc_ = 0;
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    this->__gc_ = this->rdbuf()->sgetn(__s, __n);
                    if (this->__gc_ != __n)
                        __state |= ios_base::failbit | ios_base::eofbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
            } else {
                __state |= ios_base::failbit;
            }
            this->setstate(__state);
            return *this;
        }
        template <class _CharT, class _Traits> std::__1::streamsize basic_istream<_CharT, _Traits>::readsome(std::__1::basic_istream::char_type *__s, std::__1::streamsize __n)         {
            ios_base::iostate __state = ios_base::goodbit;
            this->__gc_ = 0;
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    std::__1::streamsize __c = this->rdbuf()->in_avail();
                    switch (__c) {
                      case -1:
                        __state |= ios_base::eofbit;
                        break;
                      case 0:
                        break;
                      default:
                        __n = std::__1::min(__c, __n);
                        this->__gc_ = this->rdbuf()->sgetn(__s, __n);
                        if (this->__gc_ != __n)
                            __state |= ios_base::failbit | ios_base::eofbit;
                        break;
                    }
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
            } else {
                __state |= ios_base::failbit;
            }
            this->setstate(__state);
            return this->__gc_;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::putback(std::__1::basic_istream::char_type __c)         {
            ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
            this->__gc_ = 0;
            this->clear(__state);
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())
                        __state |= ios_base::badbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
            } else {
                __state |= ios_base::failbit;
            }
            this->setstate(__state);
            return *this;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::unget()         {
            ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
            this->__gc_ = 0;
            this->clear(__state);
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())
                        __state |= ios_base::badbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
            } else {
                __state |= ios_base::failbit;
            }
            this->setstate(__state);
            return *this;
        }
        template <class _CharT, class _Traits> int basic_istream<_CharT, _Traits>::sync()         {
            ios_base::iostate __state = ios_base::goodbit;
            int __r = 0;
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    if (this->rdbuf() == 0)
                        return -1;
                    if (this->rdbuf()->pubsync() == -1) {
                        __state |= ios_base::badbit;
                        return -1;
                    }
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                this->setstate(__state);
            }
            return __r;
        }
        template <class _CharT, class _Traits> typename basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg()         {
            ios_base::iostate __state = ios_base::goodbit;
            std::__1::basic_istream::pos_type __r(-1);
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                this->setstate(__state);
            }
            return __r;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::__1::basic_istream::pos_type __pos)         {
            ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
            this->clear(__state);
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == std::__1::basic_istream::pos_type(-1))
                        __state |= ios_base::failbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                this->setstate(__state);
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::__1::basic_istream::off_type __off, ios_base::seekdir __dir)         {
            ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
            this->clear(__state);
            std::__1::basic_istream::sentry __sen(*this, true);
            if (__sen) {
                try {
                    if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == std::__1::basic_istream::pos_type(-1))
                        __state |= ios_base::failbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    this->__setstate_nothrow(__state);
                    if (this->exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                this->setstate(__state);
            }
            return *this;
        }
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__is)         {
            ios_base::iostate __state = ios_base::goodbit;
            typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
            if (__sen) {
                try {
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    while (true)
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __state |= ios_base::eofbit;
                                break;
                            }
                            if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
                                break;
                            __is.rdbuf()->sbumpc();
                        }
                } catch (...) {
                    __state |= ios_base::badbit;
                    __is.__setstate_nothrow(__state);
                    if (__is.exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                __is.setstate(__state);
            }
            return __is;
        }
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_iostream : public basic_istream<_CharT, _Traits>, public basic_ostream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            inline explicit basic_iostream<_CharT, _Traits>(basic_streambuf<std::__1::basic_iostream::char_type, std::__1::basic_iostream::traits_type> *__sb) : basic_istream<_CharT, _Traits>(__sb) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            virtual ~basic_iostream<_CharT, _Traits>();
        protected:
            inline void swap(basic_iostream<_CharT, _Traits> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                basic_istream<char_type, traits_type>::swap(__rhs);
            }
        };
        template <class _CharT, class _Traits> basic_iostream<_CharT, _Traits>::~basic_iostream<_CharT, _Traits>()         {
        }
        template <class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str)         {
            ios_base::iostate __state = ios_base::goodbit;
            typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
            if (__sen) {
                try {
                    __str.clear();
                    std::__1::streamsize __n = __is.width();
                    if (__n <= 0)
                        __n = __str.max_size();
                    if (__n <= 0)
                        __n = numeric_limits<streamsize>::max();
                    std::__1::streamsize __c = 0;
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    while (__c < __n)
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __state |= ios_base::eofbit;
                                break;
                            }
                            _CharT __ch = _Traits::to_char_type(__i);
                            if (__ct.is(__ct.space, __ch))
                                break;
                            __str.push_back(__ch);
                            ++__c;
                            __is.rdbuf()->sbumpc();
                        }
                    __is.width(0);
                    if (__c == 0)
                        __state |= ios_base::failbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    __is.__setstate_nothrow(__state);
                    if (__is.exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                __is.setstate(__state);
            }
            return __is;
        }
        template <class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm)         {
            ios_base::iostate __state = ios_base::goodbit;
            typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
            if (__sen) {
                try {
                    __str.clear();
                    std::__1::streamsize __extr = 0;
                    while (true)
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __state |= ios_base::eofbit;
                                break;
                            }
                            ++__extr;
                            _CharT __ch = _Traits::to_char_type(__i);
                            if (_Traits::eq(__ch, __dlm))
                                break;
                            __str.push_back(__ch);
                            if (__str.size() == __str.max_size()) {
                                __state |= ios_base::failbit;
                                break;
                            }
                        }
                    if (__extr == 0)
                        __state |= ios_base::failbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    __is.__setstate_nothrow(__state);
                    if (__is.exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                __is.setstate(__state);
            }
            return __is;
        }
        template <class _CharT, class _Traits, class _Allocator> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Allocator> &__str) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return getline(__is, __str, __is.widen('\n'));
        }
        template <class _CharT, class _Traits, size_t _Size> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, bitset<_Size> &__x)         {
            ios_base::iostate __state = ios_base::goodbit;
            typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
            if (__sen) {
                try {
                    basic_string<_CharT, _Traits> __str;
                    const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__is.getloc());
                    size_t __c = 0;
                    _CharT __zero = __ct.widen('0');
                    _CharT __one = __ct.widen('1');
                    while (__c < _Size)
                        {
                            typename _Traits::int_type __i = __is.rdbuf()->sgetc();
                            if (_Traits::eq_int_type(__i, _Traits::eof())) {
                                __state |= ios_base::eofbit;
                                break;
                            }
                            _CharT __ch = _Traits::to_char_type(__i);
                            if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
                                break;
                            __str.push_back(__ch);
                            ++__c;
                            __is.rdbuf()->sbumpc();
                        }
                    __x = bitset<_Size>(__str);
                    if (_Size > 0 && __c == 0)
                        __state |= ios_base::failbit;
                } catch (...) {
                    __state |= ios_base::badbit;
                    __is.__setstate_nothrow(__state);
                    if (__is.exceptions() & ios_base::badbit) {
                        throw;
                    }
                }
                __is.setstate(__state);
            }
            return __is;
        }
        template<> class __attribute__((visibility("default"))) basic_istream<char> : virtual public basic_ios<char, std::__1::char_traits<char> > {
            std::__1::streamsize __gc_;
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            inline explicit basic_istream(basic_streambuf<std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_istream<char, std::__1::char_traits<char> >::traits_type> *__sb) __attribute__((internal_linkage));
            virtual ~basic_istream<char>();
        protected:
            inline void swap(std::__1::basic_istream<char> &__rhs) __attribute__((internal_linkage));
        public:
            class sentry {
                bool __ok_;
                sentry(const std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &);
                std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &operator=(const std::__1::basic_istream<char, std::__1::char_traits<char> >::sentry &);
            public:
                explicit sentry(basic_istream<char, std::__1::char_traits<char> > &__is, bool __noskipws);
                operator bool() const __attribute__((internal_linkage));
            };
            inline std::__1::basic_istream<char> &operator>>(std::__1::basic_istream<char> &(*__pf)(std::__1::basic_istream<char> &)) __attribute__((internal_linkage));
            inline std::__1::basic_istream<char> &operator>>(basic_ios<std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_istream<char, std::__1::char_traits<char> >::traits_type> &(*__pf)(basic_ios<std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_istream<char, std::__1::char_traits<char> >::traits_type> &)) __attribute__((internal_linkage));
            inline std::__1::basic_istream<char> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((internal_linkage));
            std::__1::basic_istream<char> &operator>>(basic_streambuf<std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_istream<char, std::__1::char_traits<char> >::traits_type> *__sb);
            std::__1::basic_istream<char> &operator>>(bool &__n);
            std::__1::basic_istream<char> &operator>>(short &__n);
            std::__1::basic_istream<char> &operator>>(unsigned short &__n);
            std::__1::basic_istream<char> &operator>>(int &__n);
            std::__1::basic_istream<char> &operator>>(unsigned int &__n);
            std::__1::basic_istream<char> &operator>>(long &__n);
            std::__1::basic_istream<char> &operator>>(unsigned long &__n);
            std::__1::basic_istream<char> &operator>>(long long &__n);
            std::__1::basic_istream<char> &operator>>(unsigned long long &__n);
            std::__1::basic_istream<char> &operator>>(float &__f);
            std::__1::basic_istream<char> &operator>>(double &__f);
            std::__1::basic_istream<char> &operator>>(long double &__f);
            std::__1::basic_istream<char> &operator>>(void *&__p);
            std::__1::streamsize gcount() const __attribute__((internal_linkage));
            std::__1::basic_istream<char, std::__1::char_traits<char> >::int_type get();
            inline std::__1::basic_istream<char> &get(std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type &__c) __attribute__((internal_linkage));
            inline std::__1::basic_istream<char> &get(std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage));
            std::__1::basic_istream<char> &get(std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n, std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type __dlm);
            inline std::__1::basic_istream<char> &get(basic_streambuf<std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_istream<char, std::__1::char_traits<char> >::traits_type> &__sb) __attribute__((internal_linkage));
            std::__1::basic_istream<char> &get(basic_streambuf<std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_istream<char, std::__1::char_traits<char> >::traits_type> &__sb, std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type __dlm);
            inline std::__1::basic_istream<char> &getline(std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage));
            std::__1::basic_istream<char> &getline(std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n, std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type __dlm);
            std::__1::basic_istream<char> &ignore(std::__1::streamsize __n, std::__1::basic_istream<char, std::__1::char_traits<char> >::int_type __dlm);
            std::__1::basic_istream<char, std::__1::char_traits<char> >::int_type peek();
            std::__1::basic_istream<char> &read(std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n);
            std::__1::streamsize readsome(std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type *__s, std::__1::streamsize __n);
            std::__1::basic_istream<char> &putback(std::__1::basic_istream<char, std::__1::char_traits<char> >::char_type __c);
            std::__1::basic_istream<char> &unget();
            int sync();
            std::__1::basic_istream<char, std::__1::char_traits<char> >::pos_type tellg();
            std::__1::basic_istream<char> &seekg(std::__1::basic_istream<char, std::__1::char_traits<char> >::pos_type __pos);
            std::__1::basic_istream<char> &seekg(std::__1::basic_istream<char, std::__1::char_traits<char> >::off_type __off, ios_base::seekdir __dir);
        };
        template<> class __attribute__((visibility("default"))) basic_istream<wchar_t> : virtual public basic_ios<wchar_t, std::__1::char_traits<wchar_t> > {
            std::__1::streamsize __gc_;
        public:
            typedef wchar_t char_type;
            typedef std::__1::char_traits<wchar_t> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            inline explicit basic_istream(basic_streambuf<std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__sb) __attribute__((internal_linkage));
            virtual ~basic_istream<wchar_t>();
        protected:
            inline void swap(std::__1::basic_istream<wchar_t> &__rhs) __attribute__((internal_linkage));
        public:
            class sentry {
                bool __ok_;
                sentry(const std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
                std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &operator=(const std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::sentry &);
            public:
                explicit sentry(basic_istream<wchar_t, std::__1::char_traits<wchar_t> > &__is, bool __noskipws);
                operator bool() const __attribute__((internal_linkage));
            };
            inline std::__1::basic_istream<wchar_t> &operator>>(std::__1::basic_istream<wchar_t> &(*__pf)(std::__1::basic_istream<wchar_t> &)) __attribute__((internal_linkage));
            inline std::__1::basic_istream<wchar_t> &operator>>(basic_ios<std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> &(*__pf)(basic_ios<std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> &)) __attribute__((internal_linkage));
            inline std::__1::basic_istream<wchar_t> &operator>>(std::__1::ios_base &(*__pf)(std::__1::ios_base &)) __attribute__((internal_linkage));
            std::__1::basic_istream<wchar_t> &operator>>(basic_streambuf<std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> *__sb);
            std::__1::basic_istream<wchar_t> &operator>>(bool &__n);
            std::__1::basic_istream<wchar_t> &operator>>(short &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned short &__n);
            std::__1::basic_istream<wchar_t> &operator>>(int &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned int &__n);
            std::__1::basic_istream<wchar_t> &operator>>(long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(long long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(unsigned long long &__n);
            std::__1::basic_istream<wchar_t> &operator>>(float &__f);
            std::__1::basic_istream<wchar_t> &operator>>(double &__f);
            std::__1::basic_istream<wchar_t> &operator>>(long double &__f);
            std::__1::basic_istream<wchar_t> &operator>>(void *&__p);
            std::__1::streamsize gcount() const __attribute__((internal_linkage));
            std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::int_type get();
            inline std::__1::basic_istream<wchar_t> &get(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type &__c) __attribute__((internal_linkage));
            inline std::__1::basic_istream<wchar_t> &get(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage));
            std::__1::basic_istream<wchar_t> &get(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type __dlm);
            inline std::__1::basic_istream<wchar_t> &get(basic_streambuf<std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> &__sb) __attribute__((internal_linkage));
            std::__1::basic_istream<wchar_t> &get(basic_streambuf<std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::traits_type> &__sb, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type __dlm);
            inline std::__1::basic_istream<wchar_t> &getline(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n) __attribute__((internal_linkage));
            std::__1::basic_istream<wchar_t> &getline(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type __dlm);
            std::__1::basic_istream<wchar_t> &ignore(std::__1::streamsize __n, std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::int_type __dlm);
            std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::int_type peek();
            std::__1::basic_istream<wchar_t> &read(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n);
            std::__1::streamsize readsome(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type *__s, std::__1::streamsize __n);
            std::__1::basic_istream<wchar_t> &putback(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::char_type __c);
            std::__1::basic_istream<wchar_t> &unget();
            int sync();
            std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::pos_type tellg();
            std::__1::basic_istream<wchar_t> &seekg(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::pos_type __pos);
            std::__1::basic_istream<wchar_t> &seekg(std::__1::basic_istream<wchar_t, std::__1::char_traits<wchar_t> >::off_type __off, ios_base::seekdir __dir);
        };
        template<> class __attribute__((visibility("default"))) basic_iostream<char> : public basic_istream<char, std::__1::char_traits<char> >, public basic_ostream<char, std::__1::char_traits<char> > {
        public:
            typedef char char_type;
            typedef std::__1::char_traits<char> traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            inline explicit basic_iostream(basic_streambuf<std::__1::basic_iostream<char, std::__1::char_traits<char> >::char_type, std::__1::basic_iostream<char, std::__1::char_traits<char> >::traits_type> *__sb) __attribute__((internal_linkage));
            virtual ~basic_iostream<char>();
        protected:
            inline void swap(std::__1::basic_iostream<char> &__rhs) __attribute__((internal_linkage));
        };
    }
}
namespace std {
    inline namespace __1 {
        class __iom_t1 {
            ios_base::fmtflags __mask_;
        public:
            explicit __iom_t1(ios_base::fmtflags __m) : __mask_(__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const std::__1::__iom_t1 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __is.unsetf(__x.__mask_);
                return __is;
            }
;
            friend template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::__1::__iom_t1 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __os.unsetf(__x.__mask_);
                return __os;
            }
;
        };
        inline std::__1::__iom_t1 resetiosflags(ios_base::fmtflags __mask) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__iom_t1(__mask);
        }
        class __iom_t2 {
            ios_base::fmtflags __mask_;
        public:
            explicit __iom_t2(ios_base::fmtflags __m) : __mask_(__m) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const std::__1::__iom_t2 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __is.setf(__x.__mask_);
                return __is;
            }
;
            friend template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::__1::__iom_t2 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __os.setf(__x.__mask_);
                return __os;
            }
;
        };
        inline std::__1::__iom_t2 setiosflags(ios_base::fmtflags __mask) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__iom_t2(__mask);
        }
        class __iom_t3 {
            int __base_;
        public:
            explicit __iom_t3(int __b) : __base_(__b) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const std::__1::__iom_t3 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __is.setf(__x.__base_ == 8 ? ios_base::oct : __x.__base_ == 10 ? ios_base::dec : __x.__base_ == 16 ? ios_base::hex : ios_base::fmtflags(0), ios_base::basefield);
                return __is;
            }
;
            friend template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::__1::__iom_t3 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __os.setf(__x.__base_ == 8 ? ios_base::oct : __x.__base_ == 10 ? ios_base::dec : __x.__base_ == 16 ? ios_base::hex : ios_base::fmtflags(0), ios_base::basefield);
                return __os;
            }
;
        };
        inline std::__1::__iom_t3 setbase(int __base) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__iom_t3(__base);
        }
        template <class _CharT> class __iom_t4 {
            _CharT __fill_;
        public:
            explicit __iom_t4<_CharT>(_CharT __c) : __fill_(__c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t4<_CharT> &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __os.fill(__x.__fill_);
                return __os;
            }
;
        };
template<> class __iom_t4<char> {
            char __fill_;
        public:
            explicit __iom_t4(char __c) : __fill_(__c) __attribute__((internal_linkage))             {
            }
            friend template <class _Traits> basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os, const std::__1::__iom_t4<char> &__x) __attribute__((internal_linkage));
            template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, const std::__1::__iom_t4<char> &__x) __attribute__((internal_linkage))             {
                __os.fill(__x.__fill_);
                return __os;
            }
;
        };
        template <class _CharT> inline __iom_t4<_CharT> setfill(_CharT __c) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __iom_t4<_CharT>(__c);
        }
        template<> inline __iom_t4<char> setfill<char>(char __c) __attribute__((internal_linkage))         {
            return __iom_t4<char>(__c);
        }
        class __iom_t5 {
            int __n_;
        public:
            explicit __iom_t5(int __n) : __n_(__n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const std::__1::__iom_t5 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __is.precision(__x.__n_);
                return __is;
            }
;
            friend template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::__1::__iom_t5 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __os.precision(__x.__n_);
                return __os;
            }
;
        };
        inline std::__1::__iom_t5 setprecision(int __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__iom_t5(__n);
        }
        class __iom_t6 {
            int __n_;
        public:
            explicit __iom_t6(int __n) : __n_(__n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const std::__1::__iom_t6 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __is.width(__x.__n_);
                return __is;
            }
;
            friend template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::__1::__iom_t6 &__x) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
                __os.width(__x.__n_);
                return __os;
            }
            template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<char, std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, const std::__1::__iom_t6 &__x) __attribute__((internal_linkage))             {
                __os.width(__x.__n_);
                return __os;
            }
;
        };
        inline std::__1::__iom_t6 setw(int __n) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return std::__1::__iom_t6(__n);
        }
        template <class _MoneyT> class __iom_t7;
        template <class _CharT, class _Traits, class _MoneyT> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t7<_MoneyT> &__x);
        template <class _MoneyT> class __iom_t7 {
            _MoneyT &__mon_;
            bool __intl_;
        public:
            __iom_t7<_MoneyT>(_MoneyT &__mon, bool __intl) : __mon_(__mon), __intl_(__intl) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _CharT, class _Traits, class _Mp> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t7<_Mp> &__x);
        };
        template <class _CharT, class _Traits, class _MoneyT> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t7<_MoneyT> &__x)         {
            try {
                typename basic_istream<_CharT, _Traits>::sentry __s(__is);
                if (__s) {
                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef money_get<_CharT, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    const _Fp &__mf = use_facet<_Fp>(__is.getloc());
                    __mf.get(_Ip(__is), _Ip(), __x.__intl_, __is, __err, __x.__mon_);
                    __is.setstate(__err);
                }
            } catch (...) {
                __is.__set_badbit_and_consider_rethrow();
            }
            return __is;
        }
        template <class _MoneyT> inline __iom_t7<_MoneyT> get_money(_MoneyT &__mon, bool __intl = false) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __iom_t7<_MoneyT>(__mon, __intl);
        }
        template <class _MoneyT> class __iom_t8;
        template <class _CharT, class _Traits, class _MoneyT> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t8<_MoneyT> &__x);
        template <class _MoneyT> class __iom_t8 {
            const _MoneyT &__mon_;
            bool __intl_;
        public:
            __iom_t8<_MoneyT>(const _MoneyT &__mon, bool __intl) : __mon_(__mon), __intl_(__intl) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _CharT, class _Traits, class _Mp> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t8<_Mp> &__x);
        };
        template <class _CharT, class _Traits, class _MoneyT> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t8<_MoneyT> &__x)         {
            try {
                typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
                if (__s) {
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    typedef money_put<_CharT, _Op> _Fp;
                    const _Fp &__mf = use_facet<_Fp>(__os.getloc());
                    if (__mf.put(_Op(__os), __x.__intl_, __os, __os.fill(), __x.__mon_).failed())
                        __os.setstate(ios_base::badbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }
        template <class _MoneyT> inline __iom_t8<_MoneyT> put_money(const _MoneyT &__mon, bool __intl = false) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __iom_t8<_MoneyT>(__mon, __intl);
        }
        template <class _CharT> class __iom_t9;
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t9<_CharT> &__x);
        template <class _CharT> class __iom_t9 {
            tm *__tm_;
            const _CharT *__fmt_;
        public:
            __iom_t9<_CharT>(tm *__tm, const _CharT *__fmt) : __tm_(__tm), __fmt_(__fmt) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _Cp, class _Traits> basic_istream<_Cp, _Traits> &operator>>(basic_istream<_Cp, _Traits> &__is, const __iom_t9<_Cp> &__x);
        };
        template <class _CharT, class _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const __iom_t9<_CharT> &__x)         {
            try {
                typename basic_istream<_CharT, _Traits>::sentry __s(__is);
                if (__s) {
                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;
                    typedef time_get<_CharT, _Ip> _Fp;
                    ios_base::iostate __err = ios_base::goodbit;
                    const _Fp &__tf = use_facet<_Fp>(__is.getloc());
                    __tf.get(_Ip(__is), _Ip(), __is, __err, __x.__tm_, __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_));
                    __is.setstate(__err);
                }
            } catch (...) {
                __is.__set_badbit_and_consider_rethrow();
            }
            return __is;
        }
        template <class _CharT> inline __iom_t9<_CharT> get_time(tm *__tm, const _CharT *__fmt) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __iom_t9<_CharT>(__tm, __fmt);
        }
        template <class _CharT> class __iom_t10
template<> class __iom_t10<char> {
            const tm *__tm_;
            const char *__fmt_;
        public:
            __iom_t10(const tm *__tm, const char *__fmt) __attribute__((internal_linkage));
            friend template <class _Cp, class _Traits> basic_ostream<_Cp, _Traits> &operator<<(basic_ostream<_Cp, _Traits> &__os, const __iom_t10<_Cp> &__x);
        };
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t10<_CharT> &__x);
        template <class _CharT> class __iom_t10 {
            const tm *__tm_;
            const _CharT *__fmt_;
        public:
            __iom_t10<_CharT>(const tm *__tm, const _CharT *__fmt) : __tm_(__tm), __fmt_(__fmt) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))             {
            }
            friend template <class _Cp, class _Traits> basic_ostream<_Cp, _Traits> &operator<<(basic_ostream<_Cp, _Traits> &__os, const __iom_t10<_Cp> &__x);
        };
template<> class __iom_t10<char> {
            const tm *__tm_;
            const char *__fmt_;
        public:
            __iom_t10(const tm *__tm, const char *__fmt) __attribute__((internal_linkage));
            friend template <class _Cp, class _Traits> basic_ostream<_Cp, _Traits> &operator<<(basic_ostream<_Cp, _Traits> &__os, const __iom_t10<_Cp> &__x);
        };
        template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const __iom_t10<_CharT> &__x)         {
            try {
                typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
                if (__s) {
                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;
                    typedef time_put<_CharT, _Op> _Fp;
                    const _Fp &__tf = use_facet<_Fp>(__os.getloc());
                    if (__tf.put(_Op(__os), __os, __os.fill(), __x.__tm_, __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_)).failed())
                        __os.setstate(ios_base::badbit);
                }
            } catch (...) {
                __os.__set_badbit_and_consider_rethrow();
            }
            return __os;
        }
        template<> basic_ostream<char, std::__1::char_traits<char> > &operator<<<char, std::__1::char_traits<char>>(basic_ostream<char, std::__1::char_traits<char> > &__os, const __iom_t10<char> &__x)        template <class _CharT> inline __iom_t10<_CharT> put_time(const tm *__tm, const _CharT *__fmt) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __iom_t10<_CharT>(__tm, __fmt);
        }
        template <class _CharT, class _Traits, class _ForwardIterator> std::basic_ostream<_CharT, _Traits> &__quoted_output(basic_ostream<_CharT, _Traits> &__os, _ForwardIterator __first, _ForwardIterator __last, _CharT __delim, _CharT __escape)         {
            std::__1::basic_string<_CharT, _Traits> __str;
            __str.push_back(__delim);
            for (; __first != __last; ++__first) {
                if (_Traits::eq(*__first, __escape) || _Traits::eq(*__first, __delim))
                    __str.push_back(__escape);
                __str.push_back(*__first);
            }
            __str.push_back(__delim);
            return __put_character_sequence(__os, __str.data(), __str.size());
        }
        template <class _CharT, class _Traits, class _String> basic_istream<_CharT, _Traits> &__quoted_input(basic_istream<_CharT, _Traits> &__is, _String &__string, _CharT __delim, _CharT __escape)         {
            __string.clear();
            _CharT __c;
            __is >> __c;
            if (__is.fail())
                return __is;
            if (!_Traits::eq(__c, __delim)) {
                __is.unget();
                __is >> __string;
                return __is;
            }
            __save_flags<_CharT, _Traits> sf(__is);
            noskipws(__is);
            while (true)
                {
                    __is >> __c;
                    if (__is.fail())
                        break;
                    if (_Traits::eq(__c, __escape)) {
                        __is >> __c;
                        if (__is.fail())
                            break;
                    } else if (_Traits::eq(__c, __delim))
                        break;
                    __string.push_back(__c);
                }
            return __is;
        }
        template <class _CharT, class _Traits, class _Iter> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const __quoted_output_proxy<_CharT, _Iter, _Traits> &__proxy)         {
            return __quoted_output(__os, __proxy.__first, __proxy.__last, __proxy.__delim, __proxy.__escape);
        }
        template <class _CharT, class _Traits, class _Allocator> struct __quoted_proxy {
            basic_string<_CharT, _Traits, _Allocator> &__string;
            _CharT __delim;
            _CharT __escape;
            __quoted_proxy<_CharT, _Traits, _Allocator>(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __d, _CharT __e) : __string(__s), __delim(__d), __escape(__e)             {
            }
        };
        template <class _CharT, class _Traits, class _Allocator> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const __quoted_proxy<_CharT, _Traits, _Allocator> &__proxy) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __quoted_output(__os, __proxy.__string.cbegin(), __proxy.__string.cend(), __proxy.__delim, __proxy.__escape);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, const __quoted_proxy<_CharT, _Traits, _Allocator> &__proxy) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __quoted_input(__is, __proxy.__string, __proxy.__delim, __proxy.__escape);
        }
        template <class _CharT> __quoted_output_proxy<_CharT, const _CharT *> quoted(const _CharT *__s, _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\')) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            const _CharT *__end = __s;
            while (*__end)
                ++__end;
            return __quoted_output_proxy<_CharT, const _CharT *>(__s, __end, __delim, __escape);
        }
        template <class _CharT, class _Traits, class _Allocator> __quoted_output_proxy<_CharT, typename basic_string<_CharT, _Traits, _Allocator>::const_iterator> __quoted(const basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\')) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __quoted_output_proxy<_CharT, typename basic_string<_CharT, _Traits, _Allocator>::const_iterator>(__s.cbegin(), __s.cend(), __delim, __escape);
        }
        template <class _CharT, class _Traits, class _Allocator> __quoted_proxy<_CharT, _Traits, _Allocator> __quoted(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\')) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            return __quoted_proxy<_CharT, _Traits, _Allocator>(__s, __delim, __escape);
        }
    }
}
namespace std {
    inline namespace __1 {
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_filebuf : public basic_streambuf<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef typename traits_type::state_type state_type;
            basic_filebuf<_CharT, _Traits>();
            virtual ~basic_filebuf<_CharT, _Traits>();
            void swap(basic_filebuf<_CharT, _Traits> &__rhs);
            bool is_open() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_filebuf<_CharT, _Traits> *open(const char *__s, ios_base::openmode __mode);
            basic_filebuf<_CharT, _Traits> *open(const std::__1::string &__s, ios_base::openmode __mode) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_filebuf<_CharT, _Traits> *__open(int __fd, ios_base::openmode __mode) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_filebuf<_CharT, _Traits> *close();
            static inline const char *__make_mdstring(ios_base::openmode __mode) throw() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        protected:
            virtual std::__1::basic_filebuf::int_type underflow();
            virtual std::__1::basic_filebuf::int_type pbackfail(std::__1::basic_filebuf::int_type __c = traits_type::eof());
            virtual std::__1::basic_filebuf::int_type overflow(std::__1::basic_filebuf::int_type __c = traits_type::eof());
            virtual basic_streambuf<std::__1::basic_filebuf::char_type, std::__1::basic_filebuf::traits_type> *setbuf(std::__1::basic_filebuf::char_type *__s, std::__1::streamsize __n);
            virtual std::__1::basic_filebuf::pos_type seekoff(std::__1::basic_filebuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __wch = ios_base::in | ios_base::out);
            virtual std::__1::basic_filebuf::pos_type seekpos(std::__1::basic_filebuf::pos_type __sp, ios_base::openmode __wch = ios_base::in | ios_base::out);
            virtual int sync();
            virtual void imbue(const std::__1::locale &__loc);
        private:
            char *__extbuf_;
            const char *__extbufnext_;
            const char *__extbufend_;
            char __extbuf_min_[8];
            size_t __ebs_;
            std::__1::basic_filebuf::char_type *__intbuf_;
            size_t __ibs_;
            FILE *__file_;
            const codecvt<std::__1::basic_filebuf::char_type, char, std::__1::basic_filebuf::state_type> *__cv_;
            std::__1::basic_filebuf::state_type __st_;
            std::__1::basic_filebuf::state_type __st_last_;
            ios_base::openmode __om_;
            ios_base::openmode __cm_;
            bool __owns_eb_;
            bool __owns_ib_;
            bool __always_noconv_;
            bool __read_mode();
            void __write_mode();
        };
        template <class _CharT, class _Traits> basic_filebuf<_CharT, _Traits>::basic_filebuf<_CharT, _Traits>() : __extbuf_(0), __extbufnext_(0), __extbufend_(0), __ebs_(0), __intbuf_(0), __ibs_(0), __file_(0), __cv_(std::__1::__get_nullptr_t()), __st_(), __st_last_(), __om_(0), __cm_(0), __owns_eb_(false), __owns_ib_(false), __always_noconv_(false)         {
            if (has_facet<codecvt<std::__1::basic_filebuf::char_type, char, std::__1::basic_filebuf::state_type> >(this->getloc())) {
                this->__cv_ = & use_facet<codecvt<std::__1::basic_filebuf::char_type, char, std::__1::basic_filebuf::state_type> >(this->getloc());
                this->__always_noconv_ = this->__cv_->always_noconv();
            }
            this->setbuf(0, 4096);
        }
        template <class _CharT, class _Traits> basic_filebuf<_CharT, _Traits>::~basic_filebuf<_CharT, _Traits>()         {
            try {
                this->close();
            } catch (...) {
            }
            if (this->__owns_eb_)
                delete [] this->__extbuf_;
            if (this->__owns_ib_)
                delete [] this->__intbuf_;
        }
        template <class _CharT, class _Traits> void basic_filebuf<_CharT, _Traits>::swap(basic_filebuf<_CharT, _Traits> &__rhs)         {
            basic_streambuf<char_type, traits_type>::swap(__rhs);
            if (this->__extbuf_ != this->__extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_) {
                std::__1::swap(this->__extbuf_, __rhs.__extbuf_);
                std::__1::swap(this->__extbufnext_, __rhs.__extbufnext_);
                std::__1::swap(this->__extbufend_, __rhs.__extbufend_);
            } else {
                ptrdiff_t __ln = this->__extbufnext_ - this->__extbuf_;
                ptrdiff_t __le = this->__extbufend_ - this->__extbuf_;
                ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;
                ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;
                if (this->__extbuf_ == this->__extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_) {
                    this->__extbuf_ = __rhs.__extbuf_;
                    __rhs.__extbuf_ = __rhs.__extbuf_min_;
                } else if (this->__extbuf_ != this->__extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_) {
                    __rhs.__extbuf_ = this->__extbuf_;
                    this->__extbuf_ = this->__extbuf_min_;
                }
                this->__extbufnext_ = this->__extbuf_ + __rn;
                this->__extbufend_ = this->__extbuf_ + __re;
                __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;
                __rhs.__extbufend_ = __rhs.__extbuf_ + __le;
            }
            std::__1::swap(this->__ebs_, __rhs.__ebs_);
            std::__1::swap(this->__intbuf_, __rhs.__intbuf_);
            std::__1::swap(this->__ibs_, __rhs.__ibs_);
            std::__1::swap(this->__file_, __rhs.__file_);
            std::__1::swap(this->__cv_, __rhs.__cv_);
            std::__1::swap(this->__st_, __rhs.__st_);
            std::__1::swap(this->__st_last_, __rhs.__st_last_);
            std::__1::swap(this->__om_, __rhs.__om_);
            std::__1::swap(this->__cm_, __rhs.__cm_);
            std::__1::swap(this->__owns_eb_, __rhs.__owns_eb_);
            std::__1::swap(this->__owns_ib_, __rhs.__owns_ib_);
            std::__1::swap(this->__always_noconv_, __rhs.__always_noconv_);
            if (this->eback() == (std::__1::basic_filebuf::char_type *)__rhs.__extbuf_min_) {
                ptrdiff_t __n = this->gptr() - this->eback();
                ptrdiff_t __e = this->egptr() - this->eback();
                this->setg((std::__1::basic_filebuf::char_type *)this->__extbuf_min_, (std::__1::basic_filebuf::char_type *)this->__extbuf_min_ + __n, (std::__1::basic_filebuf::char_type *)this->__extbuf_min_ + __e);
            } else if (this->pbase() == (std::__1::basic_filebuf::char_type *)__rhs.__extbuf_min_) {
                ptrdiff_t __n = this->pptr() - this->pbase();
                ptrdiff_t __e = this->epptr() - this->pbase();
                this->setp((std::__1::basic_filebuf::char_type *)this->__extbuf_min_, (std::__1::basic_filebuf::char_type *)this->__extbuf_min_ + __e);
                this->__pbump(__n);
            }
            if (__rhs.eback() == (std::__1::basic_filebuf::char_type *)this->__extbuf_min_) {
                ptrdiff_t __n = __rhs.gptr() - __rhs.eback();
                ptrdiff_t __e = __rhs.egptr() - __rhs.eback();
                __rhs.setg((std::__1::basic_filebuf::char_type *)__rhs.__extbuf_min_, (std::__1::basic_filebuf::char_type *)__rhs.__extbuf_min_ + __n, (std::__1::basic_filebuf::char_type *)__rhs.__extbuf_min_ + __e);
            } else if (__rhs.pbase() == (std::__1::basic_filebuf::char_type *)this->__extbuf_min_) {
                ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();
                ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();
                __rhs.setp((std::__1::basic_filebuf::char_type *)__rhs.__extbuf_min_, (std::__1::basic_filebuf::char_type *)__rhs.__extbuf_min_ + __e);
                __rhs.__pbump(__n);
            }
        }
        template <class _CharT, class _Traits> inline void swap(basic_filebuf<_CharT, _Traits> &__x, basic_filebuf<_CharT, _Traits> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits> inline bool basic_filebuf<_CharT, _Traits>::is_open() const         {
            return this->__file_ != 0;
        }
        template <class _CharT, class _Traits> const char *basic_filebuf<_CharT, _Traits>::__make_mdstring(ios_base::openmode __mode) throw()         {
            switch (__mode & ~ios_base::ate) {
              case ios_base::out:
              case ios_base::out | ios_base::trunc:
                return "w";
              case ios_base::out | ios_base::app:
              case ios_base::app:
                return "a";
              case ios_base::in:
                return "r";
              case ios_base::in | ios_base::out:
                return "r+";
              case ios_base::in | ios_base::out | ios_base::trunc:
                return "w+";
              case ios_base::in | ios_base::out | ios_base::app:
              case ios_base::in | ios_base::app:
                return "a+";
              case ios_base::out | ios_base::binary:
              case ios_base::out | ios_base::trunc | ios_base::binary:
                return "wb";
              case ios_base::out | ios_base::app | ios_base::binary:
              case ios_base::app | ios_base::binary:
                return "ab";
              case ios_base::in | ios_base::binary:
                return "rb";
              case ios_base::in | ios_base::out | ios_base::binary:
                return "r+b";
              case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:
                return "w+b";
              case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:
              case ios_base::in | ios_base::app | ios_base::binary:
                return "a+b";
              default:
                return std::__1::__get_nullptr_t();
            }
            __builtin_unreachable();
        }
        template <class _CharT, class _Traits> basic_filebuf<_CharT, _Traits> *basic_filebuf<_CharT, _Traits>::open(const char *__s, ios_base::openmode __mode)         {
            basic_filebuf<_CharT, _Traits> *__rt = 0;
            if (this->__file_ == 0) {
                if (const char *__mdstr = __make_mdstring(__mode)) {
                    __rt = this;
                    this->__file_ = fopen(__s, __mdstr);
                    if (this->__file_) {
                        this->__om_ = __mode;
                        if (__mode & ios_base::ate) {
                            if (fseek(this->__file_, 0, 2)) {
                                fclose(this->__file_);
                                this->__file_ = 0;
                                __rt = 0;
                            }
                        }
                    } else
                        __rt = 0;
                }
            }
            return __rt;
        }
        template <class _CharT, class _Traits> basic_filebuf<_CharT, _Traits> *basic_filebuf<_CharT, _Traits>::__open(int __fd, ios_base::openmode __mode) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            basic_filebuf<_CharT, _Traits> *__rt = 0;
            if (this->__file_ == 0) {
                if (const char *__mdstr = __make_mdstring(__mode)) {
                    __rt = this;
                    this->__file_ = fdopen(__fd, __mdstr);
                    if (this->__file_) {
                        this->__om_ = __mode;
                        if (__mode & ios_base::ate) {
                            if (fseek(this->__file_, 0, 2)) {
                                fclose(this->__file_);
                                this->__file_ = 0;
                                __rt = 0;
                            }
                        }
                    } else
                        __rt = 0;
                }
            }
            return __rt;
        }
        template <class _CharT, class _Traits> inline basic_filebuf<_CharT, _Traits> *basic_filebuf<_CharT, _Traits>::open(const std::__1::string &__s, ios_base::openmode __mode)         {
            return open(__s.c_str(), __mode);
        }
        template <class _CharT, class _Traits> basic_filebuf<_CharT, _Traits> *basic_filebuf<_CharT, _Traits>::close()         {
            basic_filebuf<_CharT, _Traits> *__rt = 0;
            if (this->__file_) {
                __rt = this;
                unique_ptr<FILE, int (*)(FILE *)> __h(this->__file_, fclose);
                if (this->sync())
                    __rt = 0;
                if (fclose(__h.release()))
                    __rt = 0;
                this->__file_ = 0;
                this->setbuf(0, 0);
            }
            return __rt;
        }
        template <class _CharT, class _Traits> typename basic_filebuf<_CharT, _Traits>::int_type basic_filebuf<_CharT, _Traits>::underflow()         {
            if (this->__file_ == 0)
                return traits_type::eof();
            bool __initial = this->__read_mode();
            std::__1::basic_filebuf::char_type __1buf;
            if (this->gptr() == 0)
                this->setg(& __1buf, & __1buf + 1, & __1buf + 1);
            const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
            std::__1::basic_filebuf::int_type __c = traits_type::eof();
            if (this->gptr() == this->egptr()) {
                memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(std::__1::basic_filebuf::char_type));
                if (this->__always_noconv_) {
                    size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);
                    __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, this->__file_);
                    if (__nmemb != 0) {
                        this->setg(this->eback(), this->eback() + __unget_sz, this->eback() + __unget_sz + __nmemb);
                        __c = traits_type::to_int_type(*this->gptr());
                    }
                } else {
                    ((void)0);
                    if (this->__extbufend_ != this->__extbufnext_)
                        memmove(this->__extbuf_, this->__extbufnext_, this->__extbufend_ - this->__extbufnext_);
                    this->__extbufnext_ = this->__extbuf_ + (this->__extbufend_ - this->__extbufnext_);
                    this->__extbufend_ = this->__extbuf_ + (this->__extbuf_ == this->__extbuf_min_ ? sizeof (this->__extbuf_min_) : this->__ebs_);
                    size_t __nmemb = std::__1::min(static_cast<size_t>(this->__ibs_ - __unget_sz), static_cast<size_t>(this->__extbufend_ - this->__extbufnext_));
                    codecvt_base::result __r;
                    this->__st_last_ = this->__st_;
                    size_t __nr = fread((void *)const_cast<char *>(this->__extbufnext_), 1, __nmemb, this->__file_);
                    if (__nr != 0) {
                        if (!this->__cv_)
                            __throw_bad_cast();
                        this->__extbufend_ = this->__extbufnext_ + __nr;
                        std::__1::basic_filebuf::char_type *__inext;
                        __r = this->__cv_->in(this->__st_, this->__extbuf_, this->__extbufend_, this->__extbufnext_, this->eback() + __unget_sz, this->eback() + this->__ibs_, __inext);
                        if (__r == codecvt_base::noconv) {
                            this->setg((std::__1::basic_filebuf::char_type *)this->__extbuf_, (std::__1::basic_filebuf::char_type *)this->__extbuf_, (std::__1::basic_filebuf::char_type *)const_cast<char *>(this->__extbufend_));
                            __c = traits_type::to_int_type(*this->gptr());
                        } else if (__inext != this->eback() + __unget_sz) {
                            this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                            __c = traits_type::to_int_type(*this->gptr());
                        }
                    }
                }
            } else
                __c = traits_type::to_int_type(*this->gptr());
            if (this->eback() == & __1buf)
                this->setg(0, 0, 0);
            return __c;
        }
        template <class _CharT, class _Traits> typename basic_filebuf<_CharT, _Traits>::int_type basic_filebuf<_CharT, _Traits>::pbackfail(std::__1::basic_filebuf::int_type __c = traits_type::eof())         {
            if (this->__file_ && this->eback() < this->gptr()) {
                if (traits_type::eq_int_type(__c, traits_type::eof())) {
                    this->gbump(-1);
                    return traits_type::not_eof(__c);
                }
                if ((this->__om_ & ios_base::out) || traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])) {
                    this->gbump(-1);
                    *this->gptr() = traits_type::to_char_type(__c);
                    return __c;
                }
            }
            return traits_type::eof();
        }
        template <class _CharT, class _Traits> typename basic_filebuf<_CharT, _Traits>::int_type basic_filebuf<_CharT, _Traits>::overflow(std::__1::basic_filebuf::int_type __c = traits_type::eof())         {
            if (this->__file_ == 0)
                return traits_type::eof();
            this->__write_mode();
            std::__1::basic_filebuf::char_type __1buf;
            std::__1::basic_filebuf::char_type *__pb_save = this->pbase();
            std::__1::basic_filebuf::char_type *__epb_save = this->epptr();
            if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                if (this->pptr() == 0)
                    this->setp(& __1buf, & __1buf + 1);
                *this->pptr() = traits_type::to_char_type(__c);
                this->pbump(1);
            }
            if (this->pptr() != this->pbase()) {
                if (this->__always_noconv_) {
                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                    if (fwrite(this->pbase(), sizeof(std::__1::basic_filebuf::char_type), __nmemb, this->__file_) != __nmemb)
                        return traits_type::eof();
                } else {
                    char *__extbe = this->__extbuf_;
                    codecvt_base::result __r;
                    do {
                        if (!this->__cv_)
                            __throw_bad_cast();
                        const std::__1::basic_filebuf::char_type *__e;
                        __r = this->__cv_->out(this->__st_, this->pbase(), this->pptr(), __e, this->__extbuf_, this->__extbuf_ + this->__ebs_, __extbe);
                        if (__e == this->pbase())
                            return traits_type::eof();
                        if (__r == codecvt_base::noconv) {
                            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                            if (fwrite(this->pbase(), 1, __nmemb, this->__file_) != __nmemb)
                                return traits_type::eof();
                        } else if (__r == codecvt_base::ok || __r == codecvt_base::partial) {
                            size_t __nmemb = static_cast<size_t>(__extbe - this->__extbuf_);
                            if (fwrite(this->__extbuf_, 1, __nmemb, this->__file_) != __nmemb)
                                return traits_type::eof();
                            if (__r == codecvt_base::partial) {
                                this->setp(const_cast<std::__1::basic_filebuf::char_type *>(__e), this->pptr());
                                this->__pbump(this->epptr() - this->pbase());
                            }
                        } else
                            return traits_type::eof();
                    } while (__r == codecvt_base::partial);
                }
                this->setp(__pb_save, __epb_save);
            }
            return traits_type::not_eof(__c);
        }
        template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits> *basic_filebuf<_CharT, _Traits>::setbuf(std::__1::basic_filebuf::char_type *__s, std::__1::streamsize __n)         {
            this->setg(0, 0, 0);
            this->setp(0, 0);
            if (this->__owns_eb_)
                delete [] this->__extbuf_;
            if (this->__owns_ib_)
                delete [] this->__intbuf_;
            this->__ebs_ = __n;
            if (this->__ebs_ > sizeof (this->__extbuf_min_)) {
                if (this->__always_noconv_ && __s) {
                    this->__extbuf_ = (char *)__s;
                    this->__owns_eb_ = false;
                } else {
                    this->__extbuf_ = new char [this->__ebs_];
                    this->__owns_eb_ = true;
                }
            } else {
                this->__extbuf_ = this->__extbuf_min_;
                this->__ebs_ = sizeof (this->__extbuf_min_);
                this->__owns_eb_ = false;
            }
            if (!this->__always_noconv_) {
                this->__ibs_ = max<std::__1::streamsize>(__n, sizeof (this->__extbuf_min_));
                if (__s && this->__ibs_ >= sizeof (this->__extbuf_min_)) {
                    this->__intbuf_ = __s;
                    this->__owns_ib_ = false;
                } else {
                    this->__intbuf_ = new std::__1::basic_filebuf::char_type [this->__ibs_];
                    this->__owns_ib_ = true;
                }
            } else {
                this->__ibs_ = 0;
                this->__intbuf_ = 0;
                this->__owns_ib_ = false;
            }
            return this;
        }
        template <class _CharT, class _Traits> typename basic_filebuf<_CharT, _Traits>::pos_type basic_filebuf<_CharT, _Traits>::seekoff(std::__1::basic_filebuf::off_type __off, ios_base::seekdir __way, ios_base::openmode = ios_base::in | ios_base::out)         {
            if (!this->__cv_)
                __throw_bad_cast();
            int __width = this->__cv_->encoding();
            if (this->__file_ == 0 || (__width <= 0 && __off != 0) || this->sync())
                return std::__1::basic_filebuf::pos_type(std::__1::basic_filebuf::off_type(-1));
            int __whence;
            switch (__way) {
              case ios_base::beg:
                __whence = 0;
                break;
              case ios_base::cur:
                __whence = 1;
                break;
              case ios_base::end:
                __whence = 2;
                break;
              default:
                return std::__1::basic_filebuf::pos_type(std::__1::basic_filebuf::off_type(-1));
            }
            if (fseeko(this->__file_, __width > 0 ? __width * __off : 0, __whence))
                return std::__1::basic_filebuf::pos_type(std::__1::basic_filebuf::off_type(-1));
            std::__1::basic_filebuf::pos_type __r = ftello(this->__file_);
            __r.state(this->__st_);
            return __r;
        }
        template <class _CharT, class _Traits> typename basic_filebuf<_CharT, _Traits>::pos_type basic_filebuf<_CharT, _Traits>::seekpos(std::__1::basic_filebuf::pos_type __sp, ios_base::openmode = ios_base::in | ios_base::out)         {
            if (this->__file_ == 0 || this->sync())
                return std::__1::basic_filebuf::pos_type(std::__1::basic_filebuf::off_type(-1));
            if (fseeko(this->__file_, __sp, 0))
                return std::__1::basic_filebuf::pos_type(std::__1::basic_filebuf::off_type(-1));
            this->__st_ = __sp.state();
            return __sp;
        }
        template <class _CharT, class _Traits> int basic_filebuf<_CharT, _Traits>::sync()         {
            if (this->__file_ == 0)
                return 0;
            if (!this->__cv_)
                __throw_bad_cast();
            if (this->__cm_ & ios_base::out) {
                if (this->pptr() != this->pbase())
                    if (this->overflow() == traits_type::eof())
                        return -1;
                codecvt_base::result __r;
                do {
                    char *__extbe;
                    __r = this->__cv_->unshift(this->__st_, this->__extbuf_, this->__extbuf_ + this->__ebs_, __extbe);
                    size_t __nmemb = static_cast<size_t>(__extbe - this->__extbuf_);
                    if (fwrite(this->__extbuf_, 1, __nmemb, this->__file_) != __nmemb)
                        return -1;
                } while (__r == codecvt_base::partial);
                if (__r == codecvt_base::error)
                    return -1;
                if (fflush(this->__file_))
                    return -1;
            } else if (this->__cm_ & ios_base::in) {
                std::__1::basic_filebuf::off_type __c;
                std::__1::basic_filebuf::state_type __state = this->__st_last_;
                bool __update_st = false;
                if (this->__always_noconv_)
                    __c = this->egptr() - this->gptr();
                else {
                    int __width = this->__cv_->encoding();
                    __c = this->__extbufend_ - this->__extbufnext_;
                    if (__width > 0)
                        __c += __width * (this->egptr() - this->gptr());
                    else {
                        if (this->gptr() != this->egptr()) {
                            const int __off = this->__cv_->length(__state, this->__extbuf_, this->__extbufnext_, this->gptr() - this->eback());
                            __c += this->__extbufnext_ - this->__extbuf_ - __off;
                            __update_st = true;
                        }
                    }
                }
                if (fseeko(this->__file_, - __c, 1))
                    return -1;
                if (__update_st)
                    this->__st_ = __state;
                this->__extbufnext_ = this->__extbufend_ = this->__extbuf_;
                this->setg(0, 0, 0);
                this->__cm_ = 0;
            }
            return 0;
        }
        template <class _CharT, class _Traits> void basic_filebuf<_CharT, _Traits>::imbue(const std::__1::locale &__loc)         {
            this->sync();
            this->__cv_ = & use_facet<codecvt<std::__1::basic_filebuf::char_type, char, std::__1::basic_filebuf::state_type> >(__loc);
            bool __old_anc = this->__always_noconv_;
            this->__always_noconv_ = this->__cv_->always_noconv();
            if (__old_anc != this->__always_noconv_) {
                this->setg(0, 0, 0);
                this->setp(0, 0);
                if (this->__always_noconv_) {
                    if (this->__owns_eb_)
                        delete [] this->__extbuf_;
                    this->__owns_eb_ = this->__owns_ib_;
                    this->__ebs_ = this->__ibs_;
                    this->__extbuf_ = (char *)this->__intbuf_;
                    this->__ibs_ = 0;
                    this->__intbuf_ = 0;
                    this->__owns_ib_ = false;
                } else {
                    if (!this->__owns_eb_ && this->__extbuf_ != this->__extbuf_min_) {
                        this->__ibs_ = this->__ebs_;
                        this->__intbuf_ = (std::__1::basic_filebuf::char_type *)this->__extbuf_;
                        this->__owns_ib_ = false;
                        this->__extbuf_ = new char [this->__ebs_];
                        this->__owns_eb_ = true;
                    } else {
                        this->__ibs_ = this->__ebs_;
                        this->__intbuf_ = new std::__1::basic_filebuf::char_type [this->__ibs_];
                        this->__owns_ib_ = true;
                    }
                }
            }
        }
        template <class _CharT, class _Traits> bool basic_filebuf<_CharT, _Traits>::__read_mode()         {
            if (!(this->__cm_ & ios_base::in)) {
                this->setp(0, 0);
                if (this->__always_noconv_)
                    this->setg((std::__1::basic_filebuf::char_type *)this->__extbuf_, (std::__1::basic_filebuf::char_type *)this->__extbuf_ + this->__ebs_, (std::__1::basic_filebuf::char_type *)this->__extbuf_ + this->__ebs_);
                else
                    this->setg(this->__intbuf_, this->__intbuf_ + this->__ibs_, this->__intbuf_ + this->__ibs_);
                this->__cm_ = ios_base::in;
                return true;
            }
            return false;
        }
        template <class _CharT, class _Traits> void basic_filebuf<_CharT, _Traits>::__write_mode()         {
            if (!(this->__cm_ & ios_base::out)) {
                this->setg(0, 0, 0);
                if (this->__ebs_ > sizeof (this->__extbuf_min_)) {
                    if (this->__always_noconv_)
                        this->setp((std::__1::basic_filebuf::char_type *)this->__extbuf_, (std::__1::basic_filebuf::char_type *)this->__extbuf_ + (this->__ebs_ - 1));
                    else
                        this->setp(this->__intbuf_, this->__intbuf_ + (this->__ibs_ - 1));
                } else
                    this->setp(0, 0);
                this->__cm_ = ios_base::out;
            }
        }
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ifstream : public basic_istream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            basic_ifstream<_CharT, _Traits>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit basic_ifstream<_CharT, _Traits>(const char *__s, ios_base::openmode __mode = ios_base::in) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit basic_ifstream<_CharT, _Traits>(const std::__1::string &__s, ios_base::openmode __mode = ios_base::in) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void swap(basic_ifstream<_CharT, _Traits> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_filebuf<std::__1::basic_ifstream::char_type, std::__1::basic_ifstream::traits_type> *rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool is_open() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void open(const char *__s, ios_base::openmode __mode = ios_base::in);
            void open(const std::__1::string &__s, ios_base::openmode __mode = ios_base::in);
            void __open(int __fd, ios_base::openmode __mode) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void close() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        private:
            basic_filebuf<std::__1::basic_ifstream::char_type, std::__1::basic_ifstream::traits_type> __sb_;
        };
        template <class _CharT, class _Traits> inline basic_ifstream<_CharT, _Traits>::basic_ifstream<_CharT, _Traits>() : basic_istream<std::__1::basic_ifstream::char_type, std::__1::basic_ifstream::traits_type>(& this->__sb_)         {
        }
        template <class _CharT, class _Traits> inline explicit basic_ifstream<_CharT, _Traits>::basic_ifstream<_CharT, _Traits>(const char *__s, ios_base::openmode __mode = ios_base::in) : basic_istream<std::__1::basic_ifstream::char_type, std::__1::basic_ifstream::traits_type>(& this->__sb_)         {
            if (this->__sb_.open(__s, __mode | ios_base::in) == 0)
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> inline explicit basic_ifstream<_CharT, _Traits>::basic_ifstream<_CharT, _Traits>(const std::__1::string &__s, ios_base::openmode __mode = ios_base::in) : basic_istream<std::__1::basic_ifstream::char_type, std::__1::basic_ifstream::traits_type>(& this->__sb_)         {
            if (this->__sb_.open(__s, __mode | ios_base::in) == 0)
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> inline void basic_ifstream<_CharT, _Traits>::swap(basic_ifstream<_CharT, _Traits> &__rhs)         {
            basic_istream<char_type, traits_type>::swap(__rhs);
            this->__sb_.swap(__rhs.__sb_);
        }
        template <class _CharT, class _Traits> inline void swap(basic_ifstream<_CharT, _Traits> &__x, basic_ifstream<_CharT, _Traits> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits> inline basic_filebuf<_CharT, _Traits> *basic_ifstream<_CharT, _Traits>::rdbuf() const         {
            return const_cast<basic_filebuf<std::__1::basic_ifstream::char_type, std::__1::basic_ifstream::traits_type> *>(& this->__sb_);
        }
        template <class _CharT, class _Traits> inline bool basic_ifstream<_CharT, _Traits>::is_open() const         {
            return this->__sb_.is_open();
        }
        template <class _CharT, class _Traits> void basic_ifstream<_CharT, _Traits>::open(const char *__s, ios_base::openmode __mode = ios_base::in)         {
            if (this->__sb_.open(__s, __mode | ios_base::in))
                this->clear();
            else
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> void basic_ifstream<_CharT, _Traits>::open(const std::__1::string &__s, ios_base::openmode __mode = ios_base::in)         {
            if (this->__sb_.open(__s, __mode | ios_base::in))
                this->clear();
            else
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> void basic_ifstream<_CharT, _Traits>::__open(int __fd, ios_base::openmode __mode)         {
            if (this->__sb_.__open(__fd, __mode | ios_base::in))
                this->clear();
            else
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> inline void basic_ifstream<_CharT, _Traits>::close()         {
            if (this->__sb_.close() == 0)
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_ofstream : public basic_ostream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            basic_ofstream<_CharT, _Traits>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit basic_ofstream<_CharT, _Traits>(const char *__s, ios_base::openmode __mode = ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit basic_ofstream<_CharT, _Traits>(const std::__1::string &__s, ios_base::openmode __mode = ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void swap(basic_ofstream<_CharT, _Traits> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_filebuf<std::__1::basic_ofstream::char_type, std::__1::basic_ofstream::traits_type> *rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool is_open() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void open(const char *__s, ios_base::openmode __mode = ios_base::out);
            void open(const std::__1::string &__s, ios_base::openmode __mode = ios_base::out);
            void __open(int __fd, ios_base::openmode __mode) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void close() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        private:
            basic_filebuf<std::__1::basic_ofstream::char_type, std::__1::basic_ofstream::traits_type> __sb_;
        };
        template <class _CharT, class _Traits> inline basic_ofstream<_CharT, _Traits>::basic_ofstream<_CharT, _Traits>() : basic_ostream<std::__1::basic_ofstream::char_type, std::__1::basic_ofstream::traits_type>(& this->__sb_)         {
        }
        template <class _CharT, class _Traits> inline explicit basic_ofstream<_CharT, _Traits>::basic_ofstream<_CharT, _Traits>(const char *__s, ios_base::openmode __mode = ios_base::out) : basic_ostream<std::__1::basic_ofstream::char_type, std::__1::basic_ofstream::traits_type>(& this->__sb_)         {
            if (this->__sb_.open(__s, __mode | ios_base::out) == 0)
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> inline explicit basic_ofstream<_CharT, _Traits>::basic_ofstream<_CharT, _Traits>(const std::__1::string &__s, ios_base::openmode __mode = ios_base::out) : basic_ostream<std::__1::basic_ofstream::char_type, std::__1::basic_ofstream::traits_type>(& this->__sb_)         {
            if (this->__sb_.open(__s, __mode | ios_base::out) == 0)
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> inline void basic_ofstream<_CharT, _Traits>::swap(basic_ofstream<_CharT, _Traits> &__rhs)         {
            basic_ostream<char_type, traits_type>::swap(__rhs);
            this->__sb_.swap(__rhs.__sb_);
        }
        template <class _CharT, class _Traits> inline void swap(basic_ofstream<_CharT, _Traits> &__x, basic_ofstream<_CharT, _Traits> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits> inline basic_filebuf<_CharT, _Traits> *basic_ofstream<_CharT, _Traits>::rdbuf() const         {
            return const_cast<basic_filebuf<std::__1::basic_ofstream::char_type, std::__1::basic_ofstream::traits_type> *>(& this->__sb_);
        }
        template <class _CharT, class _Traits> inline bool basic_ofstream<_CharT, _Traits>::is_open() const         {
            return this->__sb_.is_open();
        }
        template <class _CharT, class _Traits> void basic_ofstream<_CharT, _Traits>::open(const char *__s, ios_base::openmode __mode = ios_base::out)         {
            if (this->__sb_.open(__s, __mode | ios_base::out))
                this->clear();
            else
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> void basic_ofstream<_CharT, _Traits>::open(const std::__1::string &__s, ios_base::openmode __mode = ios_base::out)         {
            if (this->__sb_.open(__s, __mode | ios_base::out))
                this->clear();
            else
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> void basic_ofstream<_CharT, _Traits>::__open(int __fd, ios_base::openmode __mode)         {
            if (this->__sb_.__open(__fd, __mode | ios_base::out))
                this->clear();
            else
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> inline void basic_ofstream<_CharT, _Traits>::close()         {
            if (this->__sb_.close() == 0)
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits = char_traits<_CharT>> class __attribute__((type_visibility("default"))) basic_fstream : public basic_iostream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            basic_fstream<_CharT, _Traits>() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit basic_fstream<_CharT, _Traits>(const char *__s, ios_base::openmode __mode = ios_base::in | ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            explicit basic_fstream<_CharT, _Traits>(const std::__1::string &__s, ios_base::openmode __mode = ios_base::in | ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void swap(basic_fstream<_CharT, _Traits> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            basic_filebuf<std::__1::basic_fstream::char_type, std::__1::basic_fstream::traits_type> *rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            bool is_open() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void open(const char *__s, ios_base::openmode __mode = ios_base::in | ios_base::out);
            void open(const std::__1::string &__s, ios_base::openmode __mode = ios_base::in | ios_base::out);
            void close() __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        private:
            basic_filebuf<std::__1::basic_fstream::char_type, std::__1::basic_fstream::traits_type> __sb_;
        };
        template <class _CharT, class _Traits> inline basic_fstream<_CharT, _Traits>::basic_fstream<_CharT, _Traits>() : basic_iostream<std::__1::basic_fstream::char_type, std::__1::basic_fstream::traits_type>(& this->__sb_)         {
        }
        template <class _CharT, class _Traits> inline explicit basic_fstream<_CharT, _Traits>::basic_fstream<_CharT, _Traits>(const char *__s, ios_base::openmode __mode = ios_base::in | ios_base::out) : basic_iostream<std::__1::basic_fstream::char_type, std::__1::basic_fstream::traits_type>(& this->__sb_)         {
            if (this->__sb_.open(__s, __mode) == 0)
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> inline explicit basic_fstream<_CharT, _Traits>::basic_fstream<_CharT, _Traits>(const std::__1::string &__s, ios_base::openmode __mode = ios_base::in | ios_base::out) : basic_iostream<std::__1::basic_fstream::char_type, std::__1::basic_fstream::traits_type>(& this->__sb_)         {
            if (this->__sb_.open(__s, __mode) == 0)
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> inline void basic_fstream<_CharT, _Traits>::swap(basic_fstream<_CharT, _Traits> &__rhs)         {
            basic_iostream<char_type, traits_type>::swap(__rhs);
            this->__sb_.swap(__rhs.__sb_);
        }
        template <class _CharT, class _Traits> inline void swap(basic_fstream<_CharT, _Traits> &__x, basic_fstream<_CharT, _Traits> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits> inline basic_filebuf<_CharT, _Traits> *basic_fstream<_CharT, _Traits>::rdbuf() const         {
            return const_cast<basic_filebuf<std::__1::basic_fstream::char_type, std::__1::basic_fstream::traits_type> *>(& this->__sb_);
        }
        template <class _CharT, class _Traits> inline bool basic_fstream<_CharT, _Traits>::is_open() const         {
            return this->__sb_.is_open();
        }
        template <class _CharT, class _Traits> void basic_fstream<_CharT, _Traits>::open(const char *__s, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            if (this->__sb_.open(__s, __mode))
                this->clear();
            else
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> void basic_fstream<_CharT, _Traits>::open(const std::__1::string &__s, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            if (this->__sb_.open(__s, __mode))
                this->clear();
            else
                this->setstate(ios_base::failbit);
        }
        template <class _CharT, class _Traits> inline void basic_fstream<_CharT, _Traits>::close()         {
            if (this->__sb_.close() == 0)
                this->setstate(ios_base::failbit);
        }
    }
}
typedef void (*os_function_t)(void * _Nullable);
typedef void (^os_block_t)();
typedef __darwin_uuid_t uuid_t;
typedef __darwin_uuid_string_t uuid_string_t;
static const uuid_t UUID_NULL = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} __attribute__((unused));
extern "C" {
    void uuid_clear(uuid_t uu);
    int uuid_compare(const uuid_t uu1, const uuid_t uu2);
    void uuid_copy(uuid_t dst, const uuid_t src);
    void uuid_generate(uuid_t out);
    void uuid_generate_random(uuid_t out);
    void uuid_generate_time(uuid_t out);
    void uuid_generate_early_random(uuid_t out);
    int uuid_is_null(const uuid_t uu);
    int uuid_parse(const uuid_string_t in, uuid_t uu);
    void uuid_unparse(const uuid_t uu, uuid_string_t out);
    void uuid_unparse_lower(const uuid_t uu, uuid_string_t out);
    void uuid_unparse_upper(const uuid_t uu, uuid_string_t out);
}
extern "C" {
    int backtrace(void **, int) __attribute__((availability(macos, introduced=10.5)));
    extern int backtrace_from_fp(void *startfp, void **array, int size) __attribute__((availability(macos, introduced=10.14))) __attribute__((availability(ios, introduced=12.0))) __attribute__((availability(tvos, introduced=12.0))) __attribute__((availability(watchos, introduced=5.0))) __attribute__((visibility("default")));
    char **backtrace_symbols(void *const *, int) __attribute__((availability(macos, introduced=10.5)));
    void backtrace_symbols_fd(void *const *, int, int) __attribute__((availability(macos, introduced=10.5)));
    struct image_offset {
        uuid_t uuid;
        uint32_t offset;
    };
    extern void backtrace_image_offsets(void *const *array, struct image_offset *image_offsets, int size) __attribute__((availability(macos, introduced=10.14))) __attribute__((availability(ios, introduced=12.0))) __attribute__((availability(tvos, introduced=12.0))) __attribute__((availability(watchos, introduced=5.0))) __attribute__((visibility("default")));
}
struct timeval64 {
    __int64_t tv_sec;
    __int64_t tv_usec;
};
struct itimerval {
    struct timeval it_interval;
    struct timeval it_value;
};
struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};
struct clockinfo {
    int hz;
    int tick;
    int tickadj;
    int stathz;
    int profhz;
};
extern "C" {
    int adjtime(const struct timeval *, struct timeval *);
    int futimes(int, const struct timeval *);
    int lutimes(const char *, const struct timeval *) __attribute__((availability(macos, introduced=10.5)));
    int settimeofday(const struct timeval *, const struct timezone *);
    int getitimer(int, struct itimerval *);
    int gettimeofday(struct timeval *, void *);
    int select(int, fd_set *, fd_set *, fd_set *, struct timeval *) asm("_select$1050");
    int setitimer(int, const struct itimerval *, struct itimerval *);
    int utimes(const char *, const struct timeval *);
}
namespace std {
    inline namespace __1 {
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_stringbuf : public basic_streambuf<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef _Allocator allocator_type;
            typedef basic_string<std::__1::basic_stringbuf::char_type, std::__1::basic_stringbuf::traits_type, std::__1::basic_stringbuf::allocator_type> string_type;
        private:
            std::__1::basic_stringbuf::string_type __str_;
            mutable std::__1::basic_stringbuf::char_type *__hm_;
            ios_base::openmode __mode_;
        public:
            inline explicit basic_stringbuf<_CharT, _Traits, _Allocator>(ios_base::openmode __wch = ios_base::in | ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline explicit basic_stringbuf<_CharT, _Traits, _Allocator>(const std::__1::basic_stringbuf::string_type &__s, ios_base::openmode __wch = ios_base::in | ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            void swap(basic_stringbuf<_CharT, _Traits, _Allocator> &__rhs);
            std::__1::basic_stringbuf::string_type str() const;
            void str(const std::__1::basic_stringbuf::string_type &__s);
        protected:
            virtual std::__1::basic_stringbuf::int_type underflow();
            virtual std::__1::basic_stringbuf::int_type pbackfail(std::__1::basic_stringbuf::int_type __c = traits_type::eof());
            virtual std::__1::basic_stringbuf::int_type overflow(std::__1::basic_stringbuf::int_type __c = traits_type::eof());
            virtual std::__1::basic_stringbuf::pos_type seekoff(std::__1::basic_stringbuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __wch = ios_base::in | ios_base::out);
            inline virtual std::__1::basic_stringbuf::pos_type seekpos(std::__1::basic_stringbuf::pos_type __sp, ios_base::openmode __wch = ios_base::in | ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        };
        template <class _CharT, class _Traits, class _Allocator> explicit basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf<_CharT, _Traits, _Allocator>(ios_base::openmode __wch = ios_base::in | ios_base::out) : __hm_(0), __mode_(__wch)         {
        }
        template <class _CharT, class _Traits, class _Allocator> explicit basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf<_CharT, _Traits, _Allocator>(const std::__1::basic_stringbuf::string_type &__s, ios_base::openmode __wch = ios_base::in | ios_base::out) : __str_(__s.get_allocator()), __hm_(0), __mode_(__wch)         {
            str(__s);
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf<_CharT, _Traits, _Allocator> &__rhs)         {
            std::__1::basic_stringbuf::char_type *__p = const_cast<std::__1::basic_stringbuf::char_type *>(__rhs.__str_.data());
            ptrdiff_t __rbinp = -1;
            ptrdiff_t __rninp = -1;
            ptrdiff_t __reinp = -1;
            if (__rhs.eback() != std::__1::__get_nullptr_t()) {
                __rbinp = __rhs.eback() - __p;
                __rninp = __rhs.gptr() - __p;
                __reinp = __rhs.egptr() - __p;
            }
            ptrdiff_t __rbout = -1;
            ptrdiff_t __rnout = -1;
            ptrdiff_t __reout = -1;
            if (__rhs.pbase() != std::__1::__get_nullptr_t()) {
                __rbout = __rhs.pbase() - __p;
                __rnout = __rhs.pptr() - __p;
                __reout = __rhs.epptr() - __p;
            }
            ptrdiff_t __rhm = __rhs.__hm_ == std::__1::__get_nullptr_t() ? -1 : __rhs.__hm_ - __p;
            __p = const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data());
            ptrdiff_t __lbinp = -1;
            ptrdiff_t __lninp = -1;
            ptrdiff_t __leinp = -1;
            if (this->eback() != std::__1::__get_nullptr_t()) {
                __lbinp = this->eback() - __p;
                __lninp = this->gptr() - __p;
                __leinp = this->egptr() - __p;
            }
            ptrdiff_t __lbout = -1;
            ptrdiff_t __lnout = -1;
            ptrdiff_t __leout = -1;
            if (this->pbase() != std::__1::__get_nullptr_t()) {
                __lbout = this->pbase() - __p;
                __lnout = this->pptr() - __p;
                __leout = this->epptr() - __p;
            }
            ptrdiff_t __lhm = this->__hm_ == std::__1::__get_nullptr_t() ? -1 : this->__hm_ - __p;
            std::__1::swap(this->__mode_, __rhs.__mode_);
            this->__str_.swap(__rhs.__str_);
            __p = const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data());
            if (__rbinp != -1)
                this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);
            else
                this->setg(std::__1::__get_nullptr_t(), std::__1::__get_nullptr_t(), std::__1::__get_nullptr_t());
            if (__rbout != -1) {
                this->setp(__p + __rbout, __p + __reout);
                this->__pbump(__rnout);
            } else
                this->setp(std::__1::__get_nullptr_t(), std::__1::__get_nullptr_t());
            this->__hm_ = __rhm == -1 ? std::__1::__get_nullptr_t() : __p + __rhm;
            __p = const_cast<std::__1::basic_stringbuf::char_type *>(__rhs.__str_.data());
            if (__lbinp != -1)
                __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);
            else
                __rhs.setg(std::__1::__get_nullptr_t(), std::__1::__get_nullptr_t(), std::__1::__get_nullptr_t());
            if (__lbout != -1) {
                __rhs.setp(__p + __lbout, __p + __leout);
                __rhs.__pbump(__lnout);
            } else
                __rhs.setp(std::__1::__get_nullptr_t(), std::__1::__get_nullptr_t());
            __rhs.__hm_ = __lhm == -1 ? std::__1::__get_nullptr_t() : __p + __lhm;
            std::__1::locale __tl = __rhs.getloc();
            __rhs.pubimbue(this->getloc());
            this->pubimbue(__tl);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_stringbuf<_CharT, _Traits, _Allocator> &__x, basic_stringbuf<_CharT, _Traits, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> basic_stringbuf<_CharT, _Traits, _Allocator>::str() const         {
            if (this->__mode_ & ios_base::out) {
                if (this->__hm_ < this->pptr())
                    this->__hm_ = this->pptr();
                return std::__1::basic_stringbuf::string_type(this->pbase(), this->__hm_, this->__str_.get_allocator());
            } else if (this->__mode_ & ios_base::in)
                return std::__1::basic_stringbuf::string_type(this->eback(), this->egptr(), this->__str_.get_allocator());
            return std::__1::basic_stringbuf::string_type(this->__str_.get_allocator());
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_stringbuf<_CharT, _Traits, _Allocator>::str(const std::__1::basic_stringbuf::string_type &__s)         {
            this->__str_ = __s;
            this->__hm_ = 0;
            if (this->__mode_ & ios_base::in) {
                this->__hm_ = const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data()) + this->__str_.size();
                this->setg(const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data()), const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data()), this->__hm_);
            }
            if (this->__mode_ & ios_base::out) {
                typename string_type::size_type __sz = this->__str_.size();
                this->__hm_ = const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data()) + __sz;
                this->__str_.resize(this->__str_.capacity());
                this->setp(const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data()), const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data()) + this->__str_.size());
                if (this->__mode_ & (ios_base::app | ios_base::ate)) {
                    while (__sz > 2147483647)
                        {
                            this->pbump(2147483647);
                            __sz -= 2147483647;
                        }
                    if (__sz > 0)
                        this->pbump(__sz);
                }
            }
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type basic_stringbuf<_CharT, _Traits, _Allocator>::underflow()         {
            if (this->__hm_ < this->pptr())
                this->__hm_ = this->pptr();
            if (this->__mode_ & ios_base::in) {
                if (this->egptr() < this->__hm_)
                    this->setg(this->eback(), this->gptr(), this->__hm_);
                if (this->gptr() < this->egptr())
                    return traits_type::to_int_type(*this->gptr());
            }
            return traits_type::eof();
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type basic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(std::__1::basic_stringbuf::int_type __c = traits_type::eof())         {
            if (this->__hm_ < this->pptr())
                this->__hm_ = this->pptr();
            if (this->eback() < this->gptr()) {
                if (traits_type::eq_int_type(__c, traits_type::eof())) {
                    this->setg(this->eback(), this->gptr() - 1, this->__hm_);
                    return traits_type::not_eof(__c);
                }
                if ((this->__mode_ & ios_base::out) || traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])) {
                    this->setg(this->eback(), this->gptr() - 1, this->__hm_);
                    *this->gptr() = traits_type::to_char_type(__c);
                    return __c;
                }
            }
            return traits_type::eof();
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type basic_stringbuf<_CharT, _Traits, _Allocator>::overflow(std::__1::basic_stringbuf::int_type __c = traits_type::eof())         {
            if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                ptrdiff_t __ninp = this->gptr() - this->eback();
                if (this->pptr() == this->epptr()) {
                    if (!(this->__mode_ & ios_base::out))
                        return traits_type::eof();
                    try {
                        ptrdiff_t __nout = this->pptr() - this->pbase();
                        ptrdiff_t __hm = this->__hm_ - this->pbase();
                        this->__str_.push_back(std::__1::basic_stringbuf::char_type());
                        this->__str_.resize(this->__str_.capacity());
                        std::__1::basic_stringbuf::char_type *__p = const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data());
                        this->setp(__p, __p + this->__str_.size());
                        this->__pbump(__nout);
                        this->__hm_ = this->pbase() + __hm;
                    } catch (...) {
                        return traits_type::eof();
                    }
                }
                this->__hm_ = std::__1::max(this->pptr() + 1, this->__hm_);
                if (this->__mode_ & ios_base::in) {
                    std::__1::basic_stringbuf::char_type *__p = const_cast<std::__1::basic_stringbuf::char_type *>(this->__str_.data());
                    this->setg(__p, __p + __ninp, this->__hm_);
                }
                return this->sputc(traits_type::to_char_type(__c));
            }
            return traits_type::not_eof(__c);
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type basic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(std::__1::basic_stringbuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __wch = ios_base::in | ios_base::out)         {
            if (this->__hm_ < this->pptr())
                this->__hm_ = this->pptr();
            if ((__wch & (ios_base::in | ios_base::out)) == 0)
                return std::__1::basic_stringbuf::pos_type(-1);
            if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out) && __way == ios_base::cur)
                return std::__1::basic_stringbuf::pos_type(-1);
            const ptrdiff_t __hm = this->__hm_ == std::__1::__get_nullptr_t() ? 0 : this->__hm_ - this->__str_.data();
            std::__1::basic_stringbuf::off_type __noff;
            switch (__way) {
              case ios_base::beg:
                __noff = 0;
                break;
              case ios_base::cur:
                if (__wch & ios_base::in)
                    __noff = this->gptr() - this->eback();
                else
                    __noff = this->pptr() - this->pbase();
                break;
              case ios_base::end:
                __noff = __hm;
                break;
              default:
                return std::__1::basic_stringbuf::pos_type(-1);
            }
            __noff += __off;
            if (__noff < 0 || __hm < __noff)
                return std::__1::basic_stringbuf::pos_type(-1);
            if (__noff != 0) {
                if ((__wch & ios_base::in) && this->gptr() == 0)
                    return std::__1::basic_stringbuf::pos_type(-1);
                if ((__wch & ios_base::out) && this->pptr() == 0)
                    return std::__1::basic_stringbuf::pos_type(-1);
            }
            if (__wch & ios_base::in)
                this->setg(this->eback(), this->eback() + __noff, this->__hm_);
            if (__wch & ios_base::out) {
                this->setp(this->pbase(), this->epptr());
                this->pbump(__noff);
            }
            return std::__1::basic_stringbuf::pos_type(__noff);
        }
        template <class _CharT, class _Traits, class _Allocator> typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type basic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(std::__1::basic_stringbuf::pos_type __sp, ios_base::openmode __wch = ios_base::in | ios_base::out)         {
            return this->seekoff(__sp, ios_base::beg, __wch);
        }
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_istringstream : public basic_istream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef _Allocator allocator_type;
            typedef basic_string<std::__1::basic_istringstream::char_type, std::__1::basic_istringstream::traits_type, std::__1::basic_istringstream::allocator_type> string_type;
        private:
            basic_stringbuf<std::__1::basic_istringstream::char_type, std::__1::basic_istringstream::traits_type, std::__1::basic_istringstream::allocator_type> __sb_;
        public:
            inline explicit basic_istringstream<_CharT, _Traits, _Allocator>(ios_base::openmode __wch = ios_base::in) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline explicit basic_istringstream<_CharT, _Traits, _Allocator>(const std::__1::basic_istringstream::string_type &__s, ios_base::openmode __wch = ios_base::in) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline void swap(basic_istringstream<_CharT, _Traits, _Allocator> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline basic_stringbuf<std::__1::basic_istringstream::char_type, std::__1::basic_istringstream::traits_type, std::__1::basic_istringstream::allocator_type> *rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline std::__1::basic_istringstream::string_type str() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline void str(const std::__1::basic_istringstream::string_type &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        };
        template <class _CharT, class _Traits, class _Allocator> explicit basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream<_CharT, _Traits, _Allocator>(ios_base::openmode __wch = ios_base::in) : basic_istream<_CharT, _Traits>(& this->__sb_), __sb_(__wch | ios_base::in)         {
        }
        template <class _CharT, class _Traits, class _Allocator> explicit basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream<_CharT, _Traits, _Allocator>(const std::__1::basic_istringstream::string_type &__s, ios_base::openmode __wch = ios_base::in) : basic_istream<_CharT, _Traits>(& this->__sb_), __sb_(__s, __wch | ios_base::in)         {
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream<_CharT, _Traits, _Allocator> &__rhs)         {
            basic_istream<char_type, traits_type>::swap(__rhs);
            this->__sb_.swap(__rhs.__sb_);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_istringstream<_CharT, _Traits, _Allocator> &__x, basic_istringstream<_CharT, _Traits, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_stringbuf<_CharT, _Traits, _Allocator> *basic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const         {
            return const_cast<basic_stringbuf<std::__1::basic_istringstream::char_type, std::__1::basic_istringstream::traits_type, std::__1::basic_istringstream::allocator_type> *>(& this->__sb_);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> basic_istringstream<_CharT, _Traits, _Allocator>::str() const         {
            return this->__sb_.str();
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_istringstream<_CharT, _Traits, _Allocator>::str(const std::__1::basic_istringstream::string_type &__s)         {
            this->__sb_.str(__s);
        }
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_ostringstream : public basic_ostream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef _Allocator allocator_type;
            typedef basic_string<std::__1::basic_ostringstream::char_type, std::__1::basic_ostringstream::traits_type, std::__1::basic_ostringstream::allocator_type> string_type;
        private:
            basic_stringbuf<std::__1::basic_ostringstream::char_type, std::__1::basic_ostringstream::traits_type, std::__1::basic_ostringstream::allocator_type> __sb_;
        public:
            inline explicit basic_ostringstream<_CharT, _Traits, _Allocator>(ios_base::openmode __wch = ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline explicit basic_ostringstream<_CharT, _Traits, _Allocator>(const std::__1::basic_ostringstream::string_type &__s, ios_base::openmode __wch = ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline void swap(basic_ostringstream<_CharT, _Traits, _Allocator> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline basic_stringbuf<std::__1::basic_ostringstream::char_type, std::__1::basic_ostringstream::traits_type, std::__1::basic_ostringstream::allocator_type> *rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline std::__1::basic_ostringstream::string_type str() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline void str(const std::__1::basic_ostringstream::string_type &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        };
        template <class _CharT, class _Traits, class _Allocator> explicit basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream<_CharT, _Traits, _Allocator>(ios_base::openmode __wch = ios_base::out) : basic_ostream<_CharT, _Traits>(& this->__sb_), __sb_(__wch | ios_base::out)         {
        }
        template <class _CharT, class _Traits, class _Allocator> explicit basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream<_CharT, _Traits, _Allocator>(const std::__1::basic_ostringstream::string_type &__s, ios_base::openmode __wch = ios_base::out) : basic_ostream<_CharT, _Traits>(& this->__sb_), __sb_(__s, __wch | ios_base::out)         {
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream<_CharT, _Traits, _Allocator> &__rhs)         {
            basic_ostream<char_type, traits_type>::swap(__rhs);
            this->__sb_.swap(__rhs.__sb_);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_ostringstream<_CharT, _Traits, _Allocator> &__x, basic_ostringstream<_CharT, _Traits, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_stringbuf<_CharT, _Traits, _Allocator> *basic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const         {
            return const_cast<basic_stringbuf<std::__1::basic_ostringstream::char_type, std::__1::basic_ostringstream::traits_type, std::__1::basic_ostringstream::allocator_type> *>(& this->__sb_);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> basic_ostringstream<_CharT, _Traits, _Allocator>::str() const         {
            return this->__sb_.str();
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_ostringstream<_CharT, _Traits, _Allocator>::str(const std::__1::basic_ostringstream::string_type &__s)         {
            this->__sb_.str(__s);
        }
        template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT>> class __attribute__((type_visibility("default"))) basic_stringstream : public basic_iostream<_CharT, _Traits> {
        public:
            typedef _CharT char_type;
            typedef _Traits traits_type;
            typedef typename traits_type::int_type int_type;
            typedef typename traits_type::pos_type pos_type;
            typedef typename traits_type::off_type off_type;
            typedef _Allocator allocator_type;
            typedef basic_string<std::__1::basic_stringstream::char_type, std::__1::basic_stringstream::traits_type, std::__1::basic_stringstream::allocator_type> string_type;
        private:
            basic_stringbuf<std::__1::basic_stringstream::char_type, std::__1::basic_stringstream::traits_type, std::__1::basic_stringstream::allocator_type> __sb_;
        public:
            inline explicit basic_stringstream<_CharT, _Traits, _Allocator>(ios_base::openmode __wch = ios_base::in | ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline explicit basic_stringstream<_CharT, _Traits, _Allocator>(const std::__1::basic_stringstream::string_type &__s, ios_base::openmode __wch = ios_base::in | ios_base::out) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline void swap(basic_stringstream<_CharT, _Traits, _Allocator> &__rhs) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline basic_stringbuf<std::__1::basic_stringstream::char_type, std::__1::basic_stringstream::traits_type, std::__1::basic_stringstream::allocator_type> *rdbuf() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline std::__1::basic_stringstream::string_type str() const __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
            inline void str(const std::__1::basic_stringstream::string_type &__s) __attribute__((visibility("hidden"))) __attribute__((internal_linkage));
        };
        template <class _CharT, class _Traits, class _Allocator> explicit basic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream<_CharT, _Traits, _Allocator>(ios_base::openmode __wch = ios_base::in | ios_base::out) : basic_iostream<_CharT, _Traits>(& this->__sb_), __sb_(__wch)         {
        }
        template <class _CharT, class _Traits, class _Allocator> explicit basic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream<_CharT, _Traits, _Allocator>(const std::__1::basic_stringstream::string_type &__s, ios_base::openmode __wch = ios_base::in | ios_base::out) : basic_iostream<_CharT, _Traits>(& this->__sb_), __sb_(__s, __wch)         {
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_stringstream<_CharT, _Traits, _Allocator>::swap(basic_stringstream<_CharT, _Traits, _Allocator> &__rhs)         {
            basic_iostream<char_type, traits_type>::swap(__rhs);
            this->__sb_.swap(__rhs.__sb_);
        }
        template <class _CharT, class _Traits, class _Allocator> inline void swap(basic_stringstream<_CharT, _Traits, _Allocator> &__x, basic_stringstream<_CharT, _Traits, _Allocator> &__y) __attribute__((visibility("hidden"))) __attribute__((internal_linkage))         {
            __x.swap(__y);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_stringbuf<_CharT, _Traits, _Allocator> *basic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const         {
            return const_cast<basic_stringbuf<std::__1::basic_stringstream::char_type, std::__1::basic_stringstream::traits_type, std::__1::basic_stringstream::allocator_type> *>(& this->__sb_);
        }
        template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> basic_stringstream<_CharT, _Traits, _Allocator>::str() const         {
            return this->__sb_.str();
        }
        template <class _CharT, class _Traits, class _Allocator> void basic_stringstream<_CharT, _Traits, _Allocator>::str(const std::__1::basic_stringstream::string_type &__s)         {
            this->__sb_.str(__s);
        }
    }
}
struct accessx_descriptor {
    unsigned int ad_name_offset;
    int ad_flags;
    int ad_pad[2];
};
extern "C" {
    int getattrlistbulk(int, void *, void *, size_t, uint64_t) __attribute__((availability(macos, introduced=10.10)));
    int getattrlistat(int, const char *, void *, void *, size_t, unsigned long) __attribute__((availability(macos, introduced=10.10)));
    int setattrlistat(int, const char *, void *, void *, size_t, uint32_t) __attribute__((availability(macos, introduced=10.13))) __attribute__((availability(ios, introduced=11.0))) __attribute__((availability(tvos, introduced=11.0))) __attribute__((availability(watchos, introduced=4.0)));
}
extern "C" {
    int faccessat(int, const char *, int, int) __attribute__((availability(macos, introduced=10.10)));
    int fchownat(int, const char *, uid_t, gid_t, int) __attribute__((availability(macos, introduced=10.10)));
    int linkat(int, const char *, int, const char *, int) __attribute__((availability(macos, introduced=10.10)));
    ssize_t readlinkat(int, const char *, char *, size_t) __attribute__((availability(macos, introduced=10.10)));
    int symlinkat(const char *, int, const char *) __attribute__((availability(macos, introduced=10.10)));
    int unlinkat(int, const char *, int) __attribute__((availability(macos, introduced=10.10)));
}
extern "C" {
    void _exit(int);
    int access(const char *, int);
    unsigned int alarm(unsigned int);
    int chdir(const char *);
    int chown(const char *, uid_t, gid_t);
    int close(int) asm("_close");
    int dup(int);
    int dup2(int, int);
    int execl(const char *__path, const char *__arg0, ...) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int execle(const char *__path, const char *__arg0, ...) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int execlp(const char *__file, const char *__arg0, ...) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int execv(const char *__path, char *const *__argv) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int execve(const char *__file, char *const *__argv, char *const *__envp) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int execvp(const char *__file, char *const *__argv) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    pid_t fork() __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    long fpathconf(int, int);
    char *getcwd(char *, size_t);
    gid_t getegid();
    uid_t geteuid();
    gid_t getgid();
    int getgroups(int, gid_t []);
    char *getlogin();
    pid_t getpgrp();
    pid_t getpid();
    pid_t getppid();
    uid_t getuid();
    int isatty(int);
    int link(const char *, const char *);
    off_t lseek(int, off_t, int);
    long pathconf(const char *, int);
    int pause() asm("_pause");
    int pipe(int [2]);
    ssize_t read(int, void *, size_t) asm("_read");
    int rmdir(const char *);
    int setgid(gid_t);
    int setpgid(pid_t, pid_t);
    pid_t setsid();
    int setuid(uid_t);
    unsigned int sleep(unsigned int) asm("_sleep");
    long sysconf(int);
    pid_t tcgetpgrp(int);
    int tcsetpgrp(int, pid_t);
    char *ttyname(int);
    int ttyname_r(int, char *, size_t) asm("_ttyname_r");
    int unlink(const char *);
    ssize_t write(int __fd, const void *__buf, size_t __nbyte) asm("_write");
}
extern "C" {
    size_t confstr(int, char *, size_t) asm("_confstr");
    int getopt(int, char *const [], const char *) asm("_getopt");
    extern char *optarg;
    extern int optind;
    extern int opterr;
    extern int optopt;
}
extern "C" {
    void *brk(const void *) __attribute__((deprecated(""))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int chroot(const char *);
    char *crypt(const char *, const char *);
    void encrypt(char *, int) asm("_encrypt");
    int fchdir(int);
    long gethostid();
    pid_t getpgid(pid_t);
    pid_t getsid(pid_t);
    int getdtablesize();
    int getpagesize() __attribute__((const));
    char *getpass(const char *);
    char *getwd(char *);
    int lchown(const char *, uid_t, gid_t) asm("_lchown");
    int lockf(int, int, off_t) asm("_lockf");
    int nice(int) asm("_nice");
    ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset) asm("_pread");
    ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset) asm("_pwrite");
    void *sbrk(int) __attribute__((deprecated(""))) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    pid_t setpgrp() asm("_setpgrp");
    int setregid(gid_t, gid_t) asm("_setregid");
    int setreuid(uid_t, uid_t) asm("_setreuid");
    void swab(const void *, void *, ssize_t);
    void sync();
    int truncate(const char *, off_t);
    useconds_t ualarm(useconds_t, useconds_t);
    int usleep(useconds_t) asm("_usleep");
    pid_t vfork() __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int fsync(int) asm("_fsync");
    int ftruncate(int, off_t);
    int getlogin_r(char *, size_t);
}
extern "C" {
    int fchown(int, uid_t, gid_t);
    int gethostname(char *, size_t);
    ssize_t readlink(const char *, char *, size_t);
    int setegid(gid_t);
    int seteuid(uid_t);
    int symlink(const char *, const char *);
}
extern "C" {
    int pselect(int, fd_set *, fd_set *, fd_set *, const struct timespec *, const sigset_t *) asm("_pselect$1050");
}
extern "C" {
    void _Exit(int);
    int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
    int acct(const char *);
    int add_profil(char *, size_t, unsigned long, unsigned int) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    void endusershell();
    int execvP(const char *__file, const char *__searchpath, char *const *__argv) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    char *fflagstostr(unsigned long);
    int getdomainname(char *, int);
    int getgrouplist(const char *, int, int *, int *);
    int gethostuuid(uuid_t, const struct timespec *) __attribute__((availability(macos, introduced=10.5)));
    mode_t getmode(const void *, mode_t);
    int getpeereid(int, uid_t *, gid_t *);
    int getsgroups_np(int *, uuid_t);
    char *getusershell();
    int getwgroups_np(int *, uuid_t);
    int initgroups(const char *, int);
    int issetugid();
    char *mkdtemp(char *);
    int mknod(const char *, mode_t, dev_t);
    int mkpath_np(const char *path, mode_t omode) __attribute__((availability(macos, introduced=10.8)));
    int mkpathat_np(int dfd, const char *path, mode_t omode) __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0)));
    int mkstemp(char *);
    int mkstemps(char *, int);
    char *mktemp(char *);
    int mkostemp(char *path, int oflags) __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0)));
    int mkostemps(char *path, int slen, int oflags) __attribute__((availability(macos, introduced=10.12))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0)));
    int mkstemp_dprotected_np(char *path, int dpclass, int dpflags) __attribute__((availability(macos, unavailable))) __attribute__((availability(ios, introduced=10.0))) __attribute__((availability(tvos, introduced=10.0))) __attribute__((availability(watchos, introduced=3.0)));
    char *mkdtempat_np(int dfd, char *path) __attribute__((availability(macos, introduced=10.13))) __attribute__((availability(ios, introduced=11.0))) __attribute__((availability(tvos, introduced=11.0))) __attribute__((availability(watchos, introduced=4.0)));
    int mkstempsat_np(int dfd, char *path, int slen) __attribute__((availability(macos, introduced=10.13))) __attribute__((availability(ios, introduced=11.0))) __attribute__((availability(tvos, introduced=11.0))) __attribute__((availability(watchos, introduced=4.0)));
    int mkostempsat_np(int dfd, char *path, int slen, int oflags) __attribute__((availability(macos, introduced=10.13))) __attribute__((availability(ios, introduced=11.0))) __attribute__((availability(tvos, introduced=11.0))) __attribute__((availability(watchos, introduced=4.0)));
    int nfssvc(int, void *);
    int profil(char *, size_t, unsigned long, unsigned int);
    int pthread_setugid_np(uid_t, gid_t) __attribute__((deprecated("Use of per-thread security contexts is error-prone and discouraged.")));
    int pthread_getugid_np(uid_t *, gid_t *);
    int reboot(int);
    int revoke(const char *);
    int rcmd(char **, int, const char *, const char *, const char *, int *) __attribute__((deprecated("")));
    int rcmd_af(char **, int, const char *, const char *, const char *, int *, int) __attribute__((deprecated("")));
    int rresvport(int *) __attribute__((deprecated("")));
    int rresvport_af(int *, int) __attribute__((deprecated("")));
    int iruserok(unsigned long, int, const char *, const char *) __attribute__((deprecated("")));
    int iruserok_sa(const void *, int, int, const char *, const char *) __attribute__((deprecated("")));
    int ruserok(const char *, int, const char *, const char *) __attribute__((deprecated("")));
    int setdomainname(const char *, int);
    int setgroups(int, const gid_t *);
    void sethostid(long);
    int sethostname(const char *, int);
    void setkey(const char *) asm("_setkey");
    int setlogin(const char *);
    void *setmode(const char *) asm("_setmode");
    int setrgid(gid_t);
    int setruid(uid_t);
    int setsgroups_np(int, const uuid_t);
    void setusershell();
    int setwgroups_np(int, const uuid_t);
    int strtofflags(char **, unsigned long *, unsigned long *);
    int swapon(const char *);
    int ttyslot();
    int undelete(const char *);
    int unwhiteout(const char *);
    void *valloc(size_t);
    int syscall(int, ...) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable))) __attribute__((availability(ios, deprecated=10.0))) __attribute__((availability(macos, deprecated=10.12)));
    extern char *suboptarg;
    int getsubopt(char **, char *const *, char **);
    int fgetattrlist(int, void *, void *, size_t, unsigned int) __attribute__((availability(macos, introduced=10.6)));
    int fsetattrlist(int, void *, void *, size_t, unsigned int) __attribute__((availability(macos, introduced=10.6)));
    int getattrlist(const char *, void *, void *, size_t, unsigned int) asm("_getattrlist");
    int setattrlist(const char *, void *, void *, size_t, unsigned int) asm("_setattrlist");
    int exchangedata(const char *, const char *, unsigned int) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    struct fssearchblock;
    struct searchstate;
    int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *) __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int fsctl(const char *, unsigned long, void *, unsigned int);
    int ffsctl(int, unsigned long, void *, unsigned int) __attribute__((availability(macos, introduced=10.6)));
    int fsync_volume_np(int, int) __attribute__((availability(macos, introduced=10.8)));
    int sync_volume_np(const char *, int) __attribute__((availability(macos, introduced=10.8)));
    extern int optreset;
}
namespace std {
    inline namespace __1 {
        extern std::__1::istream cin __attribute__((visibility("default")));
        extern std::__1::wistream wcin __attribute__((visibility("default")));
        extern std::__1::ostream cout __attribute__((visibility("default")));
        extern std::__1::wostream wcout __attribute__((visibility("default")));
        extern std::__1::ostream cerr __attribute__((visibility("default")));
        extern std::__1::wostream wcerr __attribute__((visibility("default")));
        extern std::__1::ostream clog __attribute__((visibility("default")));
        extern std::__1::wostream wclog __attribute__((visibility("default")));
    }
}
extern const char *const sys_signame[32];
extern const char *const sys_siglist[32];
extern "C" {
    int raise(int);
}
extern "C" {
    void (* _Nullable bsd_signal(int, void (* _Nullable)(int)))(int);
    int kill(pid_t, int) asm("_kill");
    int killpg(pid_t, int) asm("_killpg");
    int pthread_kill(pthread_t, int);
    int pthread_sigmask(int, const sigset_t *, sigset_t *) asm("_pthread_sigmask");
    int sigaction(int, const struct sigaction *, struct sigaction *);
    int sigaddset(sigset_t *, int);
    int sigaltstack(const stack_t *, stack_t *) asm("_sigaltstack") __attribute__((availability(watchos, unavailable))) __attribute__((availability(tvos, unavailable)));
    int sigdelset(sigset_t *, int);
    int sigemptyset(sigset_t *);
    int sigfillset(sigset_t *);
    int sighold(int);
    int sigignore(int);
    int siginterrupt(int, int);
    int sigismember(const sigset_t *, int);
    int sigpause(int) asm("_sigpause");
    int sigpending(sigset_t *);
    int sigprocmask(int, const sigset_t *, sigset_t *);
    int sigrelse(int);
    void (* _Nullable sigset(int, void (* _Nullable)(int)))(int);
    int sigsuspend(const sigset_t *) asm("_sigsuspend");
    int sigwait(const sigset_t *, int *) asm("_sigwait");
    void psignal(unsigned int, const char *);
    int sigblock(int);
    int sigsetmask(int);
    int sigvec(int, struct sigvec *, struct sigvec *);
}
inline int __sigbits(int __signo) __attribute__((always_inline)) {
    return __signo > 32 ? 0 : (1 << (__signo - 1));
}
namespace std {
    inline namespace __1 {
        using ::sig_atomic_t;
        using ::signal;
        using ::raise;
    }
}
struct flock {
    off_t l_start;
    off_t l_len;
    pid_t l_pid;
    short l_type;
    short l_whence;
};
struct flocktimeout {
    struct flock fl;
    struct timespec timeout;
};
struct radvisory {
    off_t ra_offset;
    int ra_count;
};
typedef struct fcodeblobs {
    void *f_cd_hash;
    size_t f_hash_size;
    void *f_cd_buffer;
    size_t f_cd_size;
    unsigned int *f_out_size;
    int f_arch;
    int __padding;
} fcodeblobs_t;
typedef struct fsignatures {
    off_t fs_file_start;
    void *fs_blob_start;
    size_t fs_blob_size;
} fsignatures_t;
typedef struct fchecklv {
    off_t lv_file_start;
    size_t lv_error_message_size;
    void *lv_error_message;
} fchecklv_t;
typedef struct fstore {
    unsigned int fst_flags;
    int fst_posmode;
    off_t fst_offset;
    off_t fst_length;
    off_t fst_bytesalloc;
} fstore_t;
typedef struct fpunchhole {
    unsigned int fp_flags;
    unsigned int reserved;
    off_t fp_offset;
    off_t fp_length;
} fpunchhole_t;
typedef struct ftrimactivefile {
    off_t fta_offset;
    off_t fta_length;
} ftrimactivefile_t;
typedef struct fspecread {
    unsigned int fsr_flags;
    unsigned int reserved;
    off_t fsr_offset;
    off_t fsr_length;
} fspecread_t;
typedef struct fbootstraptransfer {
    off_t fbt_offset;
    size_t fbt_length;
    void *fbt_buffer;
} fbootstraptransfer_t;
struct log2phys {
    unsigned int l2p_flags;
    off_t l2p_contigbytes;
    off_t l2p_devoffset;
};
struct _filesec;
typedef struct _filesec *filesec_t;
typedef enum  {
    FILESEC_OWNER = 1,
    FILESEC_GROUP = 2,
    FILESEC_UUID = 3,
    FILESEC_MODE = 4,
    FILESEC_ACL = 5,
    FILESEC_GRPUUID = 6,
    FILESEC_ACL_RAW = 100,
    FILESEC_ACL_ALLOCSIZE = 101
} filesec_property_t;
extern "C" {
    int open(const char *, int, ...) asm("_open");
    int openat(int, const char *, int, ...) asm("_openat") __attribute__((availability(macos, introduced=10.10)));
    int creat(const char *, mode_t) asm("_creat");
    int fcntl(int, int, ...) asm("_fcntl");
    int openx_np(const char *, int, filesec_t);
    int open_dprotected_np(const char *, int, int, int, ...);
    int flock(int, int);
    filesec_t filesec_init();
    filesec_t filesec_dup(filesec_t);
    void filesec_free(filesec_t);
    int filesec_get_property(filesec_t, filesec_property_t, void *);
    int filesec_query_property(filesec_t, filesec_property_t, int *);
    int filesec_set_property(filesec_t, filesec_property_t, const void *);
    int filesec_unset_property(filesec_t, filesec_property_t) __attribute__((availability(macos, introduced=10.6)));
}
int _test_passed_cnt = 0;
using std::string;
using std::cout;
using std::endl;
const std::string GREEN = "\033[1;32m";
const std::string REDD = "\033[1;31m";
const std::string YELLOW = "\033[1;33m";
const std::string WHITE = "\033[1;39m";
const std::string RESET = "\033[0m";
void printElement(std::string t) {
    if (t == "OK")
        t = GREEN + t + RESET;
    else if (t == "FAILED")
        t = REDD + t + RESET;
    cout << std::left << std::setw(30) << std::setfill(' ') << t;
}
void outputCurrentResult(std::string test_name, int num_tests) {
    cout << endl << YELLOW + test_name << " RESULT: " << _test_passed_cnt << "/" << num_tests << RESET << endl;
}
void outputTotalResult(int num_passed, int num_tests) {
    cout << endl << YELLOW << "TOTAL RESULT: " << num_passed << "/" << num_tests << RESET << endl;
}
using namespace std;
template <class _Tp> class Alloc {
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp *pointer;
    typedef const _Tp *const_pointer;
    typedef _Tp &reference;
    typedef const _Tp &const_reference;
    typedef _Tp value_type;
    typedef std::__1::true_type propagate_on_container_move_assignment;
    typedef std::__1::true_type is_always_equal;
    template <class _Up> struct rebind {
        typedef Alloc<_Up> other;
    };
    Alloc<_Tp>()     {
    }
    template <class _Up> Alloc<_Tp>(const Alloc<_Up> &)     {
    }
    Alloc::pointer address(Alloc::reference __x) const     {
        return std::__1::addressof(__x);
    }
    Alloc::const_pointer address(Alloc::const_reference __x) const     {
        return std::__1::addressof(__x);
    }
    Alloc::pointer allocate(Alloc::size_type __n)     {
        _allocator_used = 1;
        if (__n > this->max_size())
            __throw_length_error("Alloc<T>::allocate(size_t n) 'n' exceeds maximum supported size");
        return static_cast<Alloc::pointer>(std::__1::__libcpp_allocate(__n * sizeof(_Tp), __alignof(_Tp)));
    }
    void deallocate(Alloc::pointer __p, Alloc::size_type __n)     {
        _allocator_used = 1;
        std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(_Tp), __alignof(_Tp));
    }
    Alloc::size_type max_size() const     {
        return Alloc::size_type(~0) / sizeof(_Tp);
    }
    void construct(Alloc::pointer __p)     {
        _allocator_used = 1;
        ::new ((void *)__p) _Tp(());
    }
    template <class _A0> void construct(Alloc::pointer __p, _A0 &__a0)     {
        _allocator_used = 1;
        ::new ((void *)__p) _Tp((__a0));
    }
    template <class _A0> void construct(Alloc::pointer __p, const _A0 &__a0)     {
        _allocator_used = 1;
        ::new ((void *)__p) _Tp((__a0));
    }
    template <class _A0, class _A1> void construct(Alloc::pointer __p, _A0 &__a0, _A1 &__a1)     {
        _allocator_used = 1;
        ::new ((void *)__p) _Tp((__a0, __a1));
    }
    template <class _A0, class _A1> void construct(Alloc::pointer __p, const _A0 &__a0, _A1 &__a1)     {
        _allocator_used = 1;
        ::new ((void *)__p) _Tp((__a0, __a1));
    }
    template <class _A0, class _A1> void construct(Alloc::pointer __p, _A0 &__a0, const _A1 &__a1)     {
        _allocator_used = 1;
        ::new ((void *)__p) _Tp((__a0, __a1));
    }
    template <class _A0, class _A1> void construct(Alloc::pointer __p, const _A0 &__a0, const _A1 &__a1)     {
        _allocator_used = 1;
        ::new ((void *)__p) _Tp((__a0, __a1));
    }
    void destroy(Alloc::pointer __p)     {
        __p->~_Tp();
    }
};
template <class _Tp> class Alloc<const _Tp> {
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp *pointer;
    typedef const _Tp *const_pointer;
    typedef const _Tp &reference;
    typedef const _Tp &const_reference;
    typedef const _Tp value_type;
    typedef std::__1::true_type propagate_on_container_move_assignment;
    typedef std::__1::true_type is_always_equal;
    template <class _Up> struct rebind {
        typedef Alloc<_Up> other;
    };
    Alloc<const type-parameter-0-0>()     {
    }
    template <class _Up> Alloc<const type-parameter-0-0>(const Alloc<_Up> &)     {
    }
    Alloc<const type-parameter-0-0>::const_pointer address(Alloc<const type-parameter-0-0>::const_reference __x) const     {
        return std::__1::addressof(__x);
    }
    Alloc<const type-parameter-0-0>::pointer allocate(Alloc<const type-parameter-0-0>::size_type __n)     {
        _allocator_used = 1;
        if (__n > this->max_size())
            __throw_length_error("Alloc<const T>::allocate(size_t n) 'n' exceeds maximum supported size");
        return static_cast<Alloc<const type-parameter-0-0>::pointer>(std::__1::__libcpp_allocate(__n * sizeof(_Tp), __alignof(_Tp)));
    }
    void deallocate(Alloc<const type-parameter-0-0>::pointer __p, Alloc<const type-parameter-0-0>::size_type __n)     {
        _allocator_used = 1;
        std::__1::__libcpp_deallocate((void *)const_cast<_Tp *>(__p), __n * sizeof(_Tp), __alignof(_Tp));
    }
    Alloc<const type-parameter-0-0>::size_type max_size() const     {
        return Alloc<const type-parameter-0-0>::size_type(~0) / sizeof(_Tp);
    }
    void construct(Alloc<const type-parameter-0-0>::pointer __p)     {
        _allocator_used = 1;
        ::new ((void *)const_cast<_Tp *>(__p)) _Tp(());
    }
    template <class _A0> void construct(Alloc<const type-parameter-0-0>::pointer __p, _A0 &__a0)     {
        _allocator_used = 1;
        ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0));
    }
    template <class _A0> void construct(Alloc<const type-parameter-0-0>::pointer __p, const _A0 &__a0)     {
        _allocator_used = 1;
        ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0));
    }
    template <class _A0, class _A1> void construct(Alloc<const type-parameter-0-0>::pointer __p, _A0 &__a0, _A1 &__a1)     {
        _allocator_used = 1;
        ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0, __a1));
    }
    template <class _A0, class _A1> void construct(Alloc<const type-parameter-0-0>::pointer __p, const _A0 &__a0, _A1 &__a1)     {
        _allocator_used = 1;
        ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0, __a1));
    }
    template <class _A0, class _A1> void construct(Alloc<const type-parameter-0-0>::pointer __p, _A0 &__a0, const _A1 &__a1)     {
        _allocator_used = 1;
        ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0, __a1));
    }
    template <class _A0, class _A1> void construct(Alloc<const type-parameter-0-0>::pointer __p, const _A0 &__a0, const _A1 &__a1)     {
        _allocator_used = 1;
        ::new ((void *)const_cast<_Tp *>(__p)) _Tp((__a0, __a1));
    }
    void destroy(Alloc<const type-parameter-0-0>::pointer __p)     {
        __p->~_Tp();
    }
};
static volatile time_t g_start1;
static volatile time_t g_start2;
static volatile time_t g_end1;
static volatile time_t g_end2;
time_t timer() {
    struct timeval start = {};
    gettimeofday(&start, std::__1::__get_nullptr_t());
    time_t msecs_time = (start.tv_sec * 1000) + (start.tv_usec / 1000);
    return msecs_time;
}
std::string exec(const char *cmd) {
    char buffer[128];
    std::string result = "";
    FILE *pipe = popen(cmd, "r");
    if (!pipe)
        throw std::runtime_error("popen() failed!");
    try {
        while (fgets(buffer, sizeof buffer, pipe) != __null)
            {
                result += buffer;
            }
    } catch (...) {
        pclose(pipe);
        throw;
    }
    pclose(pipe);
    return result;
}
std::string get_leak_string(std::string s) {
    std::string tmp;
    int idx = s.find("total leaked bytes");
    for (; s[idx] != '\n'; --idx) {
    }
    int edx = idx + 1;
    for (; s[edx] != '\n'; ++edx) {
    }
    return s.substr(++idx, edx - 101);
}
int leaks_test(pid_t pid) {
    std::__1::string a = "leaks ";
    a += std::to_string(static_cast<int>(pid));
    usleep(50);
    std::__1::string s = get_leak_string(exec(a.c_str()));
    if (s.find("0 leaks for 0 total leaked bytes") != std::string::npos) {
        printElement(GREEN + "CLEAR" + RESET);
        return (0);
    } else {
        printElement(REDD + "LEAKS" + RESET);
        return (1);
    }
}
int run_bool_unit_test(std::string test_name, bool (func1)()) {
    int ret = 0;
    time_t t1;
    time_t t2;
    bool res;
    printElement(test_name);
    res = func1();
    if (res) {
        printElement("OK");
        ret = 0;
    } else {
        printElement("FAILED");
        ret = 1;
    }
    t1 = g_end1 - g_start1 , t2 = g_end2 - g_start2;
    (t1 >= t2) ? printElement(GREEN + std::to_string(t2) + "ms" + RESET) : printElement(REDD + std::to_string(t2) + "ms" + RESET);
    (t1 > t2) ? printElement(REDD + std::to_string(t1) + "ms" + RESET) : printElement(GREEN + std::to_string(t1) + "ms" + RESET);
    cout << endl;
    return ret;
}
namespace ft {
    template <class InputIt1, class InputIt2> bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2)     {
        for (; first1 != last1; ++first1 , ++first2) {
            if (!(*first1 == *first2)) {
                return false;
            }
        }
        return true;
    }
    template <class InputIt1, class InputIt2, class BinaryPredicate> bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p)     {
        for (; first1 != last1; ++first1 , ++first2) {
            if (!p(*first1, *first2)) {
                return false;
            }
        }
        return true;
    }
    template <class InputIt1, class InputIt2> bool lexicographical_compare(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2)     {
        for (; (first1 != last1) && (first2 != last2); ++first1 , (void)++first2) {
            if (*first1 < *first2)
                return true;
            if (*first2 < *first1)
                return false;
        }
        return (first1 == last1) && (first2 != last2);
    }
    template <class InputIt1, class InputIt2, class Compare> bool lexicographical_compare(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Compare comp)     {
        for (; (first1 != last1) && (first2 != last2); ++first1 , (void)++first2) {
            if (comp(*first1, *first2))
                return true;
            if (comp(*first2, *first1))
                return false;
        }
        return (first1 == last1) && (first2 != last2);
    }
}
namespace ft {
    template <bool B, class T = void> struct enable_if {
    };
    template <class T> struct enable_if<true, T> {
        typedef T type;
    };
}
namespace ft {
    template <typename T, T v> struct integral_constant {
        static const T value = v;
        typedef T value_type;
        typedef integral_constant<T, v> type;
        operator T()         {
            return v;
        }
    };
template<> struct integral_constant<bool, true> {
        static const bool value = true;
        typedef bool value_type;
        typedef integral_constant<bool, true> type;
        operator bool();
    };
template<> struct integral_constant<bool, false> {
        static const bool value = false;
        typedef bool value_type;
        typedef integral_constant<bool, false> type;
        operator bool();
    };
    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;
    template <typename T> struct is_integral : public ft::false_type {
    };
    template<> struct is_integral<bool> : public ft::true_type {
    };
    template<> struct is_integral<char> : public ft::true_type {
    };
    template<> struct is_integral<char16_t> : public ft::true_type {
    };
    template<> struct is_integral<char32_t> : public ft::true_type {
    };
    template<> struct is_integral<wchar_t> : public ft::true_type {
    };
    template<> struct is_integral<signed char> : public ft::true_type {
    };
    template<> struct is_integral<short> : public ft::true_type {
    };
    template<> struct is_integral<int> : public ft::true_type {
    };
    template<> struct is_integral<long> : public ft::true_type {
    };
    template<> struct is_integral<long long> : public ft::true_type {
    };
    template<> struct is_integral<unsigned char> : public ft::true_type {
    };
    template<> struct is_integral<unsigned short> : public ft::true_type {
    };
    template<> struct is_integral<unsigned int> : public ft::true_type {
    };
    template<> struct is_integral<unsigned long> : public ft::true_type {
    };
    template<> struct is_integral<unsigned long long> : public ft::true_type {
    };
}
namespace ft {
    template <class Iterator> struct iterator_traits {
        typedef typename Iterator::difference_type difference_type;
        typedef typename Iterator::value_type value_type;
        typedef typename Iterator::pointer pointer;
        typedef typename Iterator::reference reference;
        typedef typename Iterator::iterator_category iterator_category;
    };
template<> struct iterator_traits<std::__1::__wrap_iter<int>> {
        typedef typename __wrap_iter<int>::difference_type difference_type;
        typedef typename __wrap_iter<int>::value_type value_type;
        typedef typename __wrap_iter<int>::pointer pointer;
        typedef typename __wrap_iter<int>::reference reference;
        typedef typename __wrap_iter<int>::iterator_category iterator_category;
    };
    template <class T> struct iterator_traits<T *> {
        typedef ptrdiff_t difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;
        typedef std::random_access_iterator_tag iterator_category;
    };
    template <class T> struct iterator_traits<const T *> {
        typedef ptrdiff_t difference_type;
        typedef T value_type;
        typedef const T *pointer;
        typedef const T &reference;
        typedef std::random_access_iterator_tag iterator_category;
    };
}
namespace ft {
    template <typename T1, typename T2> struct pair {
        typedef T1 first_type;
        typedef T2 second_type;
        T1 first;
        T2 second;
        pair<T1, T2>() : first(T1()), second(T2())         {
        }
        pair<T1, T2>(const T1 &a, const T2 &b) : first(a), second(b)         {
        }
        template <typename U, typename V> pair<T1, T2>(const pair<U, V> &p) : first(p.first), second(p.second)         {
        }
    };
    template <typename T1, typename T2> inline bool operator==(const pair<T1, T2> &x, const pair<T1, T2> &y)     {
        return (x.first == y.first && x.second == y.second);
    }
    template <typename T1, typename T2> inline bool operator!=(const pair<T1, T2> &x, const pair<T1, T2> &y)     {
        return !(x == y);
    }
    template <typename T1, typename T2> inline bool operator<(const pair<T1, T2> &x, const pair<T1, T2> &y)     {
        return (x.first < y.first || (!(y.first < x.first) && x.second < y.second));
    }
    template <typename T1, typename T2> inline bool operator>(const pair<T1, T2> &x, const pair<T1, T2> &y)     {
        return (y < x);
    }
    template <typename T1, typename T2> inline bool operator<=(const pair<T1, T2> &x, const pair<T1, T2> &y)     {
        return !(y < x);
    }
    template <typename T1, typename T2> inline bool operator>=(const pair<T1, T2> &x, const pair<T1, T2> &y)     {
        return !(x < y);
    }
    template <typename T1, typename T2> inline pair<T1, T2> make_pair(T1 x, T2 y)     {
        return (pair<T1, T2>(x, y));
    }
}
namespace ft {
    template <typename Iter> class reverse_iterator : public std::iterator<typename std::iterator_traits<Iter>::iterator_category, typename std::iterator_traits<Iter>::value_type, typename std::iterator_traits<Iter>::difference_type, typename std::iterator_traits<Iter>::pointer, typename std::iterator_traits<Iter>::reference> {
    protected:
        Iter _current;
    public:
        typedef Iter iterator_type;
        typedef typename ft::iterator_traits<Iter>::difference_type difference_type;
        typedef typename ft::iterator_traits<Iter>::pointer pointer;
        typedef typename ft::iterator_traits<Iter>::reference reference;
    public:
        reverse_iterator<Iter>() : _current()         {
        }
        reverse_iterator<Iter>(const reverse_iterator<Iter> &__x) : _current(__x._current)         {
        }
        explicit reverse_iterator<Iter>(ft::reverse_iterator::iterator_type __x) : _current(__x)         {
        }
        template <typename _Iter> reverse_iterator<Iter>(const reverse_iterator<_Iter> &__other) : _current(__other.base())         {
        }
    public:
        ft::reverse_iterator::iterator_type base() const         {
            return this->_current;
        }
        template <class _Iter> reverse_iterator<Iter> &operator=(const reverse_iterator<_Iter> &__x)         {
            this->_current = __x.base();
            return *this;
        }
        ft::reverse_iterator::reference operator*() const         {
            Iter tmp = this->_current;
            return *--tmp;
        }
        ft::reverse_iterator::pointer operator->() const         {
            return std::addressof(this->operator*());
        }
        reverse_iterator<Iter> &operator++()         {
            this->_current--;
            return *this;
        }
        reverse_iterator<Iter> &operator--()         {
            this->_current++;
            return *this;
        }
        reverse_iterator<Iter> operator++(int)         {
            reverse_iterator<Iter> __tmp = *this;
            --this->_current;
            return __tmp;
        }
        reverse_iterator<Iter> operator--(int)         {
            reverse_iterator<Iter> __tmp = *this;
            ++this->_current;
            return __tmp;
        }
        reverse_iterator<Iter> operator+(ft::reverse_iterator::difference_type __n) const         {
            return (reverse_iterator<Iter>(this->base() - __n));
        }
        reverse_iterator<Iter> operator-(ft::reverse_iterator::difference_type __n) const         {
            return (reverse_iterator<Iter>(this->base() + __n));
        }
        reverse_iterator<Iter> &operator+=(ft::reverse_iterator::difference_type __n)         {
            this->_current -= __n;
            return (*this);
        }
        reverse_iterator<Iter> &operator-=(ft::reverse_iterator::difference_type __n)         {
            this->_current += __n;
            return (*this);
        }
        ft::reverse_iterator::reference operator[](ft::reverse_iterator::difference_type __n) const         {
            return this->base()[- __n - 1];
        }
    };
template<> class reverse_iterator<std::__1::__wrap_iter<int>> {
    protected:
        std::__1::__wrap_iter<int> _current;
    public:
        typedef std::__1::__wrap_iter<int> iterator_type;
        typedef typename ft::iterator_traits<__wrap_iter<int> >::difference_type difference_type;
        typedef typename ft::iterator_traits<__wrap_iter<int> >::pointer pointer;
        typedef typename ft::iterator_traits<__wrap_iter<int> >::reference reference;
    public:
        reverse_iterator();
        reverse_iterator(const ft::reverse_iterator<std::__1::__wrap_iter<int> > &__x);
        explicit reverse_iterator(ft::reverse_iterator<std::__1::__wrap_iter<int> >::iterator_type __x);
        template <typename _Iter> reverse_iterator(const reverse_iterator<_Iter> &__other);
    public:
        ft::reverse_iterator<std::__1::__wrap_iter<int> >::iterator_type base() const;
        template <class _Iter> ft::reverse_iterator<std::__1::__wrap_iter<int> > &operator=(const reverse_iterator<_Iter> &__x);
        ft::reverse_iterator<std::__1::__wrap_iter<int> >::reference operator*() const;
        ft::reverse_iterator<std::__1::__wrap_iter<int> >::pointer operator->() const;
        ft::reverse_iterator<std::__1::__wrap_iter<int> > &operator++();
        ft::reverse_iterator<std::__1::__wrap_iter<int> > &operator--();
        ft::reverse_iterator<std::__1::__wrap_iter<int> > operator++(int);
        ft::reverse_iterator<std::__1::__wrap_iter<int> > operator--(int);
        ft::reverse_iterator<std::__1::__wrap_iter<int> > operator+(ft::reverse_iterator<std::__1::__wrap_iter<int> >::difference_type __n) const;
        ft::reverse_iterator<std::__1::__wrap_iter<int> > operator-(ft::reverse_iterator<std::__1::__wrap_iter<int> >::difference_type __n) const;
        ft::reverse_iterator<std::__1::__wrap_iter<int> > &operator+=(ft::reverse_iterator<std::__1::__wrap_iter<int> >::difference_type __n);
        ft::reverse_iterator<std::__1::__wrap_iter<int> > &operator-=(ft::reverse_iterator<std::__1::__wrap_iter<int> >::difference_type __n);
        ft::reverse_iterator<std::__1::__wrap_iter<int> >::reference operator[](ft::reverse_iterator<std::__1::__wrap_iter<int> >::difference_type __n) const;
    };
    template <class Iterator1, class Iterator2> bool operator==(const std::reverse_iterator<Iterator1> &lhs, const std::reverse_iterator<Iterator2> &rhs)     {
        return lhs.base() == rhs.base();
    }
    template <class Iterator1, class Iterator2> bool operator!=(const std::reverse_iterator<Iterator1> &lhs, const std::reverse_iterator<Iterator2> &rhs)     {
        return lhs.base() != rhs.base();
    }
    template <class Iterator1, class Iterator2> bool operator<(const std::reverse_iterator<Iterator1> &lhs, const std::reverse_iterator<Iterator2> &rhs)     {
        return lhs.base() > rhs.base();
    }
    template <class Iterator1, class Iterator2> bool operator<=(const std::reverse_iterator<Iterator1> &lhs, const std::reverse_iterator<Iterator2> &rhs)     {
        return lhs.base() >= rhs.base();
    }
    template <class Iterator1, class Iterator2> bool operator>(const std::reverse_iterator<Iterator1> &lhs, const std::reverse_iterator<Iterator2> &rhs)     {
        return lhs.base() < rhs.base();
    }
    template <class Iterator1, class Iterator2> bool operator>=(const std::reverse_iterator<Iterator1> &lhs, const std::reverse_iterator<Iterator2> &rhs)     {
        return lhs.base() <= rhs.base();
    }
    template <class Iter> reverse_iterator<Iter> operator+(typename reverse_iterator<Iter>::difference_type __n, const reverse_iterator<Iter> &it)     {
        return reverse_iterator<Iter>(it.base() - __n);
    }
    template <class Iterator1, class Iterator2> typename reverse_iterator<Iterator1>::difference_type operator-(const reverse_iterator<Iterator1> &lhs, const reverse_iterator<Iterator2> &rhs)     {
        return (rhs.base() - lhs.base());
    }
}
namespace ft {
    template <typename _Tp, typename _Alloc> struct _Vector_base {
        struct _Vector_impl : protected _Alloc {
            _Tp *_M_start;
            _Tp *_M_finish;
            _Tp *_M_end_of_storage;
            _Vector_impl(const _Alloc &__a) : _Alloc(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)             {
            }
        };
    public:
        ft::_Vector_base::_Vector_impl _M_impl;
        typedef _Alloc allocator_type;
        _Vector_base<_Tp, _Alloc>(size_t __n, const ft::_Vector_base::allocator_type &__a) : _M_impl(__a)         {
            this->_M_impl._M_start = this->_M_allocate(__n);
            this->_M_impl._M_finish = this->_M_impl._M_start;
            this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
        }
        _Vector_base<_Tp, _Alloc>(const ft::_Vector_base::allocator_type &__a) : _M_impl(__a)         {
        }
        ~_Vector_base<_Tp, _Alloc>()         {
            this->_M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        }
    public:
        _Tp *_M_allocate(size_t __n)         {
            return this->_M_impl.allocate(__n);
        }
        void _M_deallocate(_Tp *__p, size_t __n)         {
            if (__p)
                this->_M_impl.deallocate(__p, __n);
        }
        ft::_Vector_base::allocator_type get_allocator() const         {
            return *static_cast<const _Alloc *>(& this->_M_impl);
        }
    };
template<> struct _Vector_base<int, std::__1::allocator<int>> {
        struct _Vector_impl : protected std::__1::allocator<int> {
            int *_M_start;
            int *_M_finish;
            int *_M_end_of_storage;
        };
    public:
        ft::_Vector_base<int, std::__1::allocator<int> >::_Vector_impl _M_impl;
        typedef std::__1::allocator<int> allocator_type;
        _Vector_base(size_t __n, const ft::_Vector_base<int, std::__1::allocator<int> >::allocator_type &__a);
        _Vector_base(const ft::_Vector_base<int, std::__1::allocator<int> >::allocator_type &__a);
        ~_Vector_base<int, allocator<int> >();
    public:
        int *_M_allocate(size_t __n);
        void _M_deallocate(int *__p, size_t __n);
        ft::_Vector_base<int, std::__1::allocator<int> >::allocator_type get_allocator() const;
    };
    template <typename _Tp, typename _Alloc = std::allocator<_Tp>> class vector : public _Vector_base<_Tp, _Alloc> {
    private:
        typedef _Vector_base<_Tp, _Alloc> _Base;
        typedef vector<_Tp, _Alloc> vector_type;
    public:
        typedef _Tp value_type;
        typedef ft::vector::value_type pointer;
        typedef const ft::vector::value_type const_pointer;
        typedef ft::vector::value_type &reference;
        typedef const ft::vector::value_type &const_reference;
        typedef std::__wrap_iter<pointer> iterator;
        typedef std::__wrap_iter<const_pointer> const_iterator;
        typedef ft::reverse_iterator<iterator> reverse_iterator;
        typedef ft::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef typename _Base::allocator_type allocator_type;
    public:
        explicit vector<_Tp, _Alloc>(const _Alloc &__a = _Alloc()) : ft::vector::_Base(__a)         {
        }
        vector<_Tp, _Alloc>(size_t __n, const _Tp &__v = _Tp(), const _Alloc &__a = _Alloc()) : ft::vector::_Base(__n, __a)         {
            std::uninitialized_fill_n(this->_M_impl._M_start, __n, __v);
        }
        vector<_Tp, _Alloc>(const vector<_Tp, _Alloc> &__x) : ft::vector::_Base(__x.size(), __x.get_allocator())         {
            this->_M_impl._M_finish = std::uninitialized_copy(__x.begin(), __x.end(), this->_M_impl._M_start);
        }
        template <typename InputIt, typename ft::enable_if<ft::is_integral<InputIt>::value, InputIt>::type> vector<_Tp, _Alloc>(InputIt __first, InputIt __last, const _Alloc &__a = _Alloc()) : ft::vector::_Base(__a)         {
            std::uninitialized_copy(__first, __last, this->_M_impl._M_start);
        }
        template <class InputIt> vector<_Tp, _Alloc>(InputIt __first, InputIt __last, const _Alloc &__a = _Alloc()) : ft::vector::_Base(__a)         {
            std::uninitialized_copy(__first, __last, this->_M_impl._M_start);
        }
        ~vector<_Tp, _Alloc>()         {
        }
        vector<_Tp, _Alloc> &operator=(const vector<_Tp, _Alloc> &__x)         {
            if (this != __x) {
            }
            return (*this);
        }
        void assign(ft::vector::size_type count, const _Tp &value);
        template <typename InputIt> void assign(InputIt first, InputIt last)         {
        }
    public:
        ft::vector::iterator begin()         {
            return ft::vector::iterator(this->_M_impl._M_start);
        }
        ft::vector::const_iterator begin() const         {
            return ft::vector::const_iterator(this->_M_impl._M_start);
        }
        ft::vector::iterator end()         {
            return ft::vector::iterator(this->_M_impl._M_finish);
        }
        ft::vector::const_iterator end() const         {
            return ft::vector::const_iterator(this->_M_impl._M_finish);
        }
        ft::vector::reverse_iterator rbegin()         {
            return ft::vector::reverse_iterator(this->_M_impl._M_finish);
        }
        ft::vector::const_reverse_iterator rbegin() const         {
            return ft::vector::const_reverse_iterator(this->_M_impl._M_finish);
        }
        ft::vector::reverse_iterator rend()         {
            return ft::vector::reverse_iterator(this->_M_impl._M_start);
        }
        ft::vector::const_reverse_iterator rend() const         {
            return ft::vector::const_reverse_iterator(this->_M_impl._M_start);
        }
    protected:
        void _M_out_of_range_check(ft::vector::size_type __pos)         {
            if (__pos >= this->size())
                throw std::out_of_range("vector::_M_range_check");
        }
    public:
        ft::vector::reference at(ft::vector::size_type __pos)         {
            this->_M_out_of_range_check(__pos);
            return (this->_M_impl._M_start[__pos]);
        }
        ft::vector::const_reference at(ft::vector::size_type __pos) const         {
            this->_M_out_of_range_check(__pos);
            return (this->_M_impl._M_start[__pos]);
        }
        ft::vector::reference operator[](ft::vector::size_type __pos)         {
            return *(this->_M_impl._M_start + __pos);
        }
        ft::vector::const_reference operator[](ft::vector::size_type __pos) const         {
            return *(this->_M_impl._M_start + __pos);
        }
        ft::vector::reference front()         {
            return *(this->_M_impl._M_start);
        }
        ft::vector::const_reference front() const         {
            return *(this->_M_impl._M_start);
        }
        ft::vector::reference back()         {
            return *(this->_M_impl._M_finish - 1);
        }
        ft::vector::const_reference back() const         {
            return *(this->_M_impl._M_finish - 1);
        }
        _Tp *data()         {
            return (this->begin());
        }
        const _Tp *data() const         {
            return (this->begin());
        }
    public:
        bool empty() const         {
            if (this->size())
                return true;
            else
                return false;
        }
        ft::vector::size_type size() const         {
            return (this->end() - this->begin());
        }
        ft::vector::size_type max_size() const         {
            return (ft::vector::size_type(-1) / sizeof(_Tp));
        }
        ft::vector::size_type capacity() const         {
            return (ft::vector::size_type(this->_M_impl._M_end_of_storage - this->begin()));
        }
        void reserve(ft::vector::size_type __new_cap)         {
            if (!(__new_cap > this->capacity()))
                return;
            if (__new_cap > this->max_size())
                throw std::length_error("std::length error");
            ft::vector::iterator _new_pointer = this->_M_allocate(__new_cap);
            ft::vector::iterator _invalid_first = this->_M_impl._M_start;
            ft::vector::size_type _size = this->size();
            std::uninitialized_copy_n(_invalid_first, _size, _new_pointer);
            _invalid_first->~_Tp();
            this->_M_deallocate(_invalid_first, this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
            this->_M_impl._M_start = _new_pointer;
            this->_M_impl._M_finish = _new_pointer + _size;
            this->_M_impl._M_end_of_storage = _new_pointer + __new_cap;
        }
    private:
        void _M_insert_fill(ft::vector::const_iterator __pos, const _Tp &__v, ft::vector::size_type __n)         {
            this->_M_move(__pos, __n);
            for (ft::vector::size_type i = 0; i < __n; i++) {
                *(this->begin() + __pos + i) = __v;
            }
        }
        void _M_move(ft::vector::const_iterator __pos, ft::vector::size_type __n)         {
            ft::vector::reverse_iterator __past_rend = this->rend()++;
            ft::vector::size_type __new_size = this->size() + __n;
            if (__new_size > this->capacity()) {
                this->reserve(__new_size);
            }
            ft::vector::reverse_iterator __cur_rend = this->rend()++;
            for (ft::vector::size_type i = 0; i < this->size() - __pos; i++) {
                *(__cur_rend + i) = *(__past_rend + i);
            }
        }
        template <typename __InputIt> void _M_insert_range(ft::vector::const_iterator __pos, __InputIt __first, __InputIt __last)         {
            ft::vector::difference_type __d = std::distance(__first, __last);
            this->_M_move(__pos, __d);
            for (ft::vector::difference_type i = 0; i < __d; i++ , __first++) {
                *(this->begin() + __pos + i) = *(__first);
            }
        }
    public:
        void push_back(const ft::vector::value_type &__v)         {
            if (this->size() + 1 > this->capacity()) {
                this->reserve(this->size() + 1);
            }
            *(this->_M_impl._M_finish) = __v;
            this->_M_impl._M_finish++;
        }
        void pop_back()         {
            this->_M_impl._M_finish--;
        }
        ft::vector::iterator insert(ft::vector::const_iterator __pos, const _Tp &__v)         {
            this->_M_insert_fill(__pos, __v, 1);
            return (this->begin() + __pos);
        }
        ft::vector::iterator insert(ft::vector::const_iterator __pos, ft::vector::size_type __n, const _Tp &__v)         {
            this->_M_insert_fill(__pos, __v, __n);
            if (__n == 0)
                return (__pos);
            else
                return (this->begin() + __pos);
        }
        template <class InputIt> ft::vector::iterator insert(ft::vector::const_iterator __pos, InputIt __first, InputIt __last)         {
            _M_insert_range<InputIt>(__pos, __first, __last);
            if (__first == __last)
                return (__pos);
            else
                return (this->begin() + __pos);
        }
        ft::vector::iterator erase(ft::vector::iterator __pos)         {
            ft::vector::iterator __first = this->begin() + __pos;
            ft::vector::iterator __last = __first + 1;
            return (erase(__first, __last));
        }
        ft::vector::iterator erase(ft::vector::iterator __first, ft::vector::iterator __last)         {
            if (__first == __last)
                return (__last);
            else if (__last == this->end()) {
                this->_M_impl._M_finish -= __last - __first;
                return (this->end());
            } else {
                ft::vector::iterator __rtn = __last - 1;
                for (; __last < this->end(); __last++ , __first++) {
                    *(__first) = *(__last);
                    this->_M_impl._M_finish -= __last - __first;
                }
                return (__rtn);
            }
        }
        void clear()         {
        }
    };
template<> class vector<int, std::__1::allocator<int>> : public _Vector_base<int, std::__1::allocator<int> > {
    private:
        typedef _Vector_base<int, std::__1::allocator<int> > _Base;
        typedef vector<int, std::__1::allocator<int> > vector_type;
    public:
        typedef int value_type;
        typedef ft::vector<int, std::__1::allocator<int> >::value_type pointer;
        typedef const ft::vector<int, std::__1::allocator<int> >::value_type const_pointer;
        typedef ft::vector<int, std::__1::allocator<int> >::value_type &reference;
        typedef const ft::vector<int, std::__1::allocator<int> >::value_type &const_reference;
        typedef std::__wrap_iter<pointer> iterator;
        typedef std::__wrap_iter<const_pointer> const_iterator;
        typedef ft::reverse_iterator<iterator> reverse_iterator;
        typedef ft::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef size_t size_type;
        typedef ptrdiff_t difference_type;
        typedef typename _Base::allocator_type allocator_type;
    public:
        explicit vector(const std::__1::allocator<int> &__a);
        vector(size_t __n, const int &__v, const std::__1::allocator<int> &__a);
        vector(const ft::vector<int, std::__1::allocator<int> > &__x);
        template <typename InputIt, typename ft::enable_if<ft::is_integral<InputIt>::value, InputIt>::type> vector(InputIt __first, InputIt __last, const std::__1::allocator<int> &__a);
        template <class InputIt> vector(InputIt __first, InputIt __last, const std::__1::allocator<int> &__a);
        ~vector<int, allocator<int> >();
        ft::vector<int, std::__1::allocator<int> > &operator=(const ft::vector<int, std::__1::allocator<int> > &__x);
        void assign(ft::vector::size_type count, const int &value);
        template <typename InputIt> void assign(InputIt first, InputIt last);
    public:
        ft::vector<int, std::__1::allocator<int> >::iterator begin();
        ft::vector<int, std::__1::allocator<int> >::const_iterator begin() const;
        ft::vector<int, std::__1::allocator<int> >::iterator end();
        ft::vector<int, std::__1::allocator<int> >::const_iterator end() const;
        ft::vector<int, std::__1::allocator<int> >::reverse_iterator rbegin();
        ft::vector<int, std::__1::allocator<int> >::const_reverse_iterator rbegin() const;
        ft::vector<int, std::__1::allocator<int> >::reverse_iterator rend();
        ft::vector<int, std::__1::allocator<int> >::const_reverse_iterator rend() const;
    protected:
        void _M_out_of_range_check(ft::vector::size_type __pos);
    public:
        ft::vector<int, std::__1::allocator<int> >::reference at(ft::vector::size_type __pos);
        ft::vector<int, std::__1::allocator<int> >::const_reference at(ft::vector::size_type __pos) const;
        ft::vector<int, std::__1::allocator<int> >::reference operator[](ft::vector::size_type __pos);
        ft::vector<int, std::__1::allocator<int> >::const_reference operator[](ft::vector::size_type __pos) const;
        ft::vector<int, std::__1::allocator<int> >::reference front();
        ft::vector<int, std::__1::allocator<int> >::const_reference front() const;
        ft::vector<int, std::__1::allocator<int> >::reference back();
        ft::vector<int, std::__1::allocator<int> >::const_reference back() const;
        int *data();
        const int *data() const;
    public:
        bool empty() const;
        ft::vector::size_type size() const;
        ft::vector::size_type max_size() const;
        ft::vector::size_type capacity() const;
        void reserve(ft::vector::size_type __new_cap);
    private:
        void _M_insert_fill(ft::vector<int, std::__1::allocator<int> >::const_iterator __pos, const int &__v, ft::vector::size_type __n);
        void _M_move(ft::vector<int, std::__1::allocator<int> >::const_iterator __pos, ft::vector::size_type __n);
        template <typename __InputIt> void _M_insert_range(ft::vector<int, std::__1::allocator<int> >::const_iterator __pos, __InputIt __first, __InputIt __last);
    public:
        void push_back(const ft::vector<int, std::__1::allocator<int> >::value_type &__v);
        void pop_back();
        ft::vector<int, std::__1::allocator<int> >::iterator insert(ft::vector<int, std::__1::allocator<int> >::const_iterator __pos, const int &__v);
        ft::vector<int, std::__1::allocator<int> >::iterator insert(ft::vector<int, std::__1::allocator<int> >::const_iterator __pos, ft::vector::size_type __n, const int &__v);
        template <class InputIt> ft::vector<int, std::__1::allocator<int> >::iterator insert(ft::vector<int, std::__1::allocator<int> >::const_iterator __pos, InputIt __first, InputIt __last);
        ft::vector<int, std::__1::allocator<int> >::iterator erase(ft::vector<int, std::__1::allocator<int> >::iterator __pos);
        ft::vector<int, std::__1::allocator<int> >::iterator erase(ft::vector<int, std::__1::allocator<int> >::iterator __first, ft::vector<int, std::__1::allocator<int> >::iterator __last);
        void clear();
    };
}
bool iterator_traits_test() {
    std::vector<string> res;
    std::vector<string> res2;
    g_start1 = g_end1 = timer();
    res.push_back(typeid(std::vector<int>::iterator::iterator_category).name());
    res.push_back(typeid(std::vector<int>::iterator::value_type).name());
    res.push_back(typeid(std::vector<int>::iterator::difference_type).name());
    res.push_back(typeid(std::vector<int>::iterator::iterator_type).name());
    res.push_back(typeid(std::vector<int>::iterator::pointer).name());
    res.push_back(typeid(std::vector<int>::iterator::reference).name());
    res.push_back(typeid(std::vector<int>::reverse_iterator::iterator_category).name());
    res.push_back(typeid(std::vector<int>::reverse_iterator::value_type).name());
    res.push_back(typeid(std::vector<int>::reverse_iterator::difference_type).name());
    res.push_back(typeid(std::vector<int>::reverse_iterator::pointer).name());
    res.push_back(typeid(std::vector<int>::reverse_iterator::reference).name());
    res2.push_back(typeid(ft::vector<int>::iterator::value_type).name());
    res2.push_back(typeid(ft::vector<int>::iterator::difference_type).name());
    res2.push_back(typeid(ft::vector<int>::iterator::iterator_type).name());
    res2.push_back(typeid(ft::vector<int>::iterator::pointer).name());
    res2.push_back(typeid(ft::vector<int>::iterator::reference).name());
    res2.push_back(typeid(ft::vector<int>::reverse_iterator::difference_type).name());
    res2.push_back(typeid(ft::vector<int>::reverse_iterator::pointer).name());
    res2.push_back(typeid(ft::vector<int>::reverse_iterator::reference).name());
    return res == res2;
}
int main() {
    exit(run_bool_unit_test("iterators_traits", iterator_traits_test));
}
